LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_ZN7rocksdb8CacheKeyC2Ev:
   37|      2|  inline CacheKey() : file_num_etc64_(), offset_etc64_() {}
_ZN7rocksdb18OffsetableCacheKeyC2Ev:
   86|      2|  inline OffsetableCacheKey() : CacheKey() {}

_ZN7rocksdb20FullTypedCacheHelperINS_21ParsedFullFilterBlockENS_18BlockCreateContextELNS_14CacheEntryRoleE1EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_21ParsedFullFilterBlockELNS_14CacheEntryRoleE1EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_17UncompressionDictENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_17UncompressionDictELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_12Block_kIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE4EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_12Block_kIndexELNS_14CacheEntryRoleE4EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_27Block_kFilterPartitionIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE2EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_27Block_kFilterPartitionIndexELNS_14CacheEntryRoleE2EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_20Block_kRangeDeletionENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_20Block_kRangeDeletionELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_11Block_kDataENS_18BlockCreateContextELNS_14CacheEntryRoleE0EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_11Block_kDataELNS_14CacheEntryRoleE0EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }

_ZN7rocksdb19PackSequenceAndTypeEmNS_9ValueTypeE:
  148|      2|inline uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  149|      2|  assert(seq <= kMaxSequenceNumber);
  150|       |  // kTypeMaxValid is used in TruncatedRangeDelIterator, see its constructor.
  151|      2|  assert(IsExtendedValueType(t) || t == kTypeMaxValid);
  152|      2|  return (seq << 8) | t;
  153|      2|}

_ZN7rocksdb29WriteStallCauseToHyphenStringENS_15WriteStallCauseE:
   14|      2|const std::string& WriteStallCauseToHyphenString(WriteStallCause cause) {
   15|      2|  static const std::string kMemtableLimit = "memtable-limit";
   16|      2|  static const std::string kL0FileCountLimit = "l0-file-count-limit";
   17|      2|  static const std::string kPendingCompactionBytes = "pending-compaction-bytes";
   18|      2|  static const std::string kWriteBufferManagerLimit =
   19|      2|      "write-buffer-manager-limit";
   20|      2|  switch (cause) {
   21|      0|    case WriteStallCause::kMemtableLimit:
  ------------------
  |  Branch (21:5): [True: 0, False: 2]
  ------------------
   22|      0|      return kMemtableLimit;
   23|      0|    case WriteStallCause::kL0FileCountLimit:
  ------------------
  |  Branch (23:5): [True: 0, False: 2]
  ------------------
   24|      0|      return kL0FileCountLimit;
   25|      0|    case WriteStallCause::kPendingCompactionBytes:
  ------------------
  |  Branch (25:5): [True: 0, False: 2]
  ------------------
   26|      0|      return kPendingCompactionBytes;
   27|      2|    case WriteStallCause::kWriteBufferManagerLimit:
  ------------------
  |  Branch (27:5): [True: 2, False: 0]
  ------------------
   28|      2|      return kWriteBufferManagerLimit;
   29|      0|    default:
  ------------------
  |  Branch (29:5): [True: 0, False: 2]
  ------------------
   30|      0|      break;
   31|      2|  }
   32|      0|  return InvalidWriteStallHyphenString();
   33|      2|}
_ZN7rocksdb33WriteStallConditionToHyphenStringENS_19WriteStallConditionE:
   36|      2|    WriteStallCondition condition) {
   37|      2|  static const std::string kDelayed = "delays";
   38|      2|  static const std::string kStopped = "stops";
   39|      2|  switch (condition) {
   40|      0|    case WriteStallCondition::kDelayed:
  ------------------
  |  Branch (40:5): [True: 0, False: 2]
  ------------------
   41|      0|      return kDelayed;
   42|      2|    case WriteStallCondition::kStopped:
  ------------------
  |  Branch (42:5): [True: 2, False: 0]
  ------------------
   43|      2|      return kStopped;
   44|      0|    default:
  ------------------
  |  Branch (44:5): [True: 0, False: 2]
  ------------------
   45|      0|      break;
   46|      2|  }
   47|      0|  return InvalidWriteStallHyphenString();
   48|      2|}
_ZN7rocksdb24isCFScopeWriteStallCauseENS_15WriteStallCauseE:
  110|      2|bool isCFScopeWriteStallCause(WriteStallCause cause) {
  111|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  112|      2|  uint32_t lower_bound =
  113|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  114|      2|      kNumCFScopeWriteStallCauses;
  115|      2|  uint32_t upper_bound =
  116|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  117|      2|      1;
  118|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (118:10): [True: 2, False: 0]
  |  Branch (118:38): [True: 0, False: 2]
  ------------------
  119|      2|}
_ZN7rocksdb24isDBScopeWriteStallCauseENS_15WriteStallCauseE:
  121|      2|bool isDBScopeWriteStallCause(WriteStallCause cause) {
  122|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  123|      2|  uint32_t lower_bound =
  124|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  125|      2|      kNumDBScopeWriteStallCauses;
  126|      2|  uint32_t upper_bound =
  127|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  128|      2|      1;
  129|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (129:10): [True: 2, False: 0]
  |  Branch (129:38): [True: 2, False: 0]
  ------------------
  130|      2|}
_ZN7rocksdb22WriteStallStatsMapKeys19CauseConditionCountENS_15WriteStallCauseENS_19WriteStallConditionE:
  157|      2|    WriteStallCause cause, WriteStallCondition condition) {
  158|      2|  std::string cause_condition_count_name;
  159|       |
  160|      2|  std::string cause_name;
  161|      2|  if (isCFScopeWriteStallCause(cause) || isDBScopeWriteStallCause(cause)) {
  ------------------
  |  Branch (161:7): [True: 0, False: 2]
  |  Branch (161:42): [True: 2, False: 0]
  ------------------
  162|      2|    cause_name = WriteStallCauseToHyphenString(cause);
  163|      2|  } else {
  164|      0|    assert(false);
  165|      0|    return "";
  166|      0|  }
  167|       |
  168|      2|  const std::string& condition_name =
  169|      2|      WriteStallConditionToHyphenString(condition);
  170|       |
  171|      2|  cause_condition_count_name.reserve(cause_name.size() + 1 +
  172|      2|                                     condition_name.size());
  173|      2|  cause_condition_count_name.append(cause_name);
  174|      2|  cause_condition_count_name.append("-");
  175|      2|  cause_condition_count_name.append(condition_name);
  176|       |
  177|      2|  return cause_condition_count_name;
  178|      2|}

_ZN7rocksdb11WriteThread17AdaptationContextC2EPKc:
  265|     10|    explicit AdaptationContext(const char* name0) : name(name0), value(0) {}

_ZN7rocksdb21LogicalBlockSizeCacheC2ENSt3__18functionIFmiEEENS2_IFNS_6StatusERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPmEEE:
  178|      2|            get_logical_block_size_of_directory) {}

_ZN7rocksdb5Cache15CacheItemHelperC2Ev:
  144|      2|    CacheItemHelper() : CacheItemHelper(CacheEntryRole::kMisc) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEE:
  148|     14|        : CacheItemHelper(_role, _del_cb, nullptr, nullptr, nullptr, this) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEEPFmS3_EPFNS_6StatusES3_mmPcEPFSA_RKNS_5SliceEPNS0_13CreateContextES5_PS3_PmEPKS1_:
  160|     26|          without_secondary_compat(_without_secondary_compat) {
  161|       |      // Either all three secondary cache callbacks are non-nullptr or
  162|       |      // all three are nullptr
  163|     26|      assert((size_cb != nullptr) == (saveto_cb != nullptr));
  164|     26|      assert((size_cb != nullptr) == (create_cb != nullptr));
  165|       |      // without_secondary_compat points to equivalent but without
  166|       |      // secondary support
  167|     26|      assert(role == without_secondary_compat->role);
  168|     26|      assert(del_cb == without_secondary_compat->del_cb);
  169|     26|      assert(!without_secondary_compat->IsSecondaryCacheCompatible());
  170|     26|    }

_ZN7rocksdb10FileSystem4TypeEv:
  272|      2|  static const char* Type() { return "FileSystem"; }

_ZN7rocksdb5SliceC2Ev:
   35|      2|  Slice() : data_(""), size_(0) {}

_ZN7rocksdb6StatusC2Ev:
   45|      2|        state_(nullptr) {}
_ZN7rocksdb6Status2OKEv:
  154|      2|  static Status OK() { return Status(); }

_ZN7rocksdb13ObjectLibrary5EntryD2Ev:
   48|      2|    virtual ~Entry() {}
_ZN7rocksdb13ObjectLibrary12PatternEntryC2ERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
   95|      2|        : name_(name), optional_(optional), slength_(0) {
   96|      2|      nlength_ = name_.size();
   97|      2|    }
_ZN7rocksdb13ObjectLibrary12PatternEntry12AddSeparatorERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
  114|      2|                               bool at_least_one = true) {
  115|      2|      slength_ += separator.size();
  116|      2|      if (at_least_one) {
  ------------------
  |  Branch (116:11): [True: 0, False: 2]
  ------------------
  117|      0|        separators_.emplace_back(separator, kMatchAtLeastOne);
  118|      0|        ++slength_;
  119|      2|      } else {
  120|      2|        separators_.emplace_back(separator, kMatchZeroOrMore);
  121|      2|      }
  122|      2|      return *this;
  123|      2|    }
_ZN7rocksdb13ObjectLibraryC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  192|      2|  explicit ObjectLibrary(const std::string& id) { id_ = id; }
_ZN7rocksdb13ObjectLibrary15AddFactoryEntryEPKcONSt3__110unique_ptrINS0_5EntryENS3_14default_deleteIS5_EEEE:
  268|      2|  void AddFactoryEntry(const char* type, std::unique_ptr<Entry>&& entry) {
  269|      2|    std::unique_lock<std::mutex> lock(mu_);
  270|      2|    auto& factories = factories_[type];
  271|      2|    factories.emplace_back(std::move(entry));
  272|      2|  }
_ZN7rocksdb13ObjectLibrary12FactoryEntryINS_10FileSystemEEC2EPNS0_5EntryENSt3__18functionIFPS2_RKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEPNS6_10unique_ptrIS2_NS6_14default_deleteIS2_EEEEPSE_EEE:
  174|      2|        : entry_(e), factory_(std::move(f)) {}
_ZN7rocksdb13ObjectLibrary10AddFactoryINS_10FileSystemEEERKNSt3__18functionIFPT_RKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPNS3_10unique_ptrIS5_NS3_14default_deleteIS5_EEEEPSC_EEERKNS0_12PatternEntryESO_:
  252|      2|                                   const FactoryFunc<T>& func) {
  253|      2|    std::unique_ptr<Entry> factory(
  254|      2|        new FactoryEntry<T>(new PatternEntry(entry), func));
  255|      2|    AddFactoryEntry(T::Type(), std::move(factory));
  256|      2|    return func;
  257|      2|  }

_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11SystemClockEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdborERKNS_15OptionTypeFlagsES2_:
  115|     86|                                 const OptionTypeFlags& b) {
  116|     86|  return static_cast<OptionTypeFlags>(static_cast<uint32_t>(a) |
  117|     86|                                      static_cast<uint32_t>(b));
  118|     86|}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  261|    718|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo12SetParseFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEESE_PvEEE:
  590|    112|  OptionTypeInfo& SetParseFunc(const ParseFunc& f) {
  591|    112|    parse_func_ = f;
  592|    112|    return *this;
  593|    112|  }
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeE:
  251|     16|        flags_(OptionTypeFlags::kNone) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEE:
  272|     20|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEERKNS5_IFS6_S9_SH_PKvPSF_EEERKNS5_IFbS9_SH_SO_SO_SP_EEE:
  285|     18|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  373|     16|      int offset, OptionVerificationType verification, OptionTypeFlags flags) {
  374|     16|    OptionTypeInfo info(offset, OptionType::kStruct, verification, flags);
  375|     16|    info.SetParseFunc(
  376|       |        // Parses the struct and updates the fields at addr
  377|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  378|     16|                                  const std::string& name,
  379|     16|                                  const std::string& value, void* addr) {
  380|     16|          return ParseStruct(opts, struct_name, struct_map, name, value, addr);
  381|     16|        });
  382|     16|    info.SetSerializeFunc(
  383|       |        // Serializes the struct options into value
  384|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  385|     16|                                  const std::string& name, const void* addr,
  386|     16|                                  std::string* value) {
  387|     16|          return SerializeStruct(opts, struct_name, struct_map, name, addr,
  388|     16|                                 value);
  389|     16|        });
  390|     16|    info.SetEqualsFunc(
  391|       |        // Compares the struct fields of addr1 and addr2 for equality
  392|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  393|     16|                                  const std::string& name, const void* addr1,
  394|     16|                                  const void* addr2, std::string* mismatch) {
  395|     16|          return StructsAreEqual(opts, struct_name, struct_map, name, addr1,
  396|     16|                                 addr2, mismatch);
  397|     16|        });
  398|     16|    return info;
  399|     16|  }
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNS1_8functionIFNS_6StatusERKNS_13ConfigOptionsES9_S9_PvEEE:
  404|      4|      const ParseFunc& parse_func) {
  405|      4|    OptionTypeInfo info(
  406|      4|        Struct(struct_name, struct_map, offset, verification, flags));
  407|      4|    return info.SetParseFunc(parse_func);
  408|      4|  }
_ZN7rocksdb14OptionTypeInfo16SetSerializeFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvPSC_EEE:
  595|     56|  OptionTypeInfo& SetSerializeFunc(const SerializeFunc& f) {
  596|     56|    serialize_func_ = f;
  597|     56|    return *this;
  598|     56|  }
_ZN7rocksdb14OptionTypeInfo13SetEqualsFuncERKNSt3__18functionIFbRKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvSF_PSB_EEE:
  599|     56|  OptionTypeInfo& SetEqualsFunc(const EqualsFunc& f) {
  600|     56|    equals_func_ = f;
  601|     56|    return *this;
  602|     56|  }
_ZN7rocksdb14OptionTypeInfo14SetPrepareFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPvEEE:
  604|      4|  OptionTypeInfo& SetPrepareFunc(const PrepareFunc& f) {
  605|      4|    prepare_func_ = f;
  606|      4|    return *this;
  607|      4|  }
_ZN7rocksdb14OptionTypeInfo15SetValidateFuncERKNSt3__18functionIFNS_6StatusERKNS_9DBOptionsERKNS_19ColumnFamilyOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvEEE:
  609|      4|  OptionTypeInfo& SetValidateFunc(const ValidateFunc& f) {
  610|      4|    validate_func_ = f;
  611|      4|    return *this;
  612|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10FileSystemEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10StatisticsEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo6VectorIiEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_14SliceTransformEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_20PrepopulateBlobCacheEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorINS_15CompressionTypeEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_10ComparatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      2|                                       OptionTypeFlags flags) {
  564|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      2|                        flags | OptionTypeFlags::kRawPointer);
  566|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      2|                                const std::string& name,
  568|      2|                                const std::string& value, void* addr) {
  569|      2|      auto** pointer = static_cast<T**>(addr);
  570|      2|      if (name == kIdPropName() && value.empty()) {
  571|      2|        *pointer = nullptr;
  572|      2|        return Status::OK();
  573|      2|      } else {
  574|      2|        return T::CreateFromString(opts, value, pointer);
  575|      2|      }
  576|      2|    });
  577|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_12TableFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_31TablePropertiesCollectorFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__110shared_ptrINS_31TablePropertiesCollectorFactoryEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_16CompactionFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      4|                                       OptionTypeFlags flags) {
  564|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      4|                        flags | OptionTypeFlags::kRawPointer);
  566|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      4|                                const std::string& name,
  568|      4|                                const std::string& value, void* addr) {
  569|      4|      auto** pointer = static_cast<T**>(addr);
  570|      4|      if (name == kIdPropName() && value.empty()) {
  571|      4|        *pointer = nullptr;
  572|      4|        return Status::OK();
  573|      4|      } else {
  574|      4|        return T::CreateFromString(opts, value, pointer);
  575|      4|      }
  576|      4|    });
  577|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23CompactionFilterFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_13MergeOperatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_21SstPartitionerFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrINS_9WalFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      2|                                       OptionTypeFlags flags) {
  564|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      2|                        flags | OptionTypeFlags::kRawPointer);
  566|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      2|                                const std::string& name,
  568|      2|                                const std::string& value, void* addr) {
  569|      2|      auto** pointer = static_cast<T**>(addr);
  570|      2|      if (name == kIdPropName() && value.empty()) {
  571|      2|        *pointer = nullptr;
  572|      2|        return Status::OK();
  573|      2|      } else {
  574|      2|        return T::CreateFromString(opts, value, pointer);
  575|      2|      }
  576|      2|    });
  577|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_15WALRecoveryModeEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_9DBOptions10AccessHintEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_12InfoLogLevelEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_22FileChecksumGenFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_9CacheTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_11PinningTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      6|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      6|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      6|                        OptionVerificationType::kNormal, flags);
  304|      6|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      6|        [map](const ConfigOptions&, const std::string& name,
  311|      6|              const std::string& value, void* addr) {
  312|      6|          if (map == nullptr) {
  313|      6|            return Status::NotSupported("No enum mapping ", name);
  314|      6|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      6|            return Status::OK();
  316|      6|          } else {
  317|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      6|          }
  319|      6|        });
  320|      6|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      6|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      6|              std::string* value) {
  328|      6|          if (map == nullptr) {
  329|      6|            return Status::NotSupported("No enum mapping ", name);
  330|      6|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      6|                                      value)) {
  332|      6|            return Status::OK();
  333|      6|          } else {
  334|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      6|          }
  336|      6|        });
  337|      6|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      6|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      6|           const void* addr2, std::string*) {
  342|      6|          return (*static_cast<const T*>(addr1) ==
  343|      6|                  *static_cast<const T*>(addr2));
  344|      6|        });
  345|      6|    return info;
  346|      6|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23FlushBlockPolicyFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions9IndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions18DataBlockIndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions19IndexShorteningModeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_12FilterPolicyEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions21PrepopulateBlockCacheEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorImEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo5ArrayImLm2EEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  414|      2|                              char separator = ':') {
  415|      2|    OptionTypeInfo info(_offset, OptionType::kArray, _verification, _flags);
  416|      2|    info.SetParseFunc([elem_info, separator](
  417|      2|                          const ConfigOptions& opts, const std::string& name,
  418|      2|                          const std::string& value, void* addr) {
  419|      2|      auto result = static_cast<std::array<T, kSize>*>(addr);
  420|      2|      return ParseArray<T, kSize>(opts, elem_info, separator, name, value,
  421|      2|                                  result);
  422|      2|    });
  423|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  424|      2|                                                 const std::string& name,
  425|      2|                                                 const void* addr,
  426|      2|                                                 std::string* value) {
  427|      2|      const auto& array = *(static_cast<const std::array<T, kSize>*>(addr));
  428|      2|      return SerializeArray<T, kSize>(opts, elem_info, separator, name, array,
  429|      2|                                      value);
  430|      2|    });
  431|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  432|      2|                                   const std::string& name, const void* addr1,
  433|      2|                                   const void* addr2, std::string* mismatch) {
  434|      2|      const auto& array1 = *(static_cast<const std::array<T, kSize>*>(addr1));
  435|      2|      const auto& array2 = *(static_cast<const std::array<T, kSize>*>(addr2));
  436|      2|      return ArraysAreEqual<T, kSize>(opts, elem_info, name, array1, array2,
  437|      2|                                      mismatch);
  438|      2|    });
  439|      2|    return info;
  440|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINS_27CompactionServiceOutputFileEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_18EncryptionProviderEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11BlockCipherEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }

_ZN7rocksdb21HistogramBucketMapperC2Ev:
   24|      2|HistogramBucketMapper::HistogramBucketMapper() {
   25|       |  // If you change this, you also need to change
   26|       |  // size of array buckets_ in HistogramImpl
   27|      2|  bucketValues_ = {1, 2};
   28|      2|  double bucket_val = static_cast<double>(bucketValues_.back());
   29|    216|  while ((bucket_val = 1.5 * bucket_val) <=
  ------------------
  |  Branch (29:10): [True: 214, False: 2]
  ------------------
   30|    216|         static_cast<double>(std::numeric_limits<uint64_t>::max())) {
   31|    214|    bucketValues_.push_back(static_cast<uint64_t>(bucket_val));
   32|       |    // Extracts two most significant digits to make histogram buckets more
   33|       |    // human-readable. E.g., 172 becomes 170.
   34|    214|    uint64_t pow_of_ten = 1;
   35|  1.99k|    while (bucketValues_.back() / 10 > 10) {
  ------------------
  |  Branch (35:12): [True: 1.77k, False: 214]
  ------------------
   36|  1.77k|      bucketValues_.back() /= 10;
   37|  1.77k|      pow_of_ten *= 10;
   38|  1.77k|    }
   39|    214|    bucketValues_.back() *= pow_of_ten;
   40|    214|  }
   41|      2|  maxBucketValue_ = bucketValues_.back();
   42|      2|  minBucketValue_ = bucketValues_.front();
   43|      2|}

_ZN7rocksdb4port5MutexC2Eb:
   59|      4|Mutex::Mutex(bool adaptive) {
   60|      4|  (void)adaptive;
   61|       |#ifdef ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   62|       |  if (!adaptive) {
   63|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   64|       |  } else {
   65|       |    pthread_mutexattr_t mutex_attr;
   66|       |    PthreadCall("init mutex attr", pthread_mutexattr_init(&mutex_attr));
   67|       |    PthreadCall("set mutex attr", pthread_mutexattr_settype(
   68|       |                                      &mutex_attr, PTHREAD_MUTEX_ADAPTIVE_NP));
   69|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, &mutex_attr));
   70|       |    PthreadCall("destroy mutex attr", pthread_mutexattr_destroy(&mutex_attr));
   71|       |  }
   72|       |#else
   73|      4|  PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   74|      4|#endif  // ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   75|      4|}
_ZN7rocksdb4port7RWMutexC2Ev:
  152|      2|RWMutex::RWMutex() {
  153|      2|  PthreadCall("init mutex", pthread_rwlock_init(&mu_, nullptr));
  154|      2|}
port_posix.cc:_ZN7rocksdb4portL11PthreadCallEPKci:
   51|      6|static int PthreadCall(const char* label, int result) {
   52|      6|  if (result != 0 && result != ETIMEDOUT && result != EBUSY) {
  ------------------
  |  Branch (52:7): [True: 0, False: 6]
  |  Branch (52:22): [True: 0, False: 0]
  |  Branch (52:45): [True: 0, False: 0]
  ------------------
   53|      0|    fprintf(stderr, "pthread %s: %s\n", label, errnoStr(result).c_str());
   54|      0|    abort();
   55|      0|  }
   56|      6|  return result;
   57|      6|}
port_posix.cc:_ZN7rocksdb4portL11GetPageSizeEv:
  241|      2|static size_t GetPageSize() {
  242|      2|#if defined(OS_LINUX) || defined(_SC_PAGESIZE)
  243|      2|  long v = sysconf(_SC_PAGESIZE);
  244|      2|  if (v >= 1024) {
  ------------------
  |  Branch (244:7): [True: 2, False: 0]
  ------------------
  245|      2|    return static_cast<size_t>(v);
  246|      2|  }
  247|      0|#endif
  248|       |  // Default assume 4KB
  249|      0|  return 4U * 1024U;
  250|      2|}

_ZN7rocksdb11BlockHandleC2Emm:
  376|      2|    : offset_(_offset), size_(_size) {}

_ZN7rocksdb22PersistentCacheOptionsC2Ev:
   20|      2|  PersistentCacheOptions() {}

crc32c.cc:_ZN7rocksdb6crc32cL7isSSE42Ev:
  332|      2|static bool isSSE42() {
  333|      2|#ifndef HAVE_SSE42
  334|      2|  return false;
  335|       |#elif defined(__GNUC__) && defined(__x86_64__) && !defined(IOS_CROSS_COMPILE)
  336|       |  uint32_t c_;
  337|       |  __asm__("cpuid" : "=c"(c_) : "a"(1) : "ebx", "edx");
  338|       |  return c_ & (1U << 20);  // copied from CpuId.h in Folly. Test SSE42
  339|       |#elif defined(_WIN64)
  340|       |  int info[4];
  341|       |  __cpuidex(info, 0x00000001, 0);
  342|       |  return (info[2] & ((int)1 << 20)) != 0;
  343|       |#else
  344|       |  return false;
  345|       |#endif
  346|      2|}

_ZN7rocksdb13ObjectLibrary7DefaultEv:
  208|      2|std::shared_ptr<ObjectLibrary> &ObjectLibrary::Default() {
  209|       |  // Use avoid destruction here so the default ObjectLibrary will not be
  210|       |  // statically destroyed and long-lived.
  211|      2|  STATIC_AVOID_DESTRUCTION(std::shared_ptr<ObjectLibrary>, instance)
  ------------------
  |  |   53|      2|#define STATIC_AVOID_DESTRUCTION(Type, name) static Type& name = *new Type
  ------------------
  212|      2|  (std::make_shared<ObjectLibrary>("default"));
  213|      2|  return instance;
  214|      2|}

