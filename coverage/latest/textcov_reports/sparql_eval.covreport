_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith16SelectProjectionENtB5_9Arbitrary9arbitraryB12_:
  679|      3|        u.arbitrary_iter()?.collect()
  680|      3|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith20PathOneInPropertySetENtB5_9Arbitrary9arbitraryB12_:
  679|      1|        u.arbitrary_iter()?.collect()
  680|      1|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith20RelationalExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|    162|        u.arbitrary_iter()?.collect()
  680|    162|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith12PathSequenceENtB5_9Arbitrary9arbitraryB12_:
  679|      9|        u.arbitrary_iter()?.collect()
  680|      9|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith23PropertyListPathElementEENtB5_9Arbitrary9arbitraryB1E_:
  679|      5|        u.arbitrary_iter()?.collect()
  680|      5|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith10ConstraintENtB5_9Arbitrary9arbitraryB12_:
  679|      1|        u.arbitrary_iter()?.collect()
  680|      1|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith14GroupConditionENtB5_9Arbitrary9arbitraryB12_:
  679|      1|        u.arbitrary_iter()?.collect()
  680|      1|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith24ConditionalAndExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|    109|        u.arbitrary_iter()?.collect()
  680|    109|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith30GroupGraphPatternSubOtherBlockENtB5_9Arbitrary9arbitraryB12_:
  679|      9|        u.arbitrary_iter()?.collect()
  680|      9|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith16PathEltOrInverseENtB5_9Arbitrary9arbitraryB12_:
  679|     17|        u.arbitrary_iter()?.collect()
  680|     17|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith23ConditionalOrExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|    103|        u.arbitrary_iter()?.collect()
  680|    103|    }
_RNvXsa_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc3vec3VecNtCs1gTnyt4wREc_12sparql_smith13GraphNodePathENtB5_9Arbitrary9arbitraryB12_:
  679|     15|        u.arbitrary_iter()?.collect()
  680|     15|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith12TriplesBlockEENtB5_9Arbitrary9arbitraryB1G_:
  530|      2|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      2|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      1|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      1|            None
  535|       |        })
  536|      2|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith12HavingClauseENtB5_9Arbitrary9arbitraryB17_:
  530|      3|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      3|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      3|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      0|            None
  535|       |        })
  536|      3|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith12SelectOptionENtB5_9Arbitrary9arbitraryB17_:
  530|     13|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|     13|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      5|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      8|            None
  535|       |        })
  536|     13|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith12TriplesBlockENtB5_9Arbitrary9arbitraryB17_:
  530|     10|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|     10|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      3|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      7|            None
  535|       |        })
  536|     10|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith24PropertyListPathNotEmptyENtB5_9Arbitrary9arbitraryB17_:
  530|      1|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      1|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      1|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      0|            None
  535|       |        })
  536|      1|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith7PathModENtB5_9Arbitrary9arbitraryB17_:
  530|     46|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|     46|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|     31|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|     15|            None
  535|       |        })
  536|     46|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionIBu_INtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith12TriplesBlockEEENtB5_9Arbitrary9arbitraryB1K_:
  530|      4|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      4|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      2|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      2|            None
  535|       |        })
  536|      4|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith11GroupClauseENtB5_9Arbitrary9arbitraryB17_:
  530|      6|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      6|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      3|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      3|            None
  535|       |        })
  536|      6|    }
_RNvXs5_Cs99AoNPYHiPX_9arbitraryINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith23PropertyListPathElementENtB5_9Arbitrary9arbitraryB17_:
  530|      2|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  531|      2|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  532|      2|            Some(Arbitrary::arbitrary(u)?)
  533|       |        } else {
  534|      0|            None
  535|       |        })
  536|      2|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith14ObjectListPathENtB5_9Arbitrary9arbitraryB14_:
  920|      5|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|      5|        Arbitrary::arbitrary(u).map(Self::new)
  922|      5|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith12TriplesBlockENtB5_9Arbitrary9arbitraryB14_:
  920|      1|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|      1|        Arbitrary::arbitrary(u).map(Self::new)
  922|      1|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith9SubSelectENtB5_9Arbitrary9arbitraryB14_:
  920|      6|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|      6|        Arbitrary::arbitrary(u).map(Self::new)
  922|      6|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith23ConditionalOrExpressionENtB5_9Arbitrary9arbitraryB14_:
  920|    512|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|    512|        Arbitrary::arbitrary(u).map(Self::new)
  922|    512|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith13GraphNodePathENtB5_9Arbitrary9arbitraryB14_:
  920|      8|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|      8|        Arbitrary::arbitrary(u).map(Self::new)
  922|      8|    }
_RNvXsp_Cs99AoNPYHiPX_9arbitraryINtNtCsgSvt34q9kKf_5alloc5boxed3BoxNtCs1gTnyt4wREc_12sparql_smith15PathAlternativeENtB5_9Arbitrary9arbitraryB14_:
  920|      2|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  921|      2|        Arbitrary::arbitrary(u).map(Self::new)
  922|      2|    }
_RNvXsH_Cs99AoNPYHiPX_9arbitrarymNtB5_9Arbitrary9arbitrary:
  309|  6.59k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  6.59k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  6.59k|                    u.fill_buffer(&mut buf)?;
  312|  6.59k|                    let mut x: $unsigned = 0;
  313|  26.3k|                    for i in 0..mem::size_of::<$ty>() {
  314|  26.3k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  26.3k|                    }
  316|  6.59k|                    Ok(x as $ty)
  317|  6.59k|                }
_RNvXs_Cs99AoNPYHiPX_9arbitrarybNtB4_9Arbitrary9arbitrary:
  295|    684|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  296|    684|        Ok(<u8 as Arbitrary<'a>>::arbitrary(u)? & 1 == 1)
  297|    684|    }
_RNvXsF_Cs99AoNPYHiPX_9arbitraryhNtB5_9Arbitrary9arbitrary:
  309|    684|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    684|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    684|                    u.fill_buffer(&mut buf)?;
  312|    684|                    let mut x: $unsigned = 0;
  313|    684|                    for i in 0..mem::size_of::<$ty>() {
  314|    684|                        x |= buf[i] as $unsigned << (i * 8);
  315|    684|                    }
  316|    684|                    Ok(x as $ty)
  317|    684|                }

_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_implhINtNtNtNtCslsxegF6CoTF_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEECs1gTnyt4wREc_12sparql_smith:
  302|    837|    fn int_in_range_impl<T>(
  303|    837|        range: ops::RangeInclusive<T>,
  304|    837|        mut bytes: impl Iterator<Item = u8>,
  305|    837|    ) -> Result<(T, usize)>
  306|    837|    where
  307|    837|        T: Int,
  308|    837|    {
  309|    837|        let start = *range.start();
  310|    837|        let end = *range.end();
  311|    837|        assert!(
  312|    837|            start <= end,
  313|    837|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    837|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    837|        if start == end {
  319|      0|            return Ok((start, 0));
  320|    837|        }
  321|    837|
  322|    837|        // From here on out we work with the unsigned representation. All of the
  323|    837|        // operations performed below work out just as well whether or not `T`
  324|    837|        // is a signed or unsigned integer.
  325|    837|        let start = start.to_unsigned();
  326|    837|        let end = end.to_unsigned();
  327|    837|
  328|    837|        let delta = end.wrapping_sub(start);
  329|      0|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    837|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    837|        let mut bytes_consumed: usize = 0;
  337|       |
  338|  1.67k|        while (bytes_consumed < mem::size_of::<T>())
  339|    837|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    837|            let byte = match bytes.next() {
  342|      0|                None => break,
  343|    837|                Some(b) => b,
  344|    837|            };
  345|    837|            bytes_consumed += 1;
  346|    837|
  347|    837|            // Combine this byte into our arbitrary integer, but avoid
  348|    837|            // overflowing the shift for `u8` and `i8`.
  349|    837|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|    837|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|      0|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    837|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    837|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    837|        let result = start.wrapping_add(offset);
  365|    837|
  366|    837|        // And convert back to our maybe-signed representation.
  367|    837|        let result = T::from_unsigned(result);
  368|      0|        debug_assert!(*range.start() <= result);
  369|      0|        debug_assert!(result <= *range.end());
  370|       |
  371|    837|        Ok((result, bytes_consumed))
  372|    837|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith24ConditionalAndExpressionEB1i_:
  606|    109|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    109|        &'b mut self,
  608|    109|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    109|        Ok(ArbitraryIter {
  610|    109|            u: &mut *self,
  611|    109|            _marker: PhantomData,
  612|    109|        })
  613|    109|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangehECs1gTnyt4wREc_12sparql_smith:
  293|    837|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    837|    where
  295|    837|        T: Int,
  296|    837|    {
  297|    837|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    837|        self.data = &self.data[bytes_consumed..];
  299|    837|        Ok(result)
  300|    837|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith14GroupConditionENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|      2|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|      2|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|      2|        if keep_going {
  729|      2|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      0|            None
  732|       |        }
  733|      2|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith16SelectProjectionEB1i_:
  606|      3|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      3|        &'b mut self,
  608|      3|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      3|        Ok(ArbitraryIter {
  610|      3|            u: &mut *self,
  611|      3|            _marker: PhantomData,
  612|      3|        })
  613|      3|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith23ConditionalOrExpressionENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|    115|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|    115|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|    115|        if keep_going {
  729|     59|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|     56|            None
  732|       |        }
  733|    115|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith23PropertyListPathElementEEB1U_:
  606|      5|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      5|        &'b mut self,
  608|      5|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      5|        Ok(ArbitraryIter {
  610|      5|            u: &mut *self,
  611|      5|            _marker: PhantomData,
  612|      5|        })
  613|      5|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith20PathOneInPropertySetENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|      3|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|      3|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|      3|        if keep_going {
  729|      2|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      1|            None
  732|       |        }
  733|      3|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith14GroupConditionEB1i_:
  606|      1|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      1|        &'b mut self,
  608|      1|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      1|        Ok(ArbitraryIter {
  610|      1|            u: &mut *self,
  611|      1|            _marker: PhantomData,
  612|      1|        })
  613|      1|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith30GroupGraphPatternSubOtherBlockEB1i_:
  606|      9|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      9|        &'b mut self,
  608|      9|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      9|        Ok(ArbitraryIter {
  610|      9|            u: &mut *self,
  611|      9|            _marker: PhantomData,
  612|      9|        })
  613|      9|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured6chooseReECs1gTnyt4wREc_12sparql_smith:
  408|    368|    pub fn choose<'b, T>(&mut self, choices: &'b [T]) -> Result<&'b T> {
  409|    368|        let idx = self.choose_index(choices.len())?;
  410|    368|        Ok(&choices[idx])
  411|    368|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterINtNtCslsxegF6CoTF_4core6option6OptionNtCs1gTnyt4wREc_12sparql_smith23PropertyListPathElementEENtNtNtNtB18_4iter6traits8iterator8Iterator4nextB1H_:
  726|      7|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|      7|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|      7|        if keep_going {
  729|      2|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      5|            None
  732|       |        }
  733|      7|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith10ConstraintENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|      1|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|      1|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|      1|        if keep_going {
  729|      1|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      0|            None
  732|       |        }
  733|      1|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith13GraphNodePathENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|     88|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|     88|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|     88|        if keep_going {
  729|     73|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|     15|            None
  732|       |        }
  733|     88|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith16PathEltOrInverseEB1i_:
  606|     17|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|     17|        &'b mut self,
  608|     17|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|     17|        Ok(ArbitraryIter {
  610|     17|            u: &mut *self,
  611|     17|            _marker: PhantomData,
  612|     17|        })
  613|     17|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith20RelationalExpressionENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|    181|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|    181|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|    181|        if keep_going {
  729|     67|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|    114|            None
  732|       |        }
  733|    181|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith24ConditionalAndExpressionENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|    114|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|    114|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|    114|        if keep_going {
  729|     20|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|     94|            None
  732|       |        }
  733|    114|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith30GroupGraphPatternSubOtherBlockENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|     10|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|     10|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|     10|        if keep_going {
  729|      2|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      8|            None
  732|       |        }
  733|     10|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith23ConditionalOrExpressionEB1i_:
  606|    103|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    103|        &'b mut self,
  608|    103|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    103|        Ok(ArbitraryIter {
  610|    103|            u: &mut *self,
  611|    103|            _marker: PhantomData,
  612|    103|        })
  613|    103|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith16SelectProjectionENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|      3|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|      3|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|      3|        if keep_going {
  729|      0|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      3|            None
  732|       |        }
  733|      3|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith13GraphNodePathEB1i_:
  606|     15|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|     15|        &'b mut self,
  608|     15|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|     15|        Ok(ArbitraryIter {
  610|     15|            u: &mut *self,
  611|     15|            _marker: PhantomData,
  612|     15|        })
  613|     15|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith20PathOneInPropertySetEB1i_:
  606|      1|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      1|        &'b mut self,
  608|      1|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      1|        Ok(ArbitraryIter {
  610|      1|            u: &mut *self,
  611|      1|            _marker: PhantomData,
  612|      1|        })
  613|      1|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith20RelationalExpressionEB1i_:
  606|    162|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    162|        &'b mut self,
  608|    162|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    162|        Ok(ArbitraryIter {
  610|    162|            u: &mut *self,
  611|    162|            _marker: PhantomData,
  612|    162|        })
  613|    162|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith10ConstraintEB1i_:
  606|      1|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      1|        &'b mut self,
  608|      1|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      1|        Ok(ArbitraryIter {
  610|      1|            u: &mut *self,
  611|      1|            _marker: PhantomData,
  612|      1|        })
  613|      1|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs1gTnyt4wREc_12sparql_smith12PathSequenceEB1i_:
  606|      9|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|      9|        &'b mut self,
  608|      9|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|      9|        Ok(ArbitraryIter {
  610|      9|            u: &mut *self,
  611|      9|            _marker: PhantomData,
  612|      9|        })
  613|      9|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith12PathSequenceENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|     17|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|     17|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|     17|        if keep_going {
  729|      8|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|      9|            None
  732|       |        }
  733|     17|    }
_RNvXs_NtCs99AoNPYHiPX_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs1gTnyt4wREc_12sparql_smith16PathEltOrInverseENtNtNtNtCslsxegF6CoTF_4core4iter6traits8iterator8Iterator4nextB15_:
  726|     46|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|     46|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|     46|        if keep_going {
  729|     29|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|     17|            None
  732|       |        }
  733|     46|    }
_RNvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB2_12Unstructured3lenCs1gTnyt4wREc_12sparql_smith:
  108|  8.80k|    pub fn len(&self) -> usize {
  109|  8.80k|        self.data.len()
  110|  8.80k|    }
_RNvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB2_12Unstructured8is_emptyCs1gTnyt4wREc_12sparql_smith:
  132|  8.80k|    pub fn is_empty(&self) -> bool {
  133|  8.80k|        self.len() == 0
  134|  8.80k|    }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int7from_u8:
  836|    368|                fn from_u8(b: u8) -> Self {
  837|    368|                    b as Self
  838|    368|                }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int11to_unsigned:
  856|    736|                fn to_unsigned(self) -> Self::Unsigned {
  857|    736|                    self as $unsigned_ty
  858|    736|                }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int12wrapping_add:
  848|    837|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    837|                    <$ty>::wrapping_add(self, rhs)
  850|    837|                }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int11checked_add:
  844|    837|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    837|                    <$ty>::checked_add(self, rhs)
  846|    837|                }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejEB5_:
  293|    368|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    368|    where
  295|    368|        T: Int,
  296|    368|    {
  297|    368|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    368|        self.data = &self.data[bytes_consumed..];
  299|    368|        Ok(result)
  300|    368|    }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int12wrapping_add:
  848|    368|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    368|                    <$ty>::wrapping_add(self, rhs)
  850|    368|                }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int11checked_add:
  844|    368|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    368|                    <$ty>::checked_add(self, rhs)
  846|    368|                }
_RNvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB2_12Unstructured12choose_index:
  450|    368|    pub fn choose_index(&mut self, len: usize) -> Result<usize> {
  451|    368|        if len == 0 {
  452|      0|            return Err(Error::EmptyChoose);
  453|    368|        }
  454|    368|        let idx = self.int_in_range(0..=len - 1)?;
  455|    368|        Ok(idx)
  456|    368|    }
_RNvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|  7.27k|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|  7.27k|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|  7.27k|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|  7.27k|        for byte in buffer[n..].iter_mut() {
  525|    148|            *byte = 0;
  526|    148|        }
  527|  7.27k|        self.data = &self.data[n..];
  528|  7.27k|        Ok(())
  529|  7.27k|    }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int10from_usize:
  840|    837|                fn from_usize(u: usize) -> Self {
  841|    837|                    u as Self
  842|    837|                }
_RNvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|      7|    pub fn new(data: &'a [u8]) -> Self {
   86|      7|        Unstructured { data }
   87|      7|    }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int11to_unsigned:
  856|  1.67k|                fn to_unsigned(self) -> Self::Unsigned {
  857|  1.67k|                    self as $unsigned_ty
  858|  1.67k|                }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int13from_unsigned:
  860|    837|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    837|                    unsigned as Self
  862|    837|                }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int12wrapping_sub:
  852|    837|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    837|                    <$ty>::wrapping_sub(self, rhs)
  854|    837|                }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int10from_usize:
  840|    736|                fn from_usize(u: usize) -> Self {
  841|    736|                    u as Self
  842|    736|                }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int13from_unsigned:
  860|    368|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    368|                    unsigned as Self
  862|    368|                }
_RNvXs6_NtCs99AoNPYHiPX_9arbitrary12unstructuredjNtB5_3Int12wrapping_sub:
  852|    368|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    368|                    <$ty>::wrapping_sub(self, rhs)
  854|    368|                }
_RNvXs1_NtCs99AoNPYHiPX_9arbitrary12unstructuredhNtB5_3Int7from_u8:
  836|    837|                fn from_u8(b: u8) -> Self {
  837|    837|                    b as Self
  838|    837|                }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarybEB5_:
  167|    587|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    587|    where
  169|    587|        A: Arbitrary<'a>,
  170|    587|    {
  171|    587|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    587|    }
_RINvMNtCs99AoNPYHiPX_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCslsxegF6CoTF_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|    368|    fn int_in_range_impl<T>(
  303|    368|        range: ops::RangeInclusive<T>,
  304|    368|        mut bytes: impl Iterator<Item = u8>,
  305|    368|    ) -> Result<(T, usize)>
  306|    368|    where
  307|    368|        T: Int,
  308|    368|    {
  309|    368|        let start = *range.start();
  310|    368|        let end = *range.end();
  311|    368|        assert!(
  312|    368|            start <= end,
  313|    368|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    368|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    368|        if start == end {
  319|      0|            return Ok((start, 0));
  320|    368|        }
  321|    368|
  322|    368|        // From here on out we work with the unsigned representation. All of the
  323|    368|        // operations performed below work out just as well whether or not `T`
  324|    368|        // is a signed or unsigned integer.
  325|    368|        let start = start.to_unsigned();
  326|    368|        let end = end.to_unsigned();
  327|    368|
  328|    368|        let delta = end.wrapping_sub(start);
  329|      0|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    368|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    368|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    736|        while (bytes_consumed < mem::size_of::<T>())
  339|    736|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    368|            let byte = match bytes.next() {
  342|      0|                None => break,
  343|    368|                Some(b) => b,
  344|    368|            };
  345|    368|            bytes_consumed += 1;
  346|    368|
  347|    368|            // Combine this byte into our arbitrary integer, but avoid
  348|    368|            // overflowing the shift for `u8` and `i8`.
  349|    368|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|    368|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    368|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    368|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    368|        let result = start.wrapping_add(offset);
  365|    368|
  366|    368|        // And convert back to our maybe-signed representation.
  367|    368|        let result = T::from_unsigned(result);
  368|      0|        debug_assert!(*range.start() <= result);
  369|      0|        debug_assert!(result <= *range.end());
  370|       |
  371|    368|        Ok((result, bytes_consumed))
  372|    368|    }

rust_fuzzer_test_input:
  259|      7|            pub extern "C" fn rust_fuzzer_test_input(bytes: &[u8]) -> i32 {
  260|      7|                use $crate::arbitrary::{Arbitrary, Unstructured};
  261|      7|
  262|      7|                // Early exit if we don't have enough bytes for the `Arbitrary`
  263|      7|                // implementation. This helps the fuzzer avoid exploring all the
  264|      7|                // different not-enough-input-bytes paths inside the `Arbitrary`
  265|      7|                // implementation. Additionally, it exits faster, letting the fuzzer
  266|      7|                // get to longer inputs that actually lead to interesting executions
  267|      7|                // quicker.
  268|      7|                if bytes.len() < <$dty as Arbitrary>::size_hint(0).0 {
  269|      0|                    return -1;
  270|      7|                }
  271|      7|
  272|      7|                let mut u = Unstructured::new(bytes);
  273|      7|                let data = <$dty as Arbitrary>::arbitrary_take_rest(u);
  274|       |
  275|       |                // When `RUST_LIBFUZZER_DEBUG_PATH` is set, write the debug
  276|       |                // formatting of the input to that file. This is only intended for
  277|       |                // `cargo fuzz`'s use!
  278|       |
  279|       |                // `RUST_LIBFUZZER_DEBUG_PATH` is set in initialization.
  280|      7|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  281|       |                    use std::io::Write;
  282|      0|                    let mut file = std::fs::File::create(path)
  283|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  284|      0|                    (match data {
  285|      0|                        Ok(data) => writeln!(&mut file, "{:#?}", data),
  286|      0|                        Err(err) => writeln!(&mut file, "Arbitrary Error: {}", err),
  287|       |                    })
  288|      0|                    .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  289|      0|                    return -1;
  290|      7|                }
  291|       |
  292|      7|                let data = match data {
  293|      0|                    Ok(d) => d,
  294|      7|                    Err(_) => return -1,
  295|       |                };
  296|       |
  297|      0|                let result = ::libfuzzer_sys::Corpus::from(__libfuzzer_sys_run(data));
  298|      0|                result.to_libfuzzer_code()
  299|      7|            }
LLVMFuzzerTestOneInput:
   58|      7|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|      7|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|      7|    });
   63|      7|
   64|      7|    match test_input {
   65|      7|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|      7|}
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}
_RNCNvCs668liaixNHi_13libfuzzer_sys15test_input_wrap0B3_:
   59|      7|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|      7|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|      7|        rust_fuzzer_test_input(data_slice)
   62|      7|    });

_RNvMs2_NtCsfVMCCA8w6lP_9once_cell3impINtB5_8OnceCellNtNtCsgSvt34q9kKf_5alloc6string6StringE14is_initializedCs668liaixNHi_13libfuzzer_sys:
   49|      7|    pub(crate) fn is_initialized(&self) -> bool {
   50|      7|        // An `Acquire` load is enough because that makes all the initialization
   51|      7|        // operations visible to us, and, this being a fast path, weaker
   52|      7|        // ordering helps with performance. This `Acquire` synchronizes with
   53|      7|        // `SeqCst` operations on the slow path.
   54|      7|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   55|      7|    }

_RNvMs4_NtCsfVMCCA8w6lP_9once_cell4syncINtB5_8OnceCellNtNtCsgSvt34q9kKf_5alloc6string6StringE3getCs668liaixNHi_13libfuzzer_sys:
  965|      7|        pub fn get(&self) -> Option<&T> {
  966|      7|            if self.0.is_initialized() {
  967|       |                // Safe b/c value is initialized.
  968|      0|                Some(unsafe { self.get_unchecked() })
  969|       |            } else {
  970|      7|                None
  971|       |            }
  972|      7|        }

_RNvNvNvCs1gTnyt4wREc_12sparql_smiths10_1__40RECURSIVE_COUNT_ConditionalAndExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths11_1__36RECURSIVE_COUNT_RelationalExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths13_1__40RECURSIVE_COUNT_MultiplicativeExpression7___getitB5_:
   82|     15|            unsafe fn __getit(
   83|     15|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     15|            ) -> $crate::option::Option<&'static $t> {
   85|     15|                #[thread_local]
   86|     15|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     15|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     15|
   89|     15|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     15|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     15|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     15|                #[allow(unused_unsafe)]
   93|     15|                unsafe {
   94|     15|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     15|                    })
  104|     15|                }
  105|     15|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths16_1__36RECURSIVE_COUNT_BrackettedExpression7___getitB5_:
   82|     14|            unsafe fn __getit(
   83|     14|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     14|            ) -> $crate::option::Option<&'static $t> {
   85|     14|                #[thread_local]
   86|     14|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     14|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     14|
   89|     14|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     14|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     14|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     14|                #[allow(unused_unsafe)]
   93|     14|                unsafe {
   94|     14|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     14|                    })
  104|     14|                }
  105|     14|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths15_1__33RECURSIVE_COUNT_PrimaryExpression7___getitB5_:
   82|     15|            unsafe fn __getit(
   83|     15|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     15|            ) -> $crate::option::Option<&'static $t> {
   85|     15|                #[thread_local]
   86|     15|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     15|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     15|
   89|     15|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     15|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     15|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     15|                #[allow(unused_unsafe)]
   93|     15|                unsafe {
   94|     15|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     15|                    })
  104|     15|                }
  105|     15|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths15_1__33RECURSIVE_COUNT_PrimaryExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths10_1__40RECURSIVE_COUNT_ConditionalAndExpression7___getitB5_:
   82|     14|            unsafe fn __getit(
   83|     14|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     14|            ) -> $crate::option::Option<&'static $t> {
   85|     14|                #[thread_local]
   86|     14|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     14|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     14|
   89|     14|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     14|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     14|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     14|                #[allow(unused_unsafe)]
   93|     14|                unsafe {
   94|     14|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     14|                    })
  104|     14|                }
  105|     14|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths12_1__34RECURSIVE_COUNT_AdditiveExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smithsZ_1__39RECURSIVE_COUNT_ConditionalOrExpression7___getitB5_:
   82|     14|            unsafe fn __getit(
   83|     14|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     14|            ) -> $crate::option::Option<&'static $t> {
   85|     14|                #[thread_local]
   86|     14|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     14|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     14|
   89|     14|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     14|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     14|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     14|                #[allow(unused_unsafe)]
   93|     14|                unsafe {
   94|     14|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     14|                    })
  104|     14|                }
  105|     14|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths11_1__36RECURSIVE_COUNT_RelationalExpression7___getitB5_:
   82|     14|            unsafe fn __getit(
   83|     14|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     14|            ) -> $crate::option::Option<&'static $t> {
   85|     14|                #[thread_local]
   86|     14|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     14|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     14|
   89|     14|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     14|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     14|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     14|                #[allow(unused_unsafe)]
   93|     14|                unsafe {
   94|     14|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     14|                    })
  104|     14|                }
  105|     14|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smithsZ_1__39RECURSIVE_COUNT_ConditionalOrExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths12_1__34RECURSIVE_COUNT_AdditiveExpression7___getitB5_:
   82|     15|            unsafe fn __getit(
   83|     15|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     15|            ) -> $crate::option::Option<&'static $t> {
   85|     15|                #[thread_local]
   86|     15|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     15|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     15|
   89|     15|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     15|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     15|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     15|                #[allow(unused_unsafe)]
   93|     15|                unsafe {
   94|     15|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     15|                    })
  104|     15|                }
  105|     15|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths14_1__31RECURSIVE_COUNT_UnaryExpression7___getitB5_:
   82|     18|            unsafe fn __getit(
   83|     18|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   84|     18|            ) -> $crate::option::Option<&'static $t> {
   85|     18|                #[thread_local]
   86|     18|                static __KEY: $crate::thread::local_impl::Key<$t> =
   87|     18|                    $crate::thread::local_impl::Key::<$t>::new();
   88|     18|
   89|     18|                // FIXME: remove the #[allow(...)] marker when macros don't
   90|     18|                // raise warning for missing/extraneous unsafe blocks anymore.
   91|     18|                // See https://github.com/rust-lang/rust/issues/74838.
   92|     18|                #[allow(unused_unsafe)]
   93|     18|                unsafe {
   94|     18|                    __KEY.get(move || {
   95|       |                        if let $crate::option::Option::Some(init) = init {
   96|       |                            if let $crate::option::Option::Some(value) = init.take() {
   97|       |                                return value;
   98|       |                            } else if $crate::cfg!(debug_assertions) {
   99|       |                                $crate::unreachable!("missing default value");
  100|       |                            }
  101|       |                        }
  102|       |                        __init()
  103|     18|                    })
  104|     18|                }
  105|     18|            }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths14_1__31RECURSIVE_COUNT_UnaryExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths13_1__40RECURSIVE_COUNT_MultiplicativeExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }
_RNvNvNvCs1gTnyt4wREc_12sparql_smiths16_1__36RECURSIVE_COUNT_BrackettedExpression6___initB5_:
   79|      1|            fn __init() -> $t { $init }

_RNvXNvCs1gTnyt4wREc_12sparql_smithsK_1__NtB4_7PathModNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1018|     93|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths5_1__NtB4_16SelectProjectionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  142|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsE_1__NtB4_23PropertyListPathElementNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  895|      6|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsR_1__NtB4_25BlankNodePropertyListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1145|      3|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsv_1__NtB4_14ExpressionListNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  750|    309|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths11_1__NtB4_20RelationalExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1337|  1.97k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths1a_1__NtB4_13IriOrFunctionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1584|  1.20k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsB_1__NtB4_16PropertyListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  865|      3|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsf_1__NtB4_12TriplesBlockNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  444|     12|#[derive(Arbitrary)]
_RNvXCs1gTnyt4wREc_12sparql_smithNtB2_5QueryNtCs99AoNPYHiPX_9arbitrary9Arbitrary19arbitrary_take_rest:
   57|      7|    fn arbitrary_take_rest(u: Unstructured<'a>) -> Result<Self> {
   58|      7|        Ok(Self {
   59|      7|            inner: QueryContent::arbitrary_take_rest(u)?,
   60|       |        })
   61|      7|    }
_RNvXNvCs1gTnyt4wREc_12sparql_smithse_1__NtB4_30GroupGraphPatternSubOtherBlockNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  419|      6|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths9_1__NtB4_14GroupConditionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  236|     15|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsd_1__NtB4_20GroupGraphPatternSubNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  412|     27|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths1_1__NtB4_9SubSelectNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  101|     18|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths14_1__NtB4_15UnaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1406|  4.89k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsM_1__NtB4_22PathNegatedPropertySetNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1056|      6|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsW_1__NtB4_9VarOrTermNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1223|    249|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsG_1__NtB4_15PathAlternativeNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  951|     27|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths13_1__NtB4_24MultiplicativeExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1388|  3.40k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths18_1__NtB4_10ExistsFuncNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1560|      3|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsV_1__NtB4_13GraphNodePathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1207|    264|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths3_1__NtB4_12SelectOptionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  127|     15|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smith1__NtB4_12QueryContentNtCs99AoNPYHiPX_9arbitrary9Arbitrary19arbitrary_take_rest:
   36|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsc_1__NtB4_17GroupGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  394|     45|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths17_1__NtB4_11BuiltInCallNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1460|    912|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsN_1__NtB4_20PathOneInPropertySetNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1081|     12|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsZ_1__NtB4_23ConditionalOrExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1300|  1.71k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths10_1__NtB4_24ConditionalAndExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1317|  1.77k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths19_1__NtB4_13NotExistsFuncNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1572|      9|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsY_1__NtB4_9GraphTermNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1278|      3|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths12_1__NtB4_18AdditiveExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1370|  2.50k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsh_1__NtB4_20OptionalGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  494|      3|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsC_1__NtB4_24PropertyListPathNotEmptyNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  881|     15|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths_1__NtB4_12QueryVariantNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
   44|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths15_1__NtB4_17PrimaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1426|  4.88k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths7_1__NtB4_16SolutionModifierNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  188|     18|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsQ_1__NtB4_15TriplesNodePathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1129|     27|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths8_1__NtB4_11GroupClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  219|      9|#[derive(Arbitrary)]
_RNvXCs1gTnyt4wREc_12sparql_smithNtB2_5QueryNtCs99AoNPYHiPX_9arbitrary9Arbitrary9size_hint:
   63|      7|    fn size_hint(_depth: usize) -> (usize, Option<usize>) {
   64|      7|        (20, None)
   65|      7|    }
_RNvXNvCs1gTnyt4wREc_12sparql_smiths6_1__NtB4_11WhereClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  172|     27|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths4_1__NtB4_12SelectValuesNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  133|     39|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsA_1__NtB4_22TriplesSameSubjectPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  833|     12|#[derive(Arbitrary)]
_RNvXs1b_Cs1gTnyt4wREc_12sparql_smithNtB6_3IriNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1635|    443|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 1636|    443|        Ok(Self {
 1637|    443|            value: u.int_in_range(1..=NUMBER_OF_NAMED_NODES)?,
 1638|       |        })
 1639|    443|    }
_RNvXNvCs1gTnyt4wREc_12sparql_smiths16_1__NtB4_20BrackettedExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1448|  1.05k|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsJ_1__NtB4_16PathEltOrInverseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1002|    138|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsD_1__NtB4_28PropertyListPathNotEmptyVerbNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  889|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsa_1__NtB4_12HavingClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  262|      9|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smiths0_1__NtB4_11SelectQueryNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
   83|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithss_1__NtB4_10ConstraintNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  695|     12|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsL_1__NtB4_11PathPrimaryNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1036|    138|#[derive(Arbitrary)]
_RNvXs19_Cs1gTnyt4wREc_12sparql_smithNtB6_7LiteralNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1612|    368|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 1613|    368|        Ok(Self {
 1614|    368|            value: u.choose(LITERALS.as_slice())?,
 1615|       |        })
 1616|    368|    }
_RNvXNvCs1gTnyt4wREc_12sparql_smiths2_1__NtB4_12SelectClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  120|     39|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsg_1__NtB4_22GraphPatternNotTriplesNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  464|      6|#[derive(Arbitrary)]
_RNvXsU_Cs1gTnyt4wREc_12sparql_smithNtB5_3VarNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1261|    394|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 1262|    394|        Ok(Self {
 1263|    394|            value: u.int_in_range(1..=NUMBER_OF_VARIABLES)?,
 1264|       |        })
 1265|    394|    }
_RNvXNvCs1gTnyt4wREc_12sparql_smithsI_1__NtB4_7PathEltNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  985|    138|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsT_1__NtB4_14CollectionPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
 1174|     24|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsF_1__NtB4_14ObjectListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  928|     21|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsH_1__NtB4_12PathSequenceNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  968|     51|#[derive(Arbitrary)]
_RNvXNvCs1gTnyt4wREc_12sparql_smithsi_1__NtB4_19LateralGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary:
  506|      3|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths10_1__NtB6_24ConditionalAndExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1317|    596|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsK_1__NtB6_7PathModNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1018|     31|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsD_1__NtB6_28PropertyListPathNotEmptyVerbNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  889|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsM_1__NtB6_22PathNegatedPropertySetNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1056|      2|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths16_1__NtB6_20BrackettedExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1448|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths16_1__36RECURSIVE_COUNT_BrackettedExpression7___getit0B7_:
 1448|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths17_1__NtB6_11BuiltInCallNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1460|    304|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths13_1__NtB6_24MultiplicativeExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1388|      8|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths11_1__NtB6_20RelationalExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1337|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsJ_1__NtB6_16PathEltOrInverseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1002|     46|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths14_1__NtB6_15UnaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1406|  1.63k|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsv_1__NtB6_14ExpressionListNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  750|    103|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsI_1__NtB6_7PathEltNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  985|     46|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsg_1__NtB6_22GraphPatternNotTriplesNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  464|      2|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsT_1__NtB6_14CollectionPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1174|      8|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths19_1__NtB6_13NotExistsFuncNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1572|      3|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths12_1__NtB6_18AdditiveExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1370|      8|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsV_1__NtB6_13GraphNodePathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1207|     88|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithss_1__NtB6_10ConstraintNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  695|      4|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths14_1__NtB6_15UnaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1406|     11|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsc_1__NtB6_17GroupGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  394|     15|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsZ_1__NtB6_23ConditionalOrExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1300|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smithsZ_1__39RECURSIVE_COUNT_ConditionalOrExpression7___getit0B7_:
 1300|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths11_1__NtB6_20RelationalExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1337|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths16_1__NtB6_20BrackettedExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1448|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths12_1__34RECURSIVE_COUNT_AdditiveExpression7___getit0B7_:
 1370|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsf_1__NtB6_12TriplesBlockNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  444|      4|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsQ_1__NtB6_15TriplesNodePathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1129|      9|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths3_1__NtB6_12SelectOptionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  127|      5|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths0_1__NtB6_11SelectQueryNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
   83|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths8_1__NtB6_11GroupClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  219|      3|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsH_1__NtB6_12PathSequenceNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  968|     17|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsL_1__NtB6_11PathPrimaryNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1036|     46|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithse_1__NtB6_30GroupGraphPatternSubOtherBlockNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  419|      2|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths10_1__NtB6_24ConditionalAndExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1317|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths15_1__NtB6_17PrimaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1426|  1.63k|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths4_1__NtB6_12SelectValuesNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  133|     13|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths11_1__NtB6_20RelationalExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1337|    663|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsh_1__NtB6_20OptionalGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  494|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths7_1__NtB6_16SolutionModifierNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  188|      6|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsY_1__NtB6_9GraphTermNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1278|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsZ_1__NtB6_23ConditionalOrExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1300|    576|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsW_1__NtB6_9VarOrTermNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1223|     83|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths1_1__NtB6_9SubSelectNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  101|      6|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths9_1__NtB6_14GroupConditionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  236|      5|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths15_1__NtB6_17PrimaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1426|      8|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths13_1__NtB6_24MultiplicativeExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1388|  1.14k|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths_1__NtB6_12QueryVariantNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
   44|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsR_1__NtB6_25BlankNodePropertyListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1145|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsN_1__NtB6_20PathOneInPropertySetNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1081|      4|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths13_1__NtB6_24MultiplicativeExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1388|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smith1__NtB6_12QueryContentNtCs99AoNPYHiPX_9arbitrary9Arbitrary19arbitrary_take_rests_0B6_:
   36|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsi_1__NtB6_19LateralGraphPatternNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  506|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsB_1__NtB6_16PropertyListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  865|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths1a_1__NtB6_13IriOrFunctionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1584|    402|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths10_1__NtB6_24ConditionalAndExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrary0B6_:
 1317|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths10_1__40RECURSIVE_COUNT_ConditionalAndExpression7___getit0B7_:
 1317|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsG_1__NtB6_15PathAlternativeNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  951|      9|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths6_1__NtB6_11WhereClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  172|      9|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsC_1__NtB6_24PropertyListPathNotEmptyNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  881|      5|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsZ_1__NtB6_23ConditionalOrExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1300|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths11_1__36RECURSIVE_COUNT_RelationalExpression7___getit0B7_:
 1337|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths5_1__NtB6_16SelectProjectionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  142|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsF_1__NtB6_14ObjectListPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  928|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths18_1__NtB6_10ExistsFuncNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1560|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsE_1__NtB6_23PropertyListPathElementNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  895|      2|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths16_1__NtB6_20BrackettedExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1448|    355|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths13_1__40RECURSIVE_COUNT_MultiplicativeExpression7___getit0B7_:
 1388|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths14_1__NtB6_15UnaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1406|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsa_1__NtB6_12HavingClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  262|      3|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths12_1__NtB6_18AdditiveExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1370|    840|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsA_1__NtB6_22TriplesSameSubjectPathNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  833|      4|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths15_1__NtB6_17PrimaryExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1426|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths15_1__33RECURSIVE_COUNT_PrimaryExpression7___getit0B7_:
 1426|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths12_1__NtB6_18AdditiveExpressionNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1370|      7|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smiths2_1__NtB6_12SelectClauseNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  120|     13|#[derive(Arbitrary)]
_RNCNvNvNvCs1gTnyt4wREc_12sparql_smiths14_1__31RECURSIVE_COUNT_UnaryExpression7___getit0B7_:
 1406|      1|#[derive(Arbitrary)]
_RNCNvXNvCs1gTnyt4wREc_12sparql_smithsd_1__NtB6_20GroupGraphPatternSubNtCs99AoNPYHiPX_9arbitrary9Arbitrary9arbitrarys_0B6_:
  412|      9|#[derive(Arbitrary)]

_ZN7rocksdb8CacheKeyC2Ev:
   37|      2|  inline CacheKey() : file_num_etc64_(), offset_etc64_() {}
_ZN7rocksdb18OffsetableCacheKeyC2Ev:
   86|      2|  inline OffsetableCacheKey() : CacheKey() {}

_ZN7rocksdb20FullTypedCacheHelperINS_21ParsedFullFilterBlockENS_18BlockCreateContextELNS_14CacheEntryRoleE1EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_21ParsedFullFilterBlockELNS_14CacheEntryRoleE1EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_17UncompressionDictENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_17UncompressionDictELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_12Block_kIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE4EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_12Block_kIndexELNS_14CacheEntryRoleE4EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_27Block_kFilterPartitionIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE2EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_27Block_kFilterPartitionIndexELNS_14CacheEntryRoleE2EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_20Block_kRangeDeletionENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_20Block_kRangeDeletionELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_11Block_kDataENS_18BlockCreateContextELNS_14CacheEntryRoleE0EE13GetFullHelperEv:
  258|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  259|      2|    static const Cache::CacheItemHelper kHelper{
  260|      2|        kRole,
  261|      2|        &FullTypedCacheHelper::Delete,
  262|      2|        &FullTypedCacheHelper::Size,
  263|      2|        &FullTypedCacheHelper::SaveTo,
  264|      2|        &FullTypedCacheHelper::Create,
  265|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  266|      2|    return &kHelper;
  267|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_11Block_kDataELNS_14CacheEntryRoleE0EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }

_ZN7rocksdb19PackSequenceAndTypeEmNS_9ValueTypeE:
  148|      2|inline uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  149|      2|  assert(seq <= kMaxSequenceNumber);
  150|       |  // kTypeMaxValid is used in TruncatedRangeDelIterator, see its constructor.
  151|      2|  assert(IsExtendedValueType(t) || t == kTypeMaxValid);
  152|      2|  return (seq << 8) | t;
  153|      2|}

_ZN7rocksdb29WriteStallCauseToHyphenStringENS_15WriteStallCauseE:
   14|      2|const std::string& WriteStallCauseToHyphenString(WriteStallCause cause) {
   15|      2|  static const std::string kMemtableLimit = "memtable-limit";
   16|      2|  static const std::string kL0FileCountLimit = "l0-file-count-limit";
   17|      2|  static const std::string kPendingCompactionBytes = "pending-compaction-bytes";
   18|      2|  static const std::string kWriteBufferManagerLimit =
   19|      2|      "write-buffer-manager-limit";
   20|      2|  switch (cause) {
   21|      0|    case WriteStallCause::kMemtableLimit:
  ------------------
  |  Branch (21:5): [True: 0, False: 2]
  ------------------
   22|      0|      return kMemtableLimit;
   23|      0|    case WriteStallCause::kL0FileCountLimit:
  ------------------
  |  Branch (23:5): [True: 0, False: 2]
  ------------------
   24|      0|      return kL0FileCountLimit;
   25|      0|    case WriteStallCause::kPendingCompactionBytes:
  ------------------
  |  Branch (25:5): [True: 0, False: 2]
  ------------------
   26|      0|      return kPendingCompactionBytes;
   27|      2|    case WriteStallCause::kWriteBufferManagerLimit:
  ------------------
  |  Branch (27:5): [True: 2, False: 0]
  ------------------
   28|      2|      return kWriteBufferManagerLimit;
   29|      0|    default:
  ------------------
  |  Branch (29:5): [True: 0, False: 2]
  ------------------
   30|      0|      break;
   31|      2|  }
   32|      0|  return InvalidWriteStallHyphenString();
   33|      2|}
_ZN7rocksdb33WriteStallConditionToHyphenStringENS_19WriteStallConditionE:
   36|      2|    WriteStallCondition condition) {
   37|      2|  static const std::string kDelayed = "delays";
   38|      2|  static const std::string kStopped = "stops";
   39|      2|  switch (condition) {
   40|      0|    case WriteStallCondition::kDelayed:
  ------------------
  |  Branch (40:5): [True: 0, False: 2]
  ------------------
   41|      0|      return kDelayed;
   42|      2|    case WriteStallCondition::kStopped:
  ------------------
  |  Branch (42:5): [True: 2, False: 0]
  ------------------
   43|      2|      return kStopped;
   44|      0|    default:
  ------------------
  |  Branch (44:5): [True: 0, False: 2]
  ------------------
   45|      0|      break;
   46|      2|  }
   47|      0|  return InvalidWriteStallHyphenString();
   48|      2|}
_ZN7rocksdb24isCFScopeWriteStallCauseENS_15WriteStallCauseE:
  110|      2|bool isCFScopeWriteStallCause(WriteStallCause cause) {
  111|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  112|      2|  uint32_t lower_bound =
  113|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  114|      2|      kNumCFScopeWriteStallCauses;
  115|      2|  uint32_t upper_bound =
  116|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  117|      2|      1;
  118|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (118:10): [True: 2, False: 0]
  |  Branch (118:38): [True: 0, False: 2]
  ------------------
  119|      2|}
_ZN7rocksdb24isDBScopeWriteStallCauseENS_15WriteStallCauseE:
  121|      2|bool isDBScopeWriteStallCause(WriteStallCause cause) {
  122|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  123|      2|  uint32_t lower_bound =
  124|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  125|      2|      kNumDBScopeWriteStallCauses;
  126|      2|  uint32_t upper_bound =
  127|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  128|      2|      1;
  129|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (129:10): [True: 2, False: 0]
  |  Branch (129:38): [True: 2, False: 0]
  ------------------
  130|      2|}
_ZN7rocksdb22WriteStallStatsMapKeys19CauseConditionCountENS_15WriteStallCauseENS_19WriteStallConditionE:
  157|      2|    WriteStallCause cause, WriteStallCondition condition) {
  158|      2|  std::string cause_condition_count_name;
  159|       |
  160|      2|  std::string cause_name;
  161|      2|  if (isCFScopeWriteStallCause(cause) || isDBScopeWriteStallCause(cause)) {
  ------------------
  |  Branch (161:7): [True: 0, False: 2]
  |  Branch (161:42): [True: 2, False: 0]
  ------------------
  162|      2|    cause_name = WriteStallCauseToHyphenString(cause);
  163|      2|  } else {
  164|      0|    assert(false);
  165|      0|    return "";
  166|      0|  }
  167|       |
  168|      2|  const std::string& condition_name =
  169|      2|      WriteStallConditionToHyphenString(condition);
  170|       |
  171|      2|  cause_condition_count_name.reserve(cause_name.size() + 1 +
  172|      2|                                     condition_name.size());
  173|      2|  cause_condition_count_name.append(cause_name);
  174|      2|  cause_condition_count_name.append("-");
  175|      2|  cause_condition_count_name.append(condition_name);
  176|       |
  177|      2|  return cause_condition_count_name;
  178|      2|}

_ZN7rocksdb11WriteThread17AdaptationContextC2EPKc:
  265|     10|    explicit AdaptationContext(const char* name0) : name(name0), value(0) {}

_ZN7rocksdb21LogicalBlockSizeCacheC2ENSt3__18functionIFmiEEENS2_IFNS_6StatusERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPmEEE:
  178|      2|            get_logical_block_size_of_directory) {}

_ZN7rocksdb5Cache15CacheItemHelperC2Ev:
  144|      2|    CacheItemHelper() : CacheItemHelper(CacheEntryRole::kMisc) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEE:
  148|     14|        : CacheItemHelper(_role, _del_cb, nullptr, nullptr, nullptr, this) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEEPFmS3_EPFNS_6StatusES3_mmPcEPFSA_RKNS_5SliceEPNS0_13CreateContextES5_PS3_PmEPKS1_:
  160|     26|          without_secondary_compat(_without_secondary_compat) {
  161|       |      // Either all three secondary cache callbacks are non-nullptr or
  162|       |      // all three are nullptr
  163|     26|      assert((size_cb != nullptr) == (saveto_cb != nullptr));
  164|     26|      assert((size_cb != nullptr) == (create_cb != nullptr));
  165|       |      // without_secondary_compat points to equivalent but without
  166|       |      // secondary support
  167|     26|      assert(role == without_secondary_compat->role);
  168|     26|      assert(del_cb == without_secondary_compat->del_cb);
  169|     26|      assert(!without_secondary_compat->IsSecondaryCacheCompatible());
  170|     26|    }

_ZN7rocksdb10FileSystem4TypeEv:
  272|      2|  static const char* Type() { return "FileSystem"; }

_ZN7rocksdb5SliceC2Ev:
   35|      2|  Slice() : data_(""), size_(0) {}

_ZN7rocksdb6StatusC2Ev:
   45|      2|        state_(nullptr) {}
_ZN7rocksdb6Status2OKEv:
  154|      2|  static Status OK() { return Status(); }

_ZN7rocksdb13ObjectLibrary5EntryD2Ev:
   48|      2|    virtual ~Entry() {}
_ZN7rocksdb13ObjectLibrary12PatternEntryC2ERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
   95|      2|        : name_(name), optional_(optional), slength_(0) {
   96|      2|      nlength_ = name_.size();
   97|      2|    }
_ZN7rocksdb13ObjectLibrary12PatternEntry12AddSeparatorERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
  114|      2|                               bool at_least_one = true) {
  115|      2|      slength_ += separator.size();
  116|      2|      if (at_least_one) {
  ------------------
  |  Branch (116:11): [True: 0, False: 2]
  ------------------
  117|      0|        separators_.emplace_back(separator, kMatchAtLeastOne);
  118|      0|        ++slength_;
  119|      2|      } else {
  120|      2|        separators_.emplace_back(separator, kMatchZeroOrMore);
  121|      2|      }
  122|      2|      return *this;
  123|      2|    }
_ZN7rocksdb13ObjectLibraryC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  192|      2|  explicit ObjectLibrary(const std::string& id) { id_ = id; }
_ZN7rocksdb13ObjectLibrary15AddFactoryEntryEPKcONSt3__110unique_ptrINS0_5EntryENS3_14default_deleteIS5_EEEE:
  268|      2|  void AddFactoryEntry(const char* type, std::unique_ptr<Entry>&& entry) {
  269|      2|    std::unique_lock<std::mutex> lock(mu_);
  270|      2|    auto& factories = factories_[type];
  271|      2|    factories.emplace_back(std::move(entry));
  272|      2|  }
_ZN7rocksdb13ObjectLibrary12FactoryEntryINS_10FileSystemEEC2EPNS0_5EntryENSt3__18functionIFPS2_RKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEPNS6_10unique_ptrIS2_NS6_14default_deleteIS2_EEEEPSE_EEE:
  174|      2|        : entry_(e), factory_(std::move(f)) {}
_ZN7rocksdb13ObjectLibrary10AddFactoryINS_10FileSystemEEERKNSt3__18functionIFPT_RKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPNS3_10unique_ptrIS5_NS3_14default_deleteIS5_EEEEPSC_EEERKNS0_12PatternEntryESO_:
  252|      2|                                   const FactoryFunc<T>& func) {
  253|      2|    std::unique_ptr<Entry> factory(
  254|      2|        new FactoryEntry<T>(new PatternEntry(entry), func));
  255|      2|    AddFactoryEntry(T::Type(), std::move(factory));
  256|      2|    return func;
  257|      2|  }

_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11SystemClockEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdborERKNS_15OptionTypeFlagsES2_:
  115|     86|                                 const OptionTypeFlags& b) {
  116|     86|  return static_cast<OptionTypeFlags>(static_cast<uint32_t>(a) |
  117|     86|                                      static_cast<uint32_t>(b));
  118|     86|}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  261|    718|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo12SetParseFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEESE_PvEEE:
  590|    112|  OptionTypeInfo& SetParseFunc(const ParseFunc& f) {
  591|    112|    parse_func_ = f;
  592|    112|    return *this;
  593|    112|  }
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeE:
  251|     16|        flags_(OptionTypeFlags::kNone) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEE:
  272|     20|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEERKNS5_IFS6_S9_SH_PKvPSF_EEERKNS5_IFbS9_SH_SO_SO_SP_EEE:
  285|     18|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  373|     16|      int offset, OptionVerificationType verification, OptionTypeFlags flags) {
  374|     16|    OptionTypeInfo info(offset, OptionType::kStruct, verification, flags);
  375|     16|    info.SetParseFunc(
  376|       |        // Parses the struct and updates the fields at addr
  377|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  378|     16|                                  const std::string& name,
  379|     16|                                  const std::string& value, void* addr) {
  380|     16|          return ParseStruct(opts, struct_name, struct_map, name, value, addr);
  381|     16|        });
  382|     16|    info.SetSerializeFunc(
  383|       |        // Serializes the struct options into value
  384|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  385|     16|                                  const std::string& name, const void* addr,
  386|     16|                                  std::string* value) {
  387|     16|          return SerializeStruct(opts, struct_name, struct_map, name, addr,
  388|     16|                                 value);
  389|     16|        });
  390|     16|    info.SetEqualsFunc(
  391|       |        // Compares the struct fields of addr1 and addr2 for equality
  392|     16|        [struct_name, struct_map](const ConfigOptions& opts,
  393|     16|                                  const std::string& name, const void* addr1,
  394|     16|                                  const void* addr2, std::string* mismatch) {
  395|     16|          return StructsAreEqual(opts, struct_name, struct_map, name, addr1,
  396|     16|                                 addr2, mismatch);
  397|     16|        });
  398|     16|    return info;
  399|     16|  }
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNS1_8functionIFNS_6StatusERKNS_13ConfigOptionsES9_S9_PvEEE:
  404|      4|      const ParseFunc& parse_func) {
  405|      4|    OptionTypeInfo info(
  406|      4|        Struct(struct_name, struct_map, offset, verification, flags));
  407|      4|    return info.SetParseFunc(parse_func);
  408|      4|  }
_ZN7rocksdb14OptionTypeInfo16SetSerializeFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvPSC_EEE:
  595|     56|  OptionTypeInfo& SetSerializeFunc(const SerializeFunc& f) {
  596|     56|    serialize_func_ = f;
  597|     56|    return *this;
  598|     56|  }
_ZN7rocksdb14OptionTypeInfo13SetEqualsFuncERKNSt3__18functionIFbRKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvSF_PSB_EEE:
  599|     56|  OptionTypeInfo& SetEqualsFunc(const EqualsFunc& f) {
  600|     56|    equals_func_ = f;
  601|     56|    return *this;
  602|     56|  }
_ZN7rocksdb14OptionTypeInfo14SetPrepareFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPvEEE:
  604|      4|  OptionTypeInfo& SetPrepareFunc(const PrepareFunc& f) {
  605|      4|    prepare_func_ = f;
  606|      4|    return *this;
  607|      4|  }
_ZN7rocksdb14OptionTypeInfo15SetValidateFuncERKNSt3__18functionIFNS_6StatusERKNS_9DBOptionsERKNS_19ColumnFamilyOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvEEE:
  609|      4|  OptionTypeInfo& SetValidateFunc(const ValidateFunc& f) {
  610|      4|    validate_func_ = f;
  611|      4|    return *this;
  612|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10FileSystemEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10StatisticsEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo6VectorIiEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_14SliceTransformEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_20PrepopulateBlobCacheEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorINS_15CompressionTypeEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_10ComparatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      2|                                       OptionTypeFlags flags) {
  564|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      2|                        flags | OptionTypeFlags::kRawPointer);
  566|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      2|                                const std::string& name,
  568|      2|                                const std::string& value, void* addr) {
  569|      2|      auto** pointer = static_cast<T**>(addr);
  570|      2|      if (name == kIdPropName() && value.empty()) {
  571|      2|        *pointer = nullptr;
  572|      2|        return Status::OK();
  573|      2|      } else {
  574|      2|        return T::CreateFromString(opts, value, pointer);
  575|      2|      }
  576|      2|    });
  577|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_12TableFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_31TablePropertiesCollectorFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__110shared_ptrINS_31TablePropertiesCollectorFactoryEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_16CompactionFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      4|                                       OptionTypeFlags flags) {
  564|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      4|                        flags | OptionTypeFlags::kRawPointer);
  566|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      4|                                const std::string& name,
  568|      4|                                const std::string& value, void* addr) {
  569|      4|      auto** pointer = static_cast<T**>(addr);
  570|      4|      if (name == kIdPropName() && value.empty()) {
  571|      4|        *pointer = nullptr;
  572|      4|        return Status::OK();
  573|      4|      } else {
  574|      4|        return T::CreateFromString(opts, value, pointer);
  575|      4|      }
  576|      4|    });
  577|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23CompactionFilterFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_13MergeOperatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      4|                                          OptionTypeFlags flags) {
  485|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      4|                        flags | OptionTypeFlags::kShared);
  487|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      4|                                const std::string& name,
  489|      4|                                const std::string& value, void* addr) {
  490|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      4|      if (name == kIdPropName() && value.empty()) {
  492|      4|        shared->reset();
  493|      4|        return Status::OK();
  494|      4|      } else {
  495|      4|        return T::CreateFromString(opts, value, shared);
  496|      4|      }
  497|      4|    });
  498|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_21SstPartitionerFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrINS_9WalFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  563|      2|                                       OptionTypeFlags flags) {
  564|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  565|      2|                        flags | OptionTypeFlags::kRawPointer);
  566|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  567|      2|                                const std::string& name,
  568|      2|                                const std::string& value, void* addr) {
  569|      2|      auto** pointer = static_cast<T**>(addr);
  570|      2|      if (name == kIdPropName() && value.empty()) {
  571|      2|        *pointer = nullptr;
  572|      2|        return Status::OK();
  573|      2|      } else {
  574|      2|        return T::CreateFromString(opts, value, pointer);
  575|      2|      }
  576|      2|    });
  577|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_15WALRecoveryModeEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_9DBOptions10AccessHintEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_12InfoLogLevelEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_22FileChecksumGenFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_9CacheTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_11PinningTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsE:
  301|      6|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      6|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      6|                        OptionVerificationType::kNormal, flags);
  304|      6|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      6|        [map](const ConfigOptions&, const std::string& name,
  311|      6|              const std::string& value, void* addr) {
  312|      6|          if (map == nullptr) {
  313|      6|            return Status::NotSupported("No enum mapping ", name);
  314|      6|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      6|            return Status::OK();
  316|      6|          } else {
  317|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      6|          }
  319|      6|        });
  320|      6|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      6|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      6|              std::string* value) {
  328|      6|          if (map == nullptr) {
  329|      6|            return Status::NotSupported("No enum mapping ", name);
  330|      6|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      6|                                      value)) {
  332|      6|            return Status::OK();
  333|      6|          } else {
  334|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      6|          }
  336|      6|        });
  337|      6|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      6|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      6|           const void* addr2, std::string*) {
  342|      6|          return (*static_cast<const T*>(addr1) ==
  343|      6|                  *static_cast<const T*>(addr2));
  344|      6|        });
  345|      6|    return info;
  346|      6|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23FlushBlockPolicyFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions9IndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions18DataBlockIndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions19IndexShorteningModeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_12FilterPolicyEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions21PrepopulateBlockCacheEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsE:
  301|      2|      OptionTypeFlags flags = OptionTypeFlags::kNone) {
  302|      2|    OptionTypeInfo info(offset, OptionType::kEnum,
  303|      2|                        OptionVerificationType::kNormal, flags);
  304|      2|    info.SetParseFunc(
  305|       |        // Uses the map argument to convert the input string into
  306|       |        // its corresponding enum value.  If value is found in the map,
  307|       |        // addr is updated to the corresponding map entry.
  308|       |        // @return OK if the value is found in the map
  309|       |        // @return InvalidArgument if the value is not found in the map
  310|      2|        [map](const ConfigOptions&, const std::string& name,
  311|      2|              const std::string& value, void* addr) {
  312|      2|          if (map == nullptr) {
  313|      2|            return Status::NotSupported("No enum mapping ", name);
  314|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  315|      2|            return Status::OK();
  316|      2|          } else {
  317|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  318|      2|          }
  319|      2|        });
  320|      2|    info.SetSerializeFunc(
  321|       |        // Uses the map argument to convert the input enum into
  322|       |        // its corresponding string value.  If enum value is found in the map,
  323|       |        // value is updated to the corresponding string value in the map.
  324|       |        // @return OK if the enum is found in the map
  325|       |        // @return InvalidArgument if the enum is not found in the map
  326|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  327|      2|              std::string* value) {
  328|      2|          if (map == nullptr) {
  329|      2|            return Status::NotSupported("No enum mapping ", name);
  330|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  331|      2|                                      value)) {
  332|      2|            return Status::OK();
  333|      2|          } else {
  334|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  335|      2|          }
  336|      2|        });
  337|      2|    info.SetEqualsFunc(
  338|       |        // Casts addr1 and addr2 to the enum type and returns true if
  339|       |        // they are equal, false otherwise.
  340|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  341|      2|           const void* addr2, std::string*) {
  342|      2|          return (*static_cast<const T*>(addr1) ==
  343|      2|                  *static_cast<const T*>(addr2));
  344|      2|        });
  345|      2|    return info;
  346|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorImEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo5ArrayImLm2EEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  414|      2|                              char separator = ':') {
  415|      2|    OptionTypeInfo info(_offset, OptionType::kArray, _verification, _flags);
  416|      2|    info.SetParseFunc([elem_info, separator](
  417|      2|                          const ConfigOptions& opts, const std::string& name,
  418|      2|                          const std::string& value, void* addr) {
  419|      2|      auto result = static_cast<std::array<T, kSize>*>(addr);
  420|      2|      return ParseArray<T, kSize>(opts, elem_info, separator, name, value,
  421|      2|                                  result);
  422|      2|    });
  423|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  424|      2|                                                 const std::string& name,
  425|      2|                                                 const void* addr,
  426|      2|                                                 std::string* value) {
  427|      2|      const auto& array = *(static_cast<const std::array<T, kSize>*>(addr));
  428|      2|      return SerializeArray<T, kSize>(opts, elem_info, separator, name, array,
  429|      2|                                      value);
  430|      2|    });
  431|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  432|      2|                                   const std::string& name, const void* addr1,
  433|      2|                                   const void* addr2, std::string* mismatch) {
  434|      2|      const auto& array1 = *(static_cast<const std::array<T, kSize>*>(addr1));
  435|      2|      const auto& array2 = *(static_cast<const std::array<T, kSize>*>(addr2));
  436|      2|      return ArraysAreEqual<T, kSize>(opts, elem_info, name, array1, array2,
  437|      2|                                      mismatch);
  438|      2|    });
  439|      2|    return info;
  440|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINS_27CompactionServiceOutputFileEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  447|      2|                               char separator = ':') {
  448|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  449|      2|    info.SetParseFunc([elem_info, separator](
  450|      2|                          const ConfigOptions& opts, const std::string& name,
  451|      2|                          const std::string& value, void* addr) {
  452|      2|      auto result = static_cast<std::vector<T>*>(addr);
  453|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  454|      2|    });
  455|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  456|      2|                                                 const std::string& name,
  457|      2|                                                 const void* addr,
  458|      2|                                                 std::string* value) {
  459|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  460|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  461|      2|    });
  462|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  463|      2|                                   const std::string& name, const void* addr1,
  464|      2|                                   const void* addr2, std::string* mismatch) {
  465|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  466|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  467|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  468|      2|    });
  469|      2|    return info;
  470|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_18EncryptionProviderEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11BlockCipherEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  484|      2|                                          OptionTypeFlags flags) {
  485|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  486|      2|                        flags | OptionTypeFlags::kShared);
  487|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  488|      2|                                const std::string& name,
  489|      2|                                const std::string& value, void* addr) {
  490|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  491|      2|      if (name == kIdPropName() && value.empty()) {
  492|      2|        shared->reset();
  493|      2|        return Status::OK();
  494|      2|      } else {
  495|      2|        return T::CreateFromString(opts, value, shared);
  496|      2|      }
  497|      2|    });
  498|      2|  }

_ZN7rocksdb21HistogramBucketMapperC2Ev:
   24|      2|HistogramBucketMapper::HistogramBucketMapper() {
   25|       |  // If you change this, you also need to change
   26|       |  // size of array buckets_ in HistogramImpl
   27|      2|  bucketValues_ = {1, 2};
   28|      2|  double bucket_val = static_cast<double>(bucketValues_.back());
   29|    216|  while ((bucket_val = 1.5 * bucket_val) <=
  ------------------
  |  Branch (29:10): [True: 214, False: 2]
  ------------------
   30|    216|         static_cast<double>(std::numeric_limits<uint64_t>::max())) {
   31|    214|    bucketValues_.push_back(static_cast<uint64_t>(bucket_val));
   32|       |    // Extracts two most significant digits to make histogram buckets more
   33|       |    // human-readable. E.g., 172 becomes 170.
   34|    214|    uint64_t pow_of_ten = 1;
   35|  1.99k|    while (bucketValues_.back() / 10 > 10) {
  ------------------
  |  Branch (35:12): [True: 1.77k, False: 214]
  ------------------
   36|  1.77k|      bucketValues_.back() /= 10;
   37|  1.77k|      pow_of_ten *= 10;
   38|  1.77k|    }
   39|    214|    bucketValues_.back() *= pow_of_ten;
   40|    214|  }
   41|      2|  maxBucketValue_ = bucketValues_.back();
   42|      2|  minBucketValue_ = bucketValues_.front();
   43|      2|}

_ZN7rocksdb4port5MutexC2Eb:
   59|      4|Mutex::Mutex(bool adaptive) {
   60|      4|  (void)adaptive;
   61|       |#ifdef ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   62|       |  if (!adaptive) {
   63|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   64|       |  } else {
   65|       |    pthread_mutexattr_t mutex_attr;
   66|       |    PthreadCall("init mutex attr", pthread_mutexattr_init(&mutex_attr));
   67|       |    PthreadCall("set mutex attr", pthread_mutexattr_settype(
   68|       |                                      &mutex_attr, PTHREAD_MUTEX_ADAPTIVE_NP));
   69|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, &mutex_attr));
   70|       |    PthreadCall("destroy mutex attr", pthread_mutexattr_destroy(&mutex_attr));
   71|       |  }
   72|       |#else
   73|      4|  PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   74|      4|#endif  // ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   75|      4|}
_ZN7rocksdb4port7RWMutexC2Ev:
  152|      2|RWMutex::RWMutex() {
  153|      2|  PthreadCall("init mutex", pthread_rwlock_init(&mu_, nullptr));
  154|      2|}
port_posix.cc:_ZN7rocksdb4portL11PthreadCallEPKci:
   51|      6|static int PthreadCall(const char* label, int result) {
   52|      6|  if (result != 0 && result != ETIMEDOUT && result != EBUSY) {
  ------------------
  |  Branch (52:7): [True: 0, False: 6]
  |  Branch (52:22): [True: 0, False: 0]
  |  Branch (52:45): [True: 0, False: 0]
  ------------------
   53|      0|    fprintf(stderr, "pthread %s: %s\n", label, errnoStr(result).c_str());
   54|      0|    abort();
   55|      0|  }
   56|      6|  return result;
   57|      6|}
port_posix.cc:_ZN7rocksdb4portL11GetPageSizeEv:
  241|      2|static size_t GetPageSize() {
  242|      2|#if defined(OS_LINUX) || defined(_SC_PAGESIZE)
  243|      2|  long v = sysconf(_SC_PAGESIZE);
  244|      2|  if (v >= 1024) {
  ------------------
  |  Branch (244:7): [True: 2, False: 0]
  ------------------
  245|      2|    return static_cast<size_t>(v);
  246|      2|  }
  247|      0|#endif
  248|       |  // Default assume 4KB
  249|      0|  return 4U * 1024U;
  250|      2|}

_ZN7rocksdb11BlockHandleC2Emm:
  376|      2|    : offset_(_offset), size_(_size) {}

_ZN7rocksdb22PersistentCacheOptionsC2Ev:
   20|      2|  PersistentCacheOptions() {}

crc32c.cc:_ZN7rocksdb6crc32cL7isSSE42Ev:
  332|      2|static bool isSSE42() {
  333|      2|#ifndef HAVE_SSE42
  334|      2|  return false;
  335|       |#elif defined(__GNUC__) && defined(__x86_64__) && !defined(IOS_CROSS_COMPILE)
  336|       |  uint32_t c_;
  337|       |  __asm__("cpuid" : "=c"(c_) : "a"(1) : "ebx", "edx");
  338|       |  return c_ & (1U << 20);  // copied from CpuId.h in Folly. Test SSE42
  339|       |#elif defined(_WIN64)
  340|       |  int info[4];
  341|       |  __cpuidex(info, 0x00000001, 0);
  342|       |  return (info[2] & ((int)1 << 20)) != 0;
  343|       |#else
  344|       |  return false;
  345|       |#endif
  346|      2|}

_ZN7rocksdb13ObjectLibrary7DefaultEv:
  208|      2|std::shared_ptr<ObjectLibrary> &ObjectLibrary::Default() {
  209|       |  // Use avoid destruction here so the default ObjectLibrary will not be
  210|       |  // statically destroyed and long-lived.
  211|      2|  STATIC_AVOID_DESTRUCTION(std::shared_ptr<ObjectLibrary>, instance)
  ------------------
  |  |   53|      2|#define STATIC_AVOID_DESTRUCTION(Type, name) static Type& name = *new Type
  ------------------
  212|      2|  (std::make_shared<ObjectLibrary>("default"));
  213|      2|  return instance;
  214|      2|}

