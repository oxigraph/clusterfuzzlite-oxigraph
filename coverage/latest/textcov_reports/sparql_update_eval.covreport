_RNvXs1n_Cs9EteCURj6Wn_9arbitraryTNtCs6Lc7YXa2Vl_12sparql_smith3IriBv_NtBx_12IriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionBv_EENtB6_9Arbitrary9arbitraryBx_:
  575|  3.58k|            fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  576|  3.58k|                Ok(($($xs::arbitrary(u)?,)* Arbitrary::arbitrary(u)?,))
  577|  3.58k|            }
_RNvXs1n_Cs9EteCURj6Wn_9arbitraryTNtCs6Lc7YXa2Vl_12sparql_smith8VarOrIriNtBx_4VerbNtBx_17VarOrIriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionBv_EENtB6_9Arbitrary9arbitraryBx_:
  575|  15.9k|            fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  576|  15.9k|                Ok(($($xs::arbitrary(u)?,)* Arbitrary::arbitrary(u)?,))
  577|  15.9k|            }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith15PathAlternativeENtB5_9Arbitrary9arbitraryB14_:
  925|  21.8k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|  21.8k|        Arbitrary::arbitrary(u).map(Self::new)
  927|  21.8k|    }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith12TriplesBlockENtB5_9Arbitrary9arbitraryB14_:
  925|     55|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|     55|        Arbitrary::arbitrary(u).map(Self::new)
  927|     55|    }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith9SubSelectENtB5_9Arbitrary9arbitraryB14_:
  925|  3.13k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|  3.13k|        Arbitrary::arbitrary(u).map(Self::new)
  927|  3.13k|    }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith14ObjectListPathENtB5_9Arbitrary9arbitraryB14_:
  925|  11.0k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|  11.0k|        Arbitrary::arbitrary(u).map(Self::new)
  927|  11.0k|    }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith23ConditionalOrExpressionENtB5_9Arbitrary9arbitraryB14_:
  925|  8.10k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|  8.10k|        Arbitrary::arbitrary(u).map(Self::new)
  927|  8.10k|    }
_RNvXsp_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith13GraphNodePathENtB5_9Arbitrary9arbitraryB14_:
  925|  1.50k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  926|  1.50k|        Arbitrary::arbitrary(u).map(Self::new)
  927|  1.50k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionIBu_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith12TriplesBlockEEENtB5_9Arbitrary9arbitraryB1K_:
  531|  1.76k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  1.76k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|     87|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  1.67k|            None
  536|       |        })
  537|  1.76k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxNtCs6Lc7YXa2Vl_12sparql_smith12TriplesBlockEENtB5_9Arbitrary9arbitraryB1G_:
  531|     87|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|     87|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|     55|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|     32|            None
  536|       |        })
  537|     87|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith12HavingClauseENtB5_9Arbitrary9arbitraryB17_:
  531|  1.70k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  1.70k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|     58|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  1.64k|            None
  536|       |        })
  537|  1.70k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith3IriENtB5_9Arbitrary9arbitraryB17_:
  531|  6.54k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  6.54k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|  6.01k|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|    537|            None
  536|       |        })
  537|  6.54k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith7PathModENtB5_9Arbitrary9arbitraryB17_:
  531|  36.2k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  36.2k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|  10.0k|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  26.2k|            None
  536|       |        })
  537|  36.2k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith8VarOrIriENtB5_9Arbitrary9arbitraryB17_:
  531|  15.9k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  15.9k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|  13.5k|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  2.38k|            None
  536|       |        })
  537|  15.9k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith24PropertyListPathNotEmptyENtB5_9Arbitrary9arbitraryB17_:
  531|    663|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|    663|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|     29|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|    634|            None
  536|       |        })
  537|    663|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith9DataBlockENtB5_9Arbitrary9arbitraryB17_:
  531|  1.67k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  1.67k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|     71|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  1.60k|            None
  536|       |        })
  537|  1.67k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith11GroupClauseENtB5_9Arbitrary9arbitraryB17_:
  531|  1.74k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  1.74k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|    100|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  1.64k|            None
  536|       |        })
  537|  1.74k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith12TriplesBlockENtB5_9Arbitrary9arbitraryB17_:
  531|  4.46k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  4.46k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|  1.70k|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|  2.75k|            None
  536|       |        })
  537|  4.46k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith23PropertyListPathElementENtB5_9Arbitrary9arbitraryB17_:
  531|    623|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|    623|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|    389|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|    234|            None
  536|       |        })
  537|    623|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith12SelectOptionENtB5_9Arbitrary9arbitraryB17_:
  531|  3.13k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|  3.13k|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|  2.19k|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|    938|            None
  536|       |        })
  537|  3.13k|    }
_RNvXs5_Cs9EteCURj6Wn_9arbitraryINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith3VarENtB5_9Arbitrary9arbitraryB17_:
  531|      4|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  532|      4|        Ok(if <bool as Arbitrary<'a>>::arbitrary(u)? {
  533|      1|            Some(Arbitrary::arbitrary(u)?)
  534|       |        } else {
  535|      3|            None
  536|       |        })
  537|      4|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith17GroupGraphPatternENtB5_9Arbitrary9arbitraryB12_:
  679|    133|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|    133|        u.arbitrary_iter()?.collect()
  681|    133|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith10ConstraintENtB5_9Arbitrary9arbitraryB12_:
  679|     32|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|     32|        u.arbitrary_iter()?.collect()
  681|     32|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith24ConditionalAndExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|  4.33k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  4.33k|        u.arbitrary_iter()?.collect()
  681|  4.33k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith14GroupConditionENtB5_9Arbitrary9arbitraryB12_:
  679|     80|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|     80|        u.arbitrary_iter()?.collect()
  681|     80|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith20RelationalExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|  5.75k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  5.75k|        u.arbitrary_iter()?.collect()
  681|  5.75k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecTNtCs6Lc7YXa2Vl_12sparql_smith8VarOrIriNtB13_4VerbNtB13_17VarOrIriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB11_EEENtB5_9Arbitrary9arbitraryB13_:
  679|  6.31k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  6.31k|        u.arbitrary_iter()?.collect()
  681|  6.31k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith30GroupGraphPatternSubOtherBlockENtB5_9Arbitrary9arbitraryB12_:
  679|  3.48k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  3.48k|        u.arbitrary_iter()?.collect()
  681|  3.48k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith16PathEltOrInverseENtB5_9Arbitrary9arbitraryB12_:
  679|  25.7k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  25.7k|        u.arbitrary_iter()?.collect()
  681|  25.7k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith14DataBlockValueENtB5_9Arbitrary9arbitraryB12_:
  679|     48|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|     48|        u.arbitrary_iter()?.collect()
  681|     48|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith20PathOneInPropertySetENtB5_9Arbitrary9arbitraryB12_:
  679|  1.39k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  1.39k|        u.arbitrary_iter()?.collect()
  681|  1.39k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecTNtCs6Lc7YXa2Vl_12sparql_smith3IriB11_NtB13_12IriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB11_EEENtB5_9Arbitrary9arbitraryB13_:
  679|    316|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|    316|        u.arbitrary_iter()?.collect()
  681|    316|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith23PropertyListPathElementEENtB5_9Arbitrary9arbitraryB1E_:
  679|  11.0k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  11.0k|        u.arbitrary_iter()?.collect()
  681|  11.0k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith12PathSequenceENtB5_9Arbitrary9arbitraryB12_:
  679|  24.0k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  24.0k|        u.arbitrary_iter()?.collect()
  681|  24.0k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith23ConditionalOrExpressionENtB5_9Arbitrary9arbitraryB12_:
  679|  6.70k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  6.70k|        u.arbitrary_iter()?.collect()
  681|  6.70k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith13GraphNodePathENtB5_9Arbitrary9arbitraryB12_:
  679|  12.9k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  12.9k|        u.arbitrary_iter()?.collect()
  681|  12.9k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith16SelectProjectionENtB5_9Arbitrary9arbitraryB12_:
  679|  1.15k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  680|  1.15k|        u.arbitrary_iter()?.collect()
  681|  1.15k|    }
_RNvXsa_Cs9EteCURj6Wn_9arbitraryINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtCs6Lc7YXa2Vl_12sparql_smith13UpdateVariantENtB5_9Arbitrary19arbitrary_take_restB12_:
  683|  3.51k|    fn arbitrary_take_rest(u: Unstructured<'a>) -> Result<Self> {
  684|  3.51k|        u.arbitrary_take_rest_iter()?.collect()
  685|  3.51k|    }
_RNvXsI_Cs9EteCURj6Wn_9arbitraryhNtB5_9Arbitrary9arbitrary:
  309|   246k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|   246k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|   246k|                    u.fill_buffer(&mut buf)?;
  312|   246k|                    let mut x: $unsigned = 0;
  313|   246k|                    for i in 0..mem::size_of::<$ty>() {
  314|   246k|                        x |= buf[i] as $unsigned << (i * 8);
  315|   246k|                    }
  316|   246k|                    Ok(x as $ty)
  317|   246k|                }
_RNvXs_Cs9EteCURj6Wn_9arbitrarybNtB4_9Arbitrary9arbitrary:
  295|   246k|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  296|   246k|        Ok(<u8 as Arbitrary<'a>>::arbitrary(u)? & 1 == 1)
  297|   246k|    }
_RNvXsK_Cs9EteCURj6Wn_9arbitrarymNtB5_9Arbitrary9arbitrary:
  309|   414k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|   414k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|   414k|                    u.fill_buffer(&mut buf)?;
  312|   414k|                    let mut x: $unsigned = 0;
  313|  1.65M|                    for i in 0..mem::size_of::<$ty>() {
  314|  1.65M|                        x |= buf[i] as $unsigned << (i * 8);
  315|  1.65M|                    }
  316|   414k|                    Ok(x as $ty)
  317|   414k|                }

_RNvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB2_12Unstructured3lenCs6Lc7YXa2Vl_12sparql_smith:
  108|   621k|    pub fn len(&self) -> usize {
  109|   621k|        self.data.len()
  110|   621k|    }
_RNvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB2_12Unstructured8is_emptyCs6Lc7YXa2Vl_12sparql_smith:
  132|   621k|    pub fn is_empty(&self) -> bool {
  133|   621k|        self.len() == 0
  134|   621k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith14GroupConditionENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|    310|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|    310|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|    310|        if keep_going {
  723|    253|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|     57|            None
  726|       |        }
  727|    310|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryNtCs6Lc7YXa2Vl_12sparql_smith14DataBlockValueEB1c_:
  167|  4.65k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|  4.65k|    where
  169|  4.65k|        A: Arbitrary<'a>,
  170|  4.65k|    {
  171|  4.65k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|  4.65k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith16PathEltOrInverseEB1i_:
  606|  25.7k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  25.7k|        &'b mut self,
  608|  25.7k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  25.7k|        Ok(ArbitraryIter {
  610|  25.7k|            u: &mut *self,
  611|  25.7k|            _marker: PhantomData,
  612|  25.7k|        })
  613|  25.7k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith12PathSequenceENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  25.7k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  25.7k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  25.7k|        if keep_going {
  723|  1.70k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  24.0k|            None
  726|       |        }
  727|  25.7k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith20RelationalExpressionENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  6.68k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  6.68k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  6.68k|        if keep_going {
  723|  2.27k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  4.41k|            None
  726|       |        }
  727|  6.68k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangehECs6Lc7YXa2Vl_12sparql_smith:
  293|   135k|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|   135k|    where
  295|   135k|        T: Int,
  296|   135k|    {
  297|   135k|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|   135k|        self.data = &self.data[bytes_consumed..];
  299|   135k|        Ok(result)
  300|   135k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_loopNCNvXsG_Cs6Lc7YXa2Vl_12sparql_smithNtB1o_14InlineDataFullNtB5_9Arbitrary9arbitrary0EB1o_:
  692|    198|    pub fn arbitrary_loop(
  693|    198|        &mut self,
  694|    198|        min: Option<u32>,
  695|    198|        max: Option<u32>,
  696|    198|        mut f: impl FnMut(&mut Self) -> Result<ControlFlow<(), ()>>,
  697|    198|    ) -> Result<()> {
  698|    198|        let min = min.unwrap_or(0);
  699|    198|        let max = max.unwrap_or(u32::MAX);
  700|    198|
  701|    198|        for _ in 0..self.int_in_range(min..=max)? {
  702|    278|            match f(self)? {
  703|    278|                ControlFlow::Continue(_) => continue,
  704|      0|                ControlFlow::Break(_) => break,
  705|       |            }
  706|       |        }
  707|       |
  708|    198|        Ok(())
  709|    198|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith14DataBlockValueEB1i_:
  606|     48|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|     48|        &'b mut self,
  608|     48|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|     48|        Ok(ArbitraryIter {
  610|     48|            u: &mut *self,
  611|     48|            _marker: PhantomData,
  612|     48|        })
  613|     48|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith20PathOneInPropertySetEB1i_:
  606|  1.39k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  1.39k|        &'b mut self,
  608|  1.39k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  1.39k|        Ok(ArbitraryIter {
  610|  1.39k|            u: &mut *self,
  611|  1.39k|            _marker: PhantomData,
  612|  1.39k|        })
  613|  1.39k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured24arbitrary_take_rest_iterNtCs6Lc7YXa2Vl_12sparql_smith13UpdateVariantEB1s_:
  620|  3.51k|    pub fn arbitrary_take_rest_iter<ElementType: Arbitrary<'a>>(
  621|  3.51k|        self,
  622|  3.51k|    ) -> Result<ArbitraryTakeRestIter<'a, ElementType>> {
  623|  3.51k|        Ok(ArbitraryTakeRestIter {
  624|  3.51k|            u: self,
  625|  3.51k|            _marker: PhantomData,
  626|  3.51k|        })
  627|  3.51k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterTNtCs6Lc7YXa2Vl_12sparql_smith3IriB1h_NtB1j_12IriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB1h_EEEB1j_:
  606|    316|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    316|        &'b mut self,
  608|    316|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    316|        Ok(ArbitraryIter {
  610|    316|            u: &mut *self,
  611|    316|            _marker: PhantomData,
  612|    316|        })
  613|    316|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith23PropertyListPathElementEEB1U_:
  606|  11.0k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  11.0k|        &'b mut self,
  608|  11.0k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  11.0k|        Ok(ArbitraryIter {
  610|  11.0k|            u: &mut *self,
  611|  11.0k|            _marker: PhantomData,
  612|  11.0k|        })
  613|  11.0k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith23ConditionalOrExpressionEB1i_:
  606|  6.70k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  6.70k|        &'b mut self,
  608|  6.70k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  6.70k|        Ok(ArbitraryIter {
  610|  6.70k|            u: &mut *self,
  611|  6.70k|            _marker: PhantomData,
  612|  6.70k|        })
  613|  6.70k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith12PathSequenceEB1i_:
  606|  24.0k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  24.0k|        &'b mut self,
  608|  24.0k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  24.0k|        Ok(ArbitraryIter {
  610|  24.0k|            u: &mut *self,
  611|  24.0k|            _marker: PhantomData,
  612|  24.0k|        })
  613|  24.0k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith13GraphNodePathEB1i_:
  606|  12.9k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  12.9k|        &'b mut self,
  608|  12.9k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  12.9k|        Ok(ArbitraryIter {
  610|  12.9k|            u: &mut *self,
  611|  12.9k|            _marker: PhantomData,
  612|  12.9k|        })
  613|  12.9k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith16SelectProjectionEB1i_:
  606|  1.15k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  1.15k|        &'b mut self,
  608|  1.15k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  1.15k|        Ok(ArbitraryIter {
  610|  1.15k|            u: &mut *self,
  611|  1.15k|            _marker: PhantomData,
  612|  1.15k|        })
  613|  1.15k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith17GroupGraphPatternEB1i_:
  606|    133|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    133|        &'b mut self,
  608|    133|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    133|        Ok(ArbitraryIter {
  610|    133|            u: &mut *self,
  611|    133|            _marker: PhantomData,
  612|    133|        })
  613|    133|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith24ConditionalAndExpressionEB1i_:
  606|  4.33k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  4.33k|        &'b mut self,
  608|  4.33k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  4.33k|        Ok(ArbitraryIter {
  610|  4.33k|            u: &mut *self,
  611|  4.33k|            _marker: PhantomData,
  612|  4.33k|        })
  613|  4.33k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterTNtCs6Lc7YXa2Vl_12sparql_smith8VarOrIriNtB1j_4VerbNtB1j_17VarOrIriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB1h_EEEB1j_:
  606|  6.31k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  6.31k|        &'b mut self,
  608|  6.31k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  6.31k|        Ok(ArbitraryIter {
  610|  6.31k|            u: &mut *self,
  611|  6.31k|            _marker: PhantomData,
  612|  6.31k|        })
  613|  6.31k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith20RelationalExpressionEB1i_:
  606|  5.75k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  5.75k|        &'b mut self,
  608|  5.75k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  5.75k|        Ok(ArbitraryIter {
  610|  5.75k|            u: &mut *self,
  611|  5.75k|            _marker: PhantomData,
  612|  5.75k|        })
  613|  5.75k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith16SelectProjectionENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  1.57k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  1.57k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  1.57k|        if keep_going {
  723|    489|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  1.08k|            None
  726|       |        }
  727|  1.57k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith30GroupGraphPatternSubOtherBlockEB1i_:
  606|  3.48k|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|  3.48k|        &'b mut self,
  608|  3.48k|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|  3.48k|        Ok(ArbitraryIter {
  610|  3.48k|            u: &mut *self,
  611|  3.48k|            _marker: PhantomData,
  612|  3.48k|        })
  613|  3.48k|    }
_RNvXs0_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB5_21ArbitraryTakeRestIterNtCs6Lc7YXa2Vl_12sparql_smith13UpdateVariantENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB1e_:
  738|  9.50k|    fn next(&mut self) -> Option<Result<ElementType>> {
  739|  9.50k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  740|  9.50k|        if keep_going {
  741|  6.79k|            Some(Arbitrary::arbitrary(&mut self.u))
  742|       |        } else {
  743|  2.71k|            None
  744|       |        }
  745|  9.50k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured6chooseReECs6Lc7YXa2Vl_12sparql_smith:
  408|  10.8k|    pub fn choose<'b, T>(&mut self, choices: &'b [T]) -> Result<&'b T> {
  409|  10.8k|        let idx = self.choose_index(choices.len())?;
  410|  10.8k|        Ok(&choices[idx])
  411|  10.8k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith13GraphNodePathENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  18.2k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  18.2k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  18.2k|        if keep_going {
  723|  5.39k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  12.9k|            None
  726|       |        }
  727|  18.2k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith17GroupGraphPatternENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|    153|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|    153|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|    153|        if keep_going {
  723|     23|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|    130|            None
  726|       |        }
  727|    153|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith23ConditionalOrExpressionENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  8.10k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  8.10k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  8.10k|        if keep_going {
  723|  4.73k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  3.37k|            None
  726|       |        }
  727|  8.10k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_implhINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEECs6Lc7YXa2Vl_12sparql_smith:
  302|   135k|    fn int_in_range_impl<T>(
  303|   135k|        range: ops::RangeInclusive<T>,
  304|   135k|        mut bytes: impl Iterator<Item = u8>,
  305|   135k|    ) -> Result<(T, usize)>
  306|   135k|    where
  307|   135k|        T: Int,
  308|   135k|    {
  309|   135k|        let start = *range.start();
  310|   135k|        let end = *range.end();
  311|   135k|        assert!(
  312|   135k|            start <= end,
  313|      0|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|       |        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|   135k|        if start == end {
  319|      0|            return Ok((start, 0));
  320|   135k|        }
  321|   135k|
  322|   135k|        // From here on out we work with the unsigned representation. All of the
  323|   135k|        // operations performed below work out just as well whether or not `T`
  324|   135k|        // is a signed or unsigned integer.
  325|   135k|        let start = start.to_unsigned();
  326|   135k|        let end = end.to_unsigned();
  327|   135k|
  328|   135k|        let delta = end.wrapping_sub(start);
  329|      0|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|   135k|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|   135k|        let mut bytes_consumed: usize = 0;
  337|       |
  338|   265k|        while (bytes_consumed < mem::size_of::<T>())
  339|   135k|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|   135k|            let byte = match bytes.next() {
  342|  4.83k|                None => break,
  343|   130k|                Some(b) => b,
  344|   130k|            };
  345|   130k|            bytes_consumed += 1;
  346|   130k|
  347|   130k|            // Combine this byte into our arbitrary integer, but avoid
  348|   130k|            // overflowing the shift for `u8` and `i8`.
  349|   130k|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|   130k|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|      0|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|   135k|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|   135k|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|   135k|        let result = start.wrapping_add(offset);
  365|   135k|
  366|   135k|        // And convert back to our maybe-signed representation.
  367|   135k|        let result = T::from_unsigned(result);
  368|      0|        debug_assert!(*range.start() <= result);
  369|      0|        debug_assert!(result <= *range.end());
  370|       |
  371|   135k|        Ok((result, bytes_consumed))
  372|   135k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith16PathEltOrInverseENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  36.2k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  36.2k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  36.2k|        if keep_going {
  723|  10.4k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  25.7k|            None
  726|       |        }
  727|  36.2k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith24ConditionalAndExpressionENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  4.41k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  4.41k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  4.41k|        if keep_going {
  723|    218|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  4.20k|            None
  726|       |        }
  727|  4.41k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterTNtCs6Lc7YXa2Vl_12sparql_smith3IriB14_NtB16_12IriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB14_EEENtNtNtNtB24_4iter6traits8iterator8Iterator4nextB16_:
  720|  3.89k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  3.89k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  3.89k|        if keep_going {
  723|  3.58k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|    316|            None
  726|       |        }
  727|  3.89k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith20PathOneInPropertySetENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  8.51k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  8.51k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  8.51k|        if keep_going {
  723|  7.11k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  1.39k|            None
  726|       |        }
  727|  8.51k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith3VarENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  3.64k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  3.64k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  3.64k|        if keep_going {
  723|  3.45k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|    198|            None
  726|       |        }
  727|  3.64k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith10ConstraintENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|     33|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|     33|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|     33|        if keep_going {
  723|      2|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|     31|            None
  726|       |        }
  727|     33|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_loopNCNCNvXsG_Cs6Lc7YXa2Vl_12sparql_smithNtB1q_14InlineDataFullNtB5_9Arbitrary9arbitrary00EB1q_:
  692|    278|    pub fn arbitrary_loop(
  693|    278|        &mut self,
  694|    278|        min: Option<u32>,
  695|    278|        max: Option<u32>,
  696|    278|        mut f: impl FnMut(&mut Self) -> Result<ControlFlow<(), ()>>,
  697|    278|    ) -> Result<()> {
  698|    278|        let min = min.unwrap_or(0);
  699|    278|        let max = max.unwrap_or(u32::MAX);
  700|    278|
  701|    278|        for _ in 0..self.int_in_range(min..=max)? {
  702|  4.65k|            match f(self)? {
  703|  4.65k|                ControlFlow::Continue(_) => continue,
  704|      0|                ControlFlow::Break(_) => break,
  705|       |            }
  706|       |        }
  707|       |
  708|    278|        Ok(())
  709|    278|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith10ConstraintEB1i_:
  606|     32|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|     32|        &'b mut self,
  608|     32|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|     32|        Ok(ArbitraryIter {
  610|     32|            u: &mut *self,
  611|     32|            _marker: PhantomData,
  612|     32|        })
  613|     32|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterINtNtCs9nhK3FOW46N_4core6option6OptionNtCs6Lc7YXa2Vl_12sparql_smith23PropertyListPathElementEENtNtNtNtB18_4iter6traits8iterator8Iterator4nextB1H_:
  720|  11.6k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  11.6k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  11.6k|        if keep_going {
  723|    623|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  11.0k|            None
  726|       |        }
  727|  11.6k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith14GroupConditionEB1i_:
  606|     80|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|     80|        &'b mut self,
  608|     80|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|     80|        Ok(ArbitraryIter {
  610|     80|            u: &mut *self,
  611|     80|            _marker: PhantomData,
  612|     80|        })
  613|     80|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith14DataBlockValueENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|    461|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|    461|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|    461|        if keep_going {
  723|    413|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|     48|            None
  726|       |        }
  727|    461|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterNtCs6Lc7YXa2Vl_12sparql_smith30GroupGraphPatternSubOtherBlockENtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextB15_:
  720|  4.46k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  4.46k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  4.46k|        if keep_going {
  723|  1.08k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  3.38k|            None
  726|       |        }
  727|  4.46k|    }
_RNvXs_NtCs9EteCURj6Wn_9arbitrary12unstructuredINtB4_13ArbitraryIterTNtCs6Lc7YXa2Vl_12sparql_smith8VarOrIriNtB16_4VerbNtB16_17VarOrIriOrLiteralINtNtCs9nhK3FOW46N_4core6option6OptionB14_EEENtNtNtNtB2l_4iter6traits8iterator8Iterator4nextB16_:
  720|  22.2k|    fn next(&mut self) -> Option<Result<ElementType>> {
  721|  22.2k|        let keep_going = self.u.arbitrary().unwrap_or(false);
  722|  22.2k|        if keep_going {
  723|  15.9k|            Some(Arbitrary::arbitrary(self.u))
  724|       |        } else {
  725|  6.31k|            None
  726|       |        }
  727|  22.2k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterNtCs6Lc7YXa2Vl_12sparql_smith3VarEB1i_:
  606|    198|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    198|        &'b mut self,
  608|    198|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    198|        Ok(ArbitraryIter {
  610|    198|            u: &mut *self,
  611|    198|            _marker: PhantomData,
  612|    198|        })
  613|    198|    }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int11checked_add:
  829|   135k|                fn checked_add(self, rhs: Self) -> Option<Self> {
  830|   135k|                    <$ty>::checked_add(self, rhs)
  831|   135k|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int11to_unsigned:
  841|  21.7k|                fn to_unsigned(self) -> Self::Unsigned {
  842|  21.7k|                    self as $unsigned_ty
  843|  21.7k|                }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int10from_usize:
  825|   135k|                fn from_usize(u: usize) -> Self {
  826|   135k|                    u as Self
  827|   135k|                }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int10from_usize:
  825|    387|                fn from_usize(u: usize) -> Self {
  826|    387|                    u as Self
  827|    387|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int12wrapping_sub:
  837|  10.8k|                fn wrapping_sub(self, rhs: Self) -> Self {
  838|  10.8k|                    <$ty>::wrapping_sub(self, rhs)
  839|  10.8k|                }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int7from_u8:
  821|   130k|                fn from_u8(b: u8) -> Self {
  822|   130k|                    b as Self
  823|   130k|                }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int13from_unsigned:
  845|   135k|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  846|   135k|                    unsigned as Self
  847|   135k|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int12wrapping_add:
  833|  10.8k|                fn wrapping_add(self, rhs: Self) -> Self {
  834|  10.8k|                    <$ty>::wrapping_add(self, rhs)
  835|  10.8k|                }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|  10.8k|    fn int_in_range_impl<T>(
  303|  10.8k|        range: ops::RangeInclusive<T>,
  304|  10.8k|        mut bytes: impl Iterator<Item = u8>,
  305|  10.8k|    ) -> Result<(T, usize)>
  306|  10.8k|    where
  307|  10.8k|        T: Int,
  308|  10.8k|    {
  309|  10.8k|        let start = *range.start();
  310|  10.8k|        let end = *range.end();
  311|  10.8k|        assert!(
  312|  10.8k|            start <= end,
  313|      0|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|       |        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|  10.8k|        if start == end {
  319|      0|            return Ok((start, 0));
  320|  10.8k|        }
  321|  10.8k|
  322|  10.8k|        // From here on out we work with the unsigned representation. All of the
  323|  10.8k|        // operations performed below work out just as well whether or not `T`
  324|  10.8k|        // is a signed or unsigned integer.
  325|  10.8k|        let start = start.to_unsigned();
  326|  10.8k|        let end = end.to_unsigned();
  327|  10.8k|
  328|  10.8k|        let delta = end.wrapping_sub(start);
  329|      0|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|  10.8k|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|  10.8k|        let mut bytes_consumed: usize = 0;
  337|       |
  338|  21.7k|        while (bytes_consumed < mem::size_of::<T>())
  339|  21.7k|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|  10.8k|            let byte = match bytes.next() {
  342|      1|                None => break,
  343|  10.8k|                Some(b) => b,
  344|  10.8k|            };
  345|  10.8k|            bytes_consumed += 1;
  346|  10.8k|
  347|  10.8k|            // Combine this byte into our arbitrary integer, but avoid
  348|  10.8k|            // overflowing the shift for `u8` and `i8`.
  349|  10.8k|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|  10.8k|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|  10.8k|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|  10.8k|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|  10.8k|        let result = start.wrapping_add(offset);
  365|  10.8k|
  366|  10.8k|        // And convert back to our maybe-signed representation.
  367|  10.8k|        let result = T::from_unsigned(result);
  368|      0|        debug_assert!(*range.start() <= result);
  369|      0|        debug_assert!(result <= *range.end());
  370|       |
  371|  10.8k|        Ok((result, bytes_consumed))
  372|  10.8k|    }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int11checked_add:
  829|  10.8k|                fn checked_add(self, rhs: Self) -> Option<Self> {
  830|  10.8k|                    <$ty>::checked_add(self, rhs)
  831|  10.8k|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int10from_usize:
  825|  21.7k|                fn from_usize(u: usize) -> Self {
  826|  21.7k|                    u as Self
  827|  21.7k|                }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int12wrapping_add:
  833|   135k|                fn wrapping_add(self, rhs: Self) -> Self {
  834|   135k|                    <$ty>::wrapping_add(self, rhs)
  835|   135k|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int7from_u8:
  821|  10.8k|                fn from_u8(b: u8) -> Self {
  822|  10.8k|                    b as Self
  823|  10.8k|                }
_RNvXs6_NtCs9EteCURj6Wn_9arbitrary12unstructuredjNtB5_3Int13from_unsigned:
  845|  10.8k|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  846|  10.8k|                    unsigned as Self
  847|  10.8k|                }
_RNvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB2_12Unstructured12choose_index:
  450|  10.8k|    pub fn choose_index(&mut self, len: usize) -> Result<usize> {
  451|  10.8k|        if len == 0 {
  452|      0|            return Err(Error::EmptyChoose);
  453|  10.8k|        }
  454|  10.8k|        let idx = self.int_in_range(0..=len - 1)?;
  455|  10.8k|        Ok(idx)
  456|  10.8k|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejEB5_:
  293|  10.8k|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|  10.8k|    where
  295|  10.8k|        T: Int,
  296|  10.8k|    {
  297|  10.8k|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|  10.8k|        self.data = &self.data[bytes_consumed..];
  299|  10.8k|        Ok(result)
  300|  10.8k|    }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int12wrapping_add:
  833|    198|                fn wrapping_add(self, rhs: Self) -> Self {
  834|    198|                    <$ty>::wrapping_add(self, rhs)
  835|    198|                }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarybEB5_:
  167|   166k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|   166k|    where
  169|   166k|        A: Arbitrary<'a>,
  170|   166k|    {
  171|   166k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|   166k|    }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int11checked_add:
  829|    198|                fn checked_add(self, rhs: Self) -> Option<Self> {
  830|    198|                    <$ty>::checked_add(self, rhs)
  831|    198|                }
_RNvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|  3.51k|    pub fn new(data: &'a [u8]) -> Self {
   86|  3.51k|        Unstructured { data }
   87|  3.51k|    }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int7from_u8:
  821|    189|                fn from_u8(b: u8) -> Self {
  822|    189|                    b as Self
  823|    189|                }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int13from_unsigned:
  845|    198|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  846|    198|                    unsigned as Self
  847|    198|                }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int11to_unsigned:
  841|   270k|                fn to_unsigned(self) -> Self::Unsigned {
  842|   270k|                    self as $unsigned_ty
  843|   270k|                }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int11to_unsigned:
  841|    396|                fn to_unsigned(self) -> Self::Unsigned {
  842|    396|                    self as $unsigned_ty
  843|    396|                }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_implmINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|    476|    fn int_in_range_impl<T>(
  303|    476|        range: ops::RangeInclusive<T>,
  304|    476|        mut bytes: impl Iterator<Item = u8>,
  305|    476|    ) -> Result<(T, usize)>
  306|    476|    where
  307|    476|        T: Int,
  308|    476|    {
  309|    476|        let start = *range.start();
  310|    476|        let end = *range.end();
  311|    476|        assert!(
  312|    476|            start <= end,
  313|      0|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|       |        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    476|        if start == end {
  319|    278|            return Ok((start, 0));
  320|    198|        }
  321|    198|
  322|    198|        // From here on out we work with the unsigned representation. All of the
  323|    198|        // operations performed below work out just as well whether or not `T`
  324|    198|        // is a signed or unsigned integer.
  325|    198|        let start = start.to_unsigned();
  326|    198|        let end = end.to_unsigned();
  327|    198|
  328|    198|        let delta = end.wrapping_sub(start);
  329|      0|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    198|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    198|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    387|        while (bytes_consumed < mem::size_of::<T>())
  339|    387|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    198|            let byte = match bytes.next() {
  342|      9|                None => break,
  343|    189|                Some(b) => b,
  344|    189|            };
  345|    189|            bytes_consumed += 1;
  346|    189|
  347|    189|            // Combine this byte into our arbitrary integer, but avoid
  348|    189|            // overflowing the shift for `u8` and `i8`.
  349|    189|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|    189|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    198|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    198|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    198|        let result = start.wrapping_add(offset);
  365|    198|
  366|    198|        // And convert back to our maybe-signed representation.
  367|    198|        let result = T::from_unsigned(result);
  368|      0|        debug_assert!(*range.start() <= result);
  369|      0|        debug_assert!(result <= *range.end());
  370|       |
  371|    198|        Ok((result, bytes_consumed))
  372|    476|    }
_RINvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangemEB5_:
  293|    476|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    476|    where
  295|    476|        T: Int,
  296|    476|    {
  297|    476|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    476|        self.data = &self.data[bytes_consumed..];
  299|    476|        Ok(result)
  300|    476|    }
_RNvXs1_NtCs9EteCURj6Wn_9arbitrary12unstructuredhNtB5_3Int12wrapping_sub:
  837|   135k|                fn wrapping_sub(self, rhs: Self) -> Self {
  838|   135k|                    <$ty>::wrapping_sub(self, rhs)
  839|   135k|                }
_RNvMNtCs9EteCURj6Wn_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|   660k|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|   660k|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|   660k|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|   660k|        for byte in buffer[n..].iter_mut() {
  525|   119k|            *byte = 0;
  526|   119k|        }
  527|   660k|        self.data = &self.data[n..];
  528|   660k|        Ok(())
  529|   660k|    }
_RNvXs3_NtCs9EteCURj6Wn_9arbitrary12unstructuredmNtB5_3Int12wrapping_sub:
  837|    198|                fn wrapping_sub(self, rhs: Self) -> Self {
  838|    198|                    <$ty>::wrapping_sub(self, rhs)
  839|    198|                }

_RNCINvMs_NtCskDhpTLgJGsC_9getrandom4lazyNtB7_8LazyBool11unsync_initNvNtB9_3imp22is_getrandom_availableE0B9_:
   54|      1|        self.0.unsync_init(|| init() as usize) != 0
_RINvMNtCskDhpTLgJGsC_9getrandom4lazyNtB3_9LazyUsize11unsync_initNCINvMs_B3_NtB3_8LazyBool11unsync_initNvNtB5_3imp22is_getrandom_availableE0EB5_:
   34|     20|    pub fn unsync_init(&self, init: impl FnOnce() -> usize) -> usize {
   35|     20|        // Relaxed ordering is fine, as we only have a single atomic variable.
   36|     20|        let mut val = self.0.load(Relaxed);
   37|     20|        if val == Self::UNINIT {
   38|      1|            val = init();
   39|      1|            self.0.store(val, Relaxed);
   40|     19|        }
   41|     20|        val
   42|     20|    }
_RINvMs_NtCskDhpTLgJGsC_9getrandom4lazyNtB5_8LazyBool11unsync_initNvNtB7_3imp22is_getrandom_availableEB7_:
   53|     20|    pub fn unsync_init(&self, init: impl FnOnce() -> bool) -> bool {
   54|     20|        self.0.unsync_init(|| init() as usize) != 0
   55|     20|    }

_RNvCskDhpTLgJGsC_9getrandom9getrandomCsfg7E1GDOqBC_9rand_core:
  376|     20|pub fn getrandom(dest: &mut [u8]) -> Result<(), Error> {
  377|     20|    // SAFETY: The `&mut MaybeUninit<_>` reference doesn't escape, and
  378|     20|    // `getrandom_uninit` guarantees it will never de-initialize any part of
  379|     20|    // `dest`.
  380|     20|    getrandom_uninit(unsafe { slice_as_uninit_mut(dest) })?;
  381|     20|    Ok(())
  382|     20|}
_RNvCskDhpTLgJGsC_9getrandom16getrandom_uninitCsfg7E1GDOqBC_9rand_core:
  406|     20|pub fn getrandom_uninit(dest: &mut [MaybeUninit<u8>]) -> Result<&mut [u8], Error> {
  407|     20|    if !dest.is_empty() {
  408|     20|        imp::getrandom_inner(dest)?;
  409|      0|    }
  410|       |    // SAFETY: `dest` has been fully initialized by `imp::getrandom_inner`
  411|       |    // since it returned `Ok`.
  412|     20|    Ok(unsafe { slice_assume_init_mut(dest) })
  413|     20|}

_RNvNtCskDhpTLgJGsC_9getrandom3imp22is_getrandom_available:
   19|      1|fn is_getrandom_available() -> bool {
   20|      1|    if getrandom_syscall(&mut []) < 0 {
   21|      0|        match last_os_error().raw_os_error() {
   22|      0|            Some(libc::ENOSYS) => false, // No kernel support
   23|       |            // The fallback on EPERM is intentionally not done on Android since this workaround
   24|       |            // seems to be needed only for specific Linux-based products that aren't based
   25|       |            // on Android. See https://github.com/rust-random/getrandom/issues/229.
   26|       |            #[cfg(target_os = "linux")]
   27|      0|            Some(libc::EPERM) => false, // Blocked by seccomp
   28|      0|            _ => true,
   29|       |        }
   30|       |    } else {
   31|      1|        true
   32|       |    }
   33|      1|}
_RNvNtCskDhpTLgJGsC_9getrandom3imp15getrandom_inner:
    9|     20|pub fn getrandom_inner(dest: &mut [MaybeUninit<u8>]) -> Result<(), Error> {
   10|     20|    // getrandom(2) was introduced in Linux 3.17
   11|     20|    static HAS_GETRANDOM: LazyBool = LazyBool::new();
   12|     20|    if HAS_GETRANDOM.unsync_init(is_getrandom_available) {
   13|     20|        sys_fill_exact(dest, getrandom_syscall)
   14|       |    } else {
   15|      0|        use_file::getrandom_inner(dest)
   16|       |    }
   17|     20|}

_RINvNtCskDhpTLgJGsC_9getrandom4util19slice_as_uninit_muthECsfg7E1GDOqBC_9rand_core:
   32|     20|pub unsafe fn slice_as_uninit_mut<T>(slice: &mut [T]) -> &mut [MaybeUninit<T>] {
   33|     20|    // SAFETY: `MaybeUninit<T>` is guaranteed to be layout-compatible with `T`.
   34|     20|    &mut *(slice as *mut [T] as *mut [MaybeUninit<T>])
   35|     20|}
_RINvNtCskDhpTLgJGsC_9getrandom4util21slice_assume_init_muthECsfg7E1GDOqBC_9rand_core:
    8|     20|pub unsafe fn slice_assume_init_mut<T>(slice: &mut [MaybeUninit<T>]) -> &mut [T] {
    9|     20|    // SAFETY: `MaybeUninit<T>` is guaranteed to be layout-compatible with `T`.
   10|     20|    &mut *(slice as *mut [MaybeUninit<T>] as *mut [T])
   11|     20|}

_RNvNtCskDhpTLgJGsC_9getrandom9util_libc17getrandom_syscall:
  157|     21|pub fn getrandom_syscall(buf: &mut [MaybeUninit<u8>]) -> libc::ssize_t {
  158|     21|    unsafe {
  159|     21|        libc::syscall(
  160|     21|            libc::SYS_getrandom,
  161|     21|            buf.as_mut_ptr() as *mut libc::c_void,
  162|     21|            buf.len(),
  163|     21|            0,
  164|     21|        ) as libc::ssize_t
  165|     21|    }
  166|     21|}
_RINvNtCskDhpTLgJGsC_9getrandom9util_libc14sys_fill_exactNvB2_17getrandom_syscallEB4_:
   59|     20|pub fn sys_fill_exact(
   60|     20|    mut buf: &mut [MaybeUninit<u8>],
   61|     20|    sys_fill: impl Fn(&mut [MaybeUninit<u8>]) -> libc::ssize_t,
   62|     20|) -> Result<(), Error> {
   63|     40|    while !buf.is_empty() {
   64|     20|        let res = sys_fill(buf);
   65|     20|        match res {
   66|     20|            res if res > 0 => buf = buf.get_mut(res as usize..).ok_or(Error::UNEXPECTED)?,
   67|       |            -1 => {
   68|      0|                let err = last_os_error();
   69|      0|                // We should try again if the call was interrupted.
   70|      0|                if err.raw_os_error() != Some(libc::EINTR) {
   71|      0|                    return Err(err);
   72|      0|                }
   73|       |            }
   74|       |            // Negative return codes not equal to -1 should be impossible.
   75|       |            // EOF (ret = 0) should be impossible, as the data we are reading
   76|       |            // should be an infinite stream of random bytes.
   77|      0|            _ => return Err(Error::UNEXPECTED),
   78|       |        }
   79|       |    }
   80|     20|    Ok(())
   81|     20|}

rust_fuzzer_test_input:
  259|  3.51k|            pub extern "C" fn rust_fuzzer_test_input(bytes: &[u8]) -> i32 {
  260|  3.51k|                use $crate::arbitrary::{Arbitrary, Unstructured};
  261|  3.51k|
  262|  3.51k|                // Early exit if we don't have enough bytes for the `Arbitrary`
  263|  3.51k|                // implementation. This helps the fuzzer avoid exploring all the
  264|  3.51k|                // different not-enough-input-bytes paths inside the `Arbitrary`
  265|  3.51k|                // implementation. Additionally, it exits faster, letting the fuzzer
  266|  3.51k|                // get to longer inputs that actually lead to interesting executions
  267|  3.51k|                // quicker.
  268|  3.51k|                if bytes.len() < <$dty as Arbitrary>::size_hint(0).0 {
  269|      4|                    return -1;
  270|  3.51k|                }
  271|  3.51k|
  272|  3.51k|                let mut u = Unstructured::new(bytes);
  273|  3.51k|                let data = <$dty as Arbitrary>::arbitrary_take_rest(u);
  274|       |
  275|       |                // When `RUST_LIBFUZZER_DEBUG_PATH` is set, write the debug
  276|       |                // formatting of the input to that file. This is only intended for
  277|       |                // `cargo fuzz`'s use!
  278|       |
  279|       |                // `RUST_LIBFUZZER_DEBUG_PATH` is set in initialization.
  280|  3.51k|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  281|       |                    use std::io::Write;
  282|      0|                    let mut file = std::fs::File::create(path)
  283|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  284|      0|                    (match data {
  285|      0|                        Ok(data) => writeln!(&mut file, "{:#?}", data),
  286|      0|                        Err(err) => writeln!(&mut file, "Arbitrary Error: {}", err),
  287|       |                    })
  288|      0|                    .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  289|      0|                    return -1;
  290|  3.51k|                }
  291|       |
  292|  3.51k|                let data = match data {
  293|  2.71k|                    Ok(d) => d,
  294|    798|                    Err(_) => return -1,
  295|       |                };
  296|       |
  297|  2.71k|                let result = ::libfuzzer_sys::Corpus::from(__libfuzzer_sys_run(data));
  298|  2.71k|                result.to_libfuzzer_code()
  299|  3.51k|            }
_RNvNvCslmM25dSh1d8_18sparql_update_eval1__19___libfuzzer_sys_run:
  303|  2.71k|            fn __libfuzzer_sys_run($data: $dty) -> $rty {
  304|       |                $body
  305|  2.71k|            }
_RNvXCs5QDA8PpRtOW_13libfuzzer_sysNtB2_6CorpusINtNtCs9nhK3FOW46N_4core7convert4FromuE4from:
   30|  2.71k|    fn from(_: ()) -> Self {
   31|  2.71k|        Self::Keep
   32|  2.71k|    }
LLVMFuzzerTestOneInput:
   58|  3.51k|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|  3.51k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|  3.51k|    });
   63|  3.51k|
   64|  3.51k|    match test_input {
   65|  3.51k|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|  3.51k|}
_RNvMs_Cs5QDA8PpRtOW_13libfuzzer_sysNtB4_6Corpus17to_libfuzzer_code:
   40|  2.71k|    pub fn to_libfuzzer_code(self) -> i32 {
   41|  2.71k|        match self {
   42|  2.71k|            Corpus::Keep => 0,
   43|      0|            Corpus::Reject => -1,
   44|       |        }
   45|  2.71k|    }
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}
_RNCNvCs5QDA8PpRtOW_13libfuzzer_sys15test_input_wrap0B3_:
   59|  3.51k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|  3.51k|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|  3.51k|        rust_fuzzer_test_input(data_slice)
   62|  3.51k|    });

_RNvMs2_NtCs4LeKDsHh25A_9once_cell3impINtB5_8OnceCellNtNtCsjOdcKtOMjJI_5alloc6string6StringE14is_initializedCs5QDA8PpRtOW_13libfuzzer_sys:
   49|  3.51k|    pub(crate) fn is_initialized(&self) -> bool {
   50|  3.51k|        // An `Acquire` load is enough because that makes all the initialization
   51|  3.51k|        // operations visible to us, and, this being a fast path, weaker
   52|  3.51k|        // ordering helps with performance. This `Acquire` synchronizes with
   53|  3.51k|        // `SeqCst` operations on the slow path.
   54|  3.51k|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   55|  3.51k|    }

_RNvMs4_NtCs4LeKDsHh25A_9once_cell4syncINtB5_8OnceCellNtNtCsjOdcKtOMjJI_5alloc6string6StringE3getCs5QDA8PpRtOW_13libfuzzer_sys:
  963|  3.51k|        pub fn get(&self) -> Option<&T> {
  964|  3.51k|            if self.0.is_initialized() {
  965|       |                // Safe b/c value is initialized.
  966|      0|                Some(unsafe { self.get_unchecked() })
  967|       |            } else {
  968|  3.51k|                None
  969|       |            }
  970|  3.51k|        }

_RINvXsr_Cs87w0kKV82sz_10oxilangtagNtB6_16VoidOutputBufferINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect6ExtendcE6extendINtNtNtB10_8adapters3map3MapNtNtNtB12_3str4iter5CharsNCNvB6_12to_lowercase0EECshJ9d6mhVUZV_5oxrdf:
  571|  1.97k|    fn extend<T: IntoIterator<Item = char>>(&mut self, _: T) {}
_RINvCs87w0kKV82sz_10oxilangtag13parse_langtagNtB2_16VoidOutputBufferECshJ9d6mhVUZV_5oxrdf:
  632|  1.97k|fn parse_langtag(
  633|  1.97k|    input: &str,
  634|  1.97k|    output: &mut impl OutputBuffer,
  635|  1.97k|) -> Result<TagElementsPositions, LanguageTagParseError> {
  636|  1.97k|    #[derive(PartialEq, Eq)]
  637|  1.97k|    enum State {
  638|  1.97k|        Start,
  639|  1.97k|        AfterLanguage,
  640|  1.97k|        AfterExtLang,
  641|  1.97k|        AfterScript,
  642|  1.97k|        AfterRegion,
  643|  1.97k|        InExtension { expected: bool },
  644|  1.97k|        InPrivateUse { expected: bool },
  645|  1.97k|    }
  646|  1.97k|
  647|  1.97k|    let mut state = State::Start;
  648|  1.97k|    let mut language_end = 0;
  649|  1.97k|    let mut extlang_end = 0;
  650|  1.97k|    let mut script_end = 0;
  651|  1.97k|    let mut region_end = 0;
  652|  1.97k|    let mut variant_end = 0;
  653|  1.97k|    let mut extension_end = 0;
  654|  1.97k|    let mut extlangs_count = 0;
  655|  1.97k|    for (subtag, end) in SubTagIterator::new(input) {
  656|  1.97k|        if subtag.is_empty() {
  657|      0|            return Err(LanguageTagParseError {
  658|      0|                kind: TagParseErrorKind::EmptySubtag,
  659|      0|            });
  660|  1.97k|        }
  661|  1.97k|        if subtag.len() > 8 {
  662|      0|            return Err(LanguageTagParseError {
  663|      0|                kind: TagParseErrorKind::SubtagTooLong,
  664|      0|            });
  665|  1.97k|        }
  666|  1.97k|        if state == State::Start {
  667|       |            // Primary language
  668|  1.97k|            if subtag.len() < 2 || !is_alphabetic(subtag) {
  669|      0|                return Err(LanguageTagParseError {
  670|      0|                    kind: TagParseErrorKind::InvalidLanguage,
  671|      0|                });
  672|  1.97k|            }
  673|  1.97k|            language_end = end;
  674|  1.97k|            output.extend(to_lowercase(subtag));
  675|  1.97k|            if subtag.len() < 4 {
  676|  1.97k|                // extlangs are only allowed for short language tags
  677|  1.97k|                state = State::AfterLanguage;
  678|  1.97k|            } else {
  679|      0|                state = State::AfterExtLang;
  680|      0|            }
  681|      0|        } else if let State::InPrivateUse { .. } = state {
  682|      0|            if !is_alphanumeric(subtag) {
  683|      0|                return Err(LanguageTagParseError {
  684|      0|                    kind: TagParseErrorKind::InvalidSubtag,
  685|      0|                });
  686|      0|            }
  687|      0|            output.push('-');
  688|      0|            output.extend(to_lowercase(subtag));
  689|      0|            state = State::InPrivateUse { expected: false };
  690|      0|        } else if subtag == "x" || subtag == "X" {
  691|       |            // We make sure extension is found
  692|      0|            if let State::InExtension { expected: true } = state {
  693|      0|                return Err(LanguageTagParseError {
  694|      0|                    kind: TagParseErrorKind::EmptyExtension,
  695|      0|                });
  696|      0|            }
  697|      0|            output.push('-');
  698|      0|            output.push('x');
  699|      0|            state = State::InPrivateUse { expected: true };
  700|      0|        } else if subtag.len() == 1 && is_alphanumeric(subtag) {
  701|       |            // We make sure extension is found
  702|      0|            if let State::InExtension { expected: true } = state {
  703|      0|                return Err(LanguageTagParseError {
  704|      0|                    kind: TagParseErrorKind::EmptyExtension,
  705|      0|                });
  706|      0|            }
  707|      0|            let extension_tag = subtag.chars().next().unwrap().to_ascii_lowercase();
  708|      0|            output.push('-');
  709|      0|            output.push(extension_tag);
  710|      0|            state = State::InExtension { expected: true };
  711|      0|        } else if let State::InExtension { .. } = state {
  712|      0|            if !is_alphanumeric(subtag) {
  713|      0|                return Err(LanguageTagParseError {
  714|      0|                    kind: TagParseErrorKind::InvalidSubtag,
  715|      0|                });
  716|      0|            }
  717|      0|            extension_end = end;
  718|      0|            output.push('-');
  719|      0|            output.extend(to_lowercase(subtag));
  720|      0|            state = State::InExtension { expected: false };
  721|      0|        } else if state == State::AfterLanguage && subtag.len() == 3 && is_alphabetic(subtag) {
  722|      0|            extlangs_count += 1;
  723|      0|            if extlangs_count > 3 {
  724|      0|                return Err(LanguageTagParseError {
  725|      0|                    kind: TagParseErrorKind::TooManyExtlangs,
  726|      0|                });
  727|      0|            }
  728|      0|            // valid extlangs
  729|      0|            extlang_end = end;
  730|      0|            output.push('-');
  731|      0|            output.extend(to_lowercase(subtag));
  732|      0|        } else if (state == State::AfterLanguage || state == State::AfterExtLang)
  733|      0|            && subtag.len() == 4
  734|      0|            && is_alphabetic(subtag)
  735|      0|        {
  736|      0|            // Script
  737|      0|            script_end = end;
  738|      0|            output.push('-');
  739|      0|            output.extend(to_uppercase_first(subtag));
  740|      0|            state = State::AfterScript;
  741|      0|        } else if (state == State::AfterLanguage
  742|      0|            || state == State::AfterExtLang
  743|      0|            || state == State::AfterScript)
  744|      0|            && (subtag.len() == 2 && is_alphabetic(subtag)
  745|      0|                || subtag.len() == 3 && is_numeric(subtag))
  746|      0|        {
  747|      0|            // Region
  748|      0|            region_end = end;
  749|      0|            output.push('-');
  750|      0|            output.extend(to_uppercase(subtag));
  751|      0|            state = State::AfterRegion;
  752|      0|        } else if (state == State::AfterLanguage
  753|      0|            || state == State::AfterExtLang
  754|      0|            || state == State::AfterScript
  755|      0|            || state == State::AfterRegion)
  756|      0|            && is_alphanumeric(subtag)
  757|      0|            && (subtag.len() >= 5 && is_alphabetic(&subtag[0..1])
  758|      0|                || subtag.len() >= 4 && is_numeric(&subtag[0..1]))
  759|      0|        {
  760|      0|            // Variant
  761|      0|            variant_end = end;
  762|      0|            output.push('-');
  763|      0|            output.extend(to_lowercase(subtag));
  764|      0|            state = State::AfterRegion;
  765|      0|        } else {
  766|      0|            return Err(LanguageTagParseError {
  767|      0|                kind: TagParseErrorKind::InvalidSubtag,
  768|      0|            });
  769|       |        }
  770|       |    }
  771|       |
  772|       |    //We make sure we are in a correct final state
  773|  1.97k|    if let State::InExtension { expected: true } = state {
  774|      0|        return Err(LanguageTagParseError {
  775|      0|            kind: TagParseErrorKind::EmptyExtension,
  776|      0|        });
  777|  1.97k|    }
  778|  1.97k|    if let State::InPrivateUse { expected: true } = state {
  779|      0|        return Err(LanguageTagParseError {
  780|      0|            kind: TagParseErrorKind::EmptyPrivateUse,
  781|      0|        });
  782|  1.97k|    }
  783|  1.97k|
  784|  1.97k|    //We make sure we have not skipped anyone
  785|  1.97k|    if extlang_end < language_end {
  786|  1.97k|        extlang_end = language_end;
  787|  1.97k|    }
  788|  1.97k|    if script_end < extlang_end {
  789|  1.97k|        script_end = extlang_end;
  790|  1.97k|    }
  791|  1.97k|    if region_end < script_end {
  792|  1.97k|        region_end = script_end;
  793|  1.97k|    }
  794|  1.97k|    if variant_end < region_end {
  795|  1.97k|        variant_end = region_end;
  796|  1.97k|    }
  797|  1.97k|    if extension_end < variant_end {
  798|  1.97k|        extension_end = variant_end;
  799|  1.97k|    }
  800|       |
  801|  1.97k|    Ok(TagElementsPositions {
  802|  1.97k|        language_end,
  803|  1.97k|        extlang_end,
  804|  1.97k|        script_end,
  805|  1.97k|        region_end,
  806|  1.97k|        variant_end,
  807|  1.97k|        extension_end,
  808|  1.97k|    })
  809|  1.97k|}
_RNvMCs87w0kKV82sz_10oxilangtagINtB2_11LanguageTagNtNtCsjOdcKtOMjJI_5alloc6string6StringE10into_innerCshJ9d6mhVUZV_5oxrdf:
   62|  1.97k|    pub fn into_inner(self) -> T {
   63|  1.97k|        self.tag
   64|  1.97k|    }
_RINvCs87w0kKV82sz_10oxilangtag18parse_language_tagNtB2_16VoidOutputBufferECshJ9d6mhVUZV_5oxrdf:
  587|  1.97k|fn parse_language_tag(
  588|  1.97k|    input: &str,
  589|  1.97k|    output: &mut impl OutputBuffer,
  590|  1.97k|) -> Result<TagElementsPositions, LanguageTagParseError> {
  591|       |    //grandfathered tags
  592|  1.97k|    if let Some(tag) = GRANDFATHEREDS
  593|  1.97k|        .iter()
  594|  1.97k|        .find(|record| record.eq_ignore_ascii_case(input))
  595|       |    {
  596|      0|        output.push_str(tag);
  597|      0|        Ok(TagElementsPositions {
  598|      0|            language_end: tag.len(),
  599|      0|            extlang_end: tag.len(),
  600|      0|            script_end: tag.len(),
  601|      0|            region_end: tag.len(),
  602|      0|            variant_end: tag.len(),
  603|      0|            extension_end: tag.len(),
  604|      0|        })
  605|  1.97k|    } else if input.starts_with("x-") || input.starts_with("X-") {
  606|       |        // private use
  607|      0|        if !is_alphanumeric_or_dash(input) {
  608|      0|            Err(LanguageTagParseError {
  609|      0|                kind: TagParseErrorKind::ForbiddenChar,
  610|      0|            })
  611|      0|        } else if input.len() == 2 {
  612|      0|            Err(LanguageTagParseError {
  613|      0|                kind: TagParseErrorKind::EmptyPrivateUse,
  614|      0|            })
  615|       |        } else {
  616|      0|            output.extend(input.chars().map(|c| c.to_ascii_lowercase()));
  617|      0|            Ok(TagElementsPositions {
  618|      0|                language_end: input.len(),
  619|      0|                extlang_end: input.len(),
  620|      0|                script_end: input.len(),
  621|      0|                region_end: input.len(),
  622|      0|                variant_end: input.len(),
  623|      0|                extension_end: input.len(),
  624|      0|            })
  625|       |        }
  626|       |    } else {
  627|  1.97k|        parse_langtag(input, output)
  628|       |    }
  629|  1.97k|}
_RNCINvCs87w0kKV82sz_10oxilangtag18parse_language_tagNtB4_16VoidOutputBufferE0CshJ9d6mhVUZV_5oxrdf:
  594|  51.3k|        .find(|record| record.eq_ignore_ascii_case(input))
_RNvMCs87w0kKV82sz_10oxilangtagINtB2_11LanguageTagNtNtCsjOdcKtOMjJI_5alloc6string6StringE5parseCshJ9d6mhVUZV_5oxrdf:
   49|  1.97k|    pub fn parse(tag: T) -> Result<Self, LanguageTagParseError> {
   50|  1.97k|        let positions = parse_language_tag(&tag, &mut VoidOutputBuffer::default())?;
   51|  1.97k|        Ok(Self { tag, positions })
   52|  1.97k|    }
_RNvXsE_Cs87w0kKV82sz_10oxilangtagNtB5_16VoidOutputBufferNtNtCs9nhK3FOW46N_4core7default7Default7defaultCshJ9d6mhVUZV_5oxrdf:
  558|  1.97k|#[derive(Default)]
_RNvXs_NvCs87w0kKV82sz_10oxilangtag13parse_langtagNtB4_5StateNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCshJ9d6mhVUZV_5oxrdf:
  636|  1.97k|    #[derive(PartialEq, Eq)]
_RNvCs87w0kKV82sz_10oxilangtag13is_alphabeticCshJ9d6mhVUZV_5oxrdf:
  871|  1.97k|fn is_alphabetic(s: &str) -> bool {
  872|  1.97k|    s.chars().all(|x| x.is_ascii_alphabetic())
  873|  1.97k|}
_RNvCs87w0kKV82sz_10oxilangtag12to_lowercaseCshJ9d6mhVUZV_5oxrdf:
  903|  1.97k|fn to_lowercase(s: &str) -> impl Iterator<Item = char> + '_ {
  904|  1.97k|    s.chars().map(|c| c.to_ascii_lowercase())
  905|  1.97k|}
_RNvXsw_Cs87w0kKV82sz_10oxilangtagNtB5_14SubTagIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nextCshJ9d6mhVUZV_5oxrdf:
  862|  3.94k|    fn next(&mut self) -> Option<(&'a str, usize)> {
  863|  3.94k|        let tag = self.split.next()?;
  864|  1.97k|        let tag_end = self.position + tag.len();
  865|  1.97k|        self.position = tag_end + 1;
  866|  1.97k|        Some((tag, tag_end))
  867|  3.94k|    }
_RNvMsv_Cs87w0kKV82sz_10oxilangtagNtB5_14SubTagIterator3newCshJ9d6mhVUZV_5oxrdf:
  850|  1.97k|    fn new(input: &'a str) -> Self {
  851|  1.97k|        Self {
  852|  1.97k|            split: input.split('-'),
  853|  1.97k|            position: 0,
  854|  1.97k|        }
  855|  1.97k|    }
_RNCNvCs87w0kKV82sz_10oxilangtag13is_alphabetic0B3_:
  872|  3.94k|    s.chars().all(|x| x.is_ascii_alphabetic())

_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E12parse_schemeCshJ9d6mhVUZV_5oxrdf:
 1213|  55.7k|    fn parse_scheme(&mut self) -> Result<(), IriParseError> {
 1214|   278k|        loop {
 1215|   278k|            let c = self.input.next();
 1216|   278k|            match c {
 1217|   278k|                Some(c) if c.is_ascii_alphanumeric() || c == '+' || c == '-' || c == '.' => {
 1218|   223k|                    self.output.push(c)
 1219|       |                }
 1220|       |                Some(':') => {
 1221|  55.7k|                    self.output.push(':');
 1222|  55.7k|                    self.output_positions.scheme_end = self.output.len();
 1223|  55.7k|                    self.input_scheme_end = self.input.position;
 1224|  55.7k|                    return if self.input.starts_with('/') {
 1225|  55.7k|                        self.input.next();
 1226|  55.7k|                        self.output.push('/');
 1227|  55.7k|                        self.parse_path_or_authority()
 1228|       |                    } else {
 1229|      0|                        self.output_positions.authority_end = self.output.len();
 1230|      0|                        self.parse_path()
 1231|       |                    };
 1232|       |                }
 1233|       |                _ => {
 1234|      0|                    self.input = ParserInput {
 1235|      0|                        value: self.iri.chars(),
 1236|      0|                        position: 0,
 1237|      0|                    }; // reset
 1238|      0|                    self.output.clear();
 1239|      0|                    return self.parse_relative();
 1240|       |                }
 1241|       |            }
 1242|       |        }
 1243|  55.7k|    }
_RNvMCsbOXESBDtkxG_5oxiriINtB2_6IriRefNtNtCsjOdcKtOMjJI_5alloc6string6StringE10into_innerCshJ9d6mhVUZV_5oxrdf:
  185|  55.7k|    pub fn into_inner(self) -> T {
  186|  55.7k|        self.iri
  187|  55.7k|    }
_RNvMCsbOXESBDtkxG_5oxiriINtB2_6IriRefNtNtCsjOdcKtOMjJI_5alloc6string6StringE5parseCshJ9d6mhVUZV_5oxrdf:
   58|  55.7k|    pub fn parse(iri: T) -> Result<Self, IriParseError> {
   59|  55.7k|        let positions = IriParser::<_, false>::parse(&iri, None, &mut VoidOutputBuffer::default())?;
   60|  55.7k|        Ok(Self { iri, positions })
   61|  55.7k|    }
_RNvMsp_CsbOXESBDtkxG_5oxiriINtB5_3IriNtNtCsjOdcKtOMjJI_5alloc6string6StringE5parseCshJ9d6mhVUZV_5oxrdf:
  556|  55.7k|    pub fn parse(iri: T) -> Result<Self, IriParseError> {
  557|  55.7k|        IriRef::parse(iri)?.try_into()
  558|  55.7k|    }
_RNvMCsbOXESBDtkxG_5oxiriINtB2_6IriRefNtNtCsjOdcKtOMjJI_5alloc6string6StringE11is_absoluteCshJ9d6mhVUZV_5oxrdf:
  199|  55.7k|    pub fn is_absolute(&self) -> bool {
  200|  55.7k|        self.positions.scheme_end != 0
  201|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E27read_url_codepoint_or_echarCshJ9d6mhVUZV_5oxrdf:
 1534|  1.28M|    fn read_url_codepoint_or_echar(&mut self, c: char) -> Result<(), IriParseError> {
 1535|  1.28M|        if UNCHECKED || is_url_code_point(c) {
 1536|  1.28M|            self.output.push(c);
 1537|  1.28M|            Ok(())
 1538|      0|        } else if c == '%' {
 1539|      0|            self.read_echar()
 1540|       |        } else {
 1541|      0|            self.parse_error(IriParseErrorKind::InvalidIriCodePoint(c))
 1542|       |        }
 1543|  1.28M|    }
_RNvXsV_CsbOXESBDtkxG_5oxiriINtB5_3IriNtNtCsjOdcKtOMjJI_5alloc6string6StringEINtNtCs9nhK3FOW46N_4core7convert7TryFromINtB5_6IriRefBz_EE8try_fromCshJ9d6mhVUZV_5oxrdf:
  968|  55.7k|    fn try_from(iri: IriRef<T>) -> Result<Self, IriParseError> {
  969|  55.7k|        if iri.is_absolute() {
  970|  55.7k|            Ok(Self(iri))
  971|       |        } else {
  972|      0|            Err(IriParseError {
  973|      0|                kind: IriParseErrorKind::NoScheme,
  974|      0|            })
  975|       |        }
  976|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E18parse_scheme_startCshJ9d6mhVUZV_5oxrdf:
 1199|  55.7k|    fn parse_scheme_start(&mut self) -> Result<(), IriParseError> {
 1200|  55.7k|        match self.input.front() {
 1201|       |            Some(':') => {
 1202|      0|                if UNCHECKED {
 1203|      0|                    self.parse_scheme()
 1204|       |                } else {
 1205|      0|                    self.parse_error(IriParseErrorKind::NoScheme)
 1206|       |                }
 1207|       |            }
 1208|  55.7k|            Some(c) if c.is_ascii_alphabetic() => self.parse_scheme(),
 1209|      0|            _ => self.parse_relative(),
 1210|       |        }
 1211|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E10parse_hostCshJ9d6mhVUZV_5oxrdf:
 1359|  55.7k|    fn parse_host(&mut self) -> Result<(), IriParseError> {
 1360|  55.7k|        if self.input.starts_with('[') {
 1361|       |            // IP v6
 1362|      0|            let start_position = self.input.position;
 1363|      0|            while let Some(c) = self.input.next() {
 1364|      0|                self.output.push(c);
 1365|      0|                if c == ']' {
 1366|      0|                    let ip = &self.iri[start_position + 1..self.input.position - 1];
 1367|      0|                    if !UNCHECKED {
 1368|      0|                        if let Err(error) = Ipv6Addr::from_str(ip) {
 1369|      0|                            return self.parse_error(IriParseErrorKind::InvalidHostIp(error));
 1370|      0|                        }
 1371|      0|                    }
 1372|       |
 1373|      0|                    let c = self.input.next();
 1374|      0|                    return match c {
 1375|       |                        Some(':') => {
 1376|      0|                            self.output.push(':');
 1377|      0|                            self.parse_port()
 1378|       |                        }
 1379|       |                        None | Some('/') | Some('?') | Some('#') => {
 1380|      0|                            self.output_positions.authority_end = self.output.len();
 1381|      0|                            self.parse_path_start(c)
 1382|       |                        }
 1383|      0|                        Some(c) => {
 1384|      0|                            if UNCHECKED {
 1385|      0|                                self.output.push(c);
 1386|      0|                                continue;
 1387|       |                            } else {
 1388|      0|                                self.parse_error(IriParseErrorKind::InvalidHostCharacter(c))
 1389|       |                            }
 1390|       |                        }
 1391|       |                    };
 1392|      0|                }
 1393|       |            }
 1394|      0|            if UNCHECKED {
 1395|       |                // We consider it's valid even if it's not finished
 1396|      0|                self.output_positions.authority_end = self.output.len();
 1397|      0|                self.parse_path_start(None)
 1398|       |            } else {
 1399|      0|                self.parse_error(IriParseErrorKind::InvalidHostCharacter('['))
 1400|       |            }
 1401|       |        } else {
 1402|       |            // Other host
 1403|   669k|            loop {
 1404|   669k|                let c = self.input.next();
 1405|   669k|                match c {
 1406|       |                    Some(':') => {
 1407|      0|                        self.output.push(':');
 1408|      0|                        return self.parse_port();
 1409|       |                    }
 1410|       |                    None | Some('/') | Some('?') | Some('#') => {
 1411|  55.7k|                        self.output_positions.authority_end = self.output.len();
 1412|  55.7k|                        return self.parse_path_start(c);
 1413|       |                    }
 1414|   613k|                    Some(c) => self.read_url_codepoint_or_echar(c)?,
 1415|       |                }
 1416|       |            }
 1417|       |        }
 1418|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E23parse_path_or_authorityCshJ9d6mhVUZV_5oxrdf:
 1245|  55.7k|    fn parse_path_or_authority(&mut self) -> Result<(), IriParseError> {
 1246|  55.7k|        if self.input.starts_with('/') {
 1247|  55.7k|            self.input.next();
 1248|  55.7k|            self.output.push('/');
 1249|  55.7k|            self.parse_authority()
 1250|       |        } else {
 1251|      0|            self.output_positions.authority_end = self.output.len() - 1;
 1252|      0|            self.parse_path()
 1253|       |        }
 1254|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E16parse_path_startCshJ9d6mhVUZV_5oxrdf:
 1439|  55.7k|    fn parse_path_start(&mut self, c: Option<char>) -> Result<(), IriParseError> {
 1440|  55.7k|        match c {
 1441|       |            None => {
 1442|      0|                self.output_positions.path_end = self.output.len();
 1443|      0|                self.output_positions.query_end = self.output.len();
 1444|      0|                Ok(())
 1445|       |            }
 1446|       |            Some('?') => {
 1447|      0|                self.output_positions.path_end = self.output.len();
 1448|      0|                self.output.push('?');
 1449|      0|                self.parse_query()
 1450|       |            }
 1451|       |            Some('#') => {
 1452|      0|                self.output_positions.path_end = self.output.len();
 1453|      0|                self.output_positions.query_end = self.output.len();
 1454|      0|                self.output.push('#');
 1455|      0|                self.parse_fragment()
 1456|       |            }
 1457|       |            Some('/') => {
 1458|  55.7k|                self.output.push('/');
 1459|  55.7k|                self.parse_path()
 1460|       |            }
 1461|      0|            Some(c) => {
 1462|      0|                self.read_url_codepoint_or_echar(c)?;
 1463|      0|                self.parse_path()
 1464|       |            }
 1465|       |        }
 1466|  55.7k|    }
_RNvMsp_CsbOXESBDtkxG_5oxiriINtB5_3IriNtNtCsjOdcKtOMjJI_5alloc6string6StringE10into_innerCshJ9d6mhVUZV_5oxrdf:
  665|  55.7k|    pub fn into_inner(self) -> T {
  666|  55.7k|        self.0.into_inner()
  667|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E10parse_pathCshJ9d6mhVUZV_5oxrdf:
 1468|  55.7k|    fn parse_path(&mut self) -> Result<(), IriParseError> {
 1469|   114k|        loop {
 1470|   114k|            let c = self.input.next();
 1471|   114k|            match c {
 1472|       |                None | Some('/') | Some('?') | Some('#') => {
 1473|  55.9k|                    if self.output.as_str().ends_with("/..") {
 1474|      0|                        self.remove_last_segment();
 1475|      0|                        self.remove_last_segment();
 1476|      0|                        self.output.push('/');
 1477|  55.9k|                    } else if self.output.as_str().ends_with("/.") {
 1478|      0|                        self.remove_last_segment();
 1479|      0|                        self.output.push('/');
 1480|  55.9k|                    } else if c == Some('/') {
 1481|    194|                        self.output.push('/');
 1482|  55.7k|                    }
 1483|       |
 1484|  55.9k|                    if c == Some('?') {
 1485|      0|                        self.output_positions.path_end = self.output.len();
 1486|      0|                        self.output.push('?');
 1487|      0|                        return self.parse_query();
 1488|  55.9k|                    } else if c == Some('#') {
 1489|    194|                        self.output_positions.path_end = self.output.len();
 1490|    194|                        self.output_positions.query_end = self.output.len();
 1491|    194|                        self.output.push('#');
 1492|    194|                        return self.parse_fragment();
 1493|  55.7k|                    } else if c.is_none() {
 1494|  55.5k|                        self.output_positions.path_end = self.output.len();
 1495|  55.5k|                        self.output_positions.query_end = self.output.len();
 1496|  55.5k|                        return Ok(());
 1497|    194|                    }
 1498|       |                }
 1499|  58.1k|                Some(c) => self.read_url_codepoint_or_echar(c)?,
 1500|       |            }
 1501|       |        }
 1502|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E5parseCshJ9d6mhVUZV_5oxrdf:
 1174|  55.7k|    fn parse(
 1175|  55.7k|        iri: &'a str,
 1176|  55.7k|        base: Option<IriRef<&'a str>>,
 1177|  55.7k|        output: &'a mut O,
 1178|  55.7k|    ) -> Result<IriElementsPositions, IriParseError> {
 1179|  55.7k|        let mut parser = Self {
 1180|  55.7k|            iri,
 1181|  55.7k|            base,
 1182|  55.7k|            input: ParserInput {
 1183|  55.7k|                value: iri.chars(),
 1184|  55.7k|                position: 0,
 1185|  55.7k|            },
 1186|  55.7k|            output,
 1187|  55.7k|            output_positions: IriElementsPositions {
 1188|  55.7k|                scheme_end: 0,
 1189|  55.7k|                authority_end: 0,
 1190|  55.7k|                path_end: 0,
 1191|  55.7k|                query_end: 0,
 1192|  55.7k|            },
 1193|  55.7k|            input_scheme_end: 0,
 1194|  55.7k|        };
 1195|  55.7k|        parser.parse_scheme_start()?;
 1196|  55.7k|        Ok(parser.output_positions)
 1197|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E15parse_authorityCshJ9d6mhVUZV_5oxrdf:
 1335|  55.7k|    fn parse_authority(&mut self) -> Result<(), IriParseError> {
 1336|       |        // @ are not allowed in IRI authorities so not need to take care of ambiguities
 1337|   669k|        loop {
 1338|   669k|            let c = self.input.next();
 1339|   669k|            match c {
 1340|       |                Some('@') => {
 1341|      0|                    self.output.push('@');
 1342|      0|                    return self.parse_host();
 1343|       |                }
 1344|       |                None | Some('[') | Some('/') | Some('?') | Some('#') => {
 1345|  55.7k|                    self.input = ParserInput {
 1346|  55.7k|                        value: self.iri[self.input_scheme_end + 2..].chars(),
 1347|  55.7k|                        position: self.input_scheme_end + 2,
 1348|  55.7k|                    };
 1349|  55.7k|                    self.output.truncate(self.output_positions.scheme_end + 2);
 1350|  55.7k|                    return self.parse_host();
 1351|       |                }
 1352|   613k|                Some(c) => {
 1353|   613k|                    self.read_url_codepoint_or_echar(c)?;
 1354|       |                }
 1355|       |            }
 1356|       |        }
 1357|  55.7k|    }
_RNvMs11_CsbOXESBDtkxG_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferKb0_E14parse_fragmentCshJ9d6mhVUZV_5oxrdf:
 1518|    194|    fn parse_fragment(&mut self) -> Result<(), IriParseError> {
 1519|  1.35k|        while let Some(c) = self.input.next() {
 1520|  1.16k|            self.read_url_codepoint_or_echar(c)?
 1521|       |        }
 1522|    194|        Ok(())
 1523|    194|    }
_RNvMs10_CsbOXESBDtkxG_5oxiriNtB6_11ParserInput11starts_withCshJ9d6mhVUZV_5oxrdf:
 1156|   167k|    fn starts_with(&self, c: char) -> bool {
 1157|   167k|        self.value.as_str().starts_with(c)
 1158|   167k|    }
_RNvXs1b_CsbOXESBDtkxG_5oxiriNtB6_16VoidOutputBufferNtNtCs9nhK3FOW46N_4core7default7Default7defaultCshJ9d6mhVUZV_5oxrdf:
 1065|  55.7k|#[derive(Default)]
_RNvXsY_CsbOXESBDtkxG_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer3lenCshJ9d6mhVUZV_5oxrdf:
 1092|   223k|    fn len(&self) -> usize {
 1093|   223k|        self.len
 1094|   223k|    }
_RNvXsY_CsbOXESBDtkxG_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer4pushCshJ9d6mhVUZV_5oxrdf:
 1072|  1.73M|    fn push(&mut self, c: char) {
 1073|  1.73M|        self.len += c.len_utf8();
 1074|  1.73M|    }
_RNvXsY_CsbOXESBDtkxG_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer6as_strCshJ9d6mhVUZV_5oxrdf:
 1097|   111k|    fn as_str(&self) -> &str {
 1098|   111k|        ""
 1099|   111k|    }
_RNvXsY_CsbOXESBDtkxG_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer8truncateCshJ9d6mhVUZV_5oxrdf:
 1087|  55.7k|    fn truncate(&mut self, new_len: usize) {
 1088|  55.7k|        self.len = new_len;
 1089|  55.7k|    }
_RNvCsbOXESBDtkxG_5oxiri17is_url_code_pointCshJ9d6mhVUZV_5oxrdf:
 1584|  1.28M|fn is_url_code_point(c: char) -> bool {
 1585|  1.28M|    matches!(c,
 1586|  1.11M|        'a'..='z'
 1587|    776|        | 'A'..='Z'
 1588|  56.7k|        | '0'..='9'
 1589|       |        | '!'
 1590|       |        | '$'
 1591|       |        | '&'
 1592|       |        | '\''
 1593|       |        | '('
 1594|       |        | ')'
 1595|       |        | '*'
 1596|       |        | '+'
 1597|       |        | ','
 1598|       |        | '-'
 1599|       |        | '.'
 1600|       |        | '/'
 1601|       |        | ':'
 1602|       |        | ';'
 1603|       |        | '='
 1604|       |        | '?'
 1605|       |        | '@'
 1606|       |        | '_'
 1607|       |        | '~'
 1608|      0|        | '\u{A0}'..='\u{D7FF}'
 1609|      0|        | '\u{F900}'..='\u{FDCF}'
 1610|      0|        | '\u{FDF0}'..='\u{FFEF}'
 1611|      0|        | '\u{10000}'..='\u{1FFFD}'
 1612|      0|        | '\u{20000}'..='\u{2FFFD}'
 1613|      0|        | '\u{30000}'..='\u{3FFFD}'
 1614|      0|        | '\u{40000}'..='\u{4FFFD}'
 1615|      0|        | '\u{50000}'..='\u{5FFFD}'
 1616|      0|        | '\u{60000}'..='\u{6FFFD}'
 1617|      0|        | '\u{70000}'..='\u{7FFFD}'
 1618|      0|        | '\u{80000}'..='\u{8FFFD}'
 1619|      0|        | '\u{90000}'..='\u{9FFFD}'
 1620|      0|        | '\u{A0000}'..='\u{AFFFD}'
 1621|      0|        | '\u{B0000}'..='\u{BFFFD}'
 1622|      0|        | '\u{C0000}'..='\u{CFFFD}'
 1623|      0|        | '\u{D0000}'..='\u{DFFFD}'
 1624|      0|        | '\u{E1000}'..='\u{EFFFD}'
 1625|       |    )
 1626|  1.28M|}
_RNvMs10_CsbOXESBDtkxG_5oxiriNtB6_11ParserInput4nextCshJ9d6mhVUZV_5oxrdf:
 1141|  1.84M|    fn next(&mut self) -> Option<char> {
 1142|  1.84M|        if let Some(head) = self.value.next() {
 1143|  1.78M|            self.position += head.len_utf8();
 1144|  1.78M|            Some(head)
 1145|       |        } else {
 1146|  55.7k|            None
 1147|       |        }
 1148|  1.84M|    }
_RNvMs10_CsbOXESBDtkxG_5oxiriNtB6_11ParserInput5frontCshJ9d6mhVUZV_5oxrdf:
 1151|  55.7k|    fn front(&self) -> Option<char> {
 1152|  55.7k|        self.value.clone().next()
 1153|  55.7k|    }

_RINvMs2_NtCs4RBLVWBtRKn_11peg_runtime5errorNtB6_10ErrorState16into_parse_erroreECshSv3hUzq9FP_9spargebra:
  128|    217|    pub fn into_parse_error<I: Parse + ?Sized>(self, input: &I) -> ParseError<I::PositionRepr> {
  129|    217|        ParseError {
  130|    217|            location: Parse::position_repr(input, self.max_err_pos.into()),
  131|    217|            expected: self.expected,
  132|    217|        }
  133|    217|    }
_RNvMs2_NtCs4RBLVWBtRKn_11peg_runtime5errorNtB5_10ErrorState12mark_failure:
  117|  6.48M|    pub fn mark_failure(&mut self, pos: usize, expected: &'static str) -> RuleResult<()> {
  118|  6.48M|        if self.suppress_fail == 0 {
  119|  3.89M|            if self.reparsing_on_error {
  120|   435k|                self.mark_failure_slow_path(pos, expected);
  121|  3.46M|            } else if pos > self.max_err_pos {
  122|   405k|                self.max_err_pos = pos;
  123|  3.05M|            }
  124|  2.59M|        }
  125|  6.48M|        RuleResult::Failed
  126|  6.48M|    }
_RNvMs2_NtCs4RBLVWBtRKn_11peg_runtime5errorNtB5_10ErrorState3new:
   91|  2.71k|    pub fn new(initial_pos: usize) -> Self {
   92|  2.71k|        ErrorState {
   93|  2.71k|            max_err_pos: initial_pos,
   94|  2.71k|            suppress_fail: 0,
   95|  2.71k|            reparsing_on_error: false,
   96|  2.71k|            expected: ExpectedSet {
   97|  2.71k|                expected: BTreeSet::new(),
   98|  2.71k|            },
   99|  2.71k|        }
  100|  2.71k|    }
_RNvMs2_NtCs4RBLVWBtRKn_11peg_runtime5errorNtB5_10ErrorState17reparse_for_error:
  103|    217|    pub fn reparse_for_error(&mut self) {
  104|    217|        self.suppress_fail = 0;
  105|    217|        self.reparsing_on_error = true;
  106|    217|    }
_RNvMs2_NtCs4RBLVWBtRKn_11peg_runtime5errorNtB5_10ErrorState22mark_failure_slow_path:
  109|   435k|    pub fn mark_failure_slow_path(&mut self, pos: usize, expected: &'static str) {
  110|   435k|        if pos == self.max_err_pos {
  111|  2.13k|            self.expected.expected.insert(expected);
  112|   433k|        }
  113|   435k|    }

_RNvXs2_NtCs4RBLVWBtRKn_11peg_runtime3streNtB7_10ParseSlice11parse_sliceCshSv3hUzq9FP_9spargebra:
   76|   665k|    fn parse_slice(&'input self, p1: usize, p2: usize) -> &'input str {
   77|   665k|        &self[p1..p2]
   78|   665k|    }
_RNvXs1_NtCs4RBLVWBtRKn_11peg_runtime3streNtB7_12ParseLiteral20parse_string_literalCshSv3hUzq9FP_9spargebra:
   63|  2.89M|    fn parse_string_literal(&self, pos: usize, literal: &str) -> RuleResult<()> {
   64|  2.89M|        let l = literal.len();
   65|  2.89M|        if self.len() >= pos + l && &self.as_bytes()[pos..pos + l] == literal.as_bytes() {
   66|   430k|            RuleResult::Matched(pos + l, ())
   67|       |        } else {
   68|  2.46M|            RuleResult::Failed
   69|       |        }
   70|  2.89M|    }
_RNvXs_NtCs4RBLVWBtRKn_11peg_runtime3streNtB6_5Parse5startCshSv3hUzq9FP_9spargebra:
   28|  5.64k|    fn start(&self) -> usize {
   29|  5.64k|        0
   30|  5.64k|    }
_RNvXs_NtCs4RBLVWBtRKn_11peg_runtime3streNtB6_5Parse6is_eofCshSv3hUzq9FP_9spargebra:
   33|  2.93k|    fn is_eof(&self, pos: usize) -> bool {
   34|  2.93k|        pos >= self.len()
   35|  2.93k|    }
_RNvXs0_NtCs4RBLVWBtRKn_11peg_runtime3streNtB7_9ParseElem10parse_elemCshSv3hUzq9FP_9spargebra:
   53|  7.68M|    fn parse_elem(&'input self, pos: usize) -> RuleResult<char> {
   54|  7.68M|        match self[pos..].chars().next() {
   55|  7.62M|            Some(c) => RuleResult::Matched(pos + c.len_utf8(), c),
   56|  59.8k|            None => RuleResult::Failed,
   57|       |        }
   58|  7.68M|    }
_RNCNvXs_NtCs4RBLVWBtRKn_11peg_runtime3streNtB8_5Parse13position_repr0B8_:
   39|   174k|        let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
_RNCNvXs_NtCs4RBLVWBtRKn_11peg_runtime3streNtB8_5Parse13position_reprs_0B8_:
   40|   174k|        let column = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
_RNvXs_NtCs4RBLVWBtRKn_11peg_runtime3streNtB6_5Parse13position_repr:
   37|    217|    fn position_repr(&self, pos: usize) -> LineCol {
   38|    217|        let before = &self[..pos];
   39|    217|        let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
   40|    217|        let column = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
   41|    217|        LineCol {
   42|    217|            line,
   43|    217|            column,
   44|    217|            offset: pos,
   45|    217|        }
   46|    217|    }

_RNvXsM_NtCsf8HyAzZvOrI_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCs9nhK3FOW46N_4core3ops5arith9AddAssign10add_assignCswkaVU3ZAmW_11rand_chacha:
   32|   235k|            fn $fn_assign(&mut self, rhs: Self) {
   33|   235k|                (self.0[0]).$fn_assign(rhs.0[0]);
   34|   235k|                (self.0[1]).$fn_assign(rhs.0[1]);
   35|   235k|            }
_RNvXs_NtCsf8HyAzZvOrI_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right24CswkaVU3ZAmW_11rand_chacha:
   42|  58.8k|        fn $fn(self) -> Self {
   43|  58.8k|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|  58.8k|        }
_RNvXsG_NtCsf8HyAzZvOrI_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCs9nhK3FOW46N_4core3ops3bit6BitXor6bitxorCswkaVU3ZAmW_11rand_chacha:
   22|   235k|            fn $fn(self, rhs: Self) -> Self::Output {
   23|   235k|                x2::new([self.0[0].$fn(rhs.0[0]), self.0[1].$fn(rhs.0[1])])
   24|   235k|            }
_RNvXs_NtCsf8HyAzZvOrI_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right16CswkaVU3ZAmW_11rand_chacha:
   42|  58.8k|        fn $fn(self) -> Self {
   43|  58.8k|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|  58.8k|        }
_RNvMNtCsf8HyAzZvOrI_10ppv_lite864softINtB2_2x2INtNtNtNtB4_6x86_644sse24avx212u32x4x2_avx2NtBP_4NoNIENtBN_2G0E3newCswkaVU3ZAmW_11rand_chacha:
   13|   671k|    pub fn new(xs: [W; 2]) -> Self {
   14|   671k|        x2(xs, PhantomData)
   15|   671k|    }
_RNvXsg_NtCsf8HyAzZvOrI_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words3012CswkaVU3ZAmW_11rand_chacha:
  215|  58.8k|    fn shuffle_lane_words3012(self) -> Self {
  216|  58.8k|        Self::new([
  217|  58.8k|            self.0[0].shuffle_lane_words3012(),
  218|  58.8k|            self.0[1].shuffle_lane_words3012(),
  219|  58.8k|        ])
  220|  58.8k|    }
_RNvXsg_NtCsf8HyAzZvOrI_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words1230CswkaVU3ZAmW_11rand_chacha:
  208|  58.8k|    fn shuffle_lane_words1230(self) -> Self {
  209|  58.8k|        Self::new([
  210|  58.8k|            self.0[0].shuffle_lane_words1230(),
  211|  58.8k|            self.0[1].shuffle_lane_words1230(),
  212|  58.8k|        ])
  213|  58.8k|    }
_RNvXs_NtCsf8HyAzZvOrI_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right20CswkaVU3ZAmW_11rand_chacha:
   42|  58.8k|        fn $fn(self) -> Self {
   43|  58.8k|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|  58.8k|        }
_RNvXs_NtCsf8HyAzZvOrI_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right25CswkaVU3ZAmW_11rand_chacha:
   42|  58.8k|        fn $fn(self) -> Self {
   43|  58.8k|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|  58.8k|        }
_RNvXsg_NtCsf8HyAzZvOrI_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words2301CswkaVU3ZAmW_11rand_chacha:
  201|  58.8k|    fn shuffle_lane_words2301(self) -> Self {
  202|  58.8k|        Self::new([
  203|  58.8k|            self.0[0].shuffle_lane_words2301(),
  204|  58.8k|            self.0[1].shuffle_lane_words2301(),
  205|  58.8k|        ])
  206|  58.8k|    }

_RINvYINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec512_storageINtNtB8_4soft2x2INtNtNtB6_4sse24avx212u32x4x2_avx2BS_ENtB2b_2G0EECswkaVU3ZAmW_11rand_chacha:
  246|  4.90k|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|  4.90k|        unsafe { V::unpack(s) }
  248|  4.90k|    }
_RINvYINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine3vecINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EAmj4_ECswkaVU3ZAmW_11rand_chacha:
  251|  4.90k|    fn vec<V, A>(self, a: A) -> V
  252|  4.90k|    where
  253|  4.90k|        V: MultiLane<A>,
  254|  4.90k|    {
  255|  4.90k|        V::from_lanes(a)
  256|  4.90k|    }
_RINvYINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec128_storageINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EECswkaVU3ZAmW_11rand_chacha:
  246|  44.1k|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|  44.1k|        unsafe { V::unpack(s) }
  248|  44.1k|    }
_RINvYINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6410SseMachineNtB6_5YesS3NtB6_5YesS4NtB6_4NoNIENtNtB8_5types7Machine7read_leINtNtB6_4sse210u32x4_sse2BR_B12_B1d_EECswkaVU3ZAmW_11rand_chacha:
  259|     40|    fn read_le<V>(self, input: &[u8]) -> V
  260|     40|    where
  261|     40|        V: StoreBytes,
  262|     40|    {
  263|     40|        unsafe { V::unsafe_read_le(input) }
  264|     40|    }

_RNvNtCswkaVU3ZAmW_11rand_chacha4guts11init_chacha:
  333|     20|        $($pub $(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  334|     20|            #[inline(always)]
  335|     20|            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  336|     20|            use std::arch::x86_64::*;
  337|     20|            #[target_feature(enable = "avx")]
  338|     20|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|     20|                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|     20|            }
  341|     20|            #[target_feature(enable = "sse2")]
  342|     20|            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  343|     20|                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  344|     20|            }
  345|     20|            unsafe {
  346|     20|                if is_x86_feature_detected!("avx") {
  347|     20|                    impl_avx($($arg),*)
  348|      0|                } else if is_x86_feature_detected!("sse2") {
  349|      0|                    impl_sse2($($arg),*)
  350|       |                } else {
  351|      0|                    unimplemented!()
  352|       |                }
  353|       |            }
  354|     20|        }
_RNvXs_NtCsf8HyAzZvOrI_10ppv_lite866x86_64INtB4_11Avx2MachineNtB4_4NoNIENtNtB6_5types7Machine8instanceCswkaVU3ZAmW_11rand_chacha:
   92|  4.90k|    unsafe fn instance() -> Self {
   93|  4.90k|        Avx2Machine(PhantomData)
   94|  4.90k|    }
_RNvXNtCsf8HyAzZvOrI_10ppv_lite866x86_64INtB2_10SseMachineNtB2_5YesS3NtB2_5YesS4NtB2_4NoNIENtNtB4_5types7Machine8instanceCswkaVU3ZAmW_11rand_chacha:
   64|     20|    unsafe fn instance() -> Self {
   65|     20|        SseMachine(PhantomData)
   66|     20|    }
_RNvNtCswkaVU3ZAmW_11rand_chacha4guts11refill_wide:
  250|  4.90k|        $($pub$(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  251|  4.90k|            #[inline(always)]
  252|  4.90k|            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  253|  4.90k|            use std::arch::x86_64::*;
  254|  4.90k|            #[target_feature(enable = "avx2")]
  255|  4.90k|            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|  4.90k|                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|  4.90k|                _mm256_zeroupper();
  258|  4.90k|                ret
  259|  4.90k|            }
  260|  4.90k|            #[target_feature(enable = "avx")]
  261|  4.90k|            #[target_feature(enable = "sse4.1")]
  262|  4.90k|            #[target_feature(enable = "ssse3")]
  263|  4.90k|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  264|  4.90k|                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);
  265|  4.90k|                _mm256_zeroupper();
  266|  4.90k|                ret
  267|  4.90k|            }
  268|  4.90k|            #[target_feature(enable = "sse4.1")]
  269|  4.90k|            #[target_feature(enable = "ssse3")]
  270|  4.90k|            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {
  271|  4.90k|                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)
  272|  4.90k|            }
  273|  4.90k|            #[target_feature(enable = "ssse3")]
  274|  4.90k|            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {
  275|  4.90k|                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)
  276|  4.90k|            }
  277|  4.90k|            #[target_feature(enable = "sse2")]
  278|  4.90k|            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  279|  4.90k|                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  280|  4.90k|            }
  281|  4.90k|            unsafe {
  282|  4.90k|                if is_x86_feature_detected!("avx2") {
  283|  4.90k|                    impl_avx2($($arg),*)
  284|      0|                } else if is_x86_feature_detected!("avx") {
  285|      0|                    impl_avx($($arg),*)
  286|      0|                } else if is_x86_feature_detected!("sse4.1") {
  287|      0|                    impl_sse41($($arg),*)
  288|      0|                } else if is_x86_feature_detected!("ssse3") {
  289|      0|                    impl_ssse3($($arg),*)
  290|      0|                } else if is_x86_feature_detected!("sse2") {
  291|      0|                    impl_sse2($($arg),*)
  292|       |                } else {
  293|      0|                    unimplemented!()
  294|       |                }
  295|       |            }
  296|  4.90k|        }
_RNvNvNtCswkaVU3ZAmW_11rand_chacha4guts11refill_wide9impl_avx2:
  255|  4.90k|            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|  4.90k|                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|  4.90k|                _mm256_zeroupper();
  258|  4.90k|                ret
  259|  4.90k|            }
_RNvNvNtCswkaVU3ZAmW_11rand_chacha4guts11init_chacha8impl_avx:
  338|     20|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|     20|                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|     20|            }
_RNvXs2_NtCsf8HyAzZvOrI_10ppv_lite866x86_64NtB5_14vec128_storageINtNtCs9nhK3FOW46N_4core7convert4FromAmj4_E4from:
  130|     20|    fn from(u32x4: [u32; 4]) -> Self {
  131|     20|        vec128_storage { u32x4 }
  132|     20|    }

_RNvXsf_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E8to_lanesCswkaVU3ZAmW_11rand_chacha:
 1611|  19.6k|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 4] {
 1612|  19.6k|            let [a, b] = self.0[0].to_lanes();
 1613|  19.6k|            let [c, d] = self.0[1].to_lanes();
 1614|  19.6k|            [a, b, c, d]
 1615|  19.6k|        }
_RNvXs6_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E8to_lanesCswkaVU3ZAmW_11rand_chacha:
  323|  19.6k|    fn to_lanes(self) -> [u32; 4] {
  324|  19.6k|        unsafe {
  325|  19.6k|            let x = _mm_cvtsi128_si64(self.x) as u64;
  326|  19.6k|            let y = _mm_extract_epi64(self.x, 1) as u64;
  327|  19.6k|            [x as u32, (x >> 32) as u32, y as u32, (y >> 32) as u32]
  328|  19.6k|        }
  329|  19.6k|    }
_RNvXs6_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right16CswkaVU3ZAmW_11rand_chacha:
 1470|   117k|            fn $name(self) -> Self {
 1471|   117k|                Self::new(unsafe {
 1472|   117k|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|   117k|                })
 1474|   117k|            }
_RNvXs6_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right20CswkaVU3ZAmW_11rand_chacha:
 1480|   117k|            fn $name(self) -> Self {
 1481|   117k|                Self::new(unsafe {
 1482|   117k|                    _mm256_or_si256(
 1483|   117k|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|   117k|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|   117k|                    )
 1486|   117k|                })
 1487|   117k|            }
_RNvXs10_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes8write_leCswkaVU3ZAmW_11rand_chacha:
   89|  78.4k|            fn write_le(self, out: &mut [u8]) {
   90|  78.4k|                assert_eq!(out.len(), 16);
   91|  78.4k|                unsafe { _mm_storeu_si128(out.as_mut_ptr() as *mut _, self.x) }
   92|  78.4k|            }
_RNvXsc_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words1230CswkaVU3ZAmW_11rand_chacha:
 1582|   117k|        fn shuffle_lane_words1230(self) -> Self {
 1583|   117k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b1001_0011) })
 1584|   117k|        }
_RNvXsc_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words3012CswkaVU3ZAmW_11rand_chacha:
 1590|   117k|        fn shuffle_lane_words3012(self) -> Self {
 1591|   117k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0011_1001) })
 1592|   117k|        }
_RNvXsf_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E10from_lanesCswkaVU3ZAmW_11rand_chacha:
 1617|  19.6k|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 4]) -> Self {
 1618|  19.6k|            let ab = u32x4x2_avx2::from_lanes([x[0], x[1]]);
 1619|  19.6k|            let cd = u32x4x2_avx2::from_lanes([x[2], x[3]]);
 1620|  19.6k|            Self::new([ab, cd])
 1621|  19.6k|        }
_RNvMNtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB2_12u32x4x2_avx2NtB6_4NoNIE3newCswkaVU3ZAmW_11rand_chacha:
 1394|  1.81M|        fn new(x: __m256i) -> Self {
 1395|  1.81M|            Self { x, ni: PhantomData }
 1396|  1.81M|        }
_RNvXs6_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right24CswkaVU3ZAmW_11rand_chacha:
 1470|   117k|            fn $name(self) -> Self {
 1471|   117k|                Self::new(unsafe {
 1472|   117k|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|   117k|                })
 1474|   117k|            }
_RNvXsc_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words2301CswkaVU3ZAmW_11rand_chacha:
 1586|   117k|        fn shuffle_lane_words2301(self) -> Self {
 1587|   117k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0100_1110) })
 1588|   117k|        }
_RNvXs1R_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtNtCs9nhK3FOW46N_4core3ops5arith3Add3addCswkaVU3ZAmW_11rand_chacha:
   18|  78.4k|            fn $fn(self, rhs: Self) -> Self::Output {
   19|  78.4k|                Self::new(unsafe { $impl_fn(self.x, rhs.x) })
   20|  78.4k|            }
_RNvXsr_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCs9nhK3FOW46N_4core3ops3bit6BitXor6bitxorCswkaVU3ZAmW_11rand_chacha:
 1543|   470k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|   470k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|   470k|                }
_RNvXsv_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCs9nhK3FOW46N_4core3ops5arith3Add3addCswkaVU3ZAmW_11rand_chacha:
 1543|   470k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|   470k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|   470k|                }
_RNvXsq_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCs9nhK3FOW46N_4core3ops5arith9AddAssign10add_assignCswkaVU3ZAmW_11rand_chacha:
 1527|   470k|                fn $assign_fn(&mut self, rhs: Self) {
 1528|   470k|                    *self = self.$bin_fn(rhs);
 1529|   470k|                }
_RNvXs2_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E8to_lanesCswkaVU3ZAmW_11rand_chacha:
 1430|  39.2k|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 2] {
 1431|  39.2k|            unsafe {
 1432|  39.2k|                [
 1433|  39.2k|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 0)),
 1434|  39.2k|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 1)),
 1435|  39.2k|                ]
 1436|  39.2k|            }
 1437|  39.2k|        }
_RNvXs6_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right25CswkaVU3ZAmW_11rand_chacha:
 1480|   117k|            fn $name(self) -> Self {
 1481|   117k|                Self::new(unsafe {
 1482|   117k|                    _mm256_or_si256(
 1483|   117k|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|   117k|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|   117k|                    )
 1486|   117k|                })
 1487|   117k|            }
_RNvXs0_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types5StoreNtB9_14vec256_storageE6unpackCswkaVU3ZAmW_11rand_chacha:
 1402|  9.80k|        unsafe fn unpack(p: vec256_storage) -> Self {
 1403|  9.80k|            Self::new(p.avx)
 1404|  9.80k|        }
_RNvXs2_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E10from_lanesCswkaVU3ZAmW_11rand_chacha:
 1439|  39.2k|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 2]) -> Self {
 1440|  39.2k|            Self::new(unsafe { _mm256_setr_m128i(x[0].x, x[1].x) })
 1441|  39.2k|        }
_RNvXse_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types5StoreNtB9_14vec512_storageE6unpackCswkaVU3ZAmW_11rand_chacha:
 1602|  4.90k|        unsafe fn unpack(p: vec512_storage) -> Self {
 1603|  4.90k|            Self::new([
 1604|  4.90k|                u32x4x2_avx2::unpack(p.avx[0]),
 1605|  4.90k|                u32x4x2_avx2::unpack(p.avx[1]),
 1606|  4.90k|            ])
 1607|  4.90k|        }
_RNvXs10_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes14unsafe_read_leCswkaVU3ZAmW_11rand_chacha:
   79|     40|            unsafe fn unsafe_read_le(input: &[u8]) -> Self {
   80|     40|                assert_eq!(input.len(), 16);
   81|     40|                Self::new(_mm_loadu_si128(input.as_ptr() as *const _))
   82|     40|            }
_RNvXsl_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE7extractCswkaVU3ZAmW_11rand_chacha:
  519|  19.6k|    fn extract(self, i: u32) -> u32 {
  520|  19.6k|        self.to_lanes()[i as usize]
  521|  19.6k|    }
_RNvMsZ_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIE3newCswkaVU3ZAmW_11rand_chacha:
   64|   274k|            fn new(x: __m128i) -> Self {
   65|   274k|                $vec {
   66|   274k|                    x,
   67|   274k|                    s3: PhantomData,
   68|   274k|                    s4: PhantomData,
   69|   274k|                    ni: PhantomData,
   70|   274k|                }
   71|   274k|            }
_RNvXsX_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types5StoreNtB7_14vec128_storageE6unpackCswkaVU3ZAmW_11rand_chacha:
   52|  44.1k|            unsafe fn unpack(x: vec128_storage) -> Self {
   53|  44.1k|                Self::new(x.sse2)
   54|  44.1k|            }
_RNvXs6_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E10from_lanesCswkaVU3ZAmW_11rand_chacha:
  331|  4.90k|    fn from_lanes(xs: [u32; 4]) -> Self {
  332|  4.90k|        unsafe {
  333|  4.90k|            let mut x = _mm_cvtsi64_si128((xs[0] as u64 | ((xs[1] as u64) << 32)) as i64);
  334|  4.90k|            x = _mm_insert_epi64(x, (xs[2] as u64 | ((xs[3] as u64) << 32)) as i64, 1);
  335|  4.90k|            Self::new(x)
  336|  4.90k|        }
  337|  4.90k|    }
_RNvXsl_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE6insertCswkaVU3ZAmW_11rand_chacha:
  523|  68.6k|    fn insert(self, v: u32, i: u32) -> Self {
  524|  68.6k|        Self::new(unsafe {
  525|  68.6k|            match i {
  526|  34.3k|                0 => _mm_insert_epi32(self.x, v as i32, 0),
  527|  34.3k|                1 => _mm_insert_epi32(self.x, v as i32, 1),
  528|      0|                2 => _mm_insert_epi32(self.x, v as i32, 2),
  529|      0|                3 => _mm_insert_epi32(self.x, v as i32, 3),
  530|      0|                _ => unreachable!(),
  531|       |            }
  532|       |        })
  533|  68.6k|    }
_RNvXsY_NtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse2NtB7_14vec128_storageINtNtCs9nhK3FOW46N_4core7convert4FromINtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEE4fromCswkaVU3ZAmW_11rand_chacha:
   58|  4.94k|            fn from(x: $vec<S3, S4, NI>) -> Self {
   59|  4.94k|                vec128_storage { sse2: x.x }
   60|  4.94k|            }
_RNvXsj_NtNtNtCsf8HyAzZvOrI_10ppv_lite866x86_644sse24avx2NtB9_14vec512_storageINtNtCs9nhK3FOW46N_4core7convert4FromINtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EE4fromCswkaVU3ZAmW_11rand_chacha:
 1683|  4.90k|        fn from(x: u32x4x4_avx2<NI>) -> Self {
 1684|  4.90k|            Self {
 1685|  4.90k|                avx: [
 1686|  4.90k|                    vec256_storage { avx: x.0[0].x },
 1687|  4.90k|                    vec256_storage { avx: x.0[1].x },
 1688|  4.90k|                ],
 1689|  4.90k|            }
 1690|  4.90k|        }

_RINvXs2_NtNtCs6voGXdKRTOy_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionoE6sampleNtNtNtBa_4rngs6thread9ThreadRngECshSv3hUzq9FP_9spargebra:
   51|  78.4k|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u128 {
   52|  78.4k|        // Use LE; we explicitly generate one value before the next.
   53|  78.4k|        let x = u128::from(rng.next_u64());
   54|  78.4k|        let y = u128::from(rng.next_u64());
   55|  78.4k|        (y << 64) | x
   56|  78.4k|    }

_RINvCs6voGXdKRTOy_4rand6randomoECshSv3hUzq9FP_9spargebra:
  183|  78.4k|pub fn random<T>() -> T
  184|  78.4k|where Standard: Distribution<T> {
  185|  78.4k|    thread_rng().gen()
  186|  78.4k|}

_RINvYNtNtNtCs6voGXdKRTOy_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genoECshSv3hUzq9FP_9spargebra:
   93|  78.4k|    fn gen<T>(&mut self) -> T
   94|  78.4k|    where Standard: Distribution<T> {
   95|  78.4k|        Standard.sample(self)
   96|  78.4k|    }

_RNvXs_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB4_12ReseedingRngNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngENtB23_7RngCore8next_u64CshSv3hUzq9FP_9spargebra:
  124|   156k|    fn next_u64(&mut self) -> u64 {
  125|   156k|        self.0.next_u64()
  126|   156k|    }
_RNvNtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding4fork21register_fork_handler:
  317|      1|    pub fn register_fork_handler() {
  318|      1|        static REGISTER: Once = Once::new();
  319|      1|        REGISTER.call_once(|| {
  320|       |            // Bump the counter before and after forking (see #1169):
  321|       |            let ret = unsafe { libc::pthread_atfork(
  322|       |                Some(fork_handler),
  323|       |                Some(fork_handler),
  324|       |                Some(fork_handler),
  325|       |            ) };
  326|       |            if ret != 0 {
  327|       |                panic!("libc::pthread_atfork failed with code {}", ret);
  328|       |            }
  329|      1|        });
  330|      1|    }
_RNCNvMs3_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB7_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE6reseed0Bd_:
  220|     19|        R::from_rng(&mut self.reseeder).map(|result| {
  221|     19|            self.bytes_until_reseed = self.threshold;
  222|     19|            self.inner = result
  223|     19|        })
_RNvXs2_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngENtNtB25_5block12BlockRngCore8generateBb_:
  173|  4.90k|    fn generate(&mut self, results: &mut Self::Results) {
  174|  4.90k|        let global_fork_counter = fork::get_fork_counter();
  175|  4.90k|        if self.bytes_until_reseed <= 0 || self.is_forked(global_fork_counter) {
  176|       |            // We get better performance by not calling only `reseed` here
  177|       |            // and continuing with the rest of the function, but by directly
  178|       |            // returning from a non-inlined function.
  179|     19|            return self.reseed_and_generate(results, global_fork_counter);
  180|  4.88k|        }
  181|  4.88k|        let num_bytes = results.as_ref().len() * size_of::<Self::Item>();
  182|  4.88k|        self.bytes_until_reseed -= num_bytes as i64;
  183|  4.88k|        self.inner.generate(results);
  184|  4.90k|    }
_RNvMs3_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE6reseedBb_:
  219|     19|    fn reseed(&mut self) -> Result<(), Error> {
  220|     19|        R::from_rng(&mut self.reseeder).map(|result| {
  221|       |            self.bytes_until_reseed = self.threshold;
  222|       |            self.inner = result
  223|     19|        })
  224|     19|    }
_RNvMs3_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE3newBb_:
  193|      1|    fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  194|      1|        use ::core::i64::MAX;
  195|      1|        fork::register_fork_handler();
  196|       |
  197|       |        // Because generating more values than `i64::MAX` takes centuries on
  198|       |        // current hardware, we just clamp to that value.
  199|       |        // Also we set a threshold of 0, which indicates no limit, to that
  200|       |        // value.
  201|      1|        let threshold = if threshold == 0 {
  202|      0|            MAX
  203|      1|        } else if threshold <= MAX as u64 {
  204|      1|            threshold as i64
  205|       |        } else {
  206|      0|            MAX
  207|       |        };
  208|       |
  209|      1|        ReseedingCore {
  210|      1|            inner: rng,
  211|      1|            reseeder,
  212|      1|            threshold: threshold as i64,
  213|      1|            bytes_until_reseed: threshold as i64,
  214|      1|            fork_counter: 0,
  215|      1|        }
  216|      1|    }
_RNvMNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB2_12ReseedingRngNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE3newB8_:
  101|      1|    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  102|      1|        ReseedingRng(BlockRng::new(ReseedingCore::new(rng, threshold, reseeder)))
  103|      1|    }
_RNvNtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding4fork16get_fork_counter:
  307|  4.90k|    pub fn get_fork_counter() -> usize {
  308|  4.90k|        RESEEDING_RNG_FORK_COUNTER.load(Ordering::Relaxed)
  309|  4.90k|    }
_RNCNvNtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding4fork21register_fork_handler0Bb_:
  319|      1|        REGISTER.call_once(|| {
  320|      1|            // Bump the counter before and after forking (see #1169):
  321|      1|            let ret = unsafe { libc::pthread_atfork(
  322|      1|                Some(fork_handler),
  323|      1|                Some(fork_handler),
  324|      1|                Some(fork_handler),
  325|      1|            ) };
  326|      1|            if ret != 0 {
  327|      0|                panic!("libc::pthread_atfork failed with code {}", ret);
  328|      1|            }
  329|      1|        });
_RNvMs3_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE9is_forkedBb_:
  226|  4.90k|    fn is_forked(&self, global_fork_counter: usize) -> bool {
  227|  4.90k|        // In theory, on 32-bit platforms, it is possible for
  228|  4.90k|        // `global_fork_counter` to wrap around after ~4e9 forks.
  229|  4.90k|        //
  230|  4.90k|        // This check will detect a fork in the normal case where
  231|  4.90k|        // `fork_counter < global_fork_counter`, and also when the difference
  232|  4.90k|        // between both is greater than `isize::MAX` (wrapped around).
  233|  4.90k|        //
  234|  4.90k|        // It will still fail to detect a fork if there have been more than
  235|  4.90k|        // `isize::MAX` forks, without any reseed in between. Seems unlikely
  236|  4.90k|        // enough.
  237|  4.90k|        (self.fork_counter.wrapping_sub(global_fork_counter) as isize) < 0
  238|  4.90k|    }
_RNvMs3_NtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core2os5OsRngE19reseed_and_generateBb_:
  241|     19|    fn reseed_and_generate(
  242|     19|        &mut self, results: &mut <Self as BlockRngCore>::Results, global_fork_counter: usize,
  243|     19|    ) {
  244|     19|        #![allow(clippy::if_same_then_else)] // false positive
  245|     19|        if self.is_forked(global_fork_counter) {
  246|      0|            info!("Fork detected, reseeding RNG");
  247|     19|        } else {
  248|     19|            trace!("Reseeding RNG (periodic reseed)");
  249|     19|        }
  250|       |
  251|     19|        let num_bytes = results.as_ref().len() * size_of::<<R as BlockRngCore>::Item>();
  252|       |
  253|     19|        if let Err(e) = self.reseed() {
  254|      0|            warn!("Reseeding RNG failed: {}", e);
  255|      0|            let _ = e;
  256|     19|        }
  257|     19|        self.fork_counter = global_fork_counter;
  258|     19|
  259|     19|        self.bytes_until_reseed = self.threshold - num_bytes as i64;
  260|     19|        self.inner.generate(results);
  261|     19|    }

_RNvXs_NtNtCs6voGXdKRTOy_4rand4rngs6threadNtB4_9ThreadRngNtCsfg7E1GDOqBC_9rand_core7RngCore8next_u64:
  109|   156k|    fn next_u64(&mut self) -> u64 {
  110|   156k|        // SAFETY: We must make sure to stop using `rng` before anyone else
  111|   156k|        // creates another mutable reference
  112|   156k|        let rng = unsafe { &mut *self.rng.get() };
  113|   156k|        rng.next_u64()
  114|   156k|    }
_RNCNvNtNtCs6voGXdKRTOy_4rand4rngs6thread10thread_rng0B7_:
   89|  78.4k|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
_RNvNtNtCs6voGXdKRTOy_4rand4rngs6thread10thread_rng:
   88|  78.4k|pub fn thread_rng() -> ThreadRng {
   89|  78.4k|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
   90|  78.4k|    ThreadRng { rng }
   91|  78.4k|}
_RNCNvNvNtNtCs6voGXdKRTOy_4rand4rngs6thread14THREAD_RNG_KEY7___getit0B9_:
   67|      1|thread_local!(
   68|      1|    // We require Rc<..> to avoid premature freeing when thread_rng is used
   69|      1|    // within thread-local destructors. See #968.
   70|      1|    static THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>> = {
   71|      1|        let r = Core::from_rng(OsRng).unwrap_or_else(|err|
   72|      1|                panic!("could not initialize thread_rng: {}", err));
   73|      1|        let rng = ReseedingRng::new(r,
   74|      1|                                    THREAD_RNG_RESEED_THRESHOLD,
   75|      1|                                    OsRng);
   76|      1|        Rc::new(UnsafeCell::new(rng))
   77|      1|    }
   78|      1|);

_RNvXsm_NtCswkaVU3ZAmW_11rand_chacha6chachaNtB5_12ChaCha12CoreNtNtCsfg7E1GDOqBC_9rand_core5block12BlockRngCore8generateCs6voGXdKRTOy_4rand:
   89|  4.90k|            fn generate(&mut self, r: &mut Self::Results) {
   90|  4.90k|                // Fill slice of words by writing to equivalent slice of bytes, then fixing endianness.
   91|  4.90k|                self.state.refill4($rounds, unsafe {
   92|  4.90k|                    &mut *(&mut *r as *mut Array64<u32> as *mut [u8; 256])
   93|  4.90k|                });
   94|   313k|                for x in r.as_mut() {
   95|   313k|                    *x = x.to_le();
   96|   313k|                }
   97|  4.90k|            }
_RNvXsn_NtCswkaVU3ZAmW_11rand_chacha6chachaNtB5_12ChaCha12CoreNtCsfg7E1GDOqBC_9rand_core11SeedableRng9from_seedCs6voGXdKRTOy_4rand:
  103|     20|            fn from_seed(seed: Self::Seed) -> Self {
  104|     20|                $ChaChaXCore { state: ChaCha::new(&seed, &[0u8; 8]) }
  105|     20|            }
_RNvXs_NtCswkaVU3ZAmW_11rand_chacha6chachaINtB4_7Array64mEINtNtCs9nhK3FOW46N_4core7convert5AsRefSmE6as_refB6_:
   46|   323k|    fn as_ref(&self) -> &[T] {
   47|   323k|        &self.0
   48|   323k|    }
_RNvXs0_NtCswkaVU3ZAmW_11rand_chacha6chachaINtB5_7Array64mEINtNtCs9nhK3FOW46N_4core7convert5AsMutSmE6as_mutB7_:
   51|  4.90k|    fn as_mut(&mut self) -> &mut [T] {
   52|  4.90k|        &mut self.0
   53|  4.90k|    }
_RNvXNtCswkaVU3ZAmW_11rand_chacha6chachaINtB2_7Array64mENtNtCs9nhK3FOW46N_4core7default7Default7defaultB4_:
   32|      1|    fn default() -> Self {
   33|      1|        Self([
   34|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   35|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   36|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   37|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   38|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   39|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   40|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   41|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   42|      1|        ])
   43|      1|    }

_RNvMNtCswkaVU3ZAmW_11rand_chacha4gutsNtB2_6ChaCha7refill4:
   84|  4.90k|    pub fn refill4(&mut self, drounds: u32, out: &mut [u8; BUFSZ]) {
   85|  4.90k|        refill_wide(self, drounds, out)
   86|  4.90k|    }
_RNvMNtCswkaVU3ZAmW_11rand_chacha4gutsNtB2_6ChaCha3new:
   72|     20|    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {
   73|     20|        init_chacha(key, nonce)
   74|     20|    }
_RINvNvNtCswkaVU3ZAmW_11rand_chacha4guts11init_chacha7fn_implINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6410SseMachineNtBZ_5YesS3NtBZ_5YesS4NtBZ_4NoNIEEB6_:
  235|     20|    fn init_chacha(key: &[u8; 32], nonce: &[u8]) -> ChaCha {
  236|     20|        let ctr_nonce = [
  237|       |            0,
  238|     20|            if nonce.len() == 12 {
  239|      0|                read_u32le(&nonce[0..4])
  240|       |            } else {
  241|     20|                0
  242|       |            },
  243|     20|            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),
  244|     20|            read_u32le(&nonce[nonce.len() - 4..]),
  245|     20|        ];
  246|     20|        let key0: Mach::u32x4 = m.read_le(&key[..16]);
  247|     20|        let key1: Mach::u32x4 = m.read_le(&key[16..]);
  248|     20|        ChaCha {
  249|     20|            b: key0.into(),
  250|     20|            c: key1.into(),
  251|     20|            d: ctr_nonce.into(),
  252|     20|        }
_RINvNtCswkaVU3ZAmW_11rand_chacha4guts13undiagonalizeINtNtCsf8HyAzZvOrI_10ppv_lite864soft2x2INtNtNtNtBT_6x86_644sse24avx212u32x4x2_avx2NtB1y_4NoNIENtB1w_2G0EEB4_:
   63|  29.4k|pub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   64|  29.4k|    x.b = x.b.shuffle_lane_words1230();
   65|  29.4k|    x.c = x.c.shuffle_lane_words2301();
   66|  29.4k|    x.d = x.d.shuffle_lane_words3012();
   67|  29.4k|    x
   68|  29.4k|}
_RINvNtCswkaVU3ZAmW_11rand_chacha4guts11diagonalizeINtNtCsf8HyAzZvOrI_10ppv_lite864soft2x2INtNtNtNtBR_6x86_644sse24avx212u32x4x2_avx2NtB1w_4NoNIENtB1u_2G0EEB4_:
   56|  29.4k|pub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   57|  29.4k|    x.b = x.b.shuffle_lane_words3012();
   58|  29.4k|    x.c = x.c.shuffle_lane_words2301();
   59|  29.4k|    x.d = x.d.shuffle_lane_words1230();
   60|  29.4k|    x
   61|  29.4k|}
_RINvNtCswkaVU3ZAmW_11rand_chacha4guts5roundINtNtCsf8HyAzZvOrI_10ppv_lite864soft2x2INtNtNtNtBK_6x86_644sse24avx212u32x4x2_avx2NtB1p_4NoNIENtB1n_2G0EEB4_:
   43|  58.8k|pub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V> {
   44|  58.8k|    x.a += x.b;
   45|  58.8k|    x.d = (x.d ^ x.a).rotate_each_word_right16();
   46|  58.8k|    x.c += x.d;
   47|  58.8k|    x.b = (x.b ^ x.c).rotate_each_word_right20();
   48|  58.8k|    x.a += x.b;
   49|  58.8k|    x.d = (x.d ^ x.a).rotate_each_word_right24();
   50|  58.8k|    x.c += x.d;
   51|  58.8k|    x.b = (x.b ^ x.c).rotate_each_word_right25();
   52|  58.8k|    x
   53|  58.8k|}
_RINvNtCswkaVU3ZAmW_11rand_chacha4guts16refill_wide_implINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtBU_4NoNIEEB4_:
  116|  4.90k|fn refill_wide_impl<Mach: Machine>(
  117|  4.90k|    m: Mach, state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ],
  118|  4.90k|) {
  119|  4.90k|    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);
  120|  4.90k|    let mut pos = state.pos64(m);
  121|  4.90k|    let d0: Mach::u32x4 = m.unpack(state.d);
  122|  4.90k|    pos = pos.wrapping_add(1);
  123|  4.90k|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  124|  4.90k|    pos = pos.wrapping_add(1);
  125|  4.90k|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  126|  4.90k|    pos = pos.wrapping_add(1);
  127|  4.90k|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  128|  4.90k|
  129|  4.90k|    let b = m.unpack(state.b);
  130|  4.90k|    let c = m.unpack(state.c);
  131|  4.90k|    let mut x = State {
  132|  4.90k|        a: Mach::u32x4x4::from_lanes([k, k, k, k]),
  133|  4.90k|        b: Mach::u32x4x4::from_lanes([b, b, b, b]),
  134|  4.90k|        c: Mach::u32x4x4::from_lanes([c, c, c, c]),
  135|  4.90k|        d: m.unpack(Mach::u32x4x4::from_lanes([d0, d1, d2, d3]).into()),
  136|  4.90k|    };
  137|  29.4k|    for _ in 0..drounds {
  138|  29.4k|        x = round(x);
  139|  29.4k|        x = undiagonalize(round(diagonalize(x)));
  140|  29.4k|    }
  141|  4.90k|    let mut pos = state.pos64(m);
  142|  4.90k|    let d0: Mach::u32x4 = m.unpack(state.d);
  143|  4.90k|    pos = pos.wrapping_add(1);
  144|  4.90k|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  145|  4.90k|    pos = pos.wrapping_add(1);
  146|  4.90k|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  147|  4.90k|    pos = pos.wrapping_add(1);
  148|  4.90k|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  149|  4.90k|    pos = pos.wrapping_add(1);
  150|  4.90k|    let d4 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  151|  4.90k|
  152|  4.90k|    let (a, b, c, d) = (
  153|  4.90k|        x.a.to_lanes(),
  154|  4.90k|        x.b.to_lanes(),
  155|  4.90k|        x.c.to_lanes(),
  156|  4.90k|        x.d.to_lanes(),
  157|  4.90k|    );
  158|  4.90k|    let sb = m.unpack(state.b);
  159|  4.90k|    let sc = m.unpack(state.c);
  160|  4.90k|    let sd = [m.unpack(state.d), d1, d2, d3];
  161|  4.90k|    state.d = d4.into();
  162|  4.90k|    let mut words = out.chunks_exact_mut(16);
  163|  19.6k|    for ((((&a, &b), &c), &d), &sd) in a.iter().zip(&b).zip(&c).zip(&d).zip(&sd) {
  164|  19.6k|        (a + k).write_le(words.next().unwrap());
  165|  19.6k|        (b + sb).write_le(words.next().unwrap());
  166|  19.6k|        (c + sc).write_le(words.next().unwrap());
  167|  19.6k|        (d + sd).write_le(words.next().unwrap());
  168|  19.6k|    }
  169|  4.90k|}
_RNvNtCswkaVU3ZAmW_11rand_chacha4guts10read_u32le:
  229|     40|fn read_u32le(xs: &[u8]) -> u32 {
  230|     40|    assert_eq!(xs.len(), 4);
  231|     40|    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)
  232|     40|}
_RINvMNtCswkaVU3ZAmW_11rand_chacha4gutsNtB3_6ChaCha5pos64INtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtBV_4NoNIEEB5_:
   77|  9.80k|    fn pos64<M: Machine>(&self, m: M) -> u64 {
   78|  9.80k|        let d: M::u32x4 = m.unpack(self.d);
   79|  9.80k|        ((d.extract(1) as u64) << 32) | d.extract(0) as u64
   80|  9.80k|    }
_RINvNvNtCswkaVU3ZAmW_11rand_chacha4guts11refill_wide7fn_implINtNtCsf8HyAzZvOrI_10ppv_lite866x86_6411Avx2MachineNtBZ_4NoNIEEB6_:
  172|  4.90k|    fn refill_wide(state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ]) {
  173|  4.90k|        refill_wide_impl(m, state, drounds, out);
  174|  4.90k|    }

_RNCNvXs0_NtCsfg7E1GDOqBC_9rand_core5blockINtB7_8BlockRngINtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtB9_2os5OsRngEENtB9_7RngCore8next_u640CshSv3hUzq9FP_9spargebra:
  198|   156k|        let read_u64 = |results: &[u32], index| {
  199|   156k|            let data = &results[index..=index + 1];
  200|   156k|            u64::from(data[1]) << 32 | u64::from(data[0])
  201|   156k|        };
_RNvXs0_NtCsfg7E1GDOqBC_9rand_core5blockINtB5_8BlockRngINtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtB7_2os5OsRngEENtB7_7RngCore8next_u64CshSv3hUzq9FP_9spargebra:
  197|   156k|    fn next_u64(&mut self) -> u64 {
  198|   156k|        let read_u64 = |results: &[u32], index| {
  199|       |            let data = &results[index..=index + 1];
  200|       |            u64::from(data[1]) << 32 | u64::from(data[0])
  201|       |        };
  202|       |
  203|   156k|        let len = self.results.as_ref().len();
  204|   156k|
  205|   156k|        let index = self.index;
  206|   156k|        if index < len - 1 {
  207|   151k|            self.index += 2;
  208|   151k|            // Read an u64 from the current index
  209|   151k|            read_u64(self.results.as_ref(), index)
  210|  4.90k|        } else if index >= len {
  211|  4.90k|            self.generate_and_set(2);
  212|  4.90k|            read_u64(self.results.as_ref(), 0)
  213|       |        } else {
  214|      0|            let x = u64::from(self.results.as_ref()[len - 1]);
  215|      0|            self.generate_and_set(1);
  216|      0|            let y = u64::from(self.results.as_ref()[0]);
  217|      0|            (y << 32) | x
  218|       |        }
  219|   156k|    }
_RNvMs_NtCsfg7E1GDOqBC_9rand_core5blockINtB4_8BlockRngINtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE3newBY_:
  145|      1|    pub fn new(core: R) -> BlockRng<R> {
  146|      1|        let results_empty = R::Results::default();
  147|      1|        BlockRng {
  148|      1|            core,
  149|      1|            index: results_empty.as_ref().len(),
  150|      1|            results: results_empty,
  151|      1|        }
  152|      1|    }
_RNvMs_NtCsfg7E1GDOqBC_9rand_core5blockINtB4_8BlockRngINtNtNtNtCs6voGXdKRTOy_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE16generate_and_setBY_:
  174|  4.90k|    pub fn generate_and_set(&mut self, index: usize) {
  175|  4.90k|        assert!(index < self.results.as_ref().len());
  176|  4.90k|        self.core.generate(&mut self.results);
  177|  4.90k|        self.index = index;
  178|  4.90k|    }

_RINvYNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtCsfg7E1GDOqBC_9rand_core11SeedableRng8from_rngQNtNtBU_2os5OsRngECs6voGXdKRTOy_4rand:
  390|     19|    fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
  391|     19|        let mut seed = Self::Seed::default();
  392|     19|        rng.try_fill_bytes(seed.as_mut())?;
  393|     19|        Ok(Self::from_seed(seed))
  394|     19|    }
_RINvYNtNtCswkaVU3ZAmW_11rand_chacha6chacha12ChaCha12CoreNtCsfg7E1GDOqBC_9rand_core11SeedableRng8from_rngNtNtBU_2os5OsRngECs6voGXdKRTOy_4rand:
  390|      1|    fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
  391|      1|        let mut seed = Self::Seed::default();
  392|      1|        rng.try_fill_bytes(seed.as_mut())?;
  393|      1|        Ok(Self::from_seed(seed))
  394|      1|    }
_RNvXs_Csfg7E1GDOqBC_9rand_coreQNtNtB4_2os5OsRngNtB4_7RngCore14try_fill_bytesCs6voGXdKRTOy_4rand:
  441|     19|    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
  442|     19|        (**self).try_fill_bytes(dest)
  443|     19|    }

_RNvXs_NtCsfg7E1GDOqBC_9rand_core2osNtB4_5OsRngNtB6_7RngCore14try_fill_bytes:
   67|     20|    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
   68|     20|        getrandom(dest)?;
   69|     20|        Ok(())
   70|     20|    }

_RNvXsb_NtCsdmAy3pJ2Dco_9siphasher6sip128INtB5_6HasherNtB5_11Sip24RoundsENtNtCs9nhK3FOW46N_4core4hash6Hasher5writeCs2ek33vt1YA5_8oxigraph:
  558|   107k|    fn write(&mut self, msg: &[u8]) {
  559|   107k|        let length = msg.len();
  560|   107k|        self.length += length;
  561|   107k|
  562|   107k|        let mut needed = 0;
  563|   107k|
  564|   107k|        if self.ntail != 0 {
  565|      0|            needed = 8 - self.ntail;
  566|      0|            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);
  567|      0|            if length < needed {
  568|      0|                self.ntail += length;
  569|      0|                return;
  570|      0|            } else {
  571|      0|                self.state.v3 ^= self.tail;
  572|      0|                S::c_rounds(&mut self.state);
  573|      0|                self.state.v0 ^= self.tail;
  574|      0|                self.ntail = 0;
  575|      0|            }
  576|   107k|        }
  577|       |
  578|       |        // Buffered tail is now flushed, process new input.
  579|   107k|        let len = length - needed;
  580|   107k|        let left = len & 0x7;
  581|   107k|
  582|   107k|        let mut i = needed;
  583|   424k|        while i < len - left {
  584|   317k|            let mi = unsafe { load_int_le!(msg, i, u64) };
  585|   317k|
  586|   317k|            self.state.v3 ^= mi;
  587|   317k|            S::c_rounds(&mut self.state);
  588|   317k|            self.state.v0 ^= mi;
  589|   317k|
  590|   317k|            i += 8;
  591|       |        }
  592|       |
  593|   107k|        self.tail = unsafe { u8to64_le(msg, i, left) };
  594|   107k|        self.ntail = left;
  595|   107k|    }
_RNvMs7_NtCsdmAy3pJ2Dco_9siphasher6sip128INtB5_6HasherNtB5_11Sip24RoundsE9finish128Cs2ek33vt1YA5_8oxigraph:
  404|   107k|    pub fn finish128(&self) -> Hash128 {
  405|   107k|        let mut state = self.state;
  406|   107k|
  407|   107k|        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;
  408|   107k|
  409|   107k|        state.v3 ^= b;
  410|   107k|        S::c_rounds(&mut state);
  411|   107k|        state.v0 ^= b;
  412|   107k|
  413|   107k|        state.v2 ^= 0xee;
  414|   107k|        S::d_rounds(&mut state);
  415|   107k|        let h1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
  416|   107k|
  417|   107k|        state.v1 ^= 0xdd;
  418|   107k|        S::d_rounds(&mut state);
  419|   107k|        let h2 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
  420|   107k|
  421|   107k|        Hash128 { h1, h2 }
  422|   107k|    }
_RNvXsf_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11Sip24RoundsNtB5_3Sip8c_roundsCs2ek33vt1YA5_8oxigraph:
  654|   424k|    fn c_rounds(state: &mut State) {
  655|   424k|        compress!(state);
  656|   424k|        compress!(state);
  657|   424k|    }
_RNvXsf_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11Sip24RoundsNtB5_3Sip8d_roundsCs2ek33vt1YA5_8oxigraph:
  660|   215k|    fn d_rounds(state: &mut State) {
  661|   215k|        compress!(state);
  662|   215k|        compress!(state);
  663|   215k|        compress!(state);
  664|   215k|        compress!(state);
  665|   215k|    }
_RNvXsa_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11SipHasher24NtNtCs9nhK3FOW46N_4core4hash6Hasher5writeCs2ek33vt1YA5_8oxigraph:
  501|   107k|    fn write(&mut self, msg: &[u8]) {
  502|   107k|        self.hasher.write(msg)
  503|   107k|    }
_RNvMs4_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11SipHasher2413new_with_keysCs2ek33vt1YA5_8oxigraph:
  286|   107k|    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {
  287|   107k|        SipHasher24 {
  288|   107k|            hasher: Hasher::new_with_keys(key0, key1),
  289|   107k|        }
  290|   107k|    }
_RNvMs4_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11SipHasher243newCs2ek33vt1YA5_8oxigraph:
  280|   107k|    pub fn new() -> SipHasher24 {
  281|   107k|        SipHasher24::new_with_keys(0, 0)
  282|   107k|    }
_RNvXs5_NtCsdmAy3pJ2Dco_9siphasher6sip128NtB5_11SipHasher24NtB5_9Hasher1289finish128Cs2ek33vt1YA5_8oxigraph:
  328|   107k|    fn finish128(&self) -> Hash128 {
  329|   107k|        self.hasher.finish128()
  330|   107k|    }
_RNvNtCsdmAy3pJ2Dco_9siphasher6sip1289u8to64_leCs2ek33vt1YA5_8oxigraph:
  142|   107k|unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {
  143|      0|    debug_assert!(len < 8);
  144|   107k|    let mut i = 0; // current byte index (from LSB) in the output u64
  145|   107k|    let mut out = 0;
  146|   107k|    if i + 3 < len {
  147|   102k|        out = load_int_le!(buf, start + i, u32) as u64;
  148|   102k|        i += 4;
  149|  5.12k|    }
  150|   107k|    if i + 1 < len {
  151|  27.0k|        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);
  152|  27.0k|        i += 2
  153|  80.6k|    }
  154|   107k|    if i < len {
  155|  22.6k|        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);
  156|  22.6k|        i += 1;
  157|  85.0k|    }
  158|   107k|    debug_assert_eq!(i, len);
  159|   107k|    out
  160|   107k|}
_RNvMs6_NtCsdmAy3pJ2Dco_9siphasher6sip128INtB5_6HasherNtB5_11Sip24RoundsE5resetB7_:
  355|   107k|    fn reset(&mut self) {
  356|   107k|        self.length = 0;
  357|   107k|        self.state.v0 = self.k0 ^ 0x736f6d6570736575;
  358|   107k|        self.state.v1 = self.k1 ^ 0x646f72616e646f83;
  359|   107k|        self.state.v2 = self.k0 ^ 0x6c7967656e657261;
  360|   107k|        self.state.v3 = self.k1 ^ 0x7465646279746573;
  361|   107k|        self.ntail = 0;
  362|   107k|    }
_RNvXs_NtCsdmAy3pJ2Dco_9siphasher6sip128oINtNtCs9nhK3FOW46N_4core7convert4FromNtB4_7Hash128E4from:
   39|   107k|    fn from(h: Hash128) -> u128 {
   40|   107k|        (h.h1 as u128) | ((h.h2 as u128) << 64)
   41|   107k|    }
_RNvMs6_NtCsdmAy3pJ2Dco_9siphasher6sip128INtB5_6HasherNtB5_11Sip24RoundsE13new_with_keysB7_:
  335|   107k|    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {
  336|   107k|        let mut state = Hasher {
  337|   107k|            k0: key0,
  338|   107k|            k1: key1,
  339|   107k|            length: 0,
  340|   107k|            state: State {
  341|   107k|                v0: 0,
  342|   107k|                v1: 0xee,
  343|   107k|                v2: 0,
  344|   107k|                v3: 0,
  345|   107k|            },
  346|   107k|            tail: 0,
  347|   107k|            ntail: 0,
  348|   107k|            _marker: PhantomData,
  349|   107k|        };
  350|   107k|        state.reset();
  351|   107k|        state
  352|   107k|    }

_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsY_1__30RECURSIVE_COUNT_ObjectListPath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsg_1__22RECURSIVE_COUNT_Create6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__29RECURSIVE_COUNT_GraphNodePath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__29RECURSIVE_COUNT_IriOrFunction7___getitB5_:
   83|      6|            unsafe fn __getit(
   84|      6|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      6|            ) -> $crate::option::Option<&'static $t> {
   86|      6|                #[thread_local]
   87|      6|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      6|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      6|
   90|      6|                unsafe {
   91|      6|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      6|                    })
  101|      6|                }
  102|      6|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths7_1__32RECURSIVE_COUNT_SolutionModifier7___getitB5_:
   83|  2.31k|            unsafe fn __getit(
   84|  2.31k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  2.31k|            ) -> $crate::option::Option<&'static $t> {
   86|  2.31k|                #[thread_local]
   87|  2.31k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  2.31k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  2.31k|
   90|  2.31k|                unsafe {
   91|  2.31k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  2.31k|                    })
  101|  2.31k|                }
  102|  2.31k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsO_1__30RECURSIVE_COUNT_ExpressionList6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsn_1__22RECURSIVE_COUNT_Modify7___getitB5_:
   83|     10|            unsafe fn __getit(
   84|     10|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     10|            ) -> $crate::option::Option<&'static $t> {
   86|     10|                #[thread_local]
   87|     10|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     10|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     10|
   90|     10|                unsafe {
   91|     10|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     10|                    })
  101|     10|                }
  102|     10|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsq_1__27RECURSIVE_COUNT_GraphRefAll7___getitB5_:
   83|     88|            unsafe fn __getit(
   84|     88|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     88|            ) -> $crate::option::Option<&'static $t> {
   86|     88|                #[thread_local]
   87|     88|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     88|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     88|
   90|     88|                unsafe {
   91|     88|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     88|                    })
  101|     88|                }
  102|     88|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsf_1__20RECURSIVE_COUNT_Drop6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsR_1__20RECURSIVE_COUNT_Verb7___getitB5_:
   83|    180|            unsafe fn __getit(
   84|    180|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    180|            ) -> $crate::option::Option<&'static $t> {
   86|    180|                #[thread_local]
   87|    180|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    180|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    180|
   90|    180|                unsafe {
   91|    180|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    180|                    })
  101|    180|                }
  102|    180|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsX_1__39RECURSIVE_COUNT_PropertyListPathElement6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths14_1__27RECURSIVE_COUNT_PathPrimary6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths6_1__27RECURSIVE_COUNT_WhereClause7___getitB5_:
   83|    452|            unsafe fn __getit(
   84|    452|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    452|            ) -> $crate::option::Option<&'static $t> {
   86|    452|                #[thread_local]
   87|    452|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    452|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    452|
   90|    452|                unsafe {
   91|    452|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    452|                    })
  101|    452|                }
  102|    452|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithst_1__24RECURSIVE_COUNT_QuadData7___getitB5_:
   83|      6|            unsafe fn __getit(
   84|      6|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      6|            ) -> $crate::option::Option<&'static $t> {
   86|      6|                #[thread_local]
   87|      6|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      6|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      6|
   90|      6|                unsafe {
   91|      6|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      6|                    })
  101|      6|                }
  102|      6|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsz_1__38RECURSIVE_COUNT_GraphPatternNotTriples7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__40RECURSIVE_COUNT_GroupOrUnionGraphPattern6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__34RECURSIVE_COUNT_AdditiveExpression7___getitB5_:
   83|  1.75k|            unsafe fn __getit(
   84|  1.75k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.75k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.75k|                #[thread_local]
   87|  1.75k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.75k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.75k|
   90|  1.75k|                unsafe {
   91|  1.75k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.75k|                    })
  101|  1.75k|                }
  102|  1.75k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithse_1__21RECURSIVE_COUNT_Clear6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsW_1__44RECURSIVE_COUNT_PropertyListPathNotEmptyVerb6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsp_1__24RECURSIVE_COUNT_GraphRef7___getitB5_:
   83|    118|            unsafe fn __getit(
   84|    118|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    118|            ) -> $crate::option::Option<&'static $t> {
   86|    118|                #[thread_local]
   87|    118|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    118|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    118|
   90|    118|                unsafe {
   91|    118|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    118|                    })
  101|    118|                }
  102|    118|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths5_1__32RECURSIVE_COUNT_SelectProjection7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithss_1__33RECURSIVE_COUNT_VarOrIriOrLiteral6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__29RECURSIVE_COUNT_IriOrFunction6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths10_1__28RECURSIVE_COUNT_PathSequence7___getitB5_:
   83|    212|            unsafe fn __getit(
   84|    212|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    212|            ) -> $crate::option::Option<&'static $t> {
   86|    212|                #[thread_local]
   87|    212|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    212|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    212|
   90|    212|                unsafe {
   91|    212|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    212|                    })
  101|    212|                }
  102|    212|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsd_1__29RECURSIVE_COUNT_UpdateVariant6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsk_1__26RECURSIVE_COUNT_InsertData7___getitB5_:
   83|      6|            unsafe fn __getit(
   84|      6|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      6|            ) -> $crate::option::Option<&'static $t> {
   86|      6|                #[thread_local]
   87|      6|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      6|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      6|
   90|      6|                unsafe {
   91|      6|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      6|                    })
  101|      6|                }
  102|      6|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsr_1__27RECURSIVE_COUNT_QuadPattern6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__31RECURSIVE_COUNT_PathAlternative7___getitB5_:
   83|    210|            unsafe fn __getit(
   84|    210|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    210|            ) -> $crate::option::Option<&'static $t> {
   86|    210|                #[thread_local]
   87|    210|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    210|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    210|
   90|    210|                unsafe {
   91|    210|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    210|                    })
  101|    210|                }
  102|    210|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsv_1__33RECURSIVE_COUNT_GroupGraphPattern7___getitB5_:
   83|    924|            unsafe fn __getit(
   84|    924|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    924|            ) -> $crate::option::Option<&'static $t> {
   86|    924|                #[thread_local]
   87|    924|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    924|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    924|
   90|    924|                unsafe {
   91|    924|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    924|                    })
  101|    924|                }
  102|    924|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__36RECURSIVE_COUNT_BrackettedExpression7___getitB5_:
   83|  1.73k|            unsafe fn __getit(
   84|  1.73k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.73k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.73k|                #[thread_local]
   87|  1.73k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.73k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.73k|
   90|  1.73k|                unsafe {
   91|  1.73k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.73k|                    })
  101|  1.73k|                }
  102|  1.73k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__30RECURSIVE_COUNT_CollectionPath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsg_1__22RECURSIVE_COUNT_Create7___getitB5_:
   83|      2|            unsafe fn __getit(
   84|      2|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      2|            ) -> $crate::option::Option<&'static $t> {
   86|      2|                #[thread_local]
   87|      2|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      2|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      2|
   90|      2|                unsafe {
   91|      2|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      2|                    })
  101|      2|                }
  102|      2|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__33RECURSIVE_COUNT_PrimaryExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsY_1__30RECURSIVE_COUNT_ObjectListPath7___getitB5_:
   83|  1.95k|            unsafe fn __getit(
   84|  1.95k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.95k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.95k|                #[thread_local]
   87|  1.95k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.95k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.95k|
   90|  1.95k|                unsafe {
   91|  1.95k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.95k|                    })
  101|  1.95k|                }
  102|  1.95k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsO_1__30RECURSIVE_COUNT_ExpressionList7___getitB5_:
   83|    150|            unsafe fn __getit(
   84|    150|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    150|            ) -> $crate::option::Option<&'static $t> {
   86|    150|                #[thread_local]
   87|    150|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    150|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    150|
   90|    150|                unsafe {
   91|    150|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    150|                    })
  101|    150|                }
  102|    150|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__31RECURSIVE_COUNT_UnaryExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__40RECURSIVE_COUNT_MultiplicativeExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths14_1__27RECURSIVE_COUNT_PathPrimary7___getitB5_:
   83|    664|            unsafe fn __getit(
   84|    664|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    664|            ) -> $crate::option::Option<&'static $t> {
   86|    664|                #[thread_local]
   87|    664|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    664|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    664|
   90|    664|                unsafe {
   91|    664|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    664|                    })
  101|    664|                }
  102|    664|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsf_1__20RECURSIVE_COUNT_Drop7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsk_1__26RECURSIVE_COUNT_InsertData6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsG_1__32RECURSIVE_COUNT_InlineDataOneVar7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsX_1__39RECURSIVE_COUNT_PropertyListPathElement7___getitB5_:
   83|      6|            unsafe fn __getit(
   84|      6|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      6|            ) -> $crate::option::Option<&'static $t> {
   86|      6|                #[thread_local]
   87|      6|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      6|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      6|
   90|      6|                unsafe {
   91|      6|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      6|                    })
  101|      6|                }
  102|      6|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsT_1__38RECURSIVE_COUNT_TriplesSameSubjectPath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__36RECURSIVE_COUNT_BrackettedExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__27RECURSIVE_COUNT_BuiltInCall6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__40RECURSIVE_COUNT_GroupOrUnionGraphPattern7___getitB5_:
   83|     10|            unsafe fn __getit(
   84|     10|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     10|            ) -> $crate::option::Option<&'static $t> {
   86|     10|                #[thread_local]
   87|     10|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     10|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     10|
   90|     10|                unsafe {
   91|     10|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     10|                    })
  101|     10|                }
  102|     10|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__41RECURSIVE_COUNT_BlankNodePropertyListPath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths2_1__28RECURSIVE_COUNT_SelectClause6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths3_1__28RECURSIVE_COUNT_SelectOption7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithse_1__21RECURSIVE_COUNT_Clear7___getitB5_:
   83|     70|            unsafe fn __getit(
   84|     70|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     70|            ) -> $crate::option::Option<&'static $t> {
   86|     70|                #[thread_local]
   87|     70|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     70|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     70|
   90|     70|                unsafe {
   91|     70|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     70|                    })
  101|     70|                }
  102|     70|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths16_1__36RECURSIVE_COUNT_PathOneInPropertySet7___getitB5_:
   83|     80|            unsafe fn __getit(
   84|     80|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     80|            ) -> $crate::option::Option<&'static $t> {
   86|     80|                #[thread_local]
   87|     80|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     80|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     80|
   90|     80|                unsafe {
   91|     80|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     80|                    })
  101|     80|                }
  102|     80|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithss_1__33RECURSIVE_COUNT_VarOrIriOrLiteral7___getitB5_:
   83|    372|            unsafe fn __getit(
   84|    372|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    372|            ) -> $crate::option::Option<&'static $t> {
   86|    372|                #[thread_local]
   87|    372|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    372|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    372|
   90|    372|                unsafe {
   91|    372|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    372|                    })
  101|    372|                }
  102|    372|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__24RECURSIVE_COUNT_VarOrIri7___getitB5_:
   83|    328|            unsafe fn __getit(
   84|    328|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    328|            ) -> $crate::option::Option<&'static $t> {
   86|    328|                #[thread_local]
   87|    328|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    328|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    328|
   90|    328|                unsafe {
   91|    328|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    328|                    })
  101|    328|                }
  102|    328|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsm_1__27RECURSIVE_COUNT_DeleteWhere6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsi_1__20RECURSIVE_COUNT_Move6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsU_1__32RECURSIVE_COUNT_PropertyListPath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1_1__25RECURSIVE_COUNT_SubSelect6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__40RECURSIVE_COUNT_ConditionalAndExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsG_1__32RECURSIVE_COUNT_InlineDataOneVar6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsr_1__27RECURSIVE_COUNT_QuadPattern7___getitB5_:
   83|    284|            unsafe fn __getit(
   84|    284|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    284|            ) -> $crate::option::Option<&'static $t> {
   86|    284|                #[thread_local]
   87|    284|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    284|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    284|
   90|    284|                unsafe {
   91|    284|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    284|                    })
  101|    284|                }
  102|    284|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths16_1__36RECURSIVE_COUNT_PathOneInPropertySet6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsb_1__28RECURSIVE_COUNT_ValuesClause7___getitB5_:
   83|  2.33k|            unsafe fn __getit(
   84|  2.33k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  2.33k|            ) -> $crate::option::Option<&'static $t> {
   86|  2.33k|                #[thread_local]
   87|  2.33k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  2.33k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  2.33k|
   90|  2.33k|                unsafe {
   91|  2.33k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  2.33k|                    })
  101|  2.33k|                }
  102|  2.33k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__30RECURSIVE_COUNT_CollectionPath7___getitB5_:
   83|    122|            unsafe fn __getit(
   84|    122|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    122|            ) -> $crate::option::Option<&'static $t> {
   86|    122|                #[thread_local]
   87|    122|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    122|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    122|
   90|    122|                unsafe {
   91|    122|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    122|                    })
  101|    122|                }
  102|    122|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__25RECURSIVE_COUNT_VarOrTerm7___getitB5_:
   83|  2.39k|            unsafe fn __getit(
   84|  2.39k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  2.39k|            ) -> $crate::option::Option<&'static $t> {
   86|  2.39k|                #[thread_local]
   87|  2.39k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  2.39k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  2.39k|
   90|  2.39k|                unsafe {
   91|  2.39k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  2.39k|                    })
  101|  2.39k|                }
  102|  2.39k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__25RECURSIVE_COUNT_GraphTerm6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__31RECURSIVE_COUNT_UnaryExpression7___getitB5_:
   83|  1.80k|            unsafe fn __getit(
   84|  1.80k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.80k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.80k|                #[thread_local]
   87|  1.80k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.80k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.80k|
   90|  1.80k|                unsafe {
   91|  1.80k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.80k|                    })
  101|  1.80k|                }
  102|  1.80k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithst_1__24RECURSIVE_COUNT_QuadData6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__40RECURSIVE_COUNT_MultiplicativeExpression7___getitB5_:
   83|  1.73k|            unsafe fn __getit(
   84|  1.73k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.73k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.73k|                #[thread_local]
   87|  1.73k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.73k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.73k|
   90|  1.73k|                unsafe {
   91|  1.73k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.73k|                    })
  101|  1.73k|                }
  102|  1.73k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithso_1__30RECURSIVE_COUNT_GraphOrDefault6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsz_1__38RECURSIVE_COUNT_GraphPatternNotTriples6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsa_1__28RECURSIVE_COUNT_HavingClause6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths15_1__38RECURSIVE_COUNT_PathNegatedPropertySet7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsT_1__38RECURSIVE_COUNT_TriplesSameSubjectPath7___getitB5_:
   83|      8|            unsafe fn __getit(
   84|      8|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      8|            ) -> $crate::option::Option<&'static $t> {
   86|      8|                #[thread_local]
   87|      8|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      8|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      8|
   90|      8|                unsafe {
   91|      8|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      8|                    })
  101|      8|                }
  102|      8|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__27RECURSIVE_COUNT_BuiltInCall7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsV_1__40RECURSIVE_COUNT_PropertyListPathNotEmpty6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths2_1__28RECURSIVE_COUNT_SelectClause7___getitB5_:
   83|     18|            unsafe fn __getit(
   84|     18|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     18|            ) -> $crate::option::Option<&'static $t> {
   86|     18|                #[thread_local]
   87|     18|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     18|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     18|
   90|     18|                unsafe {
   91|     18|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     18|                    })
  101|     18|                }
  102|     18|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths10_1__28RECURSIVE_COUNT_PathSequence6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsw_1__36RECURSIVE_COUNT_GroupGraphPatternSub6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__29RECURSIVE_COUNT_GraphNodePath7___getitB5_:
   83|  2.09k|            unsafe fn __getit(
   84|  2.09k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  2.09k|            ) -> $crate::option::Option<&'static $t> {
   86|  2.09k|                #[thread_local]
   87|  2.09k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  2.09k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  2.09k|
   90|  2.09k|                unsafe {
   91|  2.09k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  2.09k|                    })
  101|  2.09k|                }
  102|  2.09k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsi_1__20RECURSIVE_COUNT_Move7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsm_1__27RECURSIVE_COUNT_DeleteWhere7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsv_1__33RECURSIVE_COUNT_GroupGraphPattern6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsU_1__32RECURSIVE_COUNT_PropertyListPath7___getitB5_:
   83|    948|            unsafe fn __getit(
   84|    948|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    948|            ) -> $crate::option::Option<&'static $t> {
   86|    948|                #[thread_local]
   87|    948|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    948|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    948|
   90|    948|                unsafe {
   91|    948|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    948|                    })
  101|    948|                }
  102|    948|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__40RECURSIVE_COUNT_ConditionalAndExpression7___getitB5_:
   83|  1.59k|            unsafe fn __getit(
   84|  1.59k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.59k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.59k|                #[thread_local]
   87|  1.59k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.59k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.59k|
   90|  1.59k|                unsafe {
   91|  1.59k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.59k|                    })
  101|  1.59k|                }
  102|  1.59k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths13_1__23RECURSIVE_COUNT_PathMod6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsH_1__30RECURSIVE_COUNT_DataBlockValue7___getitB5_:
   83|  3.81k|            unsafe fn __getit(
   84|  3.81k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  3.81k|            ) -> $crate::option::Option<&'static $t> {
   86|  3.81k|                #[thread_local]
   87|  3.81k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  3.81k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  3.81k|
   90|  3.81k|                unsafe {
   91|  3.81k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  3.81k|                    })
  101|  3.81k|                }
  102|  3.81k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__39RECURSIVE_COUNT_ConditionalOrExpression7___getitB5_:
   83|  1.60k|            unsafe fn __getit(
   84|  1.60k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.60k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.60k|                #[thread_local]
   87|  1.60k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.60k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.60k|
   90|  1.60k|                unsafe {
   91|  1.60k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.60k|                    })
  101|  1.60k|                }
  102|  1.60k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__36RECURSIVE_COUNT_RelationalExpression7___getitB5_:
   83|  1.60k|            unsafe fn __getit(
   84|  1.60k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.60k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.60k|                #[thread_local]
   87|  1.60k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.60k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.60k|
   90|  1.60k|                unsafe {
   91|  1.60k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.60k|                    })
  101|  1.60k|                }
  102|  1.60k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsW_1__44RECURSIVE_COUNT_PropertyListPathNotEmptyVerb7___getitB5_:
   83|     82|            unsafe fn __getit(
   84|     82|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     82|            ) -> $crate::option::Option<&'static $t> {
   86|     82|                #[thread_local]
   87|     82|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     82|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     82|
   90|     82|                unsafe {
   91|     82|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     82|                    })
  101|     82|                }
  102|     82|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsL_1__26RECURSIVE_COUNT_Constraint6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsy_1__28RECURSIVE_COUNT_TriplesBlock6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__25RECURSIVE_COUNT_GraphTerm7___getitB5_:
   83|      8|            unsafe fn __getit(
   84|      8|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      8|            ) -> $crate::option::Option<&'static $t> {
   86|      8|                #[thread_local]
   87|      8|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      8|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      8|
   90|      8|                unsafe {
   91|      8|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      8|                    })
  101|      8|                }
  102|      8|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsd_1__29RECURSIVE_COUNT_UpdateVariant7___getitB5_:
   83|     14|            unsafe fn __getit(
   84|     14|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     14|            ) -> $crate::option::Option<&'static $t> {
   86|     14|                #[thread_local]
   87|     14|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     14|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     14|
   90|     14|                unsafe {
   91|     14|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     14|                    })
  101|     14|                }
  102|     14|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsu_1__28RECURSIVE_COUNT_IriOrLiteral6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithso_1__30RECURSIVE_COUNT_GraphOrDefault7___getitB5_:
   83|     30|            unsafe fn __getit(
   84|     30|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     30|            ) -> $crate::option::Option<&'static $t> {
   86|     30|                #[thread_local]
   87|     30|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     30|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     30|
   90|     30|                unsafe {
   91|     30|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     30|                    })
  101|     30|                }
  102|     30|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsa_1__28RECURSIVE_COUNT_HavingClause7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths3_1__28RECURSIVE_COUNT_SelectOption6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsx_1__46RECURSIVE_COUNT_GroupGraphPatternSubOtherBlock6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths4_1__28RECURSIVE_COUNT_SelectValues6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths11_1__23RECURSIVE_COUNT_PathElt7___getitB5_:
   83|    664|            unsafe fn __getit(
   84|    664|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    664|            ) -> $crate::option::Option<&'static $t> {
   86|    664|                #[thread_local]
   87|    664|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    664|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    664|
   90|    664|                unsafe {
   91|    664|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    664|                    })
  101|    664|                }
  102|    664|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths12_1__32RECURSIVE_COUNT_PathEltOrInverse6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsH_1__30RECURSIVE_COUNT_DataBlockValue6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths7_1__32RECURSIVE_COUNT_SolutionModifier6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__24RECURSIVE_COUNT_VarOrIri6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__39RECURSIVE_COUNT_ConditionalOrExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsn_1__22RECURSIVE_COUNT_Modify6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsV_1__40RECURSIVE_COUNT_PropertyListPathNotEmpty7___getitB5_:
   83|     76|            unsafe fn __getit(
   84|     76|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     76|            ) -> $crate::option::Option<&'static $t> {
   86|     76|                #[thread_local]
   87|     76|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     76|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     76|
   90|     76|                unsafe {
   91|     76|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     76|                    })
  101|     76|                }
  102|     76|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsw_1__36RECURSIVE_COUNT_GroupGraphPatternSub7___getitB5_:
   83|    978|            unsafe fn __getit(
   84|    978|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    978|            ) -> $crate::option::Option<&'static $t> {
   86|    978|                #[thread_local]
   87|    978|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    978|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    978|
   90|    978|                unsafe {
   91|    978|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    978|                    })
  101|    978|                }
  102|    978|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__36RECURSIVE_COUNT_RelationalExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsq_1__27RECURSIVE_COUNT_GraphRefAll6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsR_1__20RECURSIVE_COUNT_Verb6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__33RECURSIVE_COUNT_PrimaryExpression7___getitB5_:
   83|  1.74k|            unsafe fn __getit(
   84|  1.74k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  1.74k|            ) -> $crate::option::Option<&'static $t> {
   86|  1.74k|                #[thread_local]
   87|  1.74k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  1.74k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  1.74k|
   90|  1.74k|                unsafe {
   91|  1.74k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  1.74k|                    })
  101|  1.74k|                }
  102|  1.74k|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsB_1__35RECURSIVE_COUNT_LateralGraphPattern7___getitB5_:
   83|      2|            unsafe fn __getit(
   84|      2|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      2|            ) -> $crate::option::Option<&'static $t> {
   86|      2|                #[thread_local]
   87|      2|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      2|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      2|
   90|      2|                unsafe {
   91|      2|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      2|                    })
  101|      2|                }
  102|      2|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths6_1__27RECURSIVE_COUNT_WhereClause6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths19_1__31RECURSIVE_COUNT_TriplesNodePath7___getitB5_:
   83|     12|            unsafe fn __getit(
   84|     12|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     12|            ) -> $crate::option::Option<&'static $t> {
   86|     12|                #[thread_local]
   87|     12|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     12|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     12|
   90|     12|                unsafe {
   91|     12|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     12|                    })
  101|     12|                }
  102|     12|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__34RECURSIVE_COUNT_AdditiveExpression6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsp_1__24RECURSIVE_COUNT_GraphRef6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths11_1__23RECURSIVE_COUNT_PathElt6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths5_1__32RECURSIVE_COUNT_SelectProjection6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths13_1__23RECURSIVE_COUNT_PathMod7___getitB5_:
   83|     44|            unsafe fn __getit(
   84|     44|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     44|            ) -> $crate::option::Option<&'static $t> {
   86|     44|                #[thread_local]
   87|     44|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     44|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     44|
   90|     44|                unsafe {
   91|     44|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     44|                    })
  101|     44|                }
  102|     44|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsb_1__28RECURSIVE_COUNT_ValuesClause6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__25RECURSIVE_COUNT_VarOrTerm6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__41RECURSIVE_COUNT_BlankNodePropertyListPath7___getitB5_:
   83|     22|            unsafe fn __getit(
   84|     22|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     22|            ) -> $crate::option::Option<&'static $t> {
   86|     22|                #[thread_local]
   87|     22|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     22|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     22|
   90|     22|                unsafe {
   91|     22|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     22|                    })
  101|     22|                }
  102|     22|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsL_1__26RECURSIVE_COUNT_Constraint7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths15_1__38RECURSIVE_COUNT_PathNegatedPropertySet6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsB_1__35RECURSIVE_COUNT_LateralGraphPattern6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsy_1__28RECURSIVE_COUNT_TriplesBlock7___getitB5_:
   83|      8|            unsafe fn __getit(
   84|      8|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      8|            ) -> $crate::option::Option<&'static $t> {
   86|      8|                #[thread_local]
   87|      8|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      8|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      8|
   90|      8|                unsafe {
   91|      8|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      8|                    })
  101|      8|                }
  102|      8|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths19_1__31RECURSIVE_COUNT_TriplesNodePath6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsu_1__28RECURSIVE_COUNT_IriOrLiteral7___getitB5_:
   83|     76|            unsafe fn __getit(
   84|     76|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     76|            ) -> $crate::option::Option<&'static $t> {
   86|     76|                #[thread_local]
   87|     76|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     76|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     76|
   90|     76|                unsafe {
   91|     76|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     76|                    })
  101|     76|                }
  102|     76|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1_1__25RECURSIVE_COUNT_SubSelect7___getitB5_:
   83|     18|            unsafe fn __getit(
   84|     18|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     18|            ) -> $crate::option::Option<&'static $t> {
   86|     18|                #[thread_local]
   87|     18|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     18|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     18|
   90|     18|                unsafe {
   91|     18|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     18|                    })
  101|     18|                }
  102|     18|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__31RECURSIVE_COUNT_PathAlternative6___initB5_:
   80|      1|            fn __init() -> $t { $init }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smithsx_1__46RECURSIVE_COUNT_GroupGraphPatternSubOtherBlock7___getitB5_:
   83|      4|            unsafe fn __getit(
   84|      4|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|      4|            ) -> $crate::option::Option<&'static $t> {
   86|      4|                #[thread_local]
   87|      4|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|      4|                    $crate::thread::local_impl::Key::<$t>::new();
   89|      4|
   90|      4|                unsafe {
   91|      4|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|      4|                    })
  101|      4|                }
  102|      4|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths4_1__28RECURSIVE_COUNT_SelectValues7___getitB5_:
   83|     40|            unsafe fn __getit(
   84|     40|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|     40|            ) -> $crate::option::Option<&'static $t> {
   86|     40|                #[thread_local]
   87|     40|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|     40|                    $crate::thread::local_impl::Key::<$t>::new();
   89|     40|
   90|     40|                unsafe {
   91|     40|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|     40|                    })
  101|     40|                }
  102|     40|            }
_RNvNvNvCs6Lc7YXa2Vl_12sparql_smiths12_1__32RECURSIVE_COUNT_PathEltOrInverse7___getitB5_:
   83|    264|            unsafe fn __getit(
   84|    264|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|    264|            ) -> $crate::option::Option<&'static $t> {
   86|    264|                #[thread_local]
   87|    264|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|    264|                    $crate::thread::local_impl::Key::<$t>::new();
   89|    264|
   90|    264|                unsafe {
   91|    264|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|    264|                    })
  101|    264|                }
  102|    264|            }
_RNvNvNtNtCs6voGXdKRTOy_4rand4rngs6thread14THREAD_RNG_KEY7___getitB7_:
   83|  78.4k|            unsafe fn __getit(
   84|  78.4k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
   85|  78.4k|            ) -> $crate::option::Option<&'static $t> {
   86|  78.4k|                #[thread_local]
   87|  78.4k|                static __KEY: $crate::thread::local_impl::Key<$t> =
   88|  78.4k|                    $crate::thread::local_impl::Key::<$t>::new();
   89|  78.4k|
   90|  78.4k|                unsafe {
   91|  78.4k|                    __KEY.get(move || {
   92|       |                        if let $crate::option::Option::Some(init) = init {
   93|       |                            if let $crate::option::Option::Some(value) = init.take() {
   94|       |                                return value;
   95|       |                            } else if $crate::cfg!(debug_assertions) {
   96|       |                                $crate::unreachable!("missing default value");
   97|       |                            }
   98|       |                        }
   99|       |                        __init()
  100|  78.4k|                    })
  101|  78.4k|                }
  102|  78.4k|            }
_RNvNvNtNtCs6voGXdKRTOy_4rand4rngs6thread14THREAD_RNG_KEY6___initB7_:
   80|      1|            fn __init() -> $t { $init }

_RNCNvNvCslmM25dSh1d8_18sparql_update_eval1__19___libfuzzer_sys_run0B5_:
   11|      1|    let store = STORE.get_or_init(|| Store::new().unwrap());

_RNvXsn_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_6UpdateNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  121|  2.49k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsu_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_12QueryDatasetNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  197|  2.53k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMs4_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_6Update5parse:
  129|  2.71k|    pub fn parse(
  130|  2.71k|        update: &str,
  131|  2.71k|        base_iri: Option<&str>,
  132|  2.71k|    ) -> Result<Self, spargebra::SparqlSyntaxError> {
  133|  2.71k|        Ok(spargebra::Update::parse(update, base_iri)?.into())
  134|  2.71k|    }
_RNvMsa_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_12QueryDataset3new:
  204|  4.89k|    pub(crate) fn new() -> Self {
  205|  4.89k|        Self {
  206|  4.89k|            default: None,
  207|  4.89k|            named: None,
  208|  4.89k|        }
  209|  4.89k|    }
_RNvMsa_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_12QueryDataset22available_named_graphs:
  286|  4.89k|    pub fn available_named_graphs(&self) -> Option<&[NamedOrBlankNode]> {
  287|  4.89k|        self.named.as_deref()
  288|  4.89k|    }
_RNvMsa_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_12QueryDataset12from_algebra:
  211|  2.53k|    fn from_algebra(inner: &Option<spargebra::algebra::QueryDataset>) -> Self {
  212|  2.53k|        if let Some(inner) = inner {
  213|  1.75k|            Self {
  214|  1.75k|                default: Some(inner.default.iter().map(|g| g.clone().into()).collect()),
  215|  1.75k|                named: inner
  216|  1.75k|                    .named
  217|  1.75k|                    .as_ref()
  218|  1.75k|                    .map(|named| named.iter().map(|g| g.clone().into()).collect()),
  219|  1.75k|            }
  220|       |        } else {
  221|    788|            Self {
  222|    788|                default: Some(vec![GraphName::DefaultGraph]),
  223|    788|                named: None,
  224|    788|            }
  225|       |        }
  226|  2.53k|    }
_RNvXs9_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_6UpdateINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshSv3hUzq9FP_9spargebra6update6UpdateE4from:
  178|  2.49k|    fn from(update: spargebra::Update) -> Self {
  179|  2.49k|        Self {
  180|  2.49k|            using_datasets: update
  181|  2.49k|                .operations
  182|  2.49k|                .iter()
  183|  2.49k|                .map(|operation| {
  184|       |                    if let GraphUpdateOperation::DeleteInsert { using, .. } = operation {
  185|       |                        Some(QueryDataset::from_algebra(using))
  186|       |                    } else {
  187|       |                        None
  188|       |                    }
  189|  2.49k|                })
  190|  2.49k|                .collect(),
  191|  2.49k|            inner: update,
  192|  2.49k|        }
  193|  2.49k|    }
_RNvMsa_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB5_12QueryDataset20default_graph_graphs:
  255|  4.89k|    pub fn default_graph_graphs(&self) -> Option<&[GraphName]> {
  256|  4.89k|        self.default.as_deref()
  257|  4.89k|    }
_RNCNvMsa_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB7_12QueryDataset12from_algebra0Bb_:
  214|  1.75k|                default: Some(inner.default.iter().map(|g| g.clone().into()).collect()),
_RNCNvXs9_NtNtCs2ek33vt1YA5_8oxigraph6sparql7algebraNtB7_6UpdateINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshSv3hUzq9FP_9spargebra6update6UpdateE4from0Bb_:
  183|  4.95k|                .map(|operation| {
  184|  4.95k|                    if let GraphUpdateOperation::DeleteInsert { using, .. } = operation {
  185|  2.53k|                        Some(QueryDataset::from_algebra(using))
  186|       |                    } else {
  187|  2.41k|                        None
  188|       |                    }
  189|  4.95k|                })

_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB2_11DatasetView31store_encoded_quads_for_pattern:
   34|  31.4k|    fn store_encoded_quads_for_pattern(
   35|  31.4k|        &self,
   36|  31.4k|        subject: Option<&EncodedTerm>,
   37|  31.4k|        predicate: Option<&EncodedTerm>,
   38|  31.4k|        object: Option<&EncodedTerm>,
   39|  31.4k|        graph_name: Option<&EncodedTerm>,
   40|  31.4k|    ) -> impl Iterator<Item = Result<EncodedQuad, EvaluationError>> + 'static {
   41|  31.4k|        self.reader
   42|  31.4k|            .quads_for_pattern(subject, predicate, object, graph_name)
   43|  31.4k|            .map(|t| t.map_err(Into::into))
   44|  31.4k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB2_11DatasetView3new:
   18|  4.89k|    pub fn new(reader: StorageReader, dataset: &QueryDataset) -> Self {
   19|  4.89k|        let dataset = EncodedDatasetSpec {
   20|  4.89k|            default: dataset
   21|  4.89k|                .default_graph_graphs()
   22|  4.89k|                .map(|graphs| graphs.iter().map(|g| g.as_ref().into()).collect::<Vec<_>>()),
   23|  4.89k|            named: dataset
   24|  4.89k|                .available_named_graphs()
   25|  4.89k|                .map(|graphs| graphs.iter().map(|g| g.as_ref().into()).collect::<Vec<_>>()),
   26|  4.89k|        };
   27|  4.89k|        Self {
   28|  4.89k|            reader,
   29|  4.89k|            extra: RefCell::new(HashMap::default()),
   30|  4.89k|            dataset,
   31|  4.89k|        }
   32|  4.89k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB2_11DatasetView25encoded_quads_for_pattern:
   47|  31.4k|    pub fn encoded_quads_for_pattern(
   48|  31.4k|        &self,
   49|  31.4k|        subject: Option<&EncodedTerm>,
   50|  31.4k|        predicate: Option<&EncodedTerm>,
   51|  31.4k|        object: Option<&EncodedTerm>,
   52|  31.4k|        graph_name: Option<&EncodedTerm>,
   53|  31.4k|    ) -> Box<dyn Iterator<Item = Result<EncodedQuad, EvaluationError>>> {
   54|  31.4k|        if let Some(graph_name) = graph_name {
   55|  29.8k|            if graph_name.is_default_graph() {
   56|  27.6k|                if let Some(default_graph_graphs) = &self.dataset.default {
   57|  27.6k|                    if default_graph_graphs.len() == 1 {
   58|       |                        // Single graph optimization
   59|  27.6k|                        Box::new(
   60|  27.6k|                            self.store_encoded_quads_for_pattern(
   61|  27.6k|                                subject,
   62|  27.6k|                                predicate,
   63|  27.6k|                                object,
   64|  27.6k|                                Some(&default_graph_graphs[0]),
   65|  27.6k|                            )
   66|  27.6k|                            .map(|quad| {
   67|       |                                let quad = quad?;
   68|       |                                Ok(EncodedQuad::new(
   69|       |                                    quad.subject,
   70|       |                                    quad.predicate,
   71|       |                                    quad.object,
   72|       |                                    EncodedTerm::DefaultGraph,
   73|       |                                ))
   74|  27.6k|                            }),
   75|  27.6k|                        )
   76|       |                    } else {
   77|      0|                        let iters = default_graph_graphs
   78|      0|                            .iter()
   79|      0|                            .map(|graph_name| {
   80|       |                                self.store_encoded_quads_for_pattern(
   81|       |                                    subject,
   82|       |                                    predicate,
   83|       |                                    object,
   84|       |                                    Some(graph_name),
   85|       |                                )
   86|      0|                            })
   87|      0|                            .collect::<Vec<_>>();
   88|      0|                        Box::new(iters.into_iter().flatten().map(|quad| {
   89|       |                            let quad = quad?;
   90|       |                            Ok(EncodedQuad::new(
   91|       |                                quad.subject,
   92|       |                                quad.predicate,
   93|       |                                quad.object,
   94|       |                                EncodedTerm::DefaultGraph,
   95|       |                            ))
   96|      0|                        }))
   97|       |                    }
   98|       |                } else {
   99|      0|                    Box::new(
  100|      0|                        self.store_encoded_quads_for_pattern(subject, predicate, object, None)
  101|      0|                            .map(|quad| {
  102|       |                                let quad = quad?;
  103|       |                                Ok(EncodedQuad::new(
  104|       |                                    quad.subject,
  105|       |                                    quad.predicate,
  106|       |                                    quad.object,
  107|       |                                    EncodedTerm::DefaultGraph,
  108|       |                                ))
  109|      0|                            }),
  110|      0|                    )
  111|       |                }
  112|  2.21k|            } else if self
  113|  2.21k|                .dataset
  114|  2.21k|                .named
  115|  2.21k|                .as_ref()
  116|  2.21k|                .map_or(true, |d| d.contains(graph_name))
  117|       |            {
  118|  2.21k|                Box::new(self.store_encoded_quads_for_pattern(
  119|  2.21k|                    subject,
  120|  2.21k|                    predicate,
  121|  2.21k|                    object,
  122|  2.21k|                    Some(graph_name),
  123|  2.21k|                ))
  124|       |            } else {
  125|      0|                Box::new(empty())
  126|       |            }
  127|  1.65k|        } else if let Some(named_graphs) = &self.dataset.named {
  128|      0|            let iters = named_graphs
  129|      0|                .iter()
  130|      0|                .map(|graph_name| {
  131|       |                    self.store_encoded_quads_for_pattern(
  132|       |                        subject,
  133|       |                        predicate,
  134|       |                        object,
  135|       |                        Some(graph_name),
  136|       |                    )
  137|      0|                })
  138|      0|                .collect::<Vec<_>>();
  139|      0|            Box::new(iters.into_iter().flatten())
  140|       |        } else {
  141|  1.65k|            Box::new(
  142|  1.65k|                self.store_encoded_quads_for_pattern(subject, predicate, object, None)
  143|  1.65k|                    .filter(|quad| match quad {
  144|       |                        Err(_) => true,
  145|       |                        Ok(quad) => !quad.graph_name.is_default_graph(),
  146|  1.65k|                    }),
  147|  1.65k|            )
  148|       |        }
  149|  31.4k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB2_11DatasetView10insert_str:
  162|  74.4k|    pub fn insert_str(&self, key: &StrHash, value: &str) {
  163|  74.4k|        if let Entry::Vacant(e) = self.extra.borrow_mut().entry(*key) {
  164|  13.9k|            if !matches!(self.reader.contains_str(key), Ok(true)) {
  165|  13.2k|                e.insert(value.to_owned());
  166|  13.2k|            }
  167|  60.5k|        }
  168|  74.4k|    }
_RNvXs_NtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB4_11DatasetViewNtNtNtB8_7storage15numeric_encoder9StrLookup7get_str:
  172|    369|    fn get_str(&self, key: &StrHash) -> Result<Option<String>, StorageError> {
  173|    369|        Ok(if let Some(value) = self.extra.borrow().get(key) {
  174|    303|            Some(value.clone())
  175|       |        } else {
  176|     66|            self.reader.get_str(key)?
  177|       |        })
  178|    369|    }
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB4_11DatasetView3new0B8_:
   22|  4.89k|                .map(|graphs| graphs.iter().map(|g| g.as_ref().into()).collect::<Vec<_>>()),
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB4_11DatasetView25encoded_quads_for_patterns4_0B8_:
  143|      6|                    .filter(|quad| match quad {
  144|      0|                        Err(_) => true,
  145|      6|                        Ok(quad) => !quad.graph_name.is_default_graph(),
  146|      6|                    }),
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB4_11DatasetView31store_encoded_quads_for_pattern0B8_:
   43|     85|            .map(|t| t.map_err(Into::into))
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB4_11DatasetView25encoded_quads_for_pattern0B8_:
   66|     57|                            .map(|quad| {
   67|     57|                                let quad = quad?;
   68|     57|                                Ok(EncodedQuad::new(
   69|     57|                                    quad.subject,
   70|     57|                                    quad.predicate,
   71|     57|                                    quad.object,
   72|     57|                                    EncodedTerm::DefaultGraph,
   73|     57|                                ))
   74|     57|                            }),
_RNCNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB6_11DatasetView3new00Ba_:
   22|  4.89k|                .map(|graphs| graphs.iter().map(|g| g.as_ref().into()).collect::<Vec<_>>()),
_RNCINvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB5_11DatasetView11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE0B9_:
  154|  74.4k|        insert_term(term, &encoded, &mut |key, value| {
  155|  74.4k|            self.insert_str(key, value);
  156|  74.4k|            Ok(())
  157|  74.4k|        })
_RINvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB3_11DatasetView11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeEB7_:
  151|  74.4k|    pub fn encode_term<'a>(&self, term: impl Into<TermRef<'a>>) -> EncodedTerm {
  152|  74.4k|        let term = term.into();
  153|  74.4k|        let encoded = term.into();
  154|  74.4k|        insert_term(term, &encoded, &mut |key, value| {
  155|       |            self.insert_str(key, value);
  156|       |            Ok(())
  157|  74.4k|        })
  158|  74.4k|        .unwrap();
  159|  74.4k|        encoded
  160|  74.4k|    }
_RINvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB3_11DatasetView11encode_termNtNtCshJ9d6mhVUZV_5oxrdf10named_node12NamedNodeRefEB7_:
  151|      2|    pub fn encode_term<'a>(&self, term: impl Into<TermRef<'a>>) -> EncodedTerm {
  152|      2|        let term = term.into();
  153|      2|        let encoded = term.into();
  154|      2|        insert_term(term, &encoded, &mut |key, value| {
  155|       |            self.insert_str(key, value);
  156|       |            Ok(())
  157|      2|        })
  158|      2|        .unwrap();
  159|      2|        encoded
  160|      2|    }
_RNCINvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB5_11DatasetView11encode_termNtNtCshJ9d6mhVUZV_5oxrdf10named_node12NamedNodeRefE0B9_:
  154|      2|        insert_term(term, &encoded, &mut |key, value| {
  155|      2|            self.insert_str(key, value);
  156|      2|            Ok(())
  157|      2|        })
_RINvMNtNtCs2ek33vt1YA5_8oxigraph6sparql7datasetNtB3_11DatasetView11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralEB7_:
  151|  5.96k|    pub fn encode_term<'a>(&self, term: impl Into<TermRef<'a>>) -> EncodedTerm {
  152|  5.96k|        let term = term.into();
  153|  5.96k|        let encoded = term.into();
  154|  5.96k|        insert_term(term, &encoded, &mut |key, value| {
  155|       |            self.insert_str(key, value);
  156|       |            Ok(())
  157|  5.96k|        })
  158|  5.96k|        .unwrap();
  159|  5.96k|        encoded
  160|  5.96k|    }

_RNvXs4_NtNtCs2ek33vt1YA5_8oxigraph6sparql5errorNtB5_15EvaluationErrorINtNtCs9nhK3FOW46N_4core7convert4FromNtNtNtB9_7storage5error12StorageErrorE4from:
   11|      2|#[derive(Debug, thiserror::Error)]

_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultNtNtNtBa_7storage15numeric_encoder11EncodedQuadNtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okTNtB2J_11EncodedTermB4G_B4G_ENCNvMs3_B6_NtB6_13PathEvaluator47get_subject_or_object_identity_pairs_in_dataset0AIB2l_B4F_B3s_Ej2_EBa_:
 5201|    118|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|    118|        self,
 5203|    118|        f: F,
 5204|    118|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|    118|        FlatMapOk {
 5206|    118|            inner: self,
 5207|    118|            f,
 5208|    118|            current: None,
 5209|    118|        }
 5210|    118|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultNtNtNtBa_7storage15numeric_encoder11EncodedQuadNtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okTNtB2J_11EncodedTermB4G_ENCNvMs3_B6_NtB6_13PathEvaluator45get_subject_or_object_identity_pairs_in_graph0AIB2l_B4F_B3s_Ej2_EBa_:
 5201|  3.98k|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|  3.98k|        self,
 5203|  3.98k|        f: F,
 5204|  3.98k|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|  3.98k|        FlatMapOk {
 5206|  3.98k|            inner: self,
 5207|  3.98k|            f,
 5208|  3.98k|            current: None,
 5209|  3.98k|        }
 5210|  3.98k|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultNtNtNtBa_7storage15numeric_encoder11EncodedTermNtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okB2H_NCNvMs3_B6_NtB6_13PathEvaluator18eval_from_in_graphs_0BJ_EBa_:
 5201|    188|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|    188|        self,
 5203|    188|        f: F,
 5204|    188|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|    188|        FlatMapOk {
 5206|    188|            inner: self,
 5207|    188|            f,
 5208|    188|            current: None,
 5209|    188|        }
 5210|    188|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultTNtNtNtBa_7storage15numeric_encoder11EncodedTermB2I_B2I_ENtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okB2H_NCNvMs3_B6_NtB6_13PathEvaluator26eval_open_in_unknown_graphs0_0INtNtNtB1p_8adapters3map3MapIBK_DB1j_p4ItemIB2l_B2I_B3C_EEL_ENCNCB4V_s0_00EEBa_:
 5201|    167|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|    167|        self,
 5203|    167|        f: F,
 5204|    167|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|    167|        FlatMapOk {
 5206|    167|            inner: self,
 5207|    167|            f,
 5208|    167|            current: None,
 5209|    167|        }
 5210|    167|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultNtNtNtBa_7storage15numeric_encoder11EncodedTermNtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okB2H_NCNvMs3_B6_NtB6_13PathEvaluator16eval_to_in_graphs_0BJ_EBa_:
 5201|    105|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|    105|        self,
 5203|    105|        f: F,
 5204|    105|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|    105|        FlatMapOk {
 5206|    105|            inner: self,
 5207|    105|            f,
 5208|    105|            current: None,
 5209|    105|        }
 5210|    105|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultTNtNtNtBa_7storage15numeric_encoder11EncodedTermB2I_ENtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okB2H_NCNvMs3_B6_NtB6_13PathEvaluator18eval_open_in_graphs0_0INtNtNtB1p_8adapters3map3MapIBK_DB1j_p4ItemIB2l_B2I_B3y_EEL_ENCNCB4R_s0_00EEBa_:
 5201|  2.09k|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|  2.09k|        self,
 5203|  2.09k|        f: F,
 5204|  2.09k|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|  2.09k|        FlatMapOk {
 5206|  2.09k|            inner: self,
 5207|  2.09k|            f,
 5208|  2.09k|            current: None,
 5209|  2.09k|        }
 5210|  2.09k|    }
_RINvXse_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1r_6result6ResultTNtNtNtBa_7storage15numeric_encoder11EncodedTermB2I_ENtNtB8_5error15EvaluationErrorEEL_EINtB6_14ResultIteratorB2H_E11flat_map_okB2H_NCNvMs3_B6_NtB6_13PathEvaluator24eval_to_in_unknown_graphs_0INtNtNtB1p_8adapters3map3MapIBK_DB1j_p4ItemIB2l_B2I_B3y_EEL_ENCNCB4R_s_00EEBa_:
 5201|      9|    fn flat_map_ok<O, F: FnMut(T) -> U, U: IntoIterator<Item = Result<O, EvaluationError>>>(
 5202|      9|        self,
 5203|      9|        f: F,
 5204|      9|    ) -> FlatMapOk<T, O, Self, F, U> {
 5205|      9|        FlatMapOk {
 5206|      9|            inner: self,
 5207|      9|            f,
 5208|      9|            current: None,
 5209|      9|        }
 5210|      9|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval7to_bool:
 2875|    146|fn to_bool(term: &EncodedTerm) -> Option<bool> {
 2876|    146|    match term {
 2877|    125|        EncodedTerm::BooleanLiteral(value) => Some((*value).into()),
 2878|      3|        EncodedTerm::SmallStringLiteral(value) => Some(!value.is_empty()),
 2879|       |        EncodedTerm::BigStringLiteral { .. } => {
 2880|      0|            Some(false) // A big literal can't be empty
 2881|       |        }
 2882|      0|        EncodedTerm::FloatLiteral(value) => Some(Boolean::from(*value).into()),
 2883|      0|        EncodedTerm::DoubleLiteral(value) => Some(Boolean::from(*value).into()),
 2884|      2|        EncodedTerm::IntegerLiteral(value) => Some(Boolean::from(*value).into()),
 2885|      2|        EncodedTerm::DecimalLiteral(value) => Some(Boolean::from(*value).into()),
 2886|     14|        _ => None,
 2887|       |    }
 2888|    146|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval15encode_variable:
 5502|   126k|fn encode_variable(variables: &mut Vec<Variable>, variable: &Variable) -> usize {
 5503|   126k|    if let Some(key) = slice_key(variables, variable) {
 5504|  83.6k|        key
 5505|       |    } else {
 5506|  42.5k|        variables.push(variable.clone());
 5507|  42.5k|        variables.len() - 1
 5508|       |    }
 5509|   126k|}
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple4iter:
   67|      8|    pub fn iter(&self) -> impl Iterator<Item = Option<EncodedTerm>> + '_ {
   68|      8|        self.inner.iter().cloned()
   69|      8|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator24eval_to_in_unknown_graph:
 4392|     55|    fn eval_to_in_unknown_graph(
 4393|     55|        &self,
 4394|     55|        path: &PropertyPath,
 4395|     55|        end: &EncodedTerm,
 4396|     55|    ) -> Box<dyn Iterator<Item = Result<(EncodedTerm, EncodedTerm), EvaluationError>>> {
 4397|     55|        match path {
 4398|      9|            PropertyPath::Path(p) => Box::new(
 4399|      9|                self.dataset
 4400|      9|                    .encoded_quads_for_pattern(None, Some(p), Some(end), None)
 4401|      9|                    .map(|t| {
 4402|       |                        let t = t?;
 4403|       |                        Ok((t.subject, t.graph_name))
 4404|      9|                    }),
 4405|      9|            ),
 4406|     10|            PropertyPath::Reverse(p) => self.eval_from_in_unknown_graph(p, end),
 4407|      9|            PropertyPath::Sequence(a, b) => {
 4408|      9|                let eval = self.clone();
 4409|      9|                let a = Rc::clone(a);
 4410|      9|                Box::new(self.eval_to_in_unknown_graph(b, end).flat_map_ok(
 4411|      9|                    move |(middle, graph_name)| {
 4412|       |                        eval.eval_from_in_graph(&a, &middle, &graph_name)
 4413|       |                            .map(move |start| Ok((start?, graph_name.clone())))
 4414|      9|                    },
 4415|      9|                ))
 4416|       |            }
 4417|     16|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4418|     16|                self.eval_to_in_unknown_graph(a, end)
 4419|     16|                    .chain(self.eval_to_in_unknown_graph(b, end)),
 4420|     16|            )),
 4421|      3|            PropertyPath::ZeroOrMore(p) => {
 4422|      3|                let end2 = end.clone();
 4423|      3|                let eval = self.clone();
 4424|      3|                let p = Rc::clone(p);
 4425|      3|                self.run_if_term_is_a_dataset_node(end, move |graph_name| {
 4426|       |                    let eval = eval.clone();
 4427|       |                    let p = Rc::clone(&p);
 4428|       |                    let graph_name2 = graph_name.clone();
 4429|       |                    transitive_closure(Some(Ok(end2.clone())), move |e| {
 4430|       |                        eval.eval_to_in_graph(&p, &e, &graph_name2)
 4431|       |                    })
 4432|       |                    .map(move |e| Ok((e?, graph_name.clone())))
 4433|      3|                })
 4434|       |            }
 4435|      1|            PropertyPath::OneOrMore(p) => {
 4436|      1|                let eval = self.clone();
 4437|      1|                let p = Rc::clone(p);
 4438|      1|                Box::new(transitive_closure(
 4439|      1|                    self.eval_to_in_unknown_graph(&p, end),
 4440|      1|                    move |(e, graph_name)| {
 4441|       |                        eval.eval_to_in_graph(&p, &e, &graph_name)
 4442|       |                            .map(move |e| Ok((e?, graph_name.clone())))
 4443|      1|                    },
 4444|      1|                ))
 4445|       |            }
 4446|      5|            PropertyPath::ZeroOrOne(p) => {
 4447|      5|                let eval = self.clone();
 4448|      5|                let end2 = end.clone();
 4449|      5|                let p = Rc::clone(p);
 4450|      5|                self.run_if_term_is_a_dataset_node(end, move |graph_name| {
 4451|       |                    hash_deduplicate(once(Ok(end2.clone())).chain(eval.eval_to_in_graph(
 4452|       |                        &p,
 4453|       |                        &end2,
 4454|       |                        &graph_name,
 4455|       |                    )))
 4456|       |                    .map(move |e| Ok((e?, graph_name.clone())))
 4457|      5|                })
 4458|       |            }
 4459|      2|            PropertyPath::NegatedPropertySet(ps) => {
 4460|      2|                let ps = Rc::clone(ps);
 4461|      2|                Box::new(
 4462|      2|                    self.dataset
 4463|      2|                        .encoded_quads_for_pattern(Some(end), None, None, None)
 4464|      2|                        .filter_map(move |t| match t {
 4465|       |                            Ok(t) => {
 4466|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4467|       |                                    None
 4468|       |                                } else {
 4469|       |                                    Some(Ok((t.subject, t.graph_name)))
 4470|       |                                }
 4471|       |                            }
 4472|       |                            Err(e) => Some(Err(e)),
 4473|      2|                        }),
 4474|      2|                )
 4475|       |            }
 4476|       |        }
 4477|     55|    }
_RNvXs5_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_16HashJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint:
 4790|      1|    fn size_hint(&self) -> (usize, Option<usize>) {
 4791|      1|        (
 4792|      1|            0,
 4793|      1|            self.probe_iter
 4794|      1|                .size_hint()
 4795|      1|                .1
 4796|      1|                .map(|v| v.saturating_mul(self.built.len())),
 4797|      1|        )
 4798|      1|    }
_RNvXs9_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_24ConsecutiveDeduplicationNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint:
 4932|    783|    fn size_hint(&self) -> (usize, Option<usize>) {
 4933|    783|        let (min, max) = self.inner.size_hint();
 4934|    783|        ((min != 0).into(), max)
 4935|    783|    }
_RNvXsL_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluatorNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
 3981|  4.61k|#[derive(Clone)]
_RNvXs8_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13UnionIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4886|     81|    fn next(&mut self) -> Option<Self::Item> {
 4887|       |        loop {
 4888|    157|            if let Some(tuple) = self.current_iterator.next() {
 4889|     34|                return Some(tuple);
 4890|    123|            }
 4891|    123|            if self.current_plan >= self.plans.len() {
 4892|     47|                return None;
 4893|     76|            }
 4894|     76|            self.current_iterator = self.plans[self.current_plan](self.input.clone());
 4895|     76|            self.current_plan += 1;
 4896|       |        }
 4897|     81|    }
_RNvXs9_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_24ConsecutiveDeduplicationNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4908|  3.27k|    fn next(&mut self) -> Option<Self::Item> {
 4909|       |        // Basic idea. We buffer the previous result and we only emit it when we know the next one or it's the end
 4910|       |        loop {
 4911|  4.11k|            if let Some(next) = self.inner.next() {
 4912|    915|                match next {
 4913|    915|                    Ok(next) => match self.current.take() {
 4914|    135|                        Some(current) if current != next => {
 4915|     74|                            // We found a relevant value
 4916|     74|                            self.current = Some(next);
 4917|     74|                            return Some(Ok(current));
 4918|       |                        }
 4919|    841|                        _ => {
 4920|    841|                            //  We discard the value and move to the next one
 4921|    841|                            self.current = Some(next);
 4922|    841|                        }
 4923|       |                    },
 4924|      0|                    Err(error) => return Some(Err(error)), // We swap but it's fine. It's an error.
 4925|       |                }
 4926|       |            } else {
 4927|  3.20k|                return self.current.take().map(Ok);
 4928|       |            }
 4929|       |        }
 4930|  3.27k|    }
_RNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15SimpleEvaluator29build_graph_pattern_evaluator:
  281|   104k|    fn build_graph_pattern_evaluator(
  282|   104k|        &self,
  283|   104k|        pattern: &GraphPattern,
  284|   104k|        encoded_variables: &mut Vec<Variable>,
  285|   104k|        stat_children: &mut Vec<Rc<EvalNodeWithStats>>,
  286|   104k|    ) -> Rc<dyn Fn(EncodedTuple) -> EncodedTuplesIterator> {
  287|   104k|        match pattern {
  288|       |            GraphPattern::Values {
  289|  2.35k|                variables,
  290|  2.35k|                bindings,
  291|  2.35k|            } => {
  292|  2.35k|                let encoding = variables
  293|  2.35k|                    .iter()
  294|  2.35k|                    .map(|v| encode_variable(encoded_variables, v))
  295|  2.35k|                    .collect::<Vec<_>>();
  296|  2.35k|                let encoded_tuples = bindings
  297|  2.35k|                    .iter()
  298|  2.35k|                    .map(|row| {
  299|       |                        let mut result = EncodedTuple::with_capacity(variables.len());
  300|       |                        for (key, value) in row.iter().enumerate() {
  301|       |                            if let Some(term) = value {
  302|       |                                result.set(
  303|       |                                    encoding[key],
  304|       |                                    match term {
  305|       |                                        GroundTerm::NamedNode(node) => self.encode_term(node),
  306|       |                                        GroundTerm::Literal(literal) => self.encode_term(literal),
  307|       |                                        GroundTerm::Triple(triple) => self.encode_triple(triple),
  308|       |                                    },
  309|       |                                );
  310|       |                            }
  311|       |                        }
  312|       |                        result
  313|  2.35k|                    })
  314|  2.35k|                    .collect::<Vec<_>>();
  315|  2.35k|                Rc::new(move |from| {
  316|       |                    Box::new(
  317|       |                        encoded_tuples
  318|       |                            .iter()
  319|       |                            .filter_map(move |t| Some(Ok(t.combine_with(&from)?)))
  320|       |                            .collect::<Vec<_>>()
  321|       |                            .into_iter(),
  322|       |                    )
  323|  2.35k|                })
  324|       |            }
  325|       |            GraphPattern::Service {
  326|      0|                name,
  327|      0|                inner,
  328|      0|                silent,
  329|      0|            } => {
  330|      0|                #[allow(clippy::shadow_same)]
  331|      0|                let silent = *silent;
  332|      0|                let service_name =
  333|      0|                    TupleSelector::from_named_node_pattern(name, encoded_variables, &self.dataset);
  334|      0|                self.build_graph_pattern_evaluator(inner, encoded_variables, &mut Vec::new()); // We call recursively to fill "encoded_variables"
  335|      0|                let graph_pattern = spargebra::algebra::GraphPattern::from(inner.as_ref());
  336|      0|                let variables = Rc::from(encoded_variables.as_slice());
  337|      0|                let eval = self.clone();
  338|      0|                Rc::new(move |from| {
  339|       |                    match eval.evaluate_service(
  340|       |                        &service_name,
  341|       |                        &graph_pattern,
  342|       |                        Rc::clone(&variables),
  343|       |                        &from,
  344|       |                    ) {
  345|       |                        Ok(result) => Box::new(result.filter_map(move |binding| {
  346|       |                            binding
  347|       |                                .map(|binding| binding.combine_with(&from))
  348|       |                                .transpose()
  349|       |                        })),
  350|       |                        Err(e) => {
  351|       |                            if silent {
  352|       |                                Box::new(once(Ok(from)))
  353|       |                            } else {
  354|       |                                Box::new(once(Err(e)))
  355|       |                            }
  356|       |                        }
  357|       |                    }
  358|      0|                })
  359|       |            }
  360|       |            GraphPattern::QuadPattern {
  361|  37.3k|                subject,
  362|  37.3k|                predicate,
  363|  37.3k|                object,
  364|  37.3k|                graph_name,
  365|  37.3k|            } => {
  366|  37.3k|                let subject = TupleSelector::from_ground_term_pattern(
  367|  37.3k|                    subject,
  368|  37.3k|                    encoded_variables,
  369|  37.3k|                    &self.dataset,
  370|  37.3k|                );
  371|  37.3k|                let predicate = TupleSelector::from_named_node_pattern(
  372|  37.3k|                    predicate,
  373|  37.3k|                    encoded_variables,
  374|  37.3k|                    &self.dataset,
  375|  37.3k|                );
  376|  37.3k|                let object = TupleSelector::from_ground_term_pattern(
  377|  37.3k|                    object,
  378|  37.3k|                    encoded_variables,
  379|  37.3k|                    &self.dataset,
  380|  37.3k|                );
  381|  37.3k|                let graph_name = TupleSelector::from_graph_name_pattern(
  382|  37.3k|                    graph_name,
  383|  37.3k|                    encoded_variables,
  384|  37.3k|                    &self.dataset,
  385|  37.3k|                );
  386|  37.3k|                let dataset = Rc::clone(&self.dataset);
  387|  37.3k|                Rc::new(move |from| {
  388|       |                    let iter = dataset.encoded_quads_for_pattern(
  389|       |                        subject.get_pattern_value(&from).as_ref(),
  390|       |                        predicate.get_pattern_value(&from).as_ref(),
  391|       |                        object.get_pattern_value(&from).as_ref(),
  392|       |                        graph_name.get_pattern_value(&from).as_ref(),
  393|       |                    );
  394|       |                    let subject = subject.clone();
  395|       |                    let predicate = predicate.clone();
  396|       |                    let object = object.clone();
  397|       |                    let graph_name = graph_name.clone();
  398|       |                    Box::new(iter.filter_map(move |quad| match quad {
  399|       |                        Ok(quad) => {
  400|       |                            let mut new_tuple = from.clone();
  401|       |                            put_pattern_value(&subject, quad.subject, &mut new_tuple)?;
  402|       |                            put_pattern_value(&predicate, quad.predicate, &mut new_tuple)?;
  403|       |                            put_pattern_value(&object, quad.object, &mut new_tuple)?;
  404|       |                            put_pattern_value(&graph_name, quad.graph_name, &mut new_tuple)?;
  405|       |                            Some(Ok(new_tuple))
  406|       |                        }
  407|       |                        Err(error) => Some(Err(error)),
  408|       |                    }))
  409|  37.3k|                })
  410|       |            }
  411|       |            GraphPattern::Path {
  412|  11.9k|                subject,
  413|  11.9k|                path,
  414|  11.9k|                object,
  415|  11.9k|                graph_name,
  416|  11.9k|            } => {
  417|  11.9k|                let subject = TupleSelector::from_ground_term_pattern(
  418|  11.9k|                    subject,
  419|  11.9k|                    encoded_variables,
  420|  11.9k|                    &self.dataset,
  421|  11.9k|                );
  422|  11.9k|                let path = self.encode_property_path(path);
  423|  11.9k|
  424|  11.9k|                let object = TupleSelector::from_ground_term_pattern(
  425|  11.9k|                    object,
  426|  11.9k|                    encoded_variables,
  427|  11.9k|                    &self.dataset,
  428|  11.9k|                );
  429|  11.9k|                let graph_name = TupleSelector::from_graph_name_pattern(
  430|  11.9k|                    graph_name,
  431|  11.9k|                    encoded_variables,
  432|  11.9k|                    &self.dataset,
  433|  11.9k|                );
  434|  11.9k|                let dataset = Rc::clone(&self.dataset);
  435|  11.9k|                Rc::new(move |from| {
  436|       |                    let input_subject = subject.get_pattern_value(&from);
  437|       |                    let input_object = object.get_pattern_value(&from);
  438|       |                    let input_graph_name = graph_name.get_pattern_value(&from);
  439|       |                    let path_eval = PathEvaluator {
  440|       |                        dataset: Rc::clone(&dataset),
  441|       |                    };
  442|       |                    match (input_subject, input_object, input_graph_name) {
  443|       |                        (Some(input_subject), Some(input_object), Some(input_graph_name)) => {
  444|       |                            match path_eval.eval_closed_in_graph(
  445|       |                                &path,
  446|       |                                &input_subject,
  447|       |                                &input_object,
  448|       |                                &input_graph_name,
  449|       |                            ) {
  450|       |                                Ok(true) => Box::new(once(Ok(from))),
  451|       |                                Ok(false) => Box::new(empty()),
  452|       |                                Err(e) => Box::new(once(Err(e))),
  453|       |                            }
  454|       |                        }
  455|       |                        (Some(input_subject), None, Some(input_graph_name)) => {
  456|       |                            let object = object.clone();
  457|       |                            Box::new(
  458|       |                                path_eval
  459|       |                                    .eval_from_in_graph(&path, &input_subject, &input_graph_name)
  460|       |                                    .filter_map(move |o| match o {
  461|       |                                        Ok(o) => {
  462|       |                                            let mut new_tuple = from.clone();
  463|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  464|       |                                            Some(Ok(new_tuple))
  465|       |                                        }
  466|       |                                        Err(error) => Some(Err(error)),
  467|       |                                    }),
  468|       |                            )
  469|       |                        }
  470|       |                        (None, Some(input_object), Some(input_graph_name)) => {
  471|       |                            let subject = subject.clone();
  472|       |                            Box::new(
  473|       |                                path_eval
  474|       |                                    .eval_to_in_graph(&path, &input_object, &input_graph_name)
  475|       |                                    .filter_map(move |s| match s {
  476|       |                                        Ok(s) => {
  477|       |                                            let mut new_tuple = from.clone();
  478|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  479|       |                                            Some(Ok(new_tuple))
  480|       |                                        }
  481|       |                                        Err(error) => Some(Err(error)),
  482|       |                                    }),
  483|       |                            )
  484|       |                        }
  485|       |                        (None, None, Some(input_graph_name)) => {
  486|       |                            let subject = subject.clone();
  487|       |                            let object = object.clone();
  488|       |                            Box::new(
  489|       |                                path_eval
  490|       |                                    .eval_open_in_graph(&path, &input_graph_name)
  491|       |                                    .filter_map(move |so| match so {
  492|       |                                        Ok((s, o)) => {
  493|       |                                            let mut new_tuple = from.clone();
  494|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  495|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  496|       |                                            Some(Ok(new_tuple))
  497|       |                                        }
  498|       |                                        Err(error) => Some(Err(error)),
  499|       |                                    }),
  500|       |                            )
  501|       |                        }
  502|       |                        (Some(input_subject), Some(input_object), None) => {
  503|       |                            let graph_name = graph_name.clone();
  504|       |                            Box::new(
  505|       |                                path_eval
  506|       |                                    .eval_closed_in_unknown_graph(
  507|       |                                        &path,
  508|       |                                        &input_subject,
  509|       |                                        &input_object,
  510|       |                                    )
  511|       |                                    .filter_map(move |r| match r {
  512|       |                                        Ok(g) => {
  513|       |                                            let mut new_tuple = from.clone();
  514|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  515|       |                                            Some(Ok(new_tuple))
  516|       |                                        }
  517|       |                                        Err(error) => Some(Err(error)),
  518|       |                                    }),
  519|       |                            )
  520|       |                        }
  521|       |                        (Some(input_subject), None, None) => {
  522|       |                            let object = object.clone();
  523|       |                            let graph_name = graph_name.clone();
  524|       |                            Box::new(
  525|       |                                path_eval
  526|       |                                    .eval_from_in_unknown_graph(&path, &input_subject)
  527|       |                                    .filter_map(move |r| match r {
  528|       |                                        Ok((o, g)) => {
  529|       |                                            let mut new_tuple = from.clone();
  530|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  531|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  532|       |                                            Some(Ok(new_tuple))
  533|       |                                        }
  534|       |                                        Err(error) => Some(Err(error)),
  535|       |                                    }),
  536|       |                            )
  537|       |                        }
  538|       |                        (None, Some(input_object), None) => {
  539|       |                            let subject = subject.clone();
  540|       |                            let graph_name = graph_name.clone();
  541|       |                            Box::new(
  542|       |                                path_eval
  543|       |                                    .eval_to_in_unknown_graph(&path, &input_object)
  544|       |                                    .filter_map(move |r| match r {
  545|       |                                        Ok((s, g)) => {
  546|       |                                            let mut new_tuple = from.clone();
  547|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  548|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  549|       |
  550|       |                                            Some(Ok(new_tuple))
  551|       |                                        }
  552|       |                                        Err(error) => Some(Err(error)),
  553|       |                                    }),
  554|       |                            )
  555|       |                        }
  556|       |                        (None, None, None) => {
  557|       |                            let subject = subject.clone();
  558|       |                            let object = object.clone();
  559|       |                            let graph_name = graph_name.clone();
  560|       |                            Box::new(path_eval.eval_open_in_unknown_graph(&path).filter_map(
  561|       |                                move |r| match r {
  562|       |                                    Ok((s, o, g)) => {
  563|       |                                        let mut new_tuple = from.clone();
  564|       |                                        put_pattern_value(&subject, s, &mut new_tuple)?;
  565|       |                                        put_pattern_value(&object, o, &mut new_tuple)?;
  566|       |                                        put_pattern_value(&graph_name, g, &mut new_tuple)?;
  567|       |                                        Some(Ok(new_tuple))
  568|       |                                    }
  569|       |                                    Err(error) => Some(Err(error)),
  570|       |                                },
  571|       |                            ))
  572|       |                        }
  573|       |                    }
  574|  11.9k|                })
  575|       |            }
  576|       |            GraphPattern::Join {
  577|  24.2k|                left,
  578|  24.2k|                right,
  579|  24.2k|                algorithm,
  580|  24.2k|            } => {
  581|  24.2k|                let (left, left_stats) = self.graph_pattern_evaluator(left, encoded_variables);
  582|  24.2k|                stat_children.push(left_stats);
  583|  24.2k|                let (right, right_stats) = self.graph_pattern_evaluator(right, encoded_variables);
  584|  24.2k|                stat_children.push(right_stats);
  585|  24.2k|
  586|  24.2k|                match algorithm {
  587|  24.2k|                    JoinAlgorithm::HashBuildLeftProbeRight { keys } => {
  588|  24.2k|                        let build = left;
  589|  24.2k|                        let probe = right;
  590|  24.2k|                        if keys.is_empty() {
  591|       |                            // Cartesian product
  592|  24.1k|                            Rc::new(move |from| {
  593|       |                                let mut errors = Vec::default();
  594|       |                                let build_values = build(from.clone())
  595|       |                                    .filter_map(|result| match result {
  596|       |                                        Ok(result) => Some(result),
  597|       |                                        Err(error) => {
  598|       |                                            errors.push(Err(error));
  599|       |                                            None
  600|       |                                        }
  601|       |                                    })
  602|       |                                    .collect::<Vec<_>>();
  603|       |                                Box::new(CartesianProductJoinIterator {
  604|       |                                    probe_iter: probe(from),
  605|       |                                    built: build_values,
  606|       |                                    buffered_results: errors,
  607|       |                                })
  608|  24.1k|                            })
  609|       |                        } else {
  610|       |                            // Real hash join
  611|     15|                            let keys = keys
  612|     15|                                .iter()
  613|     15|                                .map(|v| encode_variable(encoded_variables, v))
  614|     15|                                .collect::<Vec<_>>();
  615|     15|                            Rc::new(move |from| {
  616|       |                                let mut errors = Vec::default();
  617|       |                                let mut built_values = EncodedTupleSet::new(keys.clone());
  618|       |                                built_values.extend(build(from.clone()).filter_map(|result| {
  619|       |                                    match result {
  620|       |                                        Ok(result) => Some(result),
  621|       |                                        Err(error) => {
  622|       |                                            errors.push(Err(error));
  623|       |                                            None
  624|       |                                        }
  625|       |                                    }
  626|       |                                }));
  627|       |                                Box::new(HashJoinIterator {
  628|       |                                    probe_iter: probe(from),
  629|       |                                    built: built_values,
  630|       |                                    buffered_results: errors,
  631|       |                                })
  632|     15|                            })
  633|       |                        }
  634|       |                    }
  635|       |                }
  636|       |            }
  637|  22.0k|            GraphPattern::Lateral { left, right } => {
  638|  22.0k|                let (left, left_stats) = self.graph_pattern_evaluator(left, encoded_variables);
  639|  22.0k|                stat_children.push(left_stats);
  640|       |
  641|       |                if let GraphPattern::LeftJoin {
  642|     38|                    left: nested_left,
  643|     38|                    right: nested_right,
  644|     38|                    expression,
  645|       |                    ..
  646|  22.0k|                } = right.as_ref()
  647|       |                {
  648|     38|                    if nested_left.is_empty_singleton() {
  649|       |                        // We are in a ForLoopLeftJoin
  650|     37|                        let right =
  651|     37|                            GraphPattern::filter(nested_right.as_ref().clone(), expression.clone());
  652|     37|                        let (right, right_stats) =
  653|     37|                            self.graph_pattern_evaluator(&right, encoded_variables);
  654|     37|                        stat_children.push(right_stats);
  655|     37|                        return Rc::new(move |from| {
  656|       |                            Box::new(ForLoopLeftJoinIterator {
  657|       |                                right_evaluator: Rc::clone(&right),
  658|       |                                left_iter: left(from),
  659|       |                                current_right: Box::new(empty()),
  660|       |                            })
  661|     37|                        });
  662|      1|                    }
  663|  21.9k|                }
  664|  21.9k|                let (right, right_stats) = self.graph_pattern_evaluator(right, encoded_variables);
  665|  21.9k|                stat_children.push(right_stats);
  666|  21.9k|                Rc::new(move |from| {
  667|       |                    let right = Rc::clone(&right);
  668|       |                    Box::new(left(from).flat_map(move |t| match t {
  669|       |                        Ok(t) => right(t),
  670|       |                        Err(e) => Box::new(once(Err(e))),
  671|       |                    }))
  672|  21.9k|                })
  673|       |            }
  674|       |            GraphPattern::Minus {
  675|     40|                left,
  676|     40|                right,
  677|     40|                algorithm,
  678|     40|            } => {
  679|     40|                let (left, left_stats) = self.graph_pattern_evaluator(left, encoded_variables);
  680|     40|                stat_children.push(left_stats);
  681|     40|                let (right, right_stats) = self.graph_pattern_evaluator(right, encoded_variables);
  682|     40|                stat_children.push(right_stats);
  683|     40|
  684|     40|                match algorithm {
  685|     40|                    MinusAlgorithm::HashBuildRightProbeLeft { keys } => {
  686|     40|                        if keys.is_empty() {
  687|     39|                            Rc::new(move |from| {
  688|       |                                let right: Vec<_> =
  689|       |                                    right(from.clone()).filter_map(Result::ok).collect();
  690|       |                                Box::new(left(from).filter(move |left_tuple| {
  691|       |                                    if let Ok(left_tuple) = left_tuple {
  692|       |                                        !right.iter().any(|right_tuple| {
  693|       |                                            are_compatible_and_not_disjointed(
  694|       |                                                left_tuple,
  695|       |                                                right_tuple,
  696|       |                                            )
  697|       |                                        })
  698|       |                                    } else {
  699|       |                                        true
  700|       |                                    }
  701|       |                                }))
  702|     39|                            })
  703|       |                        } else {
  704|      1|                            let keys = keys
  705|      1|                                .iter()
  706|      1|                                .map(|v| encode_variable(encoded_variables, v))
  707|      1|                                .collect::<Vec<_>>();
  708|      1|                            Rc::new(move |from| {
  709|       |                                let mut right_values = EncodedTupleSet::new(keys.clone());
  710|       |                                right_values.extend(right(from.clone()).filter_map(Result::ok));
  711|       |                                Box::new(left(from).filter(move |left_tuple| {
  712|       |                                    if let Ok(left_tuple) = left_tuple {
  713|       |                                        !right_values.get(left_tuple).iter().any(|right_tuple| {
  714|       |                                            are_compatible_and_not_disjointed(
  715|       |                                                left_tuple,
  716|       |                                                right_tuple,
  717|       |                                            )
  718|       |                                        })
  719|       |                                    } else {
  720|       |                                        true
  721|       |                                    }
  722|       |                                }))
  723|      1|                            })
  724|       |                        }
  725|       |                    }
  726|       |                }
  727|       |            }
  728|       |            GraphPattern::LeftJoin {
  729|    366|                left,
  730|    366|                right,
  731|    366|                expression,
  732|    366|                algorithm,
  733|    366|            } => {
  734|    366|                let (left, left_stats) = self.graph_pattern_evaluator(left, encoded_variables);
  735|    366|                stat_children.push(left_stats);
  736|    366|                let (right, right_stats) = self.graph_pattern_evaluator(right, encoded_variables);
  737|    366|                stat_children.push(right_stats);
  738|    366|                let expression =
  739|    366|                    self.expression_evaluator(expression, encoded_variables, stat_children);
  740|    366|
  741|    366|                match algorithm {
  742|    366|                    LeftJoinAlgorithm::HashBuildRightProbeLeft { keys } => {
  743|    366|                        // Real hash join
  744|    366|                        let keys = keys
  745|    366|                            .iter()
  746|    366|                            .map(|v| encode_variable(encoded_variables, v))
  747|    366|                            .collect::<Vec<_>>();
  748|    366|                        Rc::new(move |from| {
  749|       |                            let mut errors = Vec::default();
  750|       |                            let mut right_values = EncodedTupleSet::new(keys.clone());
  751|       |                            right_values.extend(right(from.clone()).filter_map(
  752|       |                                |result| match result {
  753|       |                                    Ok(result) => Some(result),
  754|       |                                    Err(error) => {
  755|       |                                        errors.push(Err(error));
  756|       |                                        None
  757|       |                                    }
  758|       |                                },
  759|       |                            ));
  760|       |                            Box::new(HashLeftJoinIterator {
  761|       |                                left_iter: left(from),
  762|       |                                right: right_values,
  763|       |                                buffered_results: errors,
  764|       |                                expression: Rc::clone(&expression),
  765|       |                            })
  766|    366|                        })
  767|    366|                    }
  768|    366|                }
  769|       |            }
  770|     44|            GraphPattern::Filter { inner, expression } => {
  771|     44|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  772|     44|                stat_children.push(child_stats);
  773|     44|                let expression =
  774|     44|                    self.expression_evaluator(expression, encoded_variables, stat_children);
  775|     44|
  776|     44|                Rc::new(move |from| {
  777|       |                    let expression = Rc::clone(&expression);
  778|       |                    Box::new(child(from).filter(move |tuple| {
  779|       |                        match tuple {
  780|       |                            Ok(tuple) => expression(tuple)
  781|       |                                .and_then(|term| to_bool(&term))
  782|       |                                .unwrap_or(false),
  783|       |                            Err(_) => true,
  784|       |                        }
  785|       |                    }))
  786|     44|                })
  787|       |            }
  788|     38|            GraphPattern::Union { inner } => {
  789|     38|                let children = inner
  790|     38|                    .iter()
  791|     38|                    .map(|child| {
  792|       |                        let (child, child_stats) =
  793|       |                            self.graph_pattern_evaluator(child, encoded_variables);
  794|       |                        stat_children.push(child_stats);
  795|       |                        child
  796|     38|                    })
  797|     38|                    .collect::<Vec<_>>();
  798|     38|
  799|     38|                Rc::new(move |from| {
  800|       |                    Box::new(UnionIterator {
  801|       |                        plans: children.clone(),
  802|       |                        input: from,
  803|       |                        current_iterator: Box::new(empty()),
  804|       |                        current_plan: 0,
  805|       |                    })
  806|     38|                })
  807|       |            }
  808|       |            GraphPattern::Extend {
  809|    586|                inner,
  810|    586|                variable,
  811|    586|                expression,
  812|    586|            } => {
  813|    586|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  814|    586|                stat_children.push(child_stats);
  815|    586|
  816|    586|                let position = encode_variable(encoded_variables, variable);
  817|    586|                let expression =
  818|    586|                    self.expression_evaluator(expression, encoded_variables, stat_children);
  819|    586|                Rc::new(move |from| {
  820|       |                    let expression = Rc::clone(&expression);
  821|       |                    Box::new(child(from).map(move |tuple| {
  822|       |                        let mut tuple = tuple?;
  823|       |                        if let Some(value) = expression(&tuple) {
  824|       |                            tuple.set(position, value);
  825|       |                        }
  826|       |                        Ok(tuple)
  827|       |                    }))
  828|    586|                })
  829|       |            }
  830|      0|            GraphPattern::OrderBy { inner, expression } => {
  831|      0|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  832|      0|                stat_children.push(child_stats);
  833|      0|                let by = expression
  834|      0|                    .iter()
  835|      0|                    .map(|comp| match comp {
  836|       |                        OrderExpression::Asc(expression) => ComparatorFunction::Asc(
  837|       |                            self.expression_evaluator(expression, encoded_variables, stat_children),
  838|       |                        ),
  839|       |                        OrderExpression::Desc(expression) => ComparatorFunction::Desc(
  840|       |                            self.expression_evaluator(expression, encoded_variables, stat_children),
  841|       |                        ),
  842|      0|                    })
  843|      0|                    .collect::<Vec<_>>();
  844|      0|                let dataset = Rc::clone(&self.dataset);
  845|      0|                Rc::new(move |from| {
  846|       |                    let mut errors = Vec::default();
  847|       |                    let mut values = child(from)
  848|       |                        .filter_map(|result| match result {
  849|       |                            Ok(result) => Some(result),
  850|       |                            Err(error) => {
  851|       |                                errors.push(Err(error));
  852|       |                                None
  853|       |                            }
  854|       |                        })
  855|       |                        .collect::<Vec<_>>();
  856|       |                    values.sort_unstable_by(|a, b| {
  857|       |                        for comp in &by {
  858|       |                            match comp {
  859|       |                                ComparatorFunction::Asc(expression) => {
  860|       |                                    match cmp_terms(
  861|       |                                        &dataset,
  862|       |                                        expression(a).as_ref(),
  863|       |                                        expression(b).as_ref(),
  864|       |                                    ) {
  865|       |                                        Ordering::Greater => return Ordering::Greater,
  866|       |                                        Ordering::Less => return Ordering::Less,
  867|       |                                        Ordering::Equal => (),
  868|       |                                    }
  869|       |                                }
  870|       |                                ComparatorFunction::Desc(expression) => {
  871|       |                                    match cmp_terms(
  872|       |                                        &dataset,
  873|       |                                        expression(a).as_ref(),
  874|       |                                        expression(b).as_ref(),
  875|       |                                    ) {
  876|       |                                        Ordering::Greater => return Ordering::Less,
  877|       |                                        Ordering::Less => return Ordering::Greater,
  878|       |                                        Ordering::Equal => (),
  879|       |                                    }
  880|       |                                }
  881|       |                            }
  882|       |                        }
  883|       |                        Ordering::Equal
  884|       |                    });
  885|       |                    Box::new(errors.into_iter().chain(values.into_iter().map(Ok)))
  886|      0|                })
  887|       |            }
  888|  1.54k|            GraphPattern::Distinct { inner } => {
  889|  1.54k|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  890|  1.54k|                stat_children.push(child_stats);
  891|  1.54k|                Rc::new(move |from| Box::new(hash_deduplicate(child(from))))
  892|       |            }
  893|  2.42k|            GraphPattern::Reduced { inner } => {
  894|  2.42k|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  895|  2.42k|                stat_children.push(child_stats);
  896|  2.42k|                Rc::new(move |from| {
  897|       |                    Box::new(ConsecutiveDeduplication {
  898|       |                        inner: child(from),
  899|       |                        current: None,
  900|       |                    })
  901|  2.42k|                })
  902|       |            }
  903|       |            GraphPattern::Slice {
  904|      0|                inner,
  905|      0|                start,
  906|      0|                length,
  907|      0|            } => {
  908|      0|                let (mut child, child_stats) =
  909|      0|                    self.graph_pattern_evaluator(inner, encoded_variables);
  910|      0|                stat_children.push(child_stats);
  911|      0|                #[allow(clippy::shadow_same)]
  912|      0|                let start = *start;
  913|      0|                if start > 0 {
  914|      0|                    child = Rc::new(move |from| Box::new(child(from).skip(start)));
  915|      0|                }
  916|      0|                if let Some(length) = *length {
  917|      0|                    child = Rc::new(move |from| Box::new(child(from).take(length)));
  918|      0|                }
  919|      0|                child
  920|       |            }
  921|  2.00k|            GraphPattern::Project { inner, variables } => {
  922|  2.00k|                let mut inner_encoded_variables = variables.clone();
  923|  2.00k|                let (child, child_stats) =
  924|  2.00k|                    self.graph_pattern_evaluator(inner, &mut inner_encoded_variables);
  925|  2.00k|                stat_children.push(child_stats);
  926|  2.00k|                let mapping = variables
  927|  2.00k|                    .iter()
  928|  2.00k|                    .enumerate()
  929|  2.00k|                    .map(|(new_variable, variable)| {
  930|       |                        (new_variable, encode_variable(encoded_variables, variable))
  931|  2.00k|                    })
  932|  2.00k|                    .collect::<Rc<[(usize, usize)]>>();
  933|  2.00k|                Rc::new(move |from| {
  934|       |                    let mapping = Rc::clone(&mapping);
  935|       |                    let mut input_tuple = EncodedTuple::with_capacity(mapping.len());
  936|       |                    for (input_key, output_key) in &*mapping {
  937|       |                        if let Some(value) = from.get(*output_key) {
  938|       |                            input_tuple.set(*input_key, value.clone());
  939|       |                        }
  940|       |                    }
  941|       |                    Box::new(child(input_tuple).filter_map(move |tuple| {
  942|       |                        match tuple {
  943|       |                            Ok(tuple) => {
  944|       |                                let mut output_tuple = from.clone();
  945|       |                                for (input_key, output_key) in &*mapping {
  946|       |                                    if let Some(value) = tuple.get(*input_key) {
  947|       |                                        if let Some(existing_value) = output_tuple.get(*output_key)
  948|       |                                        {
  949|       |                                            if existing_value != value {
  950|       |                                                return None; // Conflict
  951|       |                                            }
  952|       |                                        } else {
  953|       |                                            output_tuple.set(*output_key, value.clone());
  954|       |                                        }
  955|       |                                    }
  956|       |                                }
  957|       |                                Some(Ok(output_tuple))
  958|       |                            }
  959|       |                            Err(e) => Some(Err(e)),
  960|       |                        }
  961|       |                    }))
  962|  2.00k|                })
  963|       |            }
  964|       |            GraphPattern::Group {
  965|     12|                inner,
  966|     12|                aggregates,
  967|     12|                variables,
  968|     12|            } => {
  969|     12|                let (child, child_stats) = self.graph_pattern_evaluator(inner, encoded_variables);
  970|     12|                stat_children.push(child_stats);
  971|     12|                let key_variables = variables
  972|     12|                    .iter()
  973|     12|                    .map(|k| encode_variable(encoded_variables, k))
  974|     12|                    .collect::<Rc<[_]>>();
  975|     12|                let aggregate_input_expressions = aggregates
  976|     12|                    .iter()
  977|     12|                    .map(|(_, expression)| match expression {
  978|       |                        AggregateExpression::CountSolutions { .. } => None,
  979|       |                        AggregateExpression::FunctionCall { expr, .. } => {
  980|       |                            Some(self.expression_evaluator(expr, encoded_variables, stat_children))
  981|       |                        }
  982|     12|                    })
  983|     12|                    .collect::<Vec<_>>();
  984|     12|                let accumulator_builders = aggregates
  985|     12|                    .iter()
  986|     12|                    .map(|(_, aggregate)| Self::accumulator_builder(&self.dataset, aggregate))
  987|     12|                    .collect::<Vec<_>>();
  988|     12|                let accumulator_variables = aggregates
  989|     12|                    .iter()
  990|     12|                    .map(|(variable, _)| encode_variable(encoded_variables, variable))
  991|     12|                    .collect::<Vec<_>>();
  992|     12|                Rc::new(move |from| {
  993|       |                    let tuple_size = from.capacity();
  994|       |                    let key_variables = Rc::clone(&key_variables);
  995|       |                    let mut errors = Vec::default();
  996|       |                    let mut accumulators_for_group =
  997|       |                        HashMap::<Vec<Option<EncodedTerm>>, Vec<Box<dyn Accumulator>>>::default();
  998|       |                    if key_variables.is_empty() {
  999|       |                        // There is always a single group if there is no GROUP BY
 1000|       |                        accumulators_for_group.insert(
 1001|       |                            Vec::new(),
 1002|       |                            accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>(),
 1003|       |                        );
 1004|       |                    }
 1005|       |                    child(from)
 1006|       |                        .filter_map(|result| match result {
 1007|       |                            Ok(result) => Some(result),
 1008|       |                            Err(error) => {
 1009|       |                                errors.push(error);
 1010|       |                                None
 1011|       |                            }
 1012|       |                        })
 1013|       |                        .for_each(|tuple| {
 1014|       |                            // TODO avoid copy for key?
 1015|       |                            let key = key_variables
 1016|       |                                .iter()
 1017|       |                                .map(|v| tuple.get(*v).cloned())
 1018|       |                                .collect();
 1019|       |
 1020|       |                            let key_accumulators =
 1021|       |                                accumulators_for_group.entry(key).or_insert_with(|| {
 1022|       |                                    accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>()
 1023|       |                                });
 1024|       |                            for (accumulator, input_expression) in key_accumulators
 1025|       |                                .iter_mut()
 1026|       |                                .zip(&aggregate_input_expressions)
 1027|       |                            {
 1028|       |                                accumulator.add(
 1029|       |                                    input_expression
 1030|       |                                        .as_ref()
 1031|       |                                        .and_then(|parameter| parameter(&tuple)),
 1032|       |                                );
 1033|       |                            }
 1034|       |                        });
 1035|       |                    let accumulator_variables = accumulator_variables.clone();
 1036|       |                    Box::new(
 1037|       |                        errors
 1038|       |                            .into_iter()
 1039|       |                            .map(Err)
 1040|       |                            .chain(accumulators_for_group.into_iter().map(
 1041|       |                                move |(key, accumulators)| {
 1042|       |                                    let mut result = EncodedTuple::with_capacity(tuple_size);
 1043|       |                                    for (variable, value) in key_variables.iter().zip(key) {
 1044|       |                                        if let Some(value) = value {
 1045|       |                                            result.set(*variable, value);
 1046|       |                                        }
 1047|       |                                    }
 1048|       |                                    for (accumulator, variable) in
 1049|       |                                        accumulators.into_iter().zip(&accumulator_variables)
 1050|       |                                    {
 1051|       |                                        if let Some(value) = accumulator.state() {
 1052|       |                                            result.set(*variable, value);
 1053|       |                                        }
 1054|       |                                    }
 1055|       |                                    Ok(result)
 1056|       |                                },
 1057|       |                            )),
 1058|       |                    )
 1059|     12|                })
 1060|       |            }
 1061|       |        }
 1062|   104k|    }
_RNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15EncodedTupleSet3get:
 5608|    289|    fn get(&self, tuple: &EncodedTuple) -> &[EncodedTuple] {
 5609|    289|        self.map.get(&self.tuple_key(tuple)).map_or(&[], |v| v)
 5610|    289|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval15eval_node_label:
 5713|   104k|fn eval_node_label(node: &GraphPattern) -> String {
 5714|   104k|    match node {
 5715|  1.54k|        GraphPattern::Distinct { .. } => "Distinct(Hash)".to_owned(),
 5716|       |        GraphPattern::Extend {
 5717|    586|            expression,
 5718|    586|            variable,
 5719|    586|            ..
 5720|    586|        } => format!(
 5721|    586|            "Extend({} -> {variable})",
 5722|    586|            spargebra::algebra::Expression::from(expression)
 5723|    586|        ),
 5724|     44|        GraphPattern::Filter { expression, .. } => format!(
 5725|     44|            "Filter({})",
 5726|     44|            spargebra::algebra::Expression::from(expression)
 5727|     44|        ),
 5728|       |        GraphPattern::Group {
 5729|     12|            variables,
 5730|     12|            aggregates,
 5731|     12|            ..
 5732|     12|        } => {
 5733|     12|            format!(
 5734|     12|                "Aggregate({})",
 5735|     12|                format_list(variables.iter().map(ToString::to_string).chain(
 5736|     12|                    aggregates.iter().map(|(v, agg)| format!(
 5737|       |                        "{} -> {v}",
 5738|       |                        spargebra::algebra::AggregateExpression::from(agg)
 5739|     12|                    ))
 5740|     12|                ))
 5741|     12|            )
 5742|       |        }
 5743|  24.2k|        GraphPattern::Join { algorithm, .. } => match algorithm {
 5744|  24.2k|            JoinAlgorithm::HashBuildLeftProbeRight { keys } => format!(
 5745|  24.2k|                "LeftJoin(HashBuildLeftProbeRight, keys = {})",
 5746|  24.2k|                format_list(keys)
 5747|  24.2k|            ),
 5748|       |        },
 5749|  22.0k|        GraphPattern::Lateral { right, .. } => {
 5750|       |            if let GraphPattern::LeftJoin {
 5751|     38|                left: nested_left,
 5752|     38|                expression,
 5753|       |                ..
 5754|  22.0k|            } = right.as_ref()
 5755|       |            {
 5756|     38|                if nested_left.is_empty_singleton() {
 5757|       |                    // We are in a ForLoopLeftJoin
 5758|     37|                    return format!(
 5759|     37|                        "ForLoopLeftJoin(expression = {})",
 5760|     37|                        spargebra::algebra::Expression::from(expression)
 5761|     37|                    );
 5762|      1|                }
 5763|  21.9k|            }
 5764|  21.9k|            "Lateral".to_owned()
 5765|       |        }
 5766|       |        GraphPattern::LeftJoin {
 5767|    366|            algorithm,
 5768|    366|            expression,
 5769|    366|            ..
 5770|    366|        } => match algorithm {
 5771|    366|            LeftJoinAlgorithm::HashBuildRightProbeLeft { keys } => format!(
 5772|    366|                "LeftJoin(HashBuildRightProbeLeft, keys = {}, expression = {})",
 5773|    366|                format_list(keys),
 5774|    366|                spargebra::algebra::Expression::from(expression)
 5775|    366|            ),
 5776|       |        },
 5777|     40|        GraphPattern::Minus { algorithm, .. } => match algorithm {
 5778|     40|            MinusAlgorithm::HashBuildRightProbeLeft { keys } => format!(
 5779|     40|                "AntiJoin(HashBuildRightProbeLeft, keys = {})",
 5780|     40|                format_list(keys)
 5781|     40|            ),
 5782|       |        },
 5783|      0|        GraphPattern::OrderBy { expression, .. } => {
 5784|      0|            format!(
 5785|      0|                "Sort({})",
 5786|      0|                format_list(
 5787|      0|                    expression
 5788|      0|                        .iter()
 5789|      0|                        .map(spargebra::algebra::OrderExpression::from)
 5790|      0|                )
 5791|      0|            )
 5792|       |        }
 5793|       |        GraphPattern::Path {
 5794|  11.9k|            subject,
 5795|  11.9k|            path,
 5796|  11.9k|            object,
 5797|  11.9k|            graph_name,
 5798|       |        } => {
 5799|  11.9k|            if let Some(graph_name) = graph_name {
 5800|    718|                format!("Path({subject} {path} {object} {graph_name})")
 5801|       |            } else {
 5802|  11.2k|                format!("Path({subject} {path} {object})")
 5803|       |            }
 5804|       |        }
 5805|  2.00k|        GraphPattern::Project { variables, .. } => {
 5806|  2.00k|            format!("Project({})", format_list(variables))
 5807|       |        }
 5808|       |        GraphPattern::QuadPattern {
 5809|  37.3k|            subject,
 5810|  37.3k|            predicate,
 5811|  37.3k|            object,
 5812|  37.3k|            graph_name,
 5813|       |        } => {
 5814|  37.3k|            if let Some(graph_name) = graph_name {
 5815|  5.50k|                format!("QuadPattern({subject} {predicate} {object} {graph_name})")
 5816|       |            } else {
 5817|  31.8k|                format!("QuadPattern({subject} {predicate} {object})")
 5818|       |            }
 5819|       |        }
 5820|  2.42k|        GraphPattern::Reduced { .. } => "Reduced".to_owned(),
 5821|      0|        GraphPattern::Service { name, silent, .. } => {
 5822|      0|            if *silent {
 5823|      0|                format!("Service({name}, Silent)")
 5824|       |            } else {
 5825|      0|                format!("Service({name})")
 5826|       |            }
 5827|       |        }
 5828|      0|        GraphPattern::Slice { start, length, .. } => {
 5829|      0|            if let Some(length) = length {
 5830|      0|                format!("Slice(start = {start}, length = {length})")
 5831|       |            } else {
 5832|      0|                format!("Slice(start = {start})")
 5833|       |            }
 5834|       |        }
 5835|     38|        GraphPattern::Union { .. } => "Union".to_owned(),
 5836|  2.35k|        GraphPattern::Values { variables, .. } => {
 5837|  2.35k|            format!("StaticBindings({})", format_list(variables))
 5838|       |        }
 5839|       |    }
 5840|   104k|}
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13TupleSelector23from_graph_name_pattern:
 3882|  49.3k|    fn from_graph_name_pattern(
 3883|  49.3k|        graph_name_pattern: &Option<NamedNodePattern>,
 3884|  49.3k|        variables: &mut Vec<Variable>,
 3885|  49.3k|        dataset: &DatasetView,
 3886|  49.3k|    ) -> Self {
 3887|  49.3k|        if let Some(graph_name_pattern) = graph_name_pattern {
 3888|  6.22k|            Self::from_named_node_pattern(graph_name_pattern, variables, dataset)
 3889|       |        } else {
 3890|  43.1k|            Self::Constant(EncodedTerm::DefaultGraph)
 3891|       |        }
 3892|  49.3k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval17put_pattern_value:
 3916|    294|fn put_pattern_value(
 3917|    294|    selector: &TupleSelector,
 3918|    294|    value: EncodedTerm,
 3919|    294|    tuple: &mut EncodedTuple,
 3920|    294|) -> Option<()> {
 3921|    294|    match selector {
 3922|     75|        TupleSelector::Constant(c) => (*c == value).then_some(()),
 3923|    219|        TupleSelector::Variable(v) => {
 3924|    219|            if let Some(old) = tuple.get(*v) {
 3925|      5|                (value == *old).then_some(())
 3926|       |            } else {
 3927|    214|                tuple.set(*v, value);
 3928|    214|                Some(())
 3929|       |            }
 3930|       |        }
 3931|      0|        TupleSelector::TriplePattern(triple) => {
 3932|      0|            if let EncodedTerm::Triple(value) = value {
 3933|      0|                put_pattern_value(&triple.subject, value.subject.clone(), tuple)?;
 3934|      0|                put_pattern_value(&triple.predicate, value.predicate.clone(), tuple)?;
 3935|      0|                put_pattern_value(&triple.object, value.object.clone(), tuple)
 3936|       |            } else {
 3937|      0|                None
 3938|       |            }
 3939|       |        }
 3940|       |    }
 3941|    294|}
_RNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15SimpleEvaluator20expression_evaluator:
 1138|  21.4k|    fn expression_evaluator(
 1139|  21.4k|        &self,
 1140|  21.4k|        expression: &Expression,
 1141|  21.4k|        encoded_variables: &mut Vec<Variable>,
 1142|  21.4k|        stat_children: &mut Vec<Rc<EvalNodeWithStats>>,
 1143|  21.4k|    ) -> Rc<dyn Fn(&EncodedTuple) -> Option<EncodedTerm>> {
 1144|  21.4k|        match expression {
 1145|    580|            Expression::NamedNode(t) => {
 1146|    580|                let t = self.encode_term(t);
 1147|    580|                Rc::new(move |_| Some(t.clone()))
 1148|       |            }
 1149|  3.91k|            Expression::Literal(t) => {
 1150|  3.91k|                let t = self.encode_term(t);
 1151|  3.91k|                Rc::new(move |_| Some(t.clone()))
 1152|       |            }
 1153|  4.36k|            Expression::Variable(v) => {
 1154|  4.36k|                let v = encode_variable(encoded_variables, v);
 1155|  4.36k|                Rc::new(move |tuple| tuple.get(v).cloned())
 1156|       |            }
 1157|    188|            Expression::Bound(v) => {
 1158|    188|                let v = encode_variable(encoded_variables, v);
 1159|    188|                Rc::new(move |tuple| Some(tuple.contains(v).into()))
 1160|       |            }
 1161|    126|            Expression::Exists(plan) => {
 1162|    126|                let (eval, stats) = self.graph_pattern_evaluator(plan, encoded_variables);
 1163|    126|                stat_children.push(stats);
 1164|    126|                Rc::new(move |tuple| Some(eval(tuple.clone()).next().is_some().into()))
 1165|       |            }
 1166|     30|            Expression::Or(inner) => {
 1167|     30|                let children = inner
 1168|     30|                    .iter()
 1169|     30|                    .map(|i| self.expression_evaluator(i, encoded_variables, stat_children))
 1170|     30|                    .collect::<Rc<[_]>>();
 1171|     30|                Rc::new(move |tuple| {
 1172|       |                    let mut error = false;
 1173|       |                    for child in &*children {
 1174|       |                        match child(tuple).and_then(|v| to_bool(&v)) {
 1175|       |                            Some(true) => return Some(true.into()),
 1176|       |                            Some(false) => continue,
 1177|       |                            None => error = true,
 1178|       |                        }
 1179|       |                    }
 1180|       |                    if error {
 1181|       |                        None
 1182|       |                    } else {
 1183|       |                        Some(false.into())
 1184|       |                    }
 1185|     30|                })
 1186|       |            }
 1187|    260|            Expression::And(inner) => {
 1188|    260|                let children = inner
 1189|    260|                    .iter()
 1190|    260|                    .map(|i| self.expression_evaluator(i, encoded_variables, stat_children))
 1191|    260|                    .collect::<Rc<[_]>>();
 1192|    260|                Rc::new(move |tuple| {
 1193|       |                    let mut error = false;
 1194|       |                    for child in &*children {
 1195|       |                        match child(tuple).and_then(|v| to_bool(&v)) {
 1196|       |                            Some(true) => continue,
 1197|       |                            Some(false) => return Some(false.into()),
 1198|       |                            None => error = true,
 1199|       |                        }
 1200|       |                    }
 1201|       |                    if error {
 1202|       |                        None
 1203|       |                    } else {
 1204|       |                        Some(true.into())
 1205|       |                    }
 1206|    260|                })
 1207|       |            }
 1208|    819|            Expression::Equal(a, b) => {
 1209|    819|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1210|    819|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1211|    819|                Rc::new(move |tuple| equals(&a(tuple)?, &b(tuple)?).map(Into::into))
 1212|       |            }
 1213|      3|            Expression::SameTerm(a, b) => {
 1214|      3|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1215|      3|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1216|      3|                Rc::new(move |tuple| Some((a(tuple)? == b(tuple)?).into()))
 1217|       |            }
 1218|     36|            Expression::Greater(a, b) => {
 1219|     36|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1220|     36|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1221|     36|                let dataset = Rc::clone(&self.dataset);
 1222|     36|                Rc::new(move |tuple| {
 1223|       |                    Some(
 1224|       |                        (partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? == Ordering::Greater)
 1225|       |                            .into(),
 1226|       |                    )
 1227|     36|                })
 1228|       |            }
 1229|    148|            Expression::GreaterOrEqual(a, b) => {
 1230|    148|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1231|    148|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1232|    148|                let dataset = Rc::clone(&self.dataset);
 1233|    148|                Rc::new(move |tuple| {
 1234|       |                    Some(
 1235|       |                        match partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? {
 1236|       |                            Ordering::Greater | Ordering::Equal => true,
 1237|       |                            Ordering::Less => false,
 1238|       |                        }
 1239|       |                        .into(),
 1240|       |                    )
 1241|    148|                })
 1242|       |            }
 1243|     14|            Expression::Less(a, b) => {
 1244|     14|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1245|     14|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1246|     14|                let dataset = Rc::clone(&self.dataset);
 1247|     14|                Rc::new(move |tuple| {
 1248|       |                    Some((partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? == Ordering::Less).into())
 1249|     14|                })
 1250|       |            }
 1251|     26|            Expression::LessOrEqual(a, b) => {
 1252|     26|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1253|     26|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1254|     26|                let dataset = Rc::clone(&self.dataset);
 1255|     26|                Rc::new(move |tuple| {
 1256|       |                    Some(
 1257|       |                        match partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? {
 1258|       |                            Ordering::Less | Ordering::Equal => true,
 1259|       |                            Ordering::Greater => false,
 1260|       |                        }
 1261|       |                        .into(),
 1262|       |                    )
 1263|     26|                })
 1264|       |            }
 1265|    268|            Expression::Add(a, b) => {
 1266|    268|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1267|    268|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1268|    268|                Rc::new(
 1269|    268|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1270|       |                        NumericBinaryOperands::Float(v1, v2) => Some((v1 + v2).into()),
 1271|       |                        NumericBinaryOperands::Double(v1, v2) => Some((v1 + v2).into()),
 1272|       |                        NumericBinaryOperands::Integer(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1273|       |                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1274|       |                        NumericBinaryOperands::Duration(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1275|       |                        NumericBinaryOperands::YearMonthDuration(v1, v2) => {
 1276|       |                            Some(v1.checked_add(v2)?.into())
 1277|       |                        }
 1278|       |                        NumericBinaryOperands::DayTimeDuration(v1, v2) => {
 1279|       |                            Some(v1.checked_add(v2)?.into())
 1280|       |                        }
 1281|       |                        NumericBinaryOperands::DateTimeDuration(v1, v2) => {
 1282|       |                            Some(v1.checked_add_duration(v2)?.into())
 1283|       |                        }
 1284|       |                        NumericBinaryOperands::DateTimeYearMonthDuration(v1, v2) => {
 1285|       |                            Some(v1.checked_add_year_month_duration(v2)?.into())
 1286|       |                        }
 1287|       |                        NumericBinaryOperands::DateTimeDayTimeDuration(v1, v2) => {
 1288|       |                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1289|       |                        }
 1290|       |                        NumericBinaryOperands::DateDuration(v1, v2) => {
 1291|       |                            Some(v1.checked_add_duration(v2)?.into())
 1292|       |                        }
 1293|       |                        NumericBinaryOperands::DateYearMonthDuration(v1, v2) => {
 1294|       |                            Some(v1.checked_add_year_month_duration(v2)?.into())
 1295|       |                        }
 1296|       |                        NumericBinaryOperands::DateDayTimeDuration(v1, v2) => {
 1297|       |                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1298|       |                        }
 1299|       |                        NumericBinaryOperands::TimeDuration(v1, v2) => {
 1300|       |                            Some(v1.checked_add_duration(v2)?.into())
 1301|       |                        }
 1302|       |                        NumericBinaryOperands::TimeDayTimeDuration(v1, v2) => {
 1303|       |                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1304|       |                        }
 1305|       |                        NumericBinaryOperands::DateTime(_, _)
 1306|       |                        | NumericBinaryOperands::Time(_, _)
 1307|       |                        | NumericBinaryOperands::Date(_, _) => None,
 1308|    268|                    },
 1309|    268|                )
 1310|       |            }
 1311|  1.62k|            Expression::Subtract(a, b) => {
 1312|  1.62k|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1313|  1.62k|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1314|  1.62k|                Rc::new(move |tuple| {
 1315|       |                    Some(match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1316|       |                        NumericBinaryOperands::Float(v1, v2) => (v1 - v2).into(),
 1317|       |                        NumericBinaryOperands::Double(v1, v2) => (v1 - v2).into(),
 1318|       |                        NumericBinaryOperands::Integer(v1, v2) => v1.checked_sub(v2)?.into(),
 1319|       |                        NumericBinaryOperands::Decimal(v1, v2) => v1.checked_sub(v2)?.into(),
 1320|       |                        NumericBinaryOperands::DateTime(v1, v2) => v1.checked_sub(v2)?.into(),
 1321|       |                        NumericBinaryOperands::Date(v1, v2) => v1.checked_sub(v2)?.into(),
 1322|       |                        NumericBinaryOperands::Time(v1, v2) => v1.checked_sub(v2)?.into(),
 1323|       |                        NumericBinaryOperands::Duration(v1, v2) => v1.checked_sub(v2)?.into(),
 1324|       |                        NumericBinaryOperands::YearMonthDuration(v1, v2) => {
 1325|       |                            v1.checked_sub(v2)?.into()
 1326|       |                        }
 1327|       |                        NumericBinaryOperands::DayTimeDuration(v1, v2) => {
 1328|       |                            v1.checked_sub(v2)?.into()
 1329|       |                        }
 1330|       |                        NumericBinaryOperands::DateTimeDuration(v1, v2) => {
 1331|       |                            v1.checked_sub_duration(v2)?.into()
 1332|       |                        }
 1333|       |                        NumericBinaryOperands::DateTimeYearMonthDuration(v1, v2) => {
 1334|       |                            v1.checked_sub_year_month_duration(v2)?.into()
 1335|       |                        }
 1336|       |                        NumericBinaryOperands::DateTimeDayTimeDuration(v1, v2) => {
 1337|       |                            v1.checked_sub_day_time_duration(v2)?.into()
 1338|       |                        }
 1339|       |                        NumericBinaryOperands::DateDuration(v1, v2) => {
 1340|       |                            v1.checked_sub_duration(v2)?.into()
 1341|       |                        }
 1342|       |                        NumericBinaryOperands::DateYearMonthDuration(v1, v2) => {
 1343|       |                            v1.checked_sub_year_month_duration(v2)?.into()
 1344|       |                        }
 1345|       |                        NumericBinaryOperands::DateDayTimeDuration(v1, v2) => {
 1346|       |                            v1.checked_sub_day_time_duration(v2)?.into()
 1347|       |                        }
 1348|       |                        NumericBinaryOperands::TimeDuration(v1, v2) => {
 1349|       |                            v1.checked_sub_duration(v2)?.into()
 1350|       |                        }
 1351|       |                        NumericBinaryOperands::TimeDayTimeDuration(v1, v2) => {
 1352|       |                            v1.checked_sub_day_time_duration(v2)?.into()
 1353|       |                        }
 1354|       |                    })
 1355|  1.62k|                })
 1356|       |            }
 1357|    580|            Expression::Multiply(a, b) => {
 1358|    580|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1359|    580|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1360|    580|                Rc::new(
 1361|    580|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1362|       |                        NumericBinaryOperands::Float(v1, v2) => Some((v1 * v2).into()),
 1363|       |                        NumericBinaryOperands::Double(v1, v2) => Some((v1 * v2).into()),
 1364|       |                        NumericBinaryOperands::Integer(v1, v2) => Some(v1.checked_mul(v2)?.into()),
 1365|       |                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_mul(v2)?.into()),
 1366|       |                        _ => None,
 1367|    580|                    },
 1368|    580|                )
 1369|       |            }
 1370|  3.07k|            Expression::Divide(a, b) => {
 1371|  3.07k|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1372|  3.07k|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1373|  3.07k|                Rc::new(
 1374|  3.07k|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1375|       |                        NumericBinaryOperands::Float(v1, v2) => Some((v1 / v2).into()),
 1376|       |                        NumericBinaryOperands::Double(v1, v2) => Some((v1 / v2).into()),
 1377|       |                        NumericBinaryOperands::Integer(v1, v2) => {
 1378|       |                            Some(Decimal::from(v1).checked_div(v2)?.into())
 1379|       |                        }
 1380|       |                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_div(v2)?.into()),
 1381|       |                        _ => None,
 1382|  3.07k|                    },
 1383|  3.07k|                )
 1384|       |            }
 1385|    310|            Expression::UnaryPlus(e) => {
 1386|    310|                let e = self.expression_evaluator(e, encoded_variables, stat_children);
 1387|    310|                Rc::new(move |tuple| match e(tuple)? {
 1388|       |                    EncodedTerm::FloatLiteral(value) => Some(value.into()),
 1389|       |                    EncodedTerm::DoubleLiteral(value) => Some(value.into()),
 1390|       |                    EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 1391|       |                    EncodedTerm::DecimalLiteral(value) => Some(value.into()),
 1392|       |                    EncodedTerm::DurationLiteral(value) => Some(value.into()),
 1393|       |                    EncodedTerm::YearMonthDurationLiteral(value) => Some(value.into()),
 1394|       |                    EncodedTerm::DayTimeDurationLiteral(value) => Some(value.into()),
 1395|       |                    _ => None,
 1396|    310|                })
 1397|       |            }
 1398|  2.14k|            Expression::UnaryMinus(e) => {
 1399|  2.14k|                let e = self.expression_evaluator(e, encoded_variables, stat_children);
 1400|  2.14k|                Rc::new(move |tuple| match e(tuple)? {
 1401|       |                    EncodedTerm::FloatLiteral(value) => Some((-value).into()),
 1402|       |                    EncodedTerm::DoubleLiteral(value) => Some((-value).into()),
 1403|       |                    EncodedTerm::IntegerLiteral(value) => Some(value.checked_neg()?.into()),
 1404|       |                    EncodedTerm::DecimalLiteral(value) => Some(value.checked_neg()?.into()),
 1405|       |                    EncodedTerm::DurationLiteral(value) => Some(value.checked_neg()?.into()),
 1406|       |                    EncodedTerm::YearMonthDurationLiteral(value) => {
 1407|       |                        Some(value.checked_neg()?.into())
 1408|       |                    }
 1409|       |                    EncodedTerm::DayTimeDurationLiteral(value) => Some(value.checked_neg()?.into()),
 1410|       |                    _ => None,
 1411|  2.14k|                })
 1412|       |            }
 1413|  2.10k|            Expression::Not(e) => {
 1414|  2.10k|                let e = self.expression_evaluator(e, encoded_variables, stat_children);
 1415|  2.10k|                Rc::new(move |tuple| to_bool(&e(tuple)?).map(|v| (!v).into()))
 1416|       |            }
 1417|     80|            Expression::Coalesce(l) => {
 1418|     80|                let l: Vec<_> = l
 1419|     80|                    .iter()
 1420|     80|                    .map(|e| self.expression_evaluator(e, encoded_variables, stat_children))
 1421|     80|                    .collect();
 1422|     80|                Rc::new(move |tuple| {
 1423|       |                    for e in &l {
 1424|       |                        if let Some(result) = e(tuple) {
 1425|       |                            return Some(result);
 1426|       |                        }
 1427|       |                    }
 1428|       |                    None
 1429|     80|                })
 1430|       |            }
 1431|    672|            Expression::If(a, b, c) => {
 1432|    672|                let a = self.expression_evaluator(a, encoded_variables, stat_children);
 1433|    672|                let b = self.expression_evaluator(b, encoded_variables, stat_children);
 1434|    672|                let c = self.expression_evaluator(c, encoded_variables, stat_children);
 1435|    672|                Rc::new(move |tuple| {
 1436|       |                    if to_bool(&a(tuple)?)? {
 1437|       |                        b(tuple)
 1438|       |                    } else {
 1439|       |                        c(tuple)
 1440|       |                    }
 1441|    672|                })
 1442|       |            }
 1443|     58|            Expression::FunctionCall(function, parameters) => {
 1444|     58|                match function {
 1445|       |                    Function::Str => {
 1446|     10|                        let e = self.expression_evaluator(
 1447|     10|                            &parameters[0],
 1448|     10|                            encoded_variables,
 1449|     10|                            stat_children,
 1450|     10|                        );
 1451|     10|                        let dataset = Rc::clone(&self.dataset);
 1452|     10|                        Rc::new(move |tuple| {
 1453|       |                            Some(build_string_literal_from_id(to_string_id(
 1454|       |                                &dataset,
 1455|       |                                &e(tuple)?,
 1456|       |                            )?))
 1457|     10|                        })
 1458|       |                    }
 1459|       |                    Function::Lang => {
 1460|      6|                        let e = self.expression_evaluator(
 1461|      6|                            &parameters[0],
 1462|      6|                            encoded_variables,
 1463|      6|                            stat_children,
 1464|      6|                        );
 1465|      6|                        let dataset = Rc::clone(&self.dataset);
 1466|      6|                        Rc::new(move |tuple| match e(tuple)? {
 1467|       |                            EncodedTerm::SmallSmallLangStringLiteral { language, .. }
 1468|       |                            | EncodedTerm::BigSmallLangStringLiteral { language, .. } => {
 1469|       |                                Some(build_string_literal_from_id(language.into()))
 1470|       |                            }
 1471|       |                            EncodedTerm::SmallBigLangStringLiteral { language_id, .. }
 1472|       |                            | EncodedTerm::BigBigLangStringLiteral { language_id, .. } => {
 1473|       |                                Some(build_string_literal_from_id(language_id.into()))
 1474|       |                            }
 1475|       |                            e if e.is_literal() => Some(build_string_literal(&dataset, "")),
 1476|       |                            _ => None,
 1477|      6|                        })
 1478|       |                    }
 1479|       |                    Function::LangMatches => {
 1480|      0|                        let language_tag = self.expression_evaluator(
 1481|      0|                            &parameters[0],
 1482|      0|                            encoded_variables,
 1483|      0|                            stat_children,
 1484|      0|                        );
 1485|      0|                        let language_range = self.expression_evaluator(
 1486|      0|                            &parameters[1],
 1487|      0|                            encoded_variables,
 1488|      0|                            stat_children,
 1489|      0|                        );
 1490|      0|                        let dataset = Rc::clone(&self.dataset);
 1491|      0|                        Rc::new(move |tuple| {
 1492|       |                            let mut language_tag =
 1493|       |                                to_simple_string(&dataset, &language_tag(tuple)?)?;
 1494|       |                            language_tag.make_ascii_lowercase();
 1495|       |                            let mut language_range =
 1496|       |                                to_simple_string(&dataset, &language_range(tuple)?)?;
 1497|       |                            language_range.make_ascii_lowercase();
 1498|       |                            Some(
 1499|       |                                if &*language_range == "*" {
 1500|       |                                    !language_tag.is_empty()
 1501|       |                                } else {
 1502|       |                                    !ZipLongest::new(
 1503|       |                                        language_range.split('-'),
 1504|       |                                        language_tag.split('-'),
 1505|       |                                    )
 1506|       |                                    .any(|parts| match parts {
 1507|       |                                        (Some(range_subtag), Some(language_subtag)) => {
 1508|       |                                            range_subtag != language_subtag
 1509|       |                                        }
 1510|       |                                        (Some(_), None) => true,
 1511|       |                                        (None, _) => false,
 1512|       |                                    })
 1513|       |                                }
 1514|       |                                .into(),
 1515|       |                            )
 1516|      0|                        })
 1517|       |                    }
 1518|       |                    Function::Datatype => {
 1519|      2|                        let e = self.expression_evaluator(
 1520|      2|                            &parameters[0],
 1521|      2|                            encoded_variables,
 1522|      2|                            stat_children,
 1523|      2|                        );
 1524|      2|                        let dataset = Rc::clone(&self.dataset);
 1525|      2|                        Rc::new(move |tuple| datatype(&dataset, &e(tuple)?))
 1526|       |                    }
 1527|       |                    Function::Iri => {
 1528|      4|                        let e = self.expression_evaluator(
 1529|      4|                            &parameters[0],
 1530|      4|                            encoded_variables,
 1531|      4|                            stat_children,
 1532|      4|                        );
 1533|      4|                        let dataset = Rc::clone(&self.dataset);
 1534|      4|                        let base_iri = self.base_iri.clone();
 1535|      4|                        Rc::new(move |tuple| {
 1536|       |                            let e = e(tuple)?;
 1537|       |                            if e.is_named_node() {
 1538|       |                                Some(e)
 1539|       |                            } else {
 1540|       |                                let iri = to_simple_string(&dataset, &e)?;
 1541|       |                                Some(build_named_node(
 1542|       |                                    &dataset,
 1543|       |                                    &if let Some(base_iri) = &base_iri {
 1544|       |                                        base_iri.resolve(&iri)
 1545|       |                                    } else {
 1546|       |                                        Iri::parse(iri)
 1547|       |                                    }
 1548|       |                                    .ok()?
 1549|       |                                    .into_inner(),
 1550|       |                                ))
 1551|       |                            }
 1552|      4|                        })
 1553|       |                    }
 1554|      8|                    Function::BNode => match parameters.first() {
 1555|      8|                        Some(id) => {
 1556|      8|                            let id =
 1557|      8|                                self.expression_evaluator(id, encoded_variables, stat_children);
 1558|      8|                            let dataset = Rc::clone(&self.dataset);
 1559|      8|                            Rc::new(move |tuple| {
 1560|       |                                Some(
 1561|       |                                    dataset.encode_term(
 1562|       |                                        BlankNode::new(to_simple_string(&dataset, &id(tuple)?)?)
 1563|       |                                            .ok()?
 1564|       |                                            .as_ref(),
 1565|       |                                    ),
 1566|       |                                )
 1567|      8|                            })
 1568|       |                        }
 1569|      0|                        None => Rc::new(|_| {
 1570|       |                            Some(EncodedTerm::NumericalBlankNode {
 1571|       |                                id: random::<u128>(),
 1572|       |                            })
 1573|      0|                        }),
 1574|       |                    },
 1575|      0|                    Function::Rand => Rc::new(|_| Some(random::<f64>().into())),
 1576|       |                    Function::Abs => {
 1577|      0|                        let e = self.expression_evaluator(
 1578|      0|                            &parameters[0],
 1579|      0|                            encoded_variables,
 1580|      0|                            stat_children,
 1581|      0|                        );
 1582|      0|                        Rc::new(move |tuple| match e(tuple)? {
 1583|       |                            EncodedTerm::IntegerLiteral(value) => Some(value.checked_abs()?.into()),
 1584|       |                            EncodedTerm::DecimalLiteral(value) => Some(value.checked_abs()?.into()),
 1585|       |                            EncodedTerm::FloatLiteral(value) => Some(value.abs().into()),
 1586|       |                            EncodedTerm::DoubleLiteral(value) => Some(value.abs().into()),
 1587|       |                            _ => None,
 1588|      0|                        })
 1589|       |                    }
 1590|       |                    Function::Ceil => {
 1591|      0|                        let e = self.expression_evaluator(
 1592|      0|                            &parameters[0],
 1593|      0|                            encoded_variables,
 1594|      0|                            stat_children,
 1595|      0|                        );
 1596|      0|                        Rc::new(move |tuple| match e(tuple)? {
 1597|       |                            EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 1598|       |                            EncodedTerm::DecimalLiteral(value) => {
 1599|       |                                Some(value.checked_ceil()?.into())
 1600|       |                            }
 1601|       |                            EncodedTerm::FloatLiteral(value) => Some(value.ceil().into()),
 1602|       |                            EncodedTerm::DoubleLiteral(value) => Some(value.ceil().into()),
 1603|       |                            _ => None,
 1604|      0|                        })
 1605|       |                    }
 1606|       |                    Function::Floor => {
 1607|      0|                        let e = self.expression_evaluator(
 1608|      0|                            &parameters[0],
 1609|      0|                            encoded_variables,
 1610|      0|                            stat_children,
 1611|      0|                        );
 1612|      0|                        Rc::new(move |tuple| match e(tuple)? {
 1613|       |                            EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 1614|       |                            EncodedTerm::DecimalLiteral(value) => {
 1615|       |                                Some(value.checked_floor()?.into())
 1616|       |                            }
 1617|       |                            EncodedTerm::FloatLiteral(value) => Some(value.floor().into()),
 1618|       |                            EncodedTerm::DoubleLiteral(value) => Some(value.floor().into()),
 1619|       |                            _ => None,
 1620|      0|                        })
 1621|       |                    }
 1622|       |                    Function::Round => {
 1623|      0|                        let e = self.expression_evaluator(
 1624|      0|                            &parameters[0],
 1625|      0|                            encoded_variables,
 1626|      0|                            stat_children,
 1627|      0|                        );
 1628|      0|                        Rc::new(move |tuple| match e(tuple)? {
 1629|       |                            EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 1630|       |                            EncodedTerm::DecimalLiteral(value) => {
 1631|       |                                Some(value.checked_round()?.into())
 1632|       |                            }
 1633|       |                            EncodedTerm::FloatLiteral(value) => Some(value.round().into()),
 1634|       |                            EncodedTerm::DoubleLiteral(value) => Some(value.round().into()),
 1635|       |                            _ => None,
 1636|      0|                        })
 1637|       |                    }
 1638|       |                    Function::Concat => {
 1639|      0|                        let l: Vec<_> = parameters
 1640|      0|                            .iter()
 1641|      0|                            .map(|e| self.expression_evaluator(e, encoded_variables, stat_children))
 1642|      0|                            .collect();
 1643|      0|                        let dataset = Rc::clone(&self.dataset);
 1644|      0|                        Rc::new(move |tuple| {
 1645|       |                            let mut result = String::default();
 1646|       |                            let mut language = None;
 1647|       |                            for e in &l {
 1648|       |                                let (value, e_language) =
 1649|       |                                    to_string_and_language(&dataset, &e(tuple)?)?;
 1650|       |                                if let Some(lang) = language {
 1651|       |                                    if lang != e_language {
 1652|       |                                        language = Some(None)
 1653|       |                                    }
 1654|       |                                } else {
 1655|       |                                    language = Some(e_language)
 1656|       |                                }
 1657|       |                                result += &value
 1658|       |                            }
 1659|       |                            Some(build_plain_literal(
 1660|       |                                &dataset,
 1661|       |                                &result,
 1662|       |                                language.and_then(|v| v),
 1663|       |                            ))
 1664|      0|                        })
 1665|       |                    }
 1666|       |                    Function::SubStr => {
 1667|      0|                        let source = self.expression_evaluator(
 1668|      0|                            &parameters[0],
 1669|      0|                            encoded_variables,
 1670|      0|                            stat_children,
 1671|      0|                        );
 1672|      0|                        let starting_loc = self.expression_evaluator(
 1673|      0|                            &parameters[1],
 1674|      0|                            encoded_variables,
 1675|      0|                            stat_children,
 1676|      0|                        );
 1677|      0|                        let length = parameters.get(2).map(|l| {
 1678|       |                            self.expression_evaluator(l, encoded_variables, stat_children)
 1679|      0|                        });
 1680|      0|                        let dataset = Rc::clone(&self.dataset);
 1681|      0|                        Rc::new(move |tuple| {
 1682|       |                            let (source, language) =
 1683|       |                                to_string_and_language(&dataset, &source(tuple)?)?;
 1684|       |
 1685|       |                            let starting_location: usize =
 1686|       |                                if let EncodedTerm::IntegerLiteral(v) = starting_loc(tuple)? {
 1687|       |                                    i64::from(v).try_into().ok()?
 1688|       |                                } else {
 1689|       |                                    return None;
 1690|       |                                };
 1691|       |                            let length: Option<usize> = if let Some(length) = &length {
 1692|       |                                if let EncodedTerm::IntegerLiteral(v) = length(tuple)? {
 1693|       |                                    Some(i64::from(v).try_into().ok()?)
 1694|       |                                } else {
 1695|       |                                    return None;
 1696|       |                                }
 1697|       |                            } else {
 1698|       |                                None
 1699|       |                            };
 1700|       |
 1701|       |                            // We want to slice on char indices, not byte indices
 1702|       |                            let mut start_iter = source
 1703|       |                                .char_indices()
 1704|       |                                .skip(starting_location.checked_sub(1)?)
 1705|       |                                .peekable();
 1706|       |                            let result =
 1707|       |                                if let Some((start_position, _)) = start_iter.peek().copied() {
 1708|       |                                    if let Some(length) = length {
 1709|       |                                        let mut end_iter = start_iter.skip(length).peekable();
 1710|       |                                        if let Some((end_position, _)) = end_iter.peek() {
 1711|       |                                            &source[start_position..*end_position]
 1712|       |                                        } else {
 1713|       |                                            &source[start_position..]
 1714|       |                                        }
 1715|       |                                    } else {
 1716|       |                                        &source[start_position..]
 1717|       |                                    }
 1718|       |                                } else {
 1719|       |                                    ""
 1720|       |                                };
 1721|       |                            Some(build_plain_literal(&dataset, result, language))
 1722|      0|                        })
 1723|       |                    }
 1724|       |                    Function::StrLen => {
 1725|      0|                        let arg = self.expression_evaluator(
 1726|      0|                            &parameters[0],
 1727|      0|                            encoded_variables,
 1728|      0|                            stat_children,
 1729|      0|                        );
 1730|      0|                        let dataset = Rc::clone(&self.dataset);
 1731|      0|                        Rc::new(move |tuple| {
 1732|       |                            Some(
 1733|       |                                i64::try_from(to_string(&dataset, &arg(tuple)?)?.chars().count())
 1734|       |                                    .ok()?
 1735|       |                                    .into(),
 1736|       |                            )
 1737|      0|                        })
 1738|       |                    }
 1739|       |                    Function::Replace => {
 1740|      0|                        let arg = self.expression_evaluator(
 1741|      0|                            &parameters[0],
 1742|      0|                            encoded_variables,
 1743|      0|                            stat_children,
 1744|      0|                        );
 1745|      0|                        let replacement = self.expression_evaluator(
 1746|      0|                            &parameters[2],
 1747|      0|                            encoded_variables,
 1748|      0|                            stat_children,
 1749|      0|                        );
 1750|      0|                        let dataset = Rc::clone(&self.dataset);
 1751|      0|                        if let Some(regex) =
 1752|      0|                            compile_static_pattern_if_exists(&parameters[1], parameters.get(3))
 1753|       |                        {
 1754|      0|                            Rc::new(move |tuple| {
 1755|       |                                let (text, language) =
 1756|       |                                    to_string_and_language(&dataset, &arg(tuple)?)?;
 1757|       |                                let replacement = to_simple_string(&dataset, &replacement(tuple)?)?;
 1758|       |                                Some(build_plain_literal(
 1759|       |                                    &dataset,
 1760|       |                                    &regex.replace_all(&text, replacement.as_str()),
 1761|       |                                    language,
 1762|       |                                ))
 1763|      0|                            })
 1764|       |                        } else {
 1765|      0|                            let pattern = self.expression_evaluator(
 1766|      0|                                &parameters[1],
 1767|      0|                                encoded_variables,
 1768|      0|                                stat_children,
 1769|      0|                            );
 1770|      0|                            let flags = parameters.get(3).map(|flags| {
 1771|       |                                self.expression_evaluator(flags, encoded_variables, stat_children)
 1772|      0|                            });
 1773|      0|                            Rc::new(move |tuple| {
 1774|       |                                let pattern = to_simple_string(&dataset, &pattern(tuple)?)?;
 1775|       |                                let options = if let Some(flags) = &flags {
 1776|       |                                    Some(to_simple_string(&dataset, &flags(tuple)?)?)
 1777|       |                                } else {
 1778|       |                                    None
 1779|       |                                };
 1780|       |                                let regex = compile_pattern(&pattern, options.as_deref())?;
 1781|       |                                let (text, language) =
 1782|       |                                    to_string_and_language(&dataset, &arg(tuple)?)?;
 1783|       |                                let replacement = to_simple_string(&dataset, &replacement(tuple)?)?;
 1784|       |                                Some(build_plain_literal(
 1785|       |                                    &dataset,
 1786|       |                                    &regex.replace_all(&text, replacement.as_str()),
 1787|       |                                    language,
 1788|       |                                ))
 1789|      0|                            })
 1790|       |                        }
 1791|       |                    }
 1792|       |                    Function::UCase => {
 1793|      0|                        let e = self.expression_evaluator(
 1794|      0|                            &parameters[0],
 1795|      0|                            encoded_variables,
 1796|      0|                            stat_children,
 1797|      0|                        );
 1798|      0|                        let dataset = Rc::clone(&self.dataset);
 1799|      0|                        Rc::new(move |tuple| {
 1800|       |                            let (value, language) = to_string_and_language(&dataset, &e(tuple)?)?;
 1801|       |                            Some(build_plain_literal(
 1802|       |                                &dataset,
 1803|       |                                &value.to_uppercase(),
 1804|       |                                language,
 1805|       |                            ))
 1806|      0|                        })
 1807|       |                    }
 1808|       |                    Function::LCase => {
 1809|      0|                        let e = self.expression_evaluator(
 1810|      0|                            &parameters[0],
 1811|      0|                            encoded_variables,
 1812|      0|                            stat_children,
 1813|      0|                        );
 1814|      0|                        let dataset = Rc::clone(&self.dataset);
 1815|      0|                        Rc::new(move |tuple| {
 1816|       |                            let (value, language) = to_string_and_language(&dataset, &e(tuple)?)?;
 1817|       |                            Some(build_plain_literal(
 1818|       |                                &dataset,
 1819|       |                                &value.to_lowercase(),
 1820|       |                                language,
 1821|       |                            ))
 1822|      0|                        })
 1823|       |                    }
 1824|       |                    Function::StrStarts => {
 1825|      0|                        let arg1 = self.expression_evaluator(
 1826|      0|                            &parameters[0],
 1827|      0|                            encoded_variables,
 1828|      0|                            stat_children,
 1829|      0|                        );
 1830|      0|                        let arg2 = self.expression_evaluator(
 1831|      0|                            &parameters[1],
 1832|      0|                            encoded_variables,
 1833|      0|                            stat_children,
 1834|      0|                        );
 1835|      0|                        let dataset = Rc::clone(&self.dataset);
 1836|      0|                        Rc::new(move |tuple| {
 1837|       |                            let (arg1, arg2, _) = to_argument_compatible_strings(
 1838|       |                                &dataset,
 1839|       |                                &arg1(tuple)?,
 1840|       |                                &arg2(tuple)?,
 1841|       |                            )?;
 1842|       |                            Some(arg1.starts_with(arg2.as_str()).into())
 1843|      0|                        })
 1844|       |                    }
 1845|       |                    Function::EncodeForUri => {
 1846|      0|                        let ltrl = self.expression_evaluator(
 1847|      0|                            &parameters[0],
 1848|      0|                            encoded_variables,
 1849|      0|                            stat_children,
 1850|      0|                        );
 1851|      0|                        let dataset = Rc::clone(&self.dataset);
 1852|      0|                        Rc::new(move |tuple| {
 1853|       |                            let ltlr = to_string(&dataset, &ltrl(tuple)?)?;
 1854|       |                            let mut result = Vec::with_capacity(ltlr.len());
 1855|       |                            for c in ltlr.bytes() {
 1856|       |                                match c {
 1857|       |                                    b'A'..=b'Z'
 1858|       |                                    | b'a'..=b'z'
 1859|       |                                    | b'0'..=b'9'
 1860|       |                                    | b'-'
 1861|       |                                    | b'_'
 1862|       |                                    | b'.'
 1863|       |                                    | b'~' => result.push(c),
 1864|       |                                    _ => {
 1865|       |                                        result.push(b'%');
 1866|       |                                        let high = c / 16;
 1867|       |                                        let low = c % 16;
 1868|       |                                        result.push(if high < 10 {
 1869|       |                                            b'0' + high
 1870|       |                                        } else {
 1871|       |                                            b'A' + (high - 10)
 1872|       |                                        });
 1873|       |                                        result.push(if low < 10 {
 1874|       |                                            b'0' + low
 1875|       |                                        } else {
 1876|       |                                            b'A' + (low - 10)
 1877|       |                                        });
 1878|       |                                    }
 1879|       |                                }
 1880|       |                            }
 1881|       |                            Some(build_string_literal(
 1882|       |                                &dataset,
 1883|       |                                str::from_utf8(&result).ok()?,
 1884|       |                            ))
 1885|      0|                        })
 1886|       |                    }
 1887|       |                    Function::StrEnds => {
 1888|      0|                        let arg1 = self.expression_evaluator(
 1889|      0|                            &parameters[0],
 1890|      0|                            encoded_variables,
 1891|      0|                            stat_children,
 1892|      0|                        );
 1893|      0|                        let arg2 = self.expression_evaluator(
 1894|      0|                            &parameters[1],
 1895|      0|                            encoded_variables,
 1896|      0|                            stat_children,
 1897|      0|                        );
 1898|      0|                        let dataset = Rc::clone(&self.dataset);
 1899|      0|                        Rc::new(move |tuple| {
 1900|       |                            let (arg1, arg2, _) = to_argument_compatible_strings(
 1901|       |                                &dataset,
 1902|       |                                &arg1(tuple)?,
 1903|       |                                &arg2(tuple)?,
 1904|       |                            )?;
 1905|       |                            Some(arg1.ends_with(arg2.as_str()).into())
 1906|      0|                        })
 1907|       |                    }
 1908|       |                    Function::Contains => {
 1909|      0|                        let arg1 = self.expression_evaluator(
 1910|      0|                            &parameters[0],
 1911|      0|                            encoded_variables,
 1912|      0|                            stat_children,
 1913|      0|                        );
 1914|      0|                        let arg2 = self.expression_evaluator(
 1915|      0|                            &parameters[1],
 1916|      0|                            encoded_variables,
 1917|      0|                            stat_children,
 1918|      0|                        );
 1919|      0|                        let dataset = Rc::clone(&self.dataset);
 1920|      0|                        Rc::new(move |tuple| {
 1921|       |                            let (arg1, arg2, _) = to_argument_compatible_strings(
 1922|       |                                &dataset,
 1923|       |                                &arg1(tuple)?,
 1924|       |                                &arg2(tuple)?,
 1925|       |                            )?;
 1926|       |                            Some(arg1.contains(arg2.as_str()).into())
 1927|      0|                        })
 1928|       |                    }
 1929|       |                    Function::StrBefore => {
 1930|      0|                        let arg1 = self.expression_evaluator(
 1931|      0|                            &parameters[0],
 1932|      0|                            encoded_variables,
 1933|      0|                            stat_children,
 1934|      0|                        );
 1935|      0|                        let arg2 = self.expression_evaluator(
 1936|      0|                            &parameters[1],
 1937|      0|                            encoded_variables,
 1938|      0|                            stat_children,
 1939|      0|                        );
 1940|      0|                        let dataset = Rc::clone(&self.dataset);
 1941|      0|                        Rc::new(move |tuple| {
 1942|       |                            let (arg1, arg2, language) = to_argument_compatible_strings(
 1943|       |                                &dataset,
 1944|       |                                &arg1(tuple)?,
 1945|       |                                &arg2(tuple)?,
 1946|       |                            )?;
 1947|       |                            Some(if let Some(position) = arg1.find(arg2.as_str()) {
 1948|       |                                build_plain_literal(&dataset, &arg1[..position], language)
 1949|       |                            } else {
 1950|       |                                build_string_literal(&dataset, "")
 1951|       |                            })
 1952|      0|                        })
 1953|       |                    }
 1954|       |                    Function::StrAfter => {
 1955|      0|                        let arg1 = self.expression_evaluator(
 1956|      0|                            &parameters[0],
 1957|      0|                            encoded_variables,
 1958|      0|                            stat_children,
 1959|      0|                        );
 1960|      0|                        let arg2 = self.expression_evaluator(
 1961|      0|                            &parameters[1],
 1962|      0|                            encoded_variables,
 1963|      0|                            stat_children,
 1964|      0|                        );
 1965|      0|                        let dataset = Rc::clone(&self.dataset);
 1966|      0|                        Rc::new(move |tuple| {
 1967|       |                            let (arg1, arg2, language) = to_argument_compatible_strings(
 1968|       |                                &dataset,
 1969|       |                                &arg1(tuple)?,
 1970|       |                                &arg2(tuple)?,
 1971|       |                            )?;
 1972|       |                            Some(if let Some(position) = arg1.find(arg2.as_str()) {
 1973|       |                                build_plain_literal(
 1974|       |                                    &dataset,
 1975|       |                                    &arg1[position + arg2.len()..],
 1976|       |                                    language,
 1977|       |                                )
 1978|       |                            } else {
 1979|       |                                build_string_literal(&dataset, "")
 1980|       |                            })
 1981|      0|                        })
 1982|       |                    }
 1983|       |                    Function::Year => {
 1984|      0|                        let e = self.expression_evaluator(
 1985|      0|                            &parameters[0],
 1986|      0|                            encoded_variables,
 1987|      0|                            stat_children,
 1988|      0|                        );
 1989|      0|                        Rc::new(move |tuple| match e(tuple)? {
 1990|       |                            EncodedTerm::DateTimeLiteral(date_time) => {
 1991|       |                                Some(date_time.year().into())
 1992|       |                            }
 1993|       |                            EncodedTerm::DateLiteral(date) => Some(date.year().into()),
 1994|       |                            EncodedTerm::GYearMonthLiteral(year_month) => {
 1995|       |                                Some(year_month.year().into())
 1996|       |                            }
 1997|       |                            EncodedTerm::GYearLiteral(year) => Some(year.year().into()),
 1998|       |                            _ => None,
 1999|      0|                        })
 2000|       |                    }
 2001|       |                    Function::Month => {
 2002|      0|                        let e = self.expression_evaluator(
 2003|      0|                            &parameters[0],
 2004|      0|                            encoded_variables,
 2005|      0|                            stat_children,
 2006|      0|                        );
 2007|      0|                        Rc::new(move |tuple| match e(tuple)? {
 2008|       |                            EncodedTerm::DateTimeLiteral(date_time) => {
 2009|       |                                Some(date_time.month().into())
 2010|       |                            }
 2011|       |                            EncodedTerm::DateLiteral(date) => Some(date.month().into()),
 2012|       |                            EncodedTerm::GYearMonthLiteral(year_month) => {
 2013|       |                                Some(year_month.month().into())
 2014|       |                            }
 2015|       |                            EncodedTerm::GMonthDayLiteral(month_day) => {
 2016|       |                                Some(month_day.month().into())
 2017|       |                            }
 2018|       |                            EncodedTerm::GMonthLiteral(month) => Some(month.month().into()),
 2019|       |                            _ => None,
 2020|      0|                        })
 2021|       |                    }
 2022|       |                    Function::Day => {
 2023|      0|                        let e = self.expression_evaluator(
 2024|      0|                            &parameters[0],
 2025|      0|                            encoded_variables,
 2026|      0|                            stat_children,
 2027|      0|                        );
 2028|      0|                        Rc::new(move |tuple| match e(tuple)? {
 2029|       |                            EncodedTerm::DateTimeLiteral(date_time) => Some(date_time.day().into()),
 2030|       |                            EncodedTerm::DateLiteral(date) => Some(date.day().into()),
 2031|       |                            EncodedTerm::GMonthDayLiteral(month_day) => {
 2032|       |                                Some(month_day.day().into())
 2033|       |                            }
 2034|       |                            EncodedTerm::GDayLiteral(day) => Some(day.day().into()),
 2035|       |                            _ => None,
 2036|      0|                        })
 2037|       |                    }
 2038|       |                    Function::Hours => {
 2039|      0|                        let e = self.expression_evaluator(
 2040|      0|                            &parameters[0],
 2041|      0|                            encoded_variables,
 2042|      0|                            stat_children,
 2043|      0|                        );
 2044|      0|                        Rc::new(move |tuple| match e(tuple)? {
 2045|       |                            EncodedTerm::DateTimeLiteral(date_time) => {
 2046|       |                                Some(date_time.hour().into())
 2047|       |                            }
 2048|       |                            EncodedTerm::TimeLiteral(time) => Some(time.hour().into()),
 2049|       |                            _ => None,
 2050|      0|                        })
 2051|       |                    }
 2052|       |                    Function::Minutes => {
 2053|      0|                        let e = self.expression_evaluator(
 2054|      0|                            &parameters[0],
 2055|      0|                            encoded_variables,
 2056|      0|                            stat_children,
 2057|      0|                        );
 2058|      0|                        Rc::new(move |tuple| match e(tuple)? {
 2059|       |                            EncodedTerm::DateTimeLiteral(date_time) => {
 2060|       |                                Some(date_time.minute().into())
 2061|       |                            }
 2062|       |                            EncodedTerm::TimeLiteral(time) => Some(time.minute().into()),
 2063|       |                            _ => None,
 2064|      0|                        })
 2065|       |                    }
 2066|       |                    Function::Seconds => {
 2067|      0|                        let e = self.expression_evaluator(
 2068|      0|                            &parameters[0],
 2069|      0|                            encoded_variables,
 2070|      0|                            stat_children,
 2071|      0|                        );
 2072|      0|                        Rc::new(move |tuple| match e(tuple)? {
 2073|       |                            EncodedTerm::DateTimeLiteral(date_time) => {
 2074|       |                                Some(date_time.second().into())
 2075|       |                            }
 2076|       |                            EncodedTerm::TimeLiteral(time) => Some(time.second().into()),
 2077|       |                            _ => None,
 2078|      0|                        })
 2079|       |                    }
 2080|       |                    Function::Timezone => {
 2081|      0|                        let e = self.expression_evaluator(
 2082|      0|                            &parameters[0],
 2083|      0|                            encoded_variables,
 2084|      0|                            stat_children,
 2085|      0|                        );
 2086|      0|                        Rc::new(move |tuple| {
 2087|       |                            Some(
 2088|       |                                match e(tuple)? {
 2089|       |                                    EncodedTerm::DateTimeLiteral(date_time) => date_time.timezone(),
 2090|       |                                    EncodedTerm::TimeLiteral(time) => time.timezone(),
 2091|       |                                    EncodedTerm::DateLiteral(date) => date.timezone(),
 2092|       |                                    EncodedTerm::GYearMonthLiteral(year_month) => {
 2093|       |                                        year_month.timezone()
 2094|       |                                    }
 2095|       |                                    EncodedTerm::GYearLiteral(year) => year.timezone(),
 2096|       |                                    EncodedTerm::GMonthDayLiteral(month_day) => {
 2097|       |                                        month_day.timezone()
 2098|       |                                    }
 2099|       |                                    EncodedTerm::GDayLiteral(day) => day.timezone(),
 2100|       |                                    EncodedTerm::GMonthLiteral(month) => month.timezone(),
 2101|       |                                    _ => None,
 2102|       |                                }?
 2103|       |                                .into(),
 2104|       |                            )
 2105|      0|                        })
 2106|       |                    }
 2107|       |                    Function::Tz => {
 2108|      0|                        let e = self.expression_evaluator(
 2109|      0|                            &parameters[0],
 2110|      0|                            encoded_variables,
 2111|      0|                            stat_children,
 2112|      0|                        );
 2113|      0|                        let dataset = Rc::clone(&self.dataset);
 2114|      0|                        Rc::new(move |tuple| {
 2115|       |                            let timezone_offset = match e(tuple)? {
 2116|       |                                EncodedTerm::DateTimeLiteral(date_time) => {
 2117|       |                                    date_time.timezone_offset()
 2118|       |                                }
 2119|       |                                EncodedTerm::TimeLiteral(time) => time.timezone_offset(),
 2120|       |                                EncodedTerm::DateLiteral(date) => date.timezone_offset(),
 2121|       |                                EncodedTerm::GYearMonthLiteral(year_month) => {
 2122|       |                                    year_month.timezone_offset()
 2123|       |                                }
 2124|       |                                EncodedTerm::GYearLiteral(year) => year.timezone_offset(),
 2125|       |                                EncodedTerm::GMonthDayLiteral(month_day) => {
 2126|       |                                    month_day.timezone_offset()
 2127|       |                                }
 2128|       |                                EncodedTerm::GDayLiteral(day) => day.timezone_offset(),
 2129|       |                                EncodedTerm::GMonthLiteral(month) => month.timezone_offset(),
 2130|       |                                _ => return None,
 2131|       |                            };
 2132|       |                            Some(match timezone_offset {
 2133|       |                                Some(timezone_offset) => {
 2134|       |                                    build_string_literal(&dataset, &timezone_offset.to_string())
 2135|       |                                }
 2136|       |                                None => build_string_literal(&dataset, ""),
 2137|       |                            })
 2138|      0|                        })
 2139|       |                    }
 2140|       |                    Function::Adjust => {
 2141|      0|                        let dt = self.expression_evaluator(
 2142|      0|                            &parameters[0],
 2143|      0|                            encoded_variables,
 2144|      0|                            stat_children,
 2145|      0|                        );
 2146|      0|                        let tz = self.expression_evaluator(
 2147|      0|                            &parameters[1],
 2148|      0|                            encoded_variables,
 2149|      0|                            stat_children,
 2150|      0|                        );
 2151|      0|                        Rc::new(move |tuple| {
 2152|       |                            let timezone_offset = Some(
 2153|       |                                match tz(tuple)? {
 2154|       |                                    EncodedTerm::DayTimeDurationLiteral(tz) => {
 2155|       |                                        TimezoneOffset::try_from(tz)
 2156|       |                                    }
 2157|       |                                    EncodedTerm::DurationLiteral(tz) => {
 2158|       |                                        TimezoneOffset::try_from(tz)
 2159|       |                                    }
 2160|       |                                    _ => return None,
 2161|       |                                }
 2162|       |                                .ok()?,
 2163|       |                            );
 2164|       |                            Some(match dt(tuple)? {
 2165|       |                                EncodedTerm::DateTimeLiteral(date_time) => {
 2166|       |                                    date_time.adjust(timezone_offset)?.into()
 2167|       |                                }
 2168|       |                                EncodedTerm::TimeLiteral(time) => {
 2169|       |                                    time.adjust(timezone_offset)?.into()
 2170|       |                                }
 2171|       |                                EncodedTerm::DateLiteral(date) => {
 2172|       |                                    date.adjust(timezone_offset)?.into()
 2173|       |                                }
 2174|       |                                EncodedTerm::GYearMonthLiteral(year_month) => {
 2175|       |                                    year_month.adjust(timezone_offset)?.into()
 2176|       |                                }
 2177|       |                                EncodedTerm::GYearLiteral(year) => {
 2178|       |                                    year.adjust(timezone_offset)?.into()
 2179|       |                                }
 2180|       |                                EncodedTerm::GMonthDayLiteral(month_day) => {
 2181|       |                                    month_day.adjust(timezone_offset)?.into()
 2182|       |                                }
 2183|       |                                EncodedTerm::GDayLiteral(day) => {
 2184|       |                                    day.adjust(timezone_offset)?.into()
 2185|       |                                }
 2186|       |                                EncodedTerm::GMonthLiteral(month) => {
 2187|       |                                    month.adjust(timezone_offset)?.into()
 2188|       |                                }
 2189|       |                                _ => return None,
 2190|       |                            })
 2191|      0|                        })
 2192|       |                    }
 2193|       |                    Function::Now => {
 2194|      0|                        let now = self.now;
 2195|      0|                        Rc::new(move |_| Some(now.into()))
 2196|       |                    }
 2197|       |                    Function::Uuid => {
 2198|      0|                        let dataset = Rc::clone(&self.dataset);
 2199|      0|                        Rc::new(move |_| {
 2200|       |                            let mut buffer = String::with_capacity(44);
 2201|       |                            buffer.push_str("urn:uuid:");
 2202|       |                            generate_uuid(&mut buffer);
 2203|       |                            Some(build_named_node(&dataset, &buffer))
 2204|      0|                        })
 2205|       |                    }
 2206|       |                    Function::StrUuid => {
 2207|      0|                        let dataset = Rc::clone(&self.dataset);
 2208|      0|                        Rc::new(move |_| {
 2209|       |                            let mut buffer = String::with_capacity(36);
 2210|       |                            generate_uuid(&mut buffer);
 2211|       |                            Some(build_string_literal(&dataset, &buffer))
 2212|      0|                        })
 2213|       |                    }
 2214|      0|                    Function::Md5 => self.hash::<Md5>(parameters, encoded_variables, stat_children),
 2215|       |                    Function::Sha1 => {
 2216|      0|                        self.hash::<Sha1>(parameters, encoded_variables, stat_children)
 2217|       |                    }
 2218|       |                    Function::Sha256 => {
 2219|      0|                        self.hash::<Sha256>(parameters, encoded_variables, stat_children)
 2220|       |                    }
 2221|       |                    Function::Sha384 => {
 2222|      0|                        self.hash::<Sha384>(parameters, encoded_variables, stat_children)
 2223|       |                    }
 2224|       |                    Function::Sha512 => {
 2225|      0|                        self.hash::<Sha512>(parameters, encoded_variables, stat_children)
 2226|       |                    }
 2227|       |                    Function::StrLang => {
 2228|      0|                        let lexical_form = self.expression_evaluator(
 2229|      0|                            &parameters[0],
 2230|      0|                            encoded_variables,
 2231|      0|                            stat_children,
 2232|      0|                        );
 2233|      0|                        let lang_tag = self.expression_evaluator(
 2234|      0|                            &parameters[1],
 2235|      0|                            encoded_variables,
 2236|      0|                            stat_children,
 2237|      0|                        );
 2238|      0|                        let dataset = Rc::clone(&self.dataset);
 2239|      0|                        Rc::new(move |tuple| {
 2240|       |                            Some(build_lang_string_literal_from_id(
 2241|       |                                to_simple_string_id(&lexical_form(tuple)?)?,
 2242|       |                                build_language_id(&dataset, &lang_tag(tuple)?)?,
 2243|       |                            ))
 2244|      0|                        })
 2245|       |                    }
 2246|       |                    Function::StrDt => {
 2247|      2|                        let lexical_form = self.expression_evaluator(
 2248|      2|                            &parameters[0],
 2249|      2|                            encoded_variables,
 2250|      2|                            stat_children,
 2251|      2|                        );
 2252|      2|                        let datatype = self.expression_evaluator(
 2253|      2|                            &parameters[1],
 2254|      2|                            encoded_variables,
 2255|      2|                            stat_children,
 2256|      2|                        );
 2257|      2|                        let dataset = Rc::clone(&self.dataset);
 2258|      2|                        Rc::new(move |tuple| {
 2259|       |                            let value = to_simple_string(&dataset, &lexical_form(tuple)?)?;
 2260|       |                            let datatype =
 2261|       |                                if let EncodedTerm::NamedNode { iri_id } = datatype(tuple)? {
 2262|       |                                    dataset.get_str(&iri_id).ok()?
 2263|       |                                } else {
 2264|       |                                    None
 2265|       |                                }?;
 2266|       |                            Some(dataset.encode_term(LiteralRef::new_typed_literal(
 2267|       |                                &value,
 2268|       |                                NamedNodeRef::new_unchecked(&datatype),
 2269|       |                            )))
 2270|      2|                        })
 2271|       |                    }
 2272|       |                    Function::IsIri => {
 2273|      6|                        let e = self.expression_evaluator(
 2274|      6|                            &parameters[0],
 2275|      6|                            encoded_variables,
 2276|      6|                            stat_children,
 2277|      6|                        );
 2278|      6|                        Rc::new(move |tuple| Some(e(tuple)?.is_named_node().into()))
 2279|       |                    }
 2280|       |                    Function::IsBlank => {
 2281|     14|                        let e = self.expression_evaluator(
 2282|     14|                            &parameters[0],
 2283|     14|                            encoded_variables,
 2284|     14|                            stat_children,
 2285|     14|                        );
 2286|     14|                        Rc::new(move |tuple| Some(e(tuple)?.is_blank_node().into()))
 2287|       |                    }
 2288|       |                    Function::IsLiteral => {
 2289|      0|                        let e = self.expression_evaluator(
 2290|      0|                            &parameters[0],
 2291|      0|                            encoded_variables,
 2292|      0|                            stat_children,
 2293|      0|                        );
 2294|      0|                        Rc::new(move |tuple| Some(e(tuple)?.is_literal().into()))
 2295|       |                    }
 2296|       |                    Function::IsNumeric => {
 2297|      6|                        let e = self.expression_evaluator(
 2298|      6|                            &parameters[0],
 2299|      6|                            encoded_variables,
 2300|      6|                            stat_children,
 2301|      6|                        );
 2302|      6|                        Rc::new(move |tuple| {
 2303|       |                            Some(
 2304|       |                                matches!(
 2305|       |                                    e(tuple)?,
 2306|       |                                    EncodedTerm::FloatLiteral(_)
 2307|       |                                        | EncodedTerm::DoubleLiteral(_)
 2308|       |                                        | EncodedTerm::IntegerLiteral(_)
 2309|       |                                        | EncodedTerm::DecimalLiteral(_)
 2310|       |                                )
 2311|       |                                .into(),
 2312|       |                            )
 2313|      6|                        })
 2314|       |                    }
 2315|       |                    Function::Regex => {
 2316|      0|                        let text = self.expression_evaluator(
 2317|      0|                            &parameters[0],
 2318|      0|                            encoded_variables,
 2319|      0|                            stat_children,
 2320|      0|                        );
 2321|      0|                        let dataset = Rc::clone(&self.dataset);
 2322|      0|                        if let Some(regex) =
 2323|      0|                            compile_static_pattern_if_exists(&parameters[1], parameters.get(2))
 2324|       |                        {
 2325|      0|                            Rc::new(move |tuple| {
 2326|       |                                let text = to_string(&dataset, &text(tuple)?)?;
 2327|       |                                Some(regex.is_match(&text).into())
 2328|      0|                            })
 2329|       |                        } else {
 2330|      0|                            let pattern = self.expression_evaluator(
 2331|      0|                                &parameters[0],
 2332|      0|                                encoded_variables,
 2333|      0|                                stat_children,
 2334|      0|                            );
 2335|      0|                            let flags = parameters.get(2).map(|flags| {
 2336|       |                                self.expression_evaluator(flags, encoded_variables, stat_children)
 2337|      0|                            });
 2338|      0|                            Rc::new(move |tuple| {
 2339|       |                                let pattern = to_simple_string(&dataset, &pattern(tuple)?)?;
 2340|       |                                let options = if let Some(flags) = &flags {
 2341|       |                                    Some(to_simple_string(&dataset, &flags(tuple)?)?)
 2342|       |                                } else {
 2343|       |                                    None
 2344|       |                                };
 2345|       |                                let regex = compile_pattern(&pattern, options.as_deref())?;
 2346|       |                                let text = to_string(&dataset, &text(tuple)?)?;
 2347|       |                                Some(regex.is_match(&text).into())
 2348|      0|                            })
 2349|       |                        }
 2350|       |                    }
 2351|       |                    Function::Triple => {
 2352|      0|                        let s = self.expression_evaluator(
 2353|      0|                            &parameters[0],
 2354|      0|                            encoded_variables,
 2355|      0|                            stat_children,
 2356|      0|                        );
 2357|      0|                        let p = self.expression_evaluator(
 2358|      0|                            &parameters[1],
 2359|      0|                            encoded_variables,
 2360|      0|                            stat_children,
 2361|      0|                        );
 2362|      0|                        let o = self.expression_evaluator(
 2363|      0|                            &parameters[2],
 2364|      0|                            encoded_variables,
 2365|      0|                            stat_children,
 2366|      0|                        );
 2367|      0|                        Rc::new(move |tuple| {
 2368|       |                            let s = s(tuple)?;
 2369|       |                            let p = p(tuple)?;
 2370|       |                            let o = o(tuple)?;
 2371|       |                            (!s.is_literal()
 2372|       |                                && !s.is_default_graph()
 2373|       |                                && p.is_named_node()
 2374|       |                                && !o.is_default_graph())
 2375|       |                            .then(|| EncodedTriple::new(s, p, o).into())
 2376|      0|                        })
 2377|       |                    }
 2378|       |                    Function::Subject => {
 2379|      0|                        let e = self.expression_evaluator(
 2380|      0|                            &parameters[0],
 2381|      0|                            encoded_variables,
 2382|      0|                            stat_children,
 2383|      0|                        );
 2384|      0|                        Rc::new(move |tuple| {
 2385|       |                            if let EncodedTerm::Triple(t) = e(tuple)? {
 2386|       |                                Some(t.subject.clone())
 2387|       |                            } else {
 2388|       |                                None
 2389|       |                            }
 2390|      0|                        })
 2391|       |                    }
 2392|       |                    Function::Predicate => {
 2393|      0|                        let e = self.expression_evaluator(
 2394|      0|                            &parameters[0],
 2395|      0|                            encoded_variables,
 2396|      0|                            stat_children,
 2397|      0|                        );
 2398|      0|                        Rc::new(move |tuple| {
 2399|       |                            if let EncodedTerm::Triple(t) = e(tuple)? {
 2400|       |                                Some(t.predicate.clone())
 2401|       |                            } else {
 2402|       |                                None
 2403|       |                            }
 2404|      0|                        })
 2405|       |                    }
 2406|       |                    Function::Object => {
 2407|      0|                        let e = self.expression_evaluator(
 2408|      0|                            &parameters[0],
 2409|      0|                            encoded_variables,
 2410|      0|                            stat_children,
 2411|      0|                        );
 2412|      0|                        Rc::new(move |tuple| {
 2413|       |                            if let EncodedTerm::Triple(t) = e(tuple)? {
 2414|       |                                Some(t.object.clone())
 2415|       |                            } else {
 2416|       |                                None
 2417|       |                            }
 2418|      0|                        })
 2419|       |                    }
 2420|       |                    Function::IsTriple => {
 2421|      0|                        let e = self.expression_evaluator(
 2422|      0|                            &parameters[0],
 2423|      0|                            encoded_variables,
 2424|      0|                            stat_children,
 2425|      0|                        );
 2426|      0|                        Rc::new(move |tuple| Some(e(tuple)?.is_triple().into()))
 2427|       |                    }
 2428|      0|                    Function::Custom(function_name) => {
 2429|      0|                        if let Some(function) = self.custom_functions.get(function_name).cloned() {
 2430|      0|                            let args = parameters
 2431|      0|                                .iter()
 2432|      0|                                .map(|e| {
 2433|       |                                    self.expression_evaluator(e, encoded_variables, stat_children)
 2434|      0|                                })
 2435|      0|                                .collect::<Vec<_>>();
 2436|      0|                            let dataset = Rc::clone(&self.dataset);
 2437|      0|                            return Rc::new(move |tuple| {
 2438|       |                                let args = args
 2439|       |                                    .iter()
 2440|       |                                    .map(|f| dataset.decode_term(&f(tuple)?).ok())
 2441|       |                                    .collect::<Option<Vec<_>>>()?;
 2442|       |                                Some(dataset.encode_term(&function(&args)?))
 2443|      0|                            });
 2444|      0|                        }
 2445|      0|                        match function_name.as_ref() {
 2446|      0|                            xsd::STRING => {
 2447|      0|                                let e = self.expression_evaluator(
 2448|      0|                                    &parameters[0],
 2449|      0|                                    encoded_variables,
 2450|      0|                                    stat_children,
 2451|      0|                                );
 2452|      0|                                let dataset = Rc::clone(&self.dataset);
 2453|      0|                                Rc::new(move |tuple| {
 2454|       |                                    Some(build_string_literal_from_id(to_string_id(
 2455|       |                                        &dataset,
 2456|       |                                        &e(tuple)?,
 2457|       |                                    )?))
 2458|      0|                                })
 2459|       |                            }
 2460|      0|                            xsd::BOOLEAN => {
 2461|      0|                                let e = self.expression_evaluator(
 2462|      0|                                    &parameters[0],
 2463|      0|                                    encoded_variables,
 2464|      0|                                    stat_children,
 2465|      0|                                );
 2466|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2467|       |                                    EncodedTerm::BooleanLiteral(value) => Some(value.into()),
 2468|       |                                    EncodedTerm::FloatLiteral(value) => {
 2469|       |                                        Some(Boolean::from(value).into())
 2470|       |                                    }
 2471|       |                                    EncodedTerm::DoubleLiteral(value) => {
 2472|       |                                        Some(Boolean::from(value).into())
 2473|       |                                    }
 2474|       |                                    EncodedTerm::IntegerLiteral(value) => {
 2475|       |                                        Some(Boolean::from(value).into())
 2476|       |                                    }
 2477|       |                                    EncodedTerm::DecimalLiteral(value) => {
 2478|       |                                        Some(Boolean::from(value).into())
 2479|       |                                    }
 2480|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2481|       |                                        parse_boolean_str(&value)
 2482|       |                                    }
 2483|       |                                    _ => None,
 2484|      0|                                })
 2485|       |                            }
 2486|      0|                            xsd::DOUBLE => {
 2487|      0|                                let e = self.expression_evaluator(
 2488|      0|                                    &parameters[0],
 2489|      0|                                    encoded_variables,
 2490|      0|                                    stat_children,
 2491|      0|                                );
 2492|      0|                                let dataset = Rc::clone(&self.dataset);
 2493|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2494|       |                                    EncodedTerm::FloatLiteral(value) => {
 2495|       |                                        Some(Double::from(value).into())
 2496|       |                                    }
 2497|       |                                    EncodedTerm::DoubleLiteral(value) => Some(value.into()),
 2498|       |                                    EncodedTerm::IntegerLiteral(value) => {
 2499|       |                                        Some(Double::from(value).into())
 2500|       |                                    }
 2501|       |                                    EncodedTerm::DecimalLiteral(value) => {
 2502|       |                                        Some(Double::from(value).into())
 2503|       |                                    }
 2504|       |                                    EncodedTerm::BooleanLiteral(value) => {
 2505|       |                                        Some(Double::from(value).into())
 2506|       |                                    }
 2507|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2508|       |                                        parse_double_str(&value)
 2509|       |                                    }
 2510|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2511|       |                                        parse_double_str(&dataset.get_str(&value_id).ok()??)
 2512|       |                                    }
 2513|       |                                    _ => None,
 2514|      0|                                })
 2515|       |                            }
 2516|      0|                            xsd::FLOAT => {
 2517|      0|                                let e = self.expression_evaluator(
 2518|      0|                                    &parameters[0],
 2519|      0|                                    encoded_variables,
 2520|      0|                                    stat_children,
 2521|      0|                                );
 2522|      0|                                let dataset = Rc::clone(&self.dataset);
 2523|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2524|       |                                    EncodedTerm::FloatLiteral(value) => Some(value.into()),
 2525|       |                                    EncodedTerm::DoubleLiteral(value) => {
 2526|       |                                        Some(Float::from(value).into())
 2527|       |                                    }
 2528|       |                                    EncodedTerm::IntegerLiteral(value) => {
 2529|       |                                        Some(Float::from(value).into())
 2530|       |                                    }
 2531|       |                                    EncodedTerm::DecimalLiteral(value) => {
 2532|       |                                        Some(Float::from(value).into())
 2533|       |                                    }
 2534|       |                                    EncodedTerm::BooleanLiteral(value) => {
 2535|       |                                        Some(Float::from(value).into())
 2536|       |                                    }
 2537|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2538|       |                                        parse_float_str(&value)
 2539|       |                                    }
 2540|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2541|       |                                        parse_float_str(&dataset.get_str(&value_id).ok()??)
 2542|       |                                    }
 2543|       |                                    _ => None,
 2544|      0|                                })
 2545|       |                            }
 2546|      0|                            xsd::INTEGER => {
 2547|      0|                                let e = self.expression_evaluator(
 2548|      0|                                    &parameters[0],
 2549|      0|                                    encoded_variables,
 2550|      0|                                    stat_children,
 2551|      0|                                );
 2552|      0|                                let dataset = Rc::clone(&self.dataset);
 2553|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2554|       |                                    EncodedTerm::FloatLiteral(value) => {
 2555|       |                                        Some(Integer::try_from(value).ok()?.into())
 2556|       |                                    }
 2557|       |                                    EncodedTerm::DoubleLiteral(value) => {
 2558|       |                                        Some(Integer::try_from(value).ok()?.into())
 2559|       |                                    }
 2560|       |                                    EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 2561|       |                                    EncodedTerm::DecimalLiteral(value) => {
 2562|       |                                        Some(Integer::try_from(value).ok()?.into())
 2563|       |                                    }
 2564|       |                                    EncodedTerm::BooleanLiteral(value) => {
 2565|       |                                        Some(Integer::from(value).into())
 2566|       |                                    }
 2567|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2568|       |                                        parse_integer_str(&value)
 2569|       |                                    }
 2570|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2571|       |                                        parse_integer_str(&dataset.get_str(&value_id).ok()??)
 2572|       |                                    }
 2573|       |                                    _ => None,
 2574|      0|                                })
 2575|       |                            }
 2576|      0|                            xsd::DECIMAL => {
 2577|      0|                                let e = self.expression_evaluator(
 2578|      0|                                    &parameters[0],
 2579|      0|                                    encoded_variables,
 2580|      0|                                    stat_children,
 2581|      0|                                );
 2582|      0|                                let dataset = Rc::clone(&self.dataset);
 2583|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2584|       |                                    EncodedTerm::FloatLiteral(value) => {
 2585|       |                                        Some(Decimal::try_from(value).ok()?.into())
 2586|       |                                    }
 2587|       |                                    EncodedTerm::DoubleLiteral(value) => {
 2588|       |                                        Some(Decimal::try_from(value).ok()?.into())
 2589|       |                                    }
 2590|       |                                    EncodedTerm::IntegerLiteral(value) => {
 2591|       |                                        Some(Decimal::from(value).into())
 2592|       |                                    }
 2593|       |                                    EncodedTerm::DecimalLiteral(value) => Some(value.into()),
 2594|       |                                    EncodedTerm::BooleanLiteral(value) => {
 2595|       |                                        Some(Decimal::from(value).into())
 2596|       |                                    }
 2597|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2598|       |                                        parse_decimal_str(&value)
 2599|       |                                    }
 2600|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2601|       |                                        parse_decimal_str(&dataset.get_str(&value_id).ok()??)
 2602|       |                                    }
 2603|       |                                    _ => None,
 2604|      0|                                })
 2605|       |                            }
 2606|      0|                            xsd::DATE => {
 2607|      0|                                let e = self.expression_evaluator(
 2608|      0|                                    &parameters[0],
 2609|      0|                                    encoded_variables,
 2610|      0|                                    stat_children,
 2611|      0|                                );
 2612|      0|                                let dataset = Rc::clone(&self.dataset);
 2613|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2614|       |                                    EncodedTerm::DateLiteral(value) => Some(value.into()),
 2615|       |                                    EncodedTerm::DateTimeLiteral(value) => {
 2616|       |                                        Some(Date::try_from(value).ok()?.into())
 2617|       |                                    }
 2618|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2619|       |                                        parse_date_str(&value)
 2620|       |                                    }
 2621|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2622|       |                                        parse_date_str(&dataset.get_str(&value_id).ok()??)
 2623|       |                                    }
 2624|       |                                    _ => None,
 2625|      0|                                })
 2626|       |                            }
 2627|      0|                            xsd::TIME => {
 2628|      0|                                let e = self.expression_evaluator(
 2629|      0|                                    &parameters[0],
 2630|      0|                                    encoded_variables,
 2631|      0|                                    stat_children,
 2632|      0|                                );
 2633|      0|                                let dataset = Rc::clone(&self.dataset);
 2634|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2635|       |                                    EncodedTerm::TimeLiteral(value) => Some(value.into()),
 2636|       |                                    EncodedTerm::DateTimeLiteral(value) => {
 2637|       |                                        Some(Time::from(value).into())
 2638|       |                                    }
 2639|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2640|       |                                        parse_time_str(&value)
 2641|       |                                    }
 2642|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2643|       |                                        parse_time_str(&dataset.get_str(&value_id).ok()??)
 2644|       |                                    }
 2645|       |                                    _ => None,
 2646|      0|                                })
 2647|       |                            }
 2648|      0|                            xsd::DATE_TIME => {
 2649|      0|                                let e = self.expression_evaluator(
 2650|      0|                                    &parameters[0],
 2651|      0|                                    encoded_variables,
 2652|      0|                                    stat_children,
 2653|      0|                                );
 2654|      0|                                let dataset = Rc::clone(&self.dataset);
 2655|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2656|       |                                    EncodedTerm::DateTimeLiteral(value) => Some(value.into()),
 2657|       |                                    EncodedTerm::DateLiteral(value) => {
 2658|       |                                        Some(DateTime::try_from(value).ok()?.into())
 2659|       |                                    }
 2660|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2661|       |                                        parse_date_time_str(&value)
 2662|       |                                    }
 2663|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2664|       |                                        parse_date_time_str(&dataset.get_str(&value_id).ok()??)
 2665|       |                                    }
 2666|       |                                    _ => None,
 2667|      0|                                })
 2668|       |                            }
 2669|      0|                            xsd::DURATION => {
 2670|      0|                                let e = self.expression_evaluator(
 2671|      0|                                    &parameters[0],
 2672|      0|                                    encoded_variables,
 2673|      0|                                    stat_children,
 2674|      0|                                );
 2675|      0|                                let dataset = Rc::clone(&self.dataset);
 2676|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2677|       |                                    EncodedTerm::DurationLiteral(value) => Some(value.into()),
 2678|       |                                    EncodedTerm::YearMonthDurationLiteral(value) => {
 2679|       |                                        Some(Duration::from(value).into())
 2680|       |                                    }
 2681|       |                                    EncodedTerm::DayTimeDurationLiteral(value) => {
 2682|       |                                        Some(Duration::from(value).into())
 2683|       |                                    }
 2684|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2685|       |                                        parse_duration_str(&value)
 2686|       |                                    }
 2687|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2688|       |                                        parse_duration_str(&dataset.get_str(&value_id).ok()??)
 2689|       |                                    }
 2690|       |                                    _ => None,
 2691|      0|                                })
 2692|       |                            }
 2693|      0|                            xsd::YEAR_MONTH_DURATION => {
 2694|      0|                                let e = self.expression_evaluator(
 2695|      0|                                    &parameters[0],
 2696|      0|                                    encoded_variables,
 2697|      0|                                    stat_children,
 2698|      0|                                );
 2699|      0|                                let dataset = Rc::clone(&self.dataset);
 2700|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2701|       |                                    EncodedTerm::DurationLiteral(value) => {
 2702|       |                                        Some(YearMonthDuration::try_from(value).ok()?.into())
 2703|       |                                    }
 2704|       |                                    EncodedTerm::YearMonthDurationLiteral(value) => {
 2705|       |                                        Some(value.into())
 2706|       |                                    }
 2707|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2708|       |                                        parse_year_month_duration_str(&value)
 2709|       |                                    }
 2710|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2711|       |                                        parse_year_month_duration_str(
 2712|       |                                            &dataset.get_str(&value_id).ok()??,
 2713|       |                                        )
 2714|       |                                    }
 2715|       |                                    _ => None,
 2716|      0|                                })
 2717|       |                            }
 2718|      0|                            xsd::DAY_TIME_DURATION => {
 2719|      0|                                let e = self.expression_evaluator(
 2720|      0|                                    &parameters[0],
 2721|      0|                                    encoded_variables,
 2722|      0|                                    stat_children,
 2723|      0|                                );
 2724|      0|                                let dataset = Rc::clone(&self.dataset);
 2725|      0|                                Rc::new(move |tuple| match e(tuple)? {
 2726|       |                                    EncodedTerm::DurationLiteral(value) => {
 2727|       |                                        Some(DayTimeDuration::try_from(value).ok()?.into())
 2728|       |                                    }
 2729|       |                                    EncodedTerm::DayTimeDurationLiteral(value) => {
 2730|       |                                        Some(value.into())
 2731|       |                                    }
 2732|       |                                    EncodedTerm::SmallStringLiteral(value) => {
 2733|       |                                        parse_day_time_duration_str(&value)
 2734|       |                                    }
 2735|       |                                    EncodedTerm::BigStringLiteral { value_id } => {
 2736|       |                                        parse_day_time_duration_str(
 2737|       |                                            &dataset.get_str(&value_id).ok()??,
 2738|       |                                        )
 2739|       |                                    }
 2740|       |                                    _ => None,
 2741|      0|                                })
 2742|       |                            }
 2743|      0|                            _ => Rc::new(|_| None),
 2744|       |                        }
 2745|       |                    }
 2746|       |                }
 2747|       |            }
 2748|       |        }
 2749|  21.4k|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator26eval_from_in_unknown_graph:
 4233|     19|    fn eval_from_in_unknown_graph(
 4234|     19|        &self,
 4235|     19|        path: &PropertyPath,
 4236|     19|        start: &EncodedTerm,
 4237|     19|    ) -> Box<dyn Iterator<Item = Result<(EncodedTerm, EncodedTerm), EvaluationError>>> {
 4238|     19|        match path {
 4239|      5|            PropertyPath::Path(p) => Box::new(
 4240|      5|                self.dataset
 4241|      5|                    .encoded_quads_for_pattern(Some(start), Some(p), None, None)
 4242|      5|                    .map(|t| {
 4243|       |                        let t = t?;
 4244|       |                        Ok((t.object, t.graph_name))
 4245|      5|                    }),
 4246|      5|            ),
 4247|      2|            PropertyPath::Reverse(p) => self.eval_to_in_unknown_graph(p, start),
 4248|      0|            PropertyPath::Sequence(a, b) => {
 4249|      0|                let eval = self.clone();
 4250|      0|                let b = Rc::clone(b);
 4251|      0|                Box::new(self.eval_from_in_unknown_graph(a, start).flat_map_ok(
 4252|      0|                    move |(middle, graph_name)| {
 4253|       |                        eval.eval_from_in_graph(&b, &middle, &graph_name)
 4254|       |                            .map(move |end| Ok((end?, graph_name.clone())))
 4255|      0|                    },
 4256|      0|                ))
 4257|       |            }
 4258|      2|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4259|      2|                self.eval_from_in_unknown_graph(a, start)
 4260|      2|                    .chain(self.eval_from_in_unknown_graph(b, start)),
 4261|      2|            )),
 4262|      4|            PropertyPath::ZeroOrMore(p) => {
 4263|      4|                let start2 = start.clone();
 4264|      4|                let eval = self.clone();
 4265|      4|                let p = Rc::clone(p);
 4266|      4|                self.run_if_term_is_a_dataset_node(start, move |graph_name| {
 4267|       |                    let eval = eval.clone();
 4268|       |                    let p = Rc::clone(&p);
 4269|       |                    let graph_name2 = graph_name.clone();
 4270|       |                    transitive_closure(Some(Ok(start2.clone())), move |e| {
 4271|       |                        eval.eval_from_in_graph(&p, &e, &graph_name2)
 4272|       |                    })
 4273|       |                    .map(move |e| Ok((e?, graph_name.clone())))
 4274|      4|                })
 4275|       |            }
 4276|      0|            PropertyPath::OneOrMore(p) => {
 4277|      0|                let eval = self.clone();
 4278|      0|                let p = Rc::clone(p);
 4279|      0|                Box::new(transitive_closure(
 4280|      0|                    self.eval_from_in_unknown_graph(&p, start),
 4281|      0|                    move |(e, graph_name)| {
 4282|       |                        eval.eval_from_in_graph(&p, &e, &graph_name)
 4283|       |                            .map(move |e| Ok((e?, graph_name.clone())))
 4284|      0|                    },
 4285|      0|                ))
 4286|       |            }
 4287|      1|            PropertyPath::ZeroOrOne(p) => {
 4288|      1|                let eval = self.clone();
 4289|      1|                let start2 = start.clone();
 4290|      1|                let p = Rc::clone(p);
 4291|      1|                self.run_if_term_is_a_dataset_node(start, move |graph_name| {
 4292|       |                    hash_deduplicate(once(Ok(start2.clone())).chain(eval.eval_from_in_graph(
 4293|       |                        &p,
 4294|       |                        &start2,
 4295|       |                        &graph_name,
 4296|       |                    )))
 4297|       |                    .map(move |e| Ok((e?, graph_name.clone())))
 4298|      1|                })
 4299|       |            }
 4300|      5|            PropertyPath::NegatedPropertySet(ps) => {
 4301|      5|                let ps = Rc::clone(ps);
 4302|      5|                Box::new(
 4303|      5|                    self.dataset
 4304|      5|                        .encoded_quads_for_pattern(Some(start), None, None, None)
 4305|      5|                        .filter_map(move |t| match t {
 4306|       |                            Ok(t) => {
 4307|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4308|       |                                    None
 4309|       |                                } else {
 4310|       |                                    Some(Ok((t.object, t.graph_name)))
 4311|       |                                }
 4312|       |                            }
 4313|       |                            Err(e) => Some(Err(e)),
 4314|      5|                        }),
 4315|      5|                )
 4316|       |            }
 4317|       |        }
 4318|     19|    }
_RNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4811|    735|    fn next(&mut self) -> Option<Self::Item> {
 4812|       |        loop {
 4813|    803|            if let Some(result) = self.buffered_results.pop() {
 4814|     68|                return Some(result);
 4815|    735|            }
 4816|    735|            let left_tuple = match self.left_iter.next()? {
 4817|    289|                Ok(left_tuple) => left_tuple,
 4818|      0|                Err(error) => return Some(Err(error)),
 4819|       |            };
 4820|    289|            self.buffered_results.extend(
 4821|    289|                self.right
 4822|    289|                    .get(&left_tuple)
 4823|    289|                    .iter()
 4824|    289|                    .filter_map(|right_tuple| left_tuple.combine_with(right_tuple))
 4825|    289|                    .filter(|tuple| {
 4826|       |                        (self.expression)(tuple)
 4827|       |                            .and_then(|term| to_bool(&term))
 4828|       |                            .unwrap_or(false)
 4829|    289|                    })
 4830|    289|                    .map(Ok),
 4831|    289|            );
 4832|    289|            if self.buffered_results.is_empty() {
 4833|       |                // We have not manage to join with anything
 4834|    221|                return Some(Ok(left_tuple));
 4835|     68|            }
 4836|       |        }
 4837|    735|    }
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13TupleSelector23from_named_node_pattern:
 3869|  43.5k|    fn from_named_node_pattern(
 3870|  43.5k|        named_node_pattern: &NamedNodePattern,
 3871|  43.5k|        variables: &mut Vec<Variable>,
 3872|  43.5k|        dataset: &DatasetView,
 3873|  43.5k|    ) -> Self {
 3874|  43.5k|        match named_node_pattern {
 3875|  23.6k|            NamedNodePattern::Variable(variable) => {
 3876|  23.6k|                Self::Variable(encode_variable(variables, variable))
 3877|       |            }
 3878|  19.9k|            NamedNodePattern::NamedNode(term) => Self::Constant(dataset.encode_term(term)),
 3879|       |        }
 3880|  43.5k|    }
_RNvXs7_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_23ForLoopLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4859|     38|    fn next(&mut self) -> Option<Self::Item> {
 4860|     38|        if let Some(tuple) = self.current_right.next() {
 4861|      0|            return Some(tuple);
 4862|     38|        }
 4863|     38|        let left_tuple = match self.left_iter.next()? {
 4864|      1|            Ok(left_tuple) => left_tuple,
 4865|      0|            Err(error) => return Some(Err(error)),
 4866|       |        };
 4867|      1|        self.current_right = (self.right_evaluator)(left_tuple.clone());
 4868|      1|        if let Some(right_tuple) = self.current_right.next() {
 4869|      1|            Some(right_tuple)
 4870|       |        } else {
 4871|      0|            Some(Ok(left_tuple))
 4872|       |        }
 4873|     38|    }
_RNvXs4_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_28CartesianProductJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint:
 4754|    708|    fn size_hint(&self) -> (usize, Option<usize>) {
 4755|    708|        let (min, max) = self.probe_iter.size_hint();
 4756|    708|        (
 4757|    708|            min.saturating_mul(self.built.len()),
 4758|    708|            max.map(|v| v.saturating_mul(self.built.len())),
 4759|    708|        )
 4760|    708|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator18eval_open_in_graph:
 4479|  17.2k|    fn eval_open_in_graph(
 4480|  17.2k|        &self,
 4481|  17.2k|        path: &PropertyPath,
 4482|  17.2k|        graph_name: &EncodedTerm,
 4483|  17.2k|    ) -> Box<dyn Iterator<Item = Result<(EncodedTerm, EncodedTerm), EvaluationError>>> {
 4484|  17.2k|        match path {
 4485|  4.80k|            PropertyPath::Path(p) => Box::new(
 4486|  4.80k|                self.dataset
 4487|  4.80k|                    .encoded_quads_for_pattern(None, Some(p), None, Some(graph_name))
 4488|  4.80k|                    .map(|t| t.map(|t| (t.subject, t.object))),
 4489|  4.80k|            ),
 4490|  3.15k|            PropertyPath::Reverse(p) => Box::new(
 4491|  3.15k|                self.eval_open_in_graph(p, graph_name)
 4492|  3.15k|                    .map(|t| t.map(|(s, o)| (o, s))),
 4493|  3.15k|            ),
 4494|  2.09k|            PropertyPath::Sequence(a, b) => {
 4495|  2.09k|                let eval = self.clone();
 4496|  2.09k|                let b = Rc::clone(b);
 4497|  2.09k|                let graph_name2 = graph_name.clone();
 4498|  2.09k|                Box::new(self.eval_open_in_graph(a, graph_name).flat_map_ok(
 4499|  2.09k|                    move |(start, middle)| {
 4500|       |                        eval.eval_from_in_graph(&b, &middle, &graph_name2)
 4501|       |                            .map(move |end| Ok((start.clone(), end?)))
 4502|  2.09k|                    },
 4503|  2.09k|                ))
 4504|       |            }
 4505|  1.18k|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4506|  1.18k|                self.eval_open_in_graph(a, graph_name)
 4507|  1.18k|                    .chain(self.eval_open_in_graph(b, graph_name)),
 4508|  1.18k|            )),
 4509|    680|            PropertyPath::ZeroOrMore(p) => {
 4510|    680|                let eval = self.clone();
 4511|    680|                let p = Rc::clone(p);
 4512|    680|                let graph_name2 = graph_name.clone();
 4513|    680|                Box::new(transitive_closure(
 4514|    680|                    self.get_subject_or_object_identity_pairs_in_graph(graph_name),
 4515|    680|                    move |(start, middle)| {
 4516|       |                        eval.eval_from_in_graph(&p, &middle, &graph_name2)
 4517|       |                            .map(move |end| Ok((start.clone(), end?)))
 4518|    680|                    },
 4519|    680|                ))
 4520|       |            }
 4521|  1.20k|            PropertyPath::OneOrMore(p) => {
 4522|  1.20k|                let eval = self.clone();
 4523|  1.20k|                let p = Rc::clone(p);
 4524|  1.20k|                let graph_name2 = graph_name.clone();
 4525|  1.20k|                Box::new(transitive_closure(
 4526|  1.20k|                    self.eval_open_in_graph(&p, graph_name),
 4527|  1.20k|                    move |(start, middle)| {
 4528|       |                        eval.eval_from_in_graph(&p, &middle, &graph_name2)
 4529|       |                            .map(move |end| Ok((start.clone(), end?)))
 4530|  1.20k|                    },
 4531|  1.20k|                ))
 4532|       |            }
 4533|  3.30k|            PropertyPath::ZeroOrOne(p) => Box::new(hash_deduplicate(
 4534|  3.30k|                self.get_subject_or_object_identity_pairs_in_graph(graph_name)
 4535|  3.30k|                    .chain(self.eval_open_in_graph(p, graph_name)),
 4536|  3.30k|            )),
 4537|    863|            PropertyPath::NegatedPropertySet(ps) => {
 4538|    863|                let ps = Rc::clone(ps);
 4539|    863|                Box::new(
 4540|    863|                    self.dataset
 4541|    863|                        .encoded_quads_for_pattern(None, None, None, Some(graph_name))
 4542|    863|                        .filter_map(move |t| match t {
 4543|       |                            Ok(t) => {
 4544|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4545|       |                                    None
 4546|       |                                } else {
 4547|       |                                    Some(Ok((t.subject, t.object)))
 4548|       |                                }
 4549|       |                            }
 4550|       |                            Err(e) => Some(Err(e)),
 4551|    863|                        }),
 4552|    863|                )
 4553|       |            }
 4554|       |        }
 4555|  17.2k|    }
_RNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15SimpleEvaluator3new:
  135|  4.89k|    pub fn new(
  136|  4.89k|        dataset: Rc<DatasetView>,
  137|  4.89k|        base_iri: Option<Rc<Iri<String>>>,
  138|  4.89k|        service_handler: Arc<dyn ServiceHandler<Error = EvaluationError>>,
  139|  4.89k|        custom_functions: Arc<CustomFunctionRegistry>,
  140|  4.89k|        run_stats: bool,
  141|  4.89k|    ) -> Self {
  142|  4.89k|        Self {
  143|  4.89k|            dataset,
  144|  4.89k|            base_iri,
  145|  4.89k|            now: DateTime::now(),
  146|  4.89k|            service_handler,
  147|  4.89k|            custom_functions,
  148|  4.89k|            run_stats,
  149|  4.89k|        }
  150|  4.89k|    }
_RNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15SimpleEvaluator23graph_pattern_evaluator:
  244|   104k|    pub fn graph_pattern_evaluator(
  245|   104k|        &self,
  246|   104k|        pattern: &GraphPattern,
  247|   104k|        encoded_variables: &mut Vec<Variable>,
  248|   104k|    ) -> (
  249|   104k|        Rc<dyn Fn(EncodedTuple) -> EncodedTuplesIterator>,
  250|   104k|        Rc<EvalNodeWithStats>,
  251|   104k|    ) {
  252|   104k|        let mut stat_children = Vec::new();
  253|   104k|        let mut evaluator =
  254|   104k|            self.build_graph_pattern_evaluator(pattern, encoded_variables, &mut stat_children);
  255|   104k|        let stats = Rc::new(EvalNodeWithStats {
  256|   104k|            label: eval_node_label(pattern),
  257|   104k|            children: stat_children,
  258|   104k|            exec_count: Cell::new(0),
  259|   104k|            exec_duration: Cell::new(self.run_stats.then(DayTimeDuration::default)),
  260|   104k|        });
  261|   104k|        if self.run_stats {
  262|      0|            let stats = Rc::clone(&stats);
  263|      0|            evaluator = Rc::new(move |tuple| {
  264|       |                let start = Timer::now();
  265|       |                let inner = evaluator(tuple);
  266|       |                stats.exec_duration.set(
  267|       |                    stats
  268|       |                        .exec_duration
  269|       |                        .get()
  270|       |                        .and_then(|stat| stat.checked_add(start.elapsed()?)),
  271|       |                );
  272|       |                Box::new(StatsIterator {
  273|       |                    inner,
  274|       |                    stats: Rc::clone(&stats),
  275|       |                })
  276|      0|            })
  277|   104k|        }
  278|   104k|        (evaluator, stats)
  279|   104k|    }
_RNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15EncodedTupleSet3len:
 5622|    297|    fn len(&self) -> usize {
 5623|    297|        self.len
 5624|    297|    }
_RNvXsK_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13TupleSelectorNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
 3820|  93.4k|#[derive(Clone)]
_RNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint:
 4839|    330|    fn size_hint(&self) -> (usize, Option<usize>) {
 4840|    330|        (
 4841|    330|            0,
 4842|    330|            self.left_iter
 4843|    330|                .size_hint()
 4844|    330|                .1
 4845|    330|                .map(|v| v.saturating_mul(self.right.len())),
 4846|    330|        )
 4847|    330|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple13with_capacity:
   49|  9.78k|    pub fn with_capacity(capacity: usize) -> Self {
   50|  9.78k|        Self {
   51|  9.78k|            inner: Vec::with_capacity(capacity),
   52|  9.78k|        }
   53|  9.78k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple12combine_with:
   78|  3.04k|    pub fn combine_with(&self, other: &Self) -> Option<Self> {
   79|  3.04k|        if self.inner.len() < other.inner.len() {
   80|      6|            let mut result = other.inner.clone();
   81|      6|            for (key, self_value) in self.inner.iter().enumerate() {
   82|      0|                if let Some(self_value) = self_value {
   83|      0|                    match &other.inner[key] {
   84|      0|                        Some(other_value) => {
   85|      0|                            if self_value != other_value {
   86|      0|                                return None;
   87|      0|                            }
   88|       |                        }
   89|      0|                        None => result[key] = Some(self_value.clone()),
   90|       |                    }
   91|      0|                }
   92|       |            }
   93|      6|            Some(Self { inner: result })
   94|       |        } else {
   95|  3.04k|            let mut result = self.inner.clone();
   96|  3.04k|            for (key, other_value) in other.inner.iter().enumerate() {
   97|      4|                if let Some(other_value) = other_value {
   98|      4|                    match &self.inner[key] {
   99|      4|                        Some(self_value) => {
  100|      4|                            if self_value != other_value {
  101|      2|                                return None;
  102|      2|                            }
  103|       |                        }
  104|      0|                        None => result[key] = Some(other_value.clone()),
  105|       |                    }
  106|      0|                }
  107|       |            }
  108|  3.04k|            Some(Self { inner: result })
  109|       |        }
  110|  3.04k|    }
_RNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15EncodedTupleSet9tuple_key:
 5612|    384|    fn tuple_key(&self, tuple: &EncodedTuple) -> u64 {
 5613|    384|        let mut hasher = DefaultHasher::default();
 5614|    387|        for v in &self.key {
 5615|      3|            if let Some(val) = tuple.get(*v) {
 5616|      3|                val.hash(&mut hasher);
 5617|      3|            }
 5618|       |        }
 5619|    384|        hasher.finish()
 5620|    384|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval8datatype:
 3635|      2|fn datatype(dataset: &DatasetView, value: &EncodedTerm) -> Option<EncodedTerm> {
 3636|      2|    // TODO: optimize?
 3637|      2|    match value {
 3638|       |        EncodedTerm::NamedNode { .. }
 3639|       |        | EncodedTerm::SmallBlankNode { .. }
 3640|       |        | EncodedTerm::BigBlankNode { .. }
 3641|       |        | EncodedTerm::NumericalBlankNode { .. }
 3642|       |        | EncodedTerm::DefaultGraph
 3643|      0|        | EncodedTerm::Triple(_) => None,
 3644|       |        EncodedTerm::SmallStringLiteral(_) | EncodedTerm::BigStringLiteral { .. } => {
 3645|      0|            Some(encode_named_node(dataset, xsd::STRING))
 3646|       |        }
 3647|       |        EncodedTerm::SmallSmallLangStringLiteral { .. }
 3648|       |        | EncodedTerm::SmallBigLangStringLiteral { .. }
 3649|       |        | EncodedTerm::BigSmallLangStringLiteral { .. }
 3650|       |        | EncodedTerm::BigBigLangStringLiteral { .. } => {
 3651|      0|            Some(encode_named_node(dataset, rdf::LANG_STRING))
 3652|       |        }
 3653|      0|        EncodedTerm::SmallTypedLiteral { datatype_id, .. }
 3654|      0|        | EncodedTerm::BigTypedLiteral { datatype_id, .. } => Some(EncodedTerm::NamedNode {
 3655|      0|            iri_id: *datatype_id,
 3656|      0|        }),
 3657|      2|        EncodedTerm::BooleanLiteral(..) => Some(encode_named_node(dataset, xsd::BOOLEAN)),
 3658|      0|        EncodedTerm::FloatLiteral(..) => Some(encode_named_node(dataset, xsd::FLOAT)),
 3659|      0|        EncodedTerm::DoubleLiteral(..) => Some(encode_named_node(dataset, xsd::DOUBLE)),
 3660|      0|        EncodedTerm::IntegerLiteral(..) => Some(encode_named_node(dataset, xsd::INTEGER)),
 3661|      0|        EncodedTerm::DecimalLiteral(..) => Some(encode_named_node(dataset, xsd::DECIMAL)),
 3662|      0|        EncodedTerm::DateTimeLiteral(..) => Some(encode_named_node(dataset, xsd::DATE_TIME)),
 3663|      0|        EncodedTerm::TimeLiteral(..) => Some(encode_named_node(dataset, xsd::TIME)),
 3664|      0|        EncodedTerm::DateLiteral(..) => Some(encode_named_node(dataset, xsd::DATE)),
 3665|      0|        EncodedTerm::GYearMonthLiteral(..) => Some(encode_named_node(dataset, xsd::G_YEAR_MONTH)),
 3666|      0|        EncodedTerm::GYearLiteral(..) => Some(encode_named_node(dataset, xsd::G_YEAR)),
 3667|      0|        EncodedTerm::GMonthDayLiteral(..) => Some(encode_named_node(dataset, xsd::G_MONTH_DAY)),
 3668|      0|        EncodedTerm::GDayLiteral(..) => Some(encode_named_node(dataset, xsd::G_DAY)),
 3669|      0|        EncodedTerm::GMonthLiteral(..) => Some(encode_named_node(dataset, xsd::G_MONTH)),
 3670|      0|        EncodedTerm::DurationLiteral(..) => Some(encode_named_node(dataset, xsd::DURATION)),
 3671|       |        EncodedTerm::YearMonthDurationLiteral(..) => {
 3672|      0|            Some(encode_named_node(dataset, xsd::YEAR_MONTH_DURATION))
 3673|       |        }
 3674|       |        EncodedTerm::DayTimeDurationLiteral(..) => {
 3675|      0|            Some(encode_named_node(dataset, xsd::DAY_TIME_DURATION))
 3676|       |        }
 3677|       |    }
 3678|      2|}
_RNvMs1_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_21NumericBinaryOperands3new:
 3702|    137|    fn new(a: EncodedTerm, b: EncodedTerm) -> Option<Self> {
 3703|    137|        match (a, b) {
 3704|      0|            (EncodedTerm::FloatLiteral(v1), EncodedTerm::FloatLiteral(v2)) => {
 3705|      0|                Some(Self::Float(v1, v2))
 3706|       |            }
 3707|      0|            (EncodedTerm::FloatLiteral(v1), EncodedTerm::DoubleLiteral(v2)) => {
 3708|      0|                Some(Self::Double(v1.into(), v2))
 3709|       |            }
 3710|      0|            (EncodedTerm::FloatLiteral(v1), EncodedTerm::IntegerLiteral(v2)) => {
 3711|      0|                Some(Self::Float(v1, v2.into()))
 3712|       |            }
 3713|      0|            (EncodedTerm::FloatLiteral(v1), EncodedTerm::DecimalLiteral(v2)) => {
 3714|      0|                Some(Self::Float(v1, v2.into()))
 3715|       |            }
 3716|      0|            (EncodedTerm::DoubleLiteral(v1), EncodedTerm::FloatLiteral(v2)) => {
 3717|      0|                Some(Self::Double(v1, v2.into()))
 3718|       |            }
 3719|      0|            (EncodedTerm::DoubleLiteral(v1), EncodedTerm::DoubleLiteral(v2)) => {
 3720|      0|                Some(Self::Double(v1, v2))
 3721|       |            }
 3722|      0|            (EncodedTerm::DoubleLiteral(v1), EncodedTerm::IntegerLiteral(v2)) => {
 3723|      0|                Some(Self::Double(v1, v2.into()))
 3724|       |            }
 3725|      0|            (EncodedTerm::DoubleLiteral(v1), EncodedTerm::DecimalLiteral(v2)) => {
 3726|      0|                Some(Self::Double(v1, v2.into()))
 3727|       |            }
 3728|      0|            (EncodedTerm::IntegerLiteral(v1), EncodedTerm::FloatLiteral(v2)) => {
 3729|      0|                Some(Self::Float(v1.into(), v2))
 3730|       |            }
 3731|      0|            (EncodedTerm::IntegerLiteral(v1), EncodedTerm::DoubleLiteral(v2)) => {
 3732|      0|                Some(Self::Double(v1.into(), v2))
 3733|       |            }
 3734|     64|            (EncodedTerm::IntegerLiteral(v1), EncodedTerm::IntegerLiteral(v2)) => {
 3735|     64|                Some(Self::Integer(v1, v2))
 3736|       |            }
 3737|      3|            (EncodedTerm::IntegerLiteral(v1), EncodedTerm::DecimalLiteral(v2)) => {
 3738|      3|                Some(Self::Decimal(v1.into(), v2))
 3739|       |            }
 3740|      0|            (EncodedTerm::DecimalLiteral(v1), EncodedTerm::FloatLiteral(v2)) => {
 3741|      0|                Some(Self::Float(v1.into(), v2))
 3742|       |            }
 3743|      0|            (EncodedTerm::DecimalLiteral(v1), EncodedTerm::DoubleLiteral(v2)) => {
 3744|      0|                Some(Self::Double(v1.into(), v2))
 3745|       |            }
 3746|      0|            (EncodedTerm::DecimalLiteral(v1), EncodedTerm::IntegerLiteral(v2)) => {
 3747|      0|                Some(Self::Decimal(v1, v2.into()))
 3748|       |            }
 3749|     36|            (EncodedTerm::DecimalLiteral(v1), EncodedTerm::DecimalLiteral(v2)) => {
 3750|     36|                Some(Self::Decimal(v1, v2))
 3751|       |            }
 3752|      0|            (EncodedTerm::DurationLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3753|      0|                Some(Self::Duration(v1, v2))
 3754|       |            }
 3755|      0|            (EncodedTerm::DurationLiteral(v1), EncodedTerm::YearMonthDurationLiteral(v2)) => {
 3756|      0|                Some(Self::Duration(v1, v2.into()))
 3757|       |            }
 3758|      0|            (EncodedTerm::DurationLiteral(v1), EncodedTerm::DayTimeDurationLiteral(v2)) => {
 3759|      0|                Some(Self::Duration(v1, v2.into()))
 3760|       |            }
 3761|      0|            (EncodedTerm::YearMonthDurationLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3762|      0|                Some(Self::Duration(v1.into(), v2))
 3763|       |            }
 3764|       |            (
 3765|      0|                EncodedTerm::YearMonthDurationLiteral(v1),
 3766|      0|                EncodedTerm::YearMonthDurationLiteral(v2),
 3767|      0|            ) => Some(Self::YearMonthDuration(v1, v2)),
 3768|       |            (
 3769|      0|                EncodedTerm::YearMonthDurationLiteral(v1),
 3770|      0|                EncodedTerm::DayTimeDurationLiteral(v2),
 3771|      0|            ) => Some(Self::Duration(v1.into(), v2.into())),
 3772|      0|            (EncodedTerm::DayTimeDurationLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3773|      0|                Some(Self::Duration(v1.into(), v2))
 3774|       |            }
 3775|       |            (
 3776|      0|                EncodedTerm::DayTimeDurationLiteral(v1),
 3777|      0|                EncodedTerm::YearMonthDurationLiteral(v2),
 3778|      0|            ) => Some(Self::Duration(v1.into(), v2.into())),
 3779|      0|            (EncodedTerm::DayTimeDurationLiteral(v1), EncodedTerm::DayTimeDurationLiteral(v2)) => {
 3780|      0|                Some(Self::DayTimeDuration(v1, v2))
 3781|       |            }
 3782|      0|            (EncodedTerm::DateTimeLiteral(v1), EncodedTerm::DateTimeLiteral(v2)) => {
 3783|      0|                Some(Self::DateTime(v1, v2))
 3784|       |            }
 3785|      0|            (EncodedTerm::DateLiteral(v1), EncodedTerm::DateLiteral(v2)) => {
 3786|      0|                Some(Self::Date(v1, v2))
 3787|       |            }
 3788|      0|            (EncodedTerm::TimeLiteral(v1), EncodedTerm::TimeLiteral(v2)) => {
 3789|      0|                Some(Self::Time(v1, v2))
 3790|       |            }
 3791|      0|            (EncodedTerm::DateTimeLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3792|      0|                Some(Self::DateTimeDuration(v1, v2))
 3793|       |            }
 3794|      0|            (EncodedTerm::DateTimeLiteral(v1), EncodedTerm::YearMonthDurationLiteral(v2)) => {
 3795|      0|                Some(Self::DateTimeYearMonthDuration(v1, v2))
 3796|       |            }
 3797|      0|            (EncodedTerm::DateTimeLiteral(v1), EncodedTerm::DayTimeDurationLiteral(v2)) => {
 3798|      0|                Some(Self::DateTimeDayTimeDuration(v1, v2))
 3799|       |            }
 3800|      0|            (EncodedTerm::DateLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3801|      0|                Some(Self::DateDuration(v1, v2))
 3802|       |            }
 3803|      0|            (EncodedTerm::DateLiteral(v1), EncodedTerm::YearMonthDurationLiteral(v2)) => {
 3804|      0|                Some(Self::DateYearMonthDuration(v1, v2))
 3805|       |            }
 3806|      0|            (EncodedTerm::DateLiteral(v1), EncodedTerm::DayTimeDurationLiteral(v2)) => {
 3807|      0|                Some(Self::DateDayTimeDuration(v1, v2))
 3808|       |            }
 3809|      0|            (EncodedTerm::TimeLiteral(v1), EncodedTerm::DurationLiteral(v2)) => {
 3810|      0|                Some(Self::TimeDuration(v1, v2))
 3811|       |            }
 3812|      0|            (EncodedTerm::TimeLiteral(v1), EncodedTerm::DayTimeDurationLiteral(v2)) => {
 3813|      0|                Some(Self::TimeDayTimeDuration(v1, v2))
 3814|       |            }
 3815|     34|            _ => None,
 3816|       |        }
 3817|    137|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval6equals:
 3178|     12|fn equals(a: &EncodedTerm, b: &EncodedTerm) -> Option<bool> {
 3179|     12|    match a {
 3180|       |        EncodedTerm::DefaultGraph
 3181|       |        | EncodedTerm::NamedNode { .. }
 3182|       |        | EncodedTerm::NumericalBlankNode { .. }
 3183|       |        | EncodedTerm::SmallBlankNode { .. }
 3184|       |        | EncodedTerm::BigBlankNode { .. }
 3185|       |        | EncodedTerm::SmallSmallLangStringLiteral { .. }
 3186|       |        | EncodedTerm::SmallBigLangStringLiteral { .. }
 3187|       |        | EncodedTerm::BigSmallLangStringLiteral { .. }
 3188|      0|        | EncodedTerm::BigBigLangStringLiteral { .. } => Some(a == b),
 3189|      0|        EncodedTerm::SmallStringLiteral(a) => match b {
 3190|      0|            EncodedTerm::SmallStringLiteral(b) => Some(a == b),
 3191|      0|            EncodedTerm::SmallTypedLiteral { .. } | EncodedTerm::BigTypedLiteral { .. } => None,
 3192|      0|            _ => Some(false),
 3193|       |        },
 3194|      0|        EncodedTerm::BigStringLiteral { value_id: a } => match b {
 3195|      0|            EncodedTerm::BigStringLiteral { value_id: b } => Some(a == b),
 3196|      0|            EncodedTerm::SmallTypedLiteral { .. } | EncodedTerm::BigTypedLiteral { .. } => None,
 3197|      0|            _ => Some(false),
 3198|       |        },
 3199|      0|        EncodedTerm::SmallTypedLiteral { .. } => match b {
 3200|      0|            EncodedTerm::SmallTypedLiteral { .. } if a == b => Some(true),
 3201|       |            EncodedTerm::NamedNode { .. }
 3202|       |            | EncodedTerm::NumericalBlankNode { .. }
 3203|       |            | EncodedTerm::SmallBlankNode { .. }
 3204|       |            | EncodedTerm::BigBlankNode { .. }
 3205|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
 3206|       |            | EncodedTerm::SmallBigLangStringLiteral { .. }
 3207|       |            | EncodedTerm::BigSmallLangStringLiteral { .. }
 3208|       |            | EncodedTerm::BigBigLangStringLiteral { .. }
 3209|      0|            | EncodedTerm::BigTypedLiteral { .. } => Some(false),
 3210|      0|            _ => None,
 3211|       |        },
 3212|      0|        EncodedTerm::BigTypedLiteral { .. } => match b {
 3213|      0|            EncodedTerm::BigTypedLiteral { .. } if a == b => Some(true),
 3214|       |            EncodedTerm::NamedNode { .. }
 3215|       |            | EncodedTerm::NumericalBlankNode { .. }
 3216|       |            | EncodedTerm::SmallBlankNode { .. }
 3217|       |            | EncodedTerm::BigBlankNode { .. }
 3218|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
 3219|       |            | EncodedTerm::SmallBigLangStringLiteral { .. }
 3220|       |            | EncodedTerm::BigSmallLangStringLiteral { .. }
 3221|       |            | EncodedTerm::BigBigLangStringLiteral { .. }
 3222|      0|            | EncodedTerm::SmallTypedLiteral { .. } => Some(false),
 3223|      0|            _ => None,
 3224|       |        },
 3225|     12|        EncodedTerm::BooleanLiteral(a) => match b {
 3226|     12|            EncodedTerm::BooleanLiteral(b) => Some(a == b),
 3227|      0|            _ if b.is_unknown_typed_literal() => None,
 3228|      0|            _ => Some(false),
 3229|       |        },
 3230|      0|        EncodedTerm::FloatLiteral(a) => match b {
 3231|      0|            EncodedTerm::FloatLiteral(b) => Some(a == b),
 3232|      0|            EncodedTerm::DoubleLiteral(b) => Some(Double::from(*a) == *b),
 3233|      0|            EncodedTerm::IntegerLiteral(b) => Some(*a == (*b).into()),
 3234|      0|            EncodedTerm::DecimalLiteral(b) => Some(*a == (*b).into()),
 3235|      0|            _ if b.is_unknown_typed_literal() => None,
 3236|      0|            _ => Some(false),
 3237|       |        },
 3238|      0|        EncodedTerm::DoubleLiteral(a) => match b {
 3239|      0|            EncodedTerm::FloatLiteral(b) => Some(*a == (*b).into()),
 3240|      0|            EncodedTerm::DoubleLiteral(b) => Some(a == b),
 3241|      0|            EncodedTerm::IntegerLiteral(b) => Some(*a == (*b).into()),
 3242|      0|            EncodedTerm::DecimalLiteral(b) => Some(*a == (*b).into()),
 3243|      0|            _ if b.is_unknown_typed_literal() => None,
 3244|      0|            _ => Some(false),
 3245|       |        },
 3246|      0|        EncodedTerm::IntegerLiteral(a) => match b {
 3247|      0|            EncodedTerm::FloatLiteral(b) => Some(Float::from(*a) == *b),
 3248|      0|            EncodedTerm::DoubleLiteral(b) => Some(Double::from(*a) == *b),
 3249|      0|            EncodedTerm::IntegerLiteral(b) => Some(a == b),
 3250|      0|            EncodedTerm::DecimalLiteral(b) => Some(Decimal::from(*a) == *b),
 3251|      0|            _ if b.is_unknown_typed_literal() => None,
 3252|      0|            _ => Some(false),
 3253|       |        },
 3254|      0|        EncodedTerm::DecimalLiteral(a) => match b {
 3255|      0|            EncodedTerm::FloatLiteral(b) => Some(Float::from(*a) == *b),
 3256|      0|            EncodedTerm::DoubleLiteral(b) => Some(Double::from(*a) == *b),
 3257|      0|            EncodedTerm::IntegerLiteral(b) => Some(*a == (*b).into()),
 3258|      0|            EncodedTerm::DecimalLiteral(b) => Some(a == b),
 3259|      0|            _ if b.is_unknown_typed_literal() => None,
 3260|      0|            _ => Some(false),
 3261|       |        },
 3262|      0|        EncodedTerm::DateTimeLiteral(a) => match b {
 3263|      0|            EncodedTerm::DateTimeLiteral(b) => Some(a == b),
 3264|      0|            _ if b.is_unknown_typed_literal() => None,
 3265|      0|            _ => Some(false),
 3266|       |        },
 3267|      0|        EncodedTerm::TimeLiteral(a) => match b {
 3268|      0|            EncodedTerm::TimeLiteral(b) => Some(a == b),
 3269|      0|            _ if b.is_unknown_typed_literal() => None,
 3270|      0|            _ => Some(false),
 3271|       |        },
 3272|      0|        EncodedTerm::DateLiteral(a) => match b {
 3273|      0|            EncodedTerm::DateLiteral(b) => Some(a == b),
 3274|      0|            _ if b.is_unknown_typed_literal() => None,
 3275|      0|            _ => Some(false),
 3276|       |        },
 3277|      0|        EncodedTerm::GYearMonthLiteral(a) => match b {
 3278|      0|            EncodedTerm::GYearMonthLiteral(b) => Some(a == b),
 3279|      0|            _ if b.is_unknown_typed_literal() => None,
 3280|      0|            _ => Some(false),
 3281|       |        },
 3282|      0|        EncodedTerm::GYearLiteral(a) => match b {
 3283|      0|            EncodedTerm::GYearLiteral(b) => Some(a == b),
 3284|      0|            _ if b.is_unknown_typed_literal() => None,
 3285|      0|            _ => Some(false),
 3286|       |        },
 3287|      0|        EncodedTerm::GMonthDayLiteral(a) => match b {
 3288|      0|            EncodedTerm::GMonthDayLiteral(b) => Some(a == b),
 3289|      0|            _ if b.is_unknown_typed_literal() => None,
 3290|      0|            _ => Some(false),
 3291|       |        },
 3292|      0|        EncodedTerm::GDayLiteral(a) => match b {
 3293|      0|            EncodedTerm::GDayLiteral(b) => Some(a == b),
 3294|      0|            _ if b.is_unknown_typed_literal() => None,
 3295|      0|            _ => Some(false),
 3296|       |        },
 3297|      0|        EncodedTerm::GMonthLiteral(a) => match b {
 3298|      0|            EncodedTerm::GMonthLiteral(b) => Some(a == b),
 3299|      0|            _ if b.is_unknown_typed_literal() => None,
 3300|      0|            _ => Some(false),
 3301|       |        },
 3302|      0|        EncodedTerm::DurationLiteral(a) => match b {
 3303|      0|            EncodedTerm::DurationLiteral(b) => Some(a == b),
 3304|      0|            EncodedTerm::YearMonthDurationLiteral(b) => Some(a == b),
 3305|      0|            EncodedTerm::DayTimeDurationLiteral(b) => Some(a == b),
 3306|      0|            _ if b.is_unknown_typed_literal() => None,
 3307|      0|            _ => Some(false),
 3308|       |        },
 3309|      0|        EncodedTerm::YearMonthDurationLiteral(a) => match b {
 3310|      0|            EncodedTerm::DurationLiteral(b) => Some(a == b),
 3311|      0|            EncodedTerm::YearMonthDurationLiteral(b) => Some(a == b),
 3312|      0|            EncodedTerm::DayTimeDurationLiteral(b) => Some(a == b),
 3313|      0|            _ if b.is_unknown_typed_literal() => None,
 3314|      0|            _ => Some(false),
 3315|       |        },
 3316|      0|        EncodedTerm::DayTimeDurationLiteral(a) => match b {
 3317|      0|            EncodedTerm::DurationLiteral(b) => Some(a == b),
 3318|      0|            EncodedTerm::YearMonthDurationLiteral(b) => Some(a == b),
 3319|      0|            EncodedTerm::DayTimeDurationLiteral(b) => Some(a == b),
 3320|      0|            _ if b.is_unknown_typed_literal() => None,
 3321|      0|            _ => Some(false),
 3322|       |        },
 3323|      0|        EncodedTerm::Triple(a) => {
 3324|      0|            if let EncodedTerm::Triple(b) = b {
 3325|       |                Some(
 3326|      0|                    equals(&a.subject, &b.subject)?
 3327|      0|                        && equals(&a.predicate, &b.predicate)?
 3328|      0|                        && equals(&a.object, &b.object)?,
 3329|       |                )
 3330|       |            } else {
 3331|      0|                Some(false)
 3332|       |            }
 3333|       |        }
 3334|       |    }
 3335|     12|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval33are_compatible_and_not_disjointed:
 3957|      4|pub fn are_compatible_and_not_disjointed(a: &EncodedTuple, b: &EncodedTuple) -> bool {
 3958|      4|    let mut found_intersection = false;
 3959|      4|    for (a_value, b_value) in a.iter().zip(b.iter()) {
 3960|      0|        if let (Some(a_value), Some(b_value)) = (a_value, b_value) {
 3961|      0|            if a_value != b_value {
 3962|      0|                return false;
 3963|      0|            }
 3964|      0|            found_intersection = true;
 3965|      0|        }
 3966|       |    }
 3967|      4|    found_intersection
 3968|      4|}
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator32find_graphs_where_the_node_is_in:
 4714|     13|    fn find_graphs_where_the_node_is_in(
 4715|     13|        &self,
 4716|     13|        term: &EncodedTerm,
 4717|     13|    ) -> impl Iterator<Item = Result<EncodedTerm, EvaluationError>> {
 4718|     13|        self.dataset
 4719|     13|            .encoded_quads_for_pattern(Some(term), None, None, None)
 4720|     13|            .chain(
 4721|     13|                self.dataset
 4722|     13|                    .encoded_quads_for_pattern(None, None, Some(term), None),
 4723|     13|            )
 4724|     13|            .map(|q| Ok(q?.graph_name))
 4725|     13|    }
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13TupleSelector17get_pattern_value:
 3894|  99.4k|    fn get_pattern_value(&self, tuple: &EncodedTuple) -> Option<EncodedTerm> {
 3895|  99.4k|        match self {
 3896|  41.5k|            Self::Constant(c) => Some(c.clone()),
 3897|  57.8k|            Self::Variable(v) => tuple.get(*v).cloned(),
 3898|      0|            Self::TriplePattern(triple) => Some(
 3899|      0|                EncodedTriple {
 3900|      0|                    subject: triple.subject.get_pattern_value(tuple)?,
 3901|      0|                    predicate: triple.predicate.get_pattern_value(tuple)?,
 3902|      0|                    object: triple.object.get_pattern_value(tuple)?,
 3903|       |                }
 3904|      0|                .into(),
 3905|       |            ),
 3906|       |        }
 3907|  99.4k|    }
_RNvXs5_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_16HashJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4772|     15|    fn next(&mut self) -> Option<Self::Item> {
 4773|       |        loop {
 4774|     15|            if let Some(result) = self.buffered_results.pop() {
 4775|      0|                return Some(result);
 4776|     15|            }
 4777|     15|            let probe_tuple = match self.probe_iter.next()? {
 4778|      0|                Ok(probe_tuple) => probe_tuple,
 4779|      0|                Err(error) => return Some(Err(error)),
 4780|       |            };
 4781|      0|            self.buffered_results.extend(
 4782|      0|                self.built
 4783|      0|                    .get(&probe_tuple)
 4784|      0|                    .iter()
 4785|      0|                    .filter_map(|built_tuple| probe_tuple.combine_with(built_tuple).map(Ok)),
 4786|      0|            )
 4787|       |        }
 4788|     15|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator16eval_to_in_graph:
 4320|    955|    fn eval_to_in_graph(
 4321|    955|        &self,
 4322|    955|        path: &PropertyPath,
 4323|    955|        end: &EncodedTerm,
 4324|    955|        graph_name: &EncodedTerm,
 4325|    955|    ) -> Box<dyn Iterator<Item = Result<EncodedTerm, EvaluationError>>> {
 4326|    955|        match path {
 4327|    117|            PropertyPath::Path(p) => Box::new(
 4328|    117|                self.dataset
 4329|    117|                    .encoded_quads_for_pattern(None, Some(p), Some(end), Some(graph_name))
 4330|    117|                    .map(|t| Ok(t?.subject)),
 4331|    117|            ),
 4332|    411|            PropertyPath::Reverse(p) => self.eval_from_in_graph(p, end, graph_name),
 4333|    105|            PropertyPath::Sequence(a, b) => {
 4334|    105|                let eval = self.clone();
 4335|    105|                let a = Rc::clone(a);
 4336|    105|                let graph_name2 = graph_name.clone();
 4337|    105|                Box::new(
 4338|    105|                    self.eval_to_in_graph(b, end, graph_name)
 4339|    105|                        .flat_map_ok(move |middle| {
 4340|       |                            eval.eval_to_in_graph(&a, &middle, &graph_name2)
 4341|    105|                        }),
 4342|    105|                )
 4343|       |            }
 4344|    126|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4345|    126|                self.eval_to_in_graph(a, end, graph_name)
 4346|    126|                    .chain(self.eval_to_in_graph(b, end, graph_name)),
 4347|    126|            )),
 4348|     37|            PropertyPath::ZeroOrMore(p) => {
 4349|     37|                self.run_if_term_is_a_graph_node(end, graph_name, || {
 4350|       |                    let eval = self.clone();
 4351|       |                    let p = Rc::clone(p);
 4352|       |                    let graph_name2 = graph_name.clone();
 4353|       |                    transitive_closure(Some(Ok(end.clone())), move |e| {
 4354|       |                        eval.eval_to_in_graph(&p, &e, &graph_name2)
 4355|       |                    })
 4356|     37|                })
 4357|       |            }
 4358|     24|            PropertyPath::OneOrMore(p) => {
 4359|     24|                let eval = self.clone();
 4360|     24|                let p = Rc::clone(p);
 4361|     24|                let graph_name2 = graph_name.clone();
 4362|     24|                Box::new(transitive_closure(
 4363|     24|                    self.eval_to_in_graph(&p, end, graph_name),
 4364|     24|                    move |e| eval.eval_to_in_graph(&p, &e, &graph_name2),
 4365|     24|                ))
 4366|       |            }
 4367|     94|            PropertyPath::ZeroOrOne(p) => self.run_if_term_is_a_graph_node(end, graph_name, || {
 4368|       |                hash_deduplicate(
 4369|       |                    once(Ok(end.clone())).chain(self.eval_to_in_graph(p, end, graph_name)),
 4370|       |                )
 4371|     94|            }),
 4372|     41|            PropertyPath::NegatedPropertySet(ps) => {
 4373|     41|                let ps = Rc::clone(ps);
 4374|     41|                Box::new(
 4375|     41|                    self.dataset
 4376|     41|                        .encoded_quads_for_pattern(None, None, Some(end), Some(graph_name))
 4377|     41|                        .filter_map(move |t| match t {
 4378|       |                            Ok(t) => {
 4379|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4380|       |                                    None
 4381|       |                                } else {
 4382|       |                                    Some(Ok(t.subject))
 4383|       |                                }
 4384|       |                            }
 4385|       |                            Err(e) => Some(Err(e)),
 4386|     41|                        }),
 4387|     41|                )
 4388|       |            }
 4389|       |        }
 4390|    955|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple3get:
   63|  65.3k|    pub fn get(&self, index: usize) -> Option<&EncodedTerm> {
   64|  65.3k|        self.inner.get(index).unwrap_or(&None).as_ref()
   65|  65.3k|    }
_RNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15EncodedTupleSet6insert:
 5600|     95|    fn insert(&mut self, tuple: EncodedTuple) {
 5601|     95|        self.map
 5602|     95|            .entry(self.tuple_key(&tuple))
 5603|     95|            .or_default()
 5604|     95|            .push(tuple);
 5605|     95|        self.len += 1;
 5606|     95|    }
_RNvXsF_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_12EncodedTupleNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB9_:
   43|    325|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple8contains:
   59|     45|    pub fn contains(&self, index: usize) -> bool {
   60|     45|        self.inner.get(index).map_or(false, Option::is_some)
   61|     45|    }
_RNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15EncodedTupleSet3new:
 5592|    371|    fn new(key: Vec<usize>) -> Self {
 5593|    371|        Self {
 5594|    371|            key,
 5595|    371|            map: HashMap::new(),
 5596|    371|            len: 0,
 5597|    371|        }
 5598|    371|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval20partial_cmp_literals:
 3445|      2|fn partial_cmp_literals(
 3446|      2|    dataset: &DatasetView,
 3447|      2|    a: &EncodedTerm,
 3448|      2|    b: &EncodedTerm,
 3449|      2|) -> Option<Ordering> {
 3450|      2|    match a {
 3451|      0|        EncodedTerm::SmallStringLiteral(a) => match b {
 3452|      0|            EncodedTerm::SmallStringLiteral(b) => a.partial_cmp(b),
 3453|      0|            EncodedTerm::BigStringLiteral { value_id: b } => compare_str_str_id(dataset, a, b),
 3454|      0|            _ => None,
 3455|       |        },
 3456|      0|        EncodedTerm::BigStringLiteral { value_id: a } => match b {
 3457|      0|            EncodedTerm::SmallStringLiteral(b) => compare_str_id_str(dataset, a, b),
 3458|      0|            EncodedTerm::BigStringLiteral { value_id: b } => compare_str_ids(dataset, a, b),
 3459|      0|            _ => None,
 3460|       |        },
 3461|       |        EncodedTerm::SmallSmallLangStringLiteral {
 3462|      0|            value: a,
 3463|      0|            language: la,
 3464|      0|        } => match b {
 3465|      0|            EncodedTerm::SmallSmallLangStringLiteral {
 3466|      0|                value: b,
 3467|      0|                language: lb,
 3468|      0|            } if la == lb => a.partial_cmp(b),
 3469|       |            EncodedTerm::BigSmallLangStringLiteral {
 3470|      0|                value_id: b,
 3471|      0|                language: lb,
 3472|      0|            } if la == lb => compare_str_str_id(dataset, a, b),
 3473|      0|            _ => None,
 3474|       |        },
 3475|       |        EncodedTerm::SmallBigLangStringLiteral {
 3476|      0|            value: a,
 3477|      0|            language_id: la,
 3478|      0|        } => match b {
 3479|      0|            EncodedTerm::SmallBigLangStringLiteral {
 3480|      0|                value: b,
 3481|      0|                language_id: lb,
 3482|      0|            } if la == lb => a.partial_cmp(b),
 3483|       |            EncodedTerm::BigBigLangStringLiteral {
 3484|      0|                value_id: b,
 3485|      0|                language_id: lb,
 3486|      0|            } if la == lb => compare_str_str_id(dataset, a, b),
 3487|      0|            _ => None,
 3488|       |        },
 3489|       |        EncodedTerm::BigSmallLangStringLiteral {
 3490|      0|            value_id: a,
 3491|      0|            language: la,
 3492|      0|        } => match b {
 3493|      0|            EncodedTerm::SmallSmallLangStringLiteral {
 3494|      0|                value: b,
 3495|      0|                language: lb,
 3496|      0|            } if la == lb => compare_str_id_str(dataset, a, b),
 3497|       |            EncodedTerm::BigSmallLangStringLiteral {
 3498|      0|                value_id: b,
 3499|      0|                language: lb,
 3500|      0|            } if la == lb => compare_str_ids(dataset, a, b),
 3501|      0|            _ => None,
 3502|       |        },
 3503|       |        EncodedTerm::BigBigLangStringLiteral {
 3504|      0|            value_id: a,
 3505|      0|            language_id: la,
 3506|      0|        } => match b {
 3507|      0|            EncodedTerm::SmallBigLangStringLiteral {
 3508|      0|                value: b,
 3509|      0|                language_id: lb,
 3510|      0|            } if la == lb => compare_str_id_str(dataset, a, b),
 3511|       |            EncodedTerm::BigBigLangStringLiteral {
 3512|      0|                value_id: b,
 3513|      0|                language_id: lb,
 3514|      0|            } if la == lb => compare_str_ids(dataset, a, b),
 3515|      0|            _ => None,
 3516|       |        },
 3517|      0|        EncodedTerm::FloatLiteral(a) => match b {
 3518|      0|            EncodedTerm::FloatLiteral(b) => a.partial_cmp(b),
 3519|      0|            EncodedTerm::DoubleLiteral(b) => Double::from(*a).partial_cmp(b),
 3520|      0|            EncodedTerm::IntegerLiteral(b) => a.partial_cmp(&Float::from(*b)),
 3521|      0|            EncodedTerm::DecimalLiteral(b) => a.partial_cmp(&(*b).into()),
 3522|      0|            _ => None,
 3523|       |        },
 3524|      0|        EncodedTerm::DoubleLiteral(a) => match b {
 3525|      0|            EncodedTerm::FloatLiteral(b) => a.partial_cmp(&(*b).into()),
 3526|      0|            EncodedTerm::DoubleLiteral(b) => a.partial_cmp(b),
 3527|      0|            EncodedTerm::IntegerLiteral(b) => a.partial_cmp(&Double::from(*b)),
 3528|      0|            EncodedTerm::DecimalLiteral(b) => a.partial_cmp(&(*b).into()),
 3529|      0|            _ => None,
 3530|       |        },
 3531|      0|        EncodedTerm::IntegerLiteral(a) => match b {
 3532|      0|            EncodedTerm::FloatLiteral(b) => Float::from(*a).partial_cmp(b),
 3533|      0|            EncodedTerm::DoubleLiteral(b) => Double::from(*a).partial_cmp(b),
 3534|      0|            EncodedTerm::IntegerLiteral(b) => a.partial_cmp(b),
 3535|      0|            EncodedTerm::DecimalLiteral(b) => Decimal::from(*a).partial_cmp(b),
 3536|      0|            _ => None,
 3537|       |        },
 3538|      2|        EncodedTerm::DecimalLiteral(a) => match b {
 3539|      0|            EncodedTerm::FloatLiteral(b) => Float::from(*a).partial_cmp(b),
 3540|      0|            EncodedTerm::DoubleLiteral(b) => Double::from(*a).partial_cmp(b),
 3541|      2|            EncodedTerm::IntegerLiteral(b) => a.partial_cmp(&Decimal::from(*b)),
 3542|      0|            EncodedTerm::DecimalLiteral(b) => a.partial_cmp(b),
 3543|      0|            _ => None,
 3544|       |        },
 3545|      0|        EncodedTerm::DateTimeLiteral(a) => {
 3546|      0|            if let EncodedTerm::DateTimeLiteral(b) = b {
 3547|      0|                a.partial_cmp(b)
 3548|       |            } else {
 3549|      0|                None
 3550|       |            }
 3551|       |        }
 3552|      0|        EncodedTerm::TimeLiteral(a) => {
 3553|      0|            if let EncodedTerm::TimeLiteral(b) = b {
 3554|      0|                a.partial_cmp(b)
 3555|       |            } else {
 3556|      0|                None
 3557|       |            }
 3558|       |        }
 3559|      0|        EncodedTerm::DateLiteral(a) => {
 3560|      0|            if let EncodedTerm::DateLiteral(b) = b {
 3561|      0|                a.partial_cmp(b)
 3562|       |            } else {
 3563|      0|                None
 3564|       |            }
 3565|       |        }
 3566|      0|        EncodedTerm::GYearMonthLiteral(a) => {
 3567|      0|            if let EncodedTerm::GYearMonthLiteral(b) = b {
 3568|      0|                a.partial_cmp(b)
 3569|       |            } else {
 3570|      0|                None
 3571|       |            }
 3572|       |        }
 3573|      0|        EncodedTerm::GYearLiteral(a) => {
 3574|      0|            if let EncodedTerm::GYearLiteral(b) = b {
 3575|      0|                a.partial_cmp(b)
 3576|       |            } else {
 3577|      0|                None
 3578|       |            }
 3579|       |        }
 3580|      0|        EncodedTerm::GMonthDayLiteral(a) => {
 3581|      0|            if let EncodedTerm::GMonthDayLiteral(b) = b {
 3582|      0|                a.partial_cmp(b)
 3583|       |            } else {
 3584|      0|                None
 3585|       |            }
 3586|       |        }
 3587|      0|        EncodedTerm::GDayLiteral(a) => {
 3588|      0|            if let EncodedTerm::GDayLiteral(b) = b {
 3589|      0|                a.partial_cmp(b)
 3590|       |            } else {
 3591|      0|                None
 3592|       |            }
 3593|       |        }
 3594|      0|        EncodedTerm::GMonthLiteral(a) => {
 3595|      0|            if let EncodedTerm::GMonthLiteral(b) = b {
 3596|      0|                a.partial_cmp(b)
 3597|       |            } else {
 3598|      0|                None
 3599|       |            }
 3600|       |        }
 3601|      0|        EncodedTerm::DurationLiteral(a) => match b {
 3602|      0|            EncodedTerm::DurationLiteral(b) => a.partial_cmp(b),
 3603|      0|            EncodedTerm::YearMonthDurationLiteral(b) => a.partial_cmp(b),
 3604|      0|            EncodedTerm::DayTimeDurationLiteral(b) => a.partial_cmp(b),
 3605|      0|            _ => None,
 3606|       |        },
 3607|      0|        EncodedTerm::YearMonthDurationLiteral(a) => match b {
 3608|      0|            EncodedTerm::DurationLiteral(b) => a.partial_cmp(b),
 3609|      0|            EncodedTerm::YearMonthDurationLiteral(b) => a.partial_cmp(b),
 3610|      0|            EncodedTerm::DayTimeDurationLiteral(b) => a.partial_cmp(b),
 3611|      0|            _ => None,
 3612|       |        },
 3613|      0|        EncodedTerm::DayTimeDurationLiteral(a) => match b {
 3614|      0|            EncodedTerm::DurationLiteral(b) => a.partial_cmp(b),
 3615|      0|            EncodedTerm::YearMonthDurationLiteral(b) => a.partial_cmp(b),
 3616|      0|            EncodedTerm::DayTimeDurationLiteral(b) => a.partial_cmp(b),
 3617|      0|            _ => None,
 3618|       |        },
 3619|      0|        _ => None,
 3620|       |    }
 3621|      2|}
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple8capacity:
   55|     12|    pub fn capacity(&self) -> usize {
   56|     12|        self.inner.capacity()
   57|     12|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator47get_subject_or_object_identity_pairs_in_dataset:
 4646|    118|    fn get_subject_or_object_identity_pairs_in_dataset(
 4647|    118|        &self,
 4648|    118|    ) -> impl Iterator<Item = Result<(EncodedTerm, EncodedTerm, EncodedTerm), EvaluationError>>
 4649|    118|    {
 4650|    118|        self.dataset
 4651|    118|            .encoded_quads_for_pattern(None, None, None, None)
 4652|    118|            .flat_map_ok(|t| {
 4653|       |                [
 4654|       |                    Ok((t.subject.clone(), t.subject, t.graph_name.clone())),
 4655|       |                    Ok((t.object.clone(), t.object, t.graph_name)),
 4656|       |                ]
 4657|    118|            })
 4658|    118|    }
_RNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_15SimpleEvaluator20encode_property_path:
 2786|  91.1k|    fn encode_property_path(&self, path: &PropertyPathExpression) -> Rc<PropertyPath> {
 2787|  91.1k|        Rc::new(match path {
 2788|  23.2k|            PropertyPathExpression::NamedNode(node) => PropertyPath::Path(self.encode_term(node)),
 2789|  28.5k|            PropertyPathExpression::Reverse(p) => {
 2790|  28.5k|                PropertyPath::Reverse(self.encode_property_path(p))
 2791|       |            }
 2792|  10.7k|            PropertyPathExpression::Sequence(a, b) => {
 2793|  10.7k|                PropertyPath::Sequence(self.encode_property_path(a), self.encode_property_path(b))
 2794|       |            }
 2795|  4.65k|            PropertyPathExpression::Alternative(a, b) => PropertyPath::Alternative(
 2796|  4.65k|                self.encode_property_path(a),
 2797|  4.65k|                self.encode_property_path(b),
 2798|  4.65k|            ),
 2799|  2.78k|            PropertyPathExpression::ZeroOrMore(p) => {
 2800|  2.78k|                PropertyPath::ZeroOrMore(self.encode_property_path(p))
 2801|       |            }
 2802|  5.08k|            PropertyPathExpression::OneOrMore(p) => {
 2803|  5.08k|                PropertyPath::OneOrMore(self.encode_property_path(p))
 2804|       |            }
 2805|  11.9k|            PropertyPathExpression::ZeroOrOne(p) => {
 2806|  11.9k|                PropertyPath::ZeroOrOne(self.encode_property_path(p))
 2807|       |            }
 2808|  4.08k|            PropertyPathExpression::NegatedPropertySet(ps) => {
 2809|  4.08k|                PropertyPath::NegatedPropertySet(ps.iter().map(|p| self.encode_term(p)).collect())
 2810|       |            }
 2811|       |        })
 2812|  91.1k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval11partial_cmp:
 3425|      6|fn partial_cmp(dataset: &DatasetView, a: &EncodedTerm, b: &EncodedTerm) -> Option<Ordering> {
 3426|      6|    if a == b {
 3427|      4|        Some(Ordering::Equal)
 3428|      2|    } else if let EncodedTerm::Triple(a) = a {
 3429|      0|        if let EncodedTerm::Triple(b) = b {
 3430|      0|            match partial_cmp(dataset, &a.subject, &b.subject) {
 3431|      0|                Some(Ordering::Equal) => match partial_cmp(dataset, &a.predicate, &b.predicate) {
 3432|      0|                    Some(Ordering::Equal) => partial_cmp(dataset, &a.object, &b.object),
 3433|      0|                    o => o,
 3434|       |                },
 3435|      0|                o => o,
 3436|       |            }
 3437|       |        } else {
 3438|      0|            None
 3439|       |        }
 3440|       |    } else {
 3441|      2|        partial_cmp_literals(dataset, a, b)
 3442|       |    }
 3443|      6|}
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13TupleSelector24from_ground_term_pattern:
 3828|  98.6k|    fn from_ground_term_pattern(
 3829|  98.6k|        term_pattern: &GroundTermPattern,
 3830|  98.6k|        variables: &mut Vec<Variable>,
 3831|  98.6k|        dataset: &DatasetView,
 3832|  98.6k|    ) -> Self {
 3833|  98.6k|        match term_pattern {
 3834|  88.4k|            GroundTermPattern::Variable(variable) => {
 3835|  88.4k|                Self::Variable(encode_variable(variables, variable))
 3836|       |            }
 3837|  8.91k|            GroundTermPattern::NamedNode(term) => Self::Constant(dataset.encode_term(term)),
 3838|  1.32k|            GroundTermPattern::Literal(term) => Self::Constant(dataset.encode_term(term)),
 3839|      0|            GroundTermPattern::Triple(triple) => {
 3840|      0|                match (
 3841|      0|                    Self::from_ground_term_pattern(&triple.subject, variables, dataset),
 3842|      0|                    Self::from_named_node_pattern(&triple.predicate, variables, dataset),
 3843|      0|                    Self::from_ground_term_pattern(&triple.object, variables, dataset),
 3844|       |                ) {
 3845|       |                    (
 3846|      0|                        Self::Constant(subject),
 3847|      0|                        Self::Constant(predicate),
 3848|      0|                        Self::Constant(object),
 3849|      0|                    ) => Self::Constant(
 3850|      0|                        EncodedTriple {
 3851|      0|                            subject,
 3852|      0|                            predicate,
 3853|      0|                            object,
 3854|      0|                        }
 3855|      0|                        .into(),
 3856|      0|                    ),
 3857|      0|                    (subject, predicate, object) => {
 3858|      0|                        Self::TriplePattern(Rc::new(TripleTupleSelector {
 3859|      0|                            subject,
 3860|      0|                            predicate,
 3861|      0|                            object,
 3862|      0|                        }))
 3863|       |                    }
 3864|       |                }
 3865|       |            }
 3866|       |        }
 3867|  98.6k|    }
_RNvXsH_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_12EncodedTupleNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
   43|  25.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator20eval_closed_in_graph:
 3987|     70|    fn eval_closed_in_graph(
 3988|     70|        &self,
 3989|     70|        path: &PropertyPath,
 3990|     70|        start: &EncodedTerm,
 3991|     70|        end: &EncodedTerm,
 3992|     70|        graph_name: &EncodedTerm,
 3993|     70|    ) -> Result<bool, EvaluationError> {
 3994|     70|        Ok(match path {
 3995|     14|            PropertyPath::Path(p) => self
 3996|     14|                .dataset
 3997|     14|                .encoded_quads_for_pattern(Some(start), Some(p), Some(end), Some(graph_name))
 3998|     14|                .next()
 3999|     14|                .transpose()?
 4000|     14|                .is_some(),
 4001|     30|            PropertyPath::Reverse(p) => self.eval_closed_in_graph(p, end, start, graph_name)?,
 4002|      8|            PropertyPath::Sequence(a, b) => self
 4003|      8|                .eval_from_in_graph(a, start, graph_name)
 4004|      8|                .find_map(|middle| {
 4005|       |                    middle
 4006|       |                        .and_then(|middle| {
 4007|       |                            Ok(self
 4008|       |                                .eval_closed_in_graph(b, &middle, end, graph_name)?
 4009|       |                                .then_some(()))
 4010|       |                        })
 4011|       |                        .transpose()
 4012|      8|                })
 4013|      8|                .transpose()?
 4014|      8|                .is_some(),
 4015|     12|            PropertyPath::Alternative(a, b) => {
 4016|     12|                self.eval_closed_in_graph(a, start, end, graph_name)?
 4017|     12|                    || self.eval_closed_in_graph(b, start, end, graph_name)?
 4018|       |            }
 4019|      0|            PropertyPath::ZeroOrMore(p) => {
 4020|      0|                if start == end {
 4021|      0|                    self.is_subject_or_object_in_graph(start, graph_name)?
 4022|       |                } else {
 4023|      0|                    look_in_transitive_closure(
 4024|      0|                        self.eval_from_in_graph(p, start, graph_name),
 4025|      0|                        move |e| self.eval_from_in_graph(p, &e, graph_name),
 4026|      0|                        end,
 4027|      0|                    )?
 4028|       |                }
 4029|       |            }
 4030|      0|            PropertyPath::OneOrMore(p) => look_in_transitive_closure(
 4031|      0|                self.eval_from_in_graph(p, start, graph_name),
 4032|      0|                move |e| self.eval_from_in_graph(p, &e, graph_name),
 4033|      0|                end,
 4034|      0|            )?,
 4035|      6|            PropertyPath::ZeroOrOne(p) => {
 4036|      6|                if start == end {
 4037|      4|                    self.is_subject_or_object_in_graph(start, graph_name)
 4038|       |                } else {
 4039|      2|                    self.eval_closed_in_graph(p, start, end, graph_name)
 4040|      0|                }?
 4041|       |            }
 4042|      0|            PropertyPath::NegatedPropertySet(ps) => self
 4043|      0|                .dataset
 4044|      0|                .encoded_quads_for_pattern(Some(start), None, Some(end), Some(graph_name))
 4045|      0|                .find_map(move |t| match t {
 4046|       |                    Ok(t) => {
 4047|       |                        if ps.iter().any(|p| *p == t.predicate) {
 4048|       |                            None
 4049|       |                        } else {
 4050|       |                            Some(Ok(()))
 4051|       |                        }
 4052|       |                    }
 4053|       |                    Err(e) => Some(Err(e)),
 4054|      0|                })
 4055|      0|                .transpose()?
 4056|      0|                .is_some(),
 4057|       |        })
 4058|     70|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator29is_subject_or_object_in_graph:
 4678|    285|    fn is_subject_or_object_in_graph(
 4679|    285|        &self,
 4680|    285|        term: &EncodedTerm,
 4681|    285|        graph_name: &EncodedTerm,
 4682|    285|    ) -> Result<bool, EvaluationError> {
 4683|    285|        Ok(self
 4684|    285|            .dataset
 4685|    285|            .encoded_quads_for_pattern(Some(term), None, None, Some(graph_name))
 4686|    285|            .next()
 4687|    285|            .transpose()?
 4688|    285|            .is_some()
 4689|    285|            || self
 4690|    285|                .dataset
 4691|    285|                .encoded_quads_for_pattern(None, None, Some(term), Some(graph_name))
 4692|    285|                .next()
 4693|    285|                .transpose()?
 4694|    285|                .is_some())
 4695|    285|    }
_RNvXs4_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_28CartesianProductJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 4737|  23.0k|    fn next(&mut self) -> Option<Self::Item> {
 4738|       |        loop {
 4739|  23.1k|            if let Some(result) = self.buffered_results.pop() {
 4740|     21|                return Some(result);
 4741|  23.1k|            }
 4742|  23.1k|            let probe_tuple = match self.probe_iter.next()? {
 4743|    156|                Ok(probe_tuple) => probe_tuple,
 4744|      0|                Err(error) => return Some(Err(error)),
 4745|       |            };
 4746|    179|            for built_tuple in &self.built {
 4747|     23|                if let Some(result_tuple) = probe_tuple.combine_with(built_tuple) {
 4748|     21|                    self.buffered_results.push(Ok(result_tuple))
 4749|      2|                }
 4750|       |            }
 4751|       |        }
 4752|  23.0k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval17encode_named_node:
 3001|      2|fn encode_named_node(dataset: &DatasetView, node: NamedNodeRef<'_>) -> EncodedTerm {
 3002|      2|    dataset.encode_term(node)
 3003|      2|}
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator45get_subject_or_object_identity_pairs_in_graph:
 4632|  3.98k|    fn get_subject_or_object_identity_pairs_in_graph(
 4633|  3.98k|        &self,
 4634|  3.98k|        graph_name: &EncodedTerm,
 4635|  3.98k|    ) -> impl Iterator<Item = Result<(EncodedTerm, EncodedTerm), EvaluationError>> {
 4636|  3.98k|        self.dataset
 4637|  3.98k|            .encoded_quads_for_pattern(None, None, None, Some(graph_name))
 4638|  3.98k|            .flat_map_ok(|t| {
 4639|       |                [
 4640|       |                    Ok((t.subject.clone(), t.subject)),
 4641|       |                    Ok((t.object.clone(), t.object)),
 4642|       |                ]
 4643|  3.98k|            })
 4644|  3.98k|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator18eval_from_in_graph:
 4158|  1.12k|    fn eval_from_in_graph(
 4159|  1.12k|        &self,
 4160|  1.12k|        path: &PropertyPath,
 4161|  1.12k|        start: &EncodedTerm,
 4162|  1.12k|        graph_name: &EncodedTerm,
 4163|  1.12k|    ) -> Box<dyn Iterator<Item = Result<EncodedTerm, EvaluationError>>> {
 4164|  1.12k|        match path {
 4165|    184|            PropertyPath::Path(p) => Box::new(
 4166|    184|                self.dataset
 4167|    184|                    .encoded_quads_for_pattern(Some(start), Some(p), None, Some(graph_name))
 4168|    184|                    .map(|t| Ok(t?.object)),
 4169|    184|            ),
 4170|    392|            PropertyPath::Reverse(p) => self.eval_to_in_graph(p, start, graph_name),
 4171|    188|            PropertyPath::Sequence(a, b) => {
 4172|    188|                let eval = self.clone();
 4173|    188|                let b = Rc::clone(b);
 4174|    188|                let graph_name2 = graph_name.clone();
 4175|    188|                Box::new(
 4176|    188|                    self.eval_from_in_graph(a, start, graph_name)
 4177|    188|                        .flat_map_ok(move |middle| {
 4178|       |                            eval.eval_from_in_graph(&b, &middle, &graph_name2)
 4179|    188|                        }),
 4180|    188|                )
 4181|       |            }
 4182|    118|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4183|    118|                self.eval_from_in_graph(a, start, graph_name)
 4184|    118|                    .chain(self.eval_from_in_graph(b, start, graph_name)),
 4185|    118|            )),
 4186|     19|            PropertyPath::ZeroOrMore(p) => {
 4187|     19|                self.run_if_term_is_a_graph_node(start, graph_name, || {
 4188|       |                    let eval = self.clone();
 4189|       |                    let p = Rc::clone(p);
 4190|       |                    let graph_name2 = graph_name.clone();
 4191|       |                    transitive_closure(Some(Ok(start.clone())), move |e| {
 4192|       |                        eval.eval_from_in_graph(&p, &e, &graph_name2)
 4193|       |                    })
 4194|     19|                })
 4195|       |            }
 4196|     62|            PropertyPath::OneOrMore(p) => {
 4197|     62|                let eval = self.clone();
 4198|     62|                let p = Rc::clone(p);
 4199|     62|                let graph_name2 = graph_name.clone();
 4200|     62|                Box::new(transitive_closure(
 4201|     62|                    self.eval_from_in_graph(&p, start, graph_name),
 4202|     62|                    move |e| eval.eval_from_in_graph(&p, &e, &graph_name2),
 4203|     62|                ))
 4204|       |            }
 4205|    131|            PropertyPath::ZeroOrOne(p) => {
 4206|    131|                self.run_if_term_is_a_graph_node(start, graph_name, || {
 4207|       |                    hash_deduplicate(
 4208|       |                        once(Ok(start.clone()))
 4209|       |                            .chain(self.eval_from_in_graph(p, start, graph_name)),
 4210|       |                    )
 4211|    131|                })
 4212|       |            }
 4213|     34|            PropertyPath::NegatedPropertySet(ps) => {
 4214|     34|                let ps = Rc::clone(ps);
 4215|     34|                Box::new(
 4216|     34|                    self.dataset
 4217|     34|                        .encoded_quads_for_pattern(Some(start), None, None, Some(graph_name))
 4218|     34|                        .filter_map(move |t| match t {
 4219|       |                            Ok(t) => {
 4220|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4221|       |                                    None
 4222|       |                                } else {
 4223|       |                                    Some(Ok(t.object))
 4224|       |                                }
 4225|       |                            }
 4226|       |                            Err(e) => Some(Err(e)),
 4227|     34|                        }),
 4228|     34|                )
 4229|       |            }
 4230|       |        }
 4231|  1.12k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB2_12EncodedTuple3set:
   71|  7.32k|    pub fn set(&mut self, index: usize, value: EncodedTerm) {
   72|  7.32k|        if self.inner.len() <= index {
   73|  1.59k|            self.inner.resize(index + 1, None);
   74|  5.73k|        }
   75|  7.32k|        self.inner[index] = Some(value);
   76|  7.32k|    }
_RNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB5_13PathEvaluator26eval_open_in_unknown_graph:
 4557|    635|    fn eval_open_in_unknown_graph(
 4558|    635|        &self,
 4559|    635|        path: &PropertyPath,
 4560|    635|    ) -> Box<dyn Iterator<Item = Result<(EncodedTerm, EncodedTerm, EncodedTerm), EvaluationError>>>
 4561|    635|    {
 4562|    635|        match path {
 4563|    122|            PropertyPath::Path(p) => Box::new(
 4564|    122|                self.dataset
 4565|    122|                    .encoded_quads_for_pattern(None, Some(p), None, None)
 4566|    122|                    .map(|t| t.map(|t| (t.subject, t.object, t.graph_name))),
 4567|    122|            ),
 4568|     90|            PropertyPath::Reverse(p) => Box::new(
 4569|     90|                self.eval_open_in_unknown_graph(p)
 4570|     90|                    .map(|t| t.map(|(s, o, g)| (o, s, g))),
 4571|     90|            ),
 4572|    167|            PropertyPath::Sequence(a, b) => {
 4573|    167|                let eval = self.clone();
 4574|    167|                let b = Rc::clone(b);
 4575|    167|                Box::new(self.eval_open_in_unknown_graph(a).flat_map_ok(
 4576|    167|                    move |(start, middle, graph_name)| {
 4577|       |                        eval.eval_from_in_graph(&b, &middle, &graph_name)
 4578|       |                            .map(move |end| Ok((start.clone(), end?, graph_name.clone())))
 4579|    167|                    },
 4580|    167|                ))
 4581|       |            }
 4582|     57|            PropertyPath::Alternative(a, b) => Box::new(hash_deduplicate(
 4583|     57|                self.eval_open_in_unknown_graph(a)
 4584|     57|                    .chain(self.eval_open_in_unknown_graph(b)),
 4585|     57|            )),
 4586|     43|            PropertyPath::ZeroOrMore(p) => {
 4587|     43|                let eval = self.clone();
 4588|     43|                let p = Rc::clone(p);
 4589|     43|                Box::new(transitive_closure(
 4590|     43|                    self.get_subject_or_object_identity_pairs_in_dataset(),
 4591|     43|                    move |(start, middle, graph_name)| {
 4592|       |                        eval.eval_from_in_graph(&p, &middle, &graph_name)
 4593|       |                            .map(move |end| Ok((start.clone(), end?, graph_name.clone())))
 4594|     43|                    },
 4595|     43|                ))
 4596|       |            }
 4597|     24|            PropertyPath::OneOrMore(p) => {
 4598|     24|                let eval = self.clone();
 4599|     24|                let p = Rc::clone(p);
 4600|     24|                Box::new(transitive_closure(
 4601|     24|                    self.eval_open_in_unknown_graph(&p),
 4602|     24|                    move |(start, middle, graph_name)| {
 4603|       |                        eval.eval_from_in_graph(&p, &middle, &graph_name)
 4604|       |                            .map(move |end| Ok((start.clone(), end?, graph_name.clone())))
 4605|     24|                    },
 4606|     24|                ))
 4607|       |            }
 4608|     75|            PropertyPath::ZeroOrOne(p) => Box::new(hash_deduplicate(
 4609|     75|                self.get_subject_or_object_identity_pairs_in_dataset()
 4610|     75|                    .chain(self.eval_open_in_unknown_graph(p)),
 4611|     75|            )),
 4612|     57|            PropertyPath::NegatedPropertySet(ps) => {
 4613|     57|                let ps = Rc::clone(ps);
 4614|     57|                Box::new(
 4615|     57|                    self.dataset
 4616|     57|                        .encoded_quads_for_pattern(None, None, None, None)
 4617|     57|                        .filter_map(move |t| match t {
 4618|       |                            Ok(t) => {
 4619|       |                                if ps.iter().any(|p| *p == t.predicate) {
 4620|       |                                    None
 4621|       |                                } else {
 4622|       |                                    Some(Ok((t.subject, t.object, t.graph_name)))
 4623|       |                                }
 4624|       |                            }
 4625|       |                            Err(e) => Some(Err(e)),
 4626|     57|                        }),
 4627|     57|                )
 4628|       |            }
 4629|       |        }
 4630|    635|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0s0_0Bd_:
 1013|     10|                        .for_each(|tuple| {
 1014|     10|                            // TODO avoid copy for key?
 1015|     10|                            let key = key_variables
 1016|     10|                                .iter()
 1017|     10|                                .map(|v| tuple.get(*v).cloned())
 1018|     10|                                .collect();
 1019|     10|
 1020|     10|                            let key_accumulators =
 1021|     10|                                accumulators_for_group.entry(key).or_insert_with(|| {
 1022|       |                                    accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>()
 1023|     10|                                });
 1024|     10|                            for (accumulator, input_expression) in key_accumulators
 1025|     10|                                .iter_mut()
 1026|     10|                                .zip(&aggregate_input_expressions)
 1027|      0|                            {
 1028|      0|                                accumulator.add(
 1029|      0|                                    input_expression
 1030|      0|                                        .as_ref()
 1031|      0|                                        .and_then(|parameter| parameter(&tuple)),
 1032|      0|                                );
 1033|      0|                            }
 1034|     10|                        });
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators8_00Bd_:
  668|    270|                    Box::new(left(from).flat_map(move |t| match t {
  669|    270|                        Ok(t) => right(t),
  670|      0|                        Err(e) => Box::new(once(Err(e))),
  671|    270|                    }))
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureTNtNtNtB6_7storage15numeric_encoder11EncodedTermB10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultB10_NtNtB4_5error15EvaluationErrorEEL_ENCNCNvMs3_B2_NtB2_13PathEvaluator18eval_open_in_graphs2_00EIB2F_DB3e_p4ItemIB3U_BZ_B4k_EEL_ENCB4X_s2_0EB6_:
 5120|  1.20k|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|  1.20k|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|  1.20k|    mut next: impl FnMut(T) -> NI,
 5123|  1.20k|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|  1.20k|    let mut errors = Vec::new();
 5125|  1.20k|    let mut todo = start
 5126|  1.20k|        .into_iter()
 5127|  1.20k|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|  1.20k|        })
 5134|  1.20k|        .collect::<Vec<_>>();
 5135|  1.20k|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|  1.20k|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|  1.20k|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|  1.20k|}
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkTNtNtNtB9_7storage15numeric_encoder11EncodedTermBZ_EBY_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2z_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator24eval_to_in_unknown_graphs_0INtNtNtB2x_8adapters3map3MapIB1S_DB2r_p4ItemIB3t_BZ_B3S_EEL_ENCNCB4t_s_00EEB2r_4nextB9_:
 5235|      9|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|      9|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|      9|            }
 5242|      9|            self.current = None;
 5243|      9|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|      9|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators4_00Bd_:
  595|    487|                                    .filter_map(|result| match result {
  596|    487|                                        Ok(result) => Some(result),
  597|      0|                                        Err(error) => {
  598|      0|                                            errors.push(Err(error));
  599|      0|                                            None
  600|       |                                        }
  601|    487|                                    })
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator27run_if_term_is_a_graph_nodeNtNtNtBa_7storage15numeric_encoder11EncodedTermINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters6filter6FilterINtNtB2m_5chain5ChainINtNtNtB2o_7sources4once4OnceINtNtB2q_6result6ResultB1w_NtNtB8_5error15EvaluationErrorEEINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB2o_6traits8iterator8Iteratorp4ItemB3Z_EL_EENCINvB6_16hash_deduplicateB1w_B3b_E0ENCNvB2_18eval_from_in_graphs2_0EBa_:
 4660|    131|    fn run_if_term_is_a_graph_node<
 4661|    131|        T: 'static,
 4662|    131|        I: Iterator<Item = Result<T, EvaluationError>> + 'static,
 4663|    131|    >(
 4664|    131|        &self,
 4665|    131|        term: &EncodedTerm,
 4666|    131|        graph_name: &EncodedTerm,
 4667|    131|        f: impl FnOnce() -> I,
 4668|    131|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4669|    131|        match self.is_subject_or_object_in_graph(term, graph_name) {
 4670|      0|            Ok(true) => Box::new(f()),
 4671|       |            Ok(false) => {
 4672|    131|                Box::new(empty()) // Not in the database
 4673|       |            }
 4674|      0|            Err(error) => Box::new(once(Err(error))),
 4675|       |        }
 4676|    131|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators4_0Bb_:
  592|  22.9k|                            Rc::new(move |from| {
  593|  22.9k|                                let mut errors = Vec::default();
  594|  22.9k|                                let build_values = build(from.clone())
  595|  22.9k|                                    .filter_map(|result| match result {
  596|       |                                        Ok(result) => Some(result),
  597|       |                                        Err(error) => {
  598|       |                                            errors.push(Err(error));
  599|       |                                            None
  600|       |                                        }
  601|  22.9k|                                    })
  602|  22.9k|                                    .collect::<Vec<_>>();
  603|  22.9k|                                Box::new(CartesianProductJoinIterator {
  604|  22.9k|                                    probe_iter: probe(from),
  605|  22.9k|                                    built: build_values,
  606|  22.9k|                                    buffered_results: errors,
  607|  22.9k|                                })
  608|  22.9k|                            })
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator29run_if_term_is_a_dataset_nodeTNtNtNtBa_7storage15numeric_encoder11EncodedTermB1z_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtB2u_5chain5ChainIB2q_INtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterNtNtB8_5error15EvaluationErrorENcNtINtNtB2y_6result6ResultB1z_B4r_E3Err0EIB2q_INtNtNtNtCsc4CYCHgsNRQ_3std11collections4hash3set8IntoIterB1z_ENcNtB50_2Ok0EENCNCNvB2_26eval_from_in_unknown_graphs0_0s_0ENCB70_s0_0EBa_:
 4697|      4|    fn run_if_term_is_a_dataset_node<
 4698|      4|        T: 'static,
 4699|      4|        I: IntoIterator<Item = Result<T, EvaluationError>> + 'static,
 4700|      4|    >(
 4701|      4|        &self,
 4702|      4|        term: &EncodedTerm,
 4703|      4|        f: impl FnMut(EncodedTerm) -> I + 'static,
 4704|      4|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4705|      4|        match self
 4706|      4|            .find_graphs_where_the_node_is_in(term)
 4707|      4|            .collect::<Result<HashSet<_>, _>>()
 4708|       |        {
 4709|      4|            Ok(graph_names) => Box::new(graph_names.into_iter().flat_map(f)),
 4710|      0|            Err(error) => Box::new(once(Err(error))),
 4711|       |        }
 4712|      4|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0Bb_:
  992|     12|                Rc::new(move |from| {
  993|     12|                    let tuple_size = from.capacity();
  994|     12|                    let key_variables = Rc::clone(&key_variables);
  995|     12|                    let mut errors = Vec::default();
  996|     12|                    let mut accumulators_for_group =
  997|     12|                        HashMap::<Vec<Option<EncodedTerm>>, Vec<Box<dyn Accumulator>>>::default();
  998|     12|                    if key_variables.is_empty() {
  999|      0|                        // There is always a single group if there is no GROUP BY
 1000|      0|                        accumulators_for_group.insert(
 1001|      0|                            Vec::new(),
 1002|      0|                            accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>(),
 1003|      0|                        );
 1004|     12|                    }
 1005|     12|                    child(from)
 1006|     12|                        .filter_map(|result| match result {
 1007|       |                            Ok(result) => Some(result),
 1008|       |                            Err(error) => {
 1009|       |                                errors.push(error);
 1010|       |                                None
 1011|       |                            }
 1012|     12|                        })
 1013|     12|                        .for_each(|tuple| {
 1014|       |                            // TODO avoid copy for key?
 1015|       |                            let key = key_variables
 1016|       |                                .iter()
 1017|       |                                .map(|v| tuple.get(*v).cloned())
 1018|       |                                .collect();
 1019|       |
 1020|       |                            let key_accumulators =
 1021|       |                                accumulators_for_group.entry(key).or_insert_with(|| {
 1022|       |                                    accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>()
 1023|       |                                });
 1024|       |                            for (accumulator, input_expression) in key_accumulators
 1025|       |                                .iter_mut()
 1026|       |                                .zip(&aggregate_input_expressions)
 1027|       |                            {
 1028|       |                                accumulator.add(
 1029|       |                                    input_expression
 1030|       |                                        .as_ref()
 1031|       |                                        .and_then(|parameter| parameter(&tuple)),
 1032|       |                                );
 1033|       |                            }
 1034|     12|                        });
 1035|     12|                    let accumulator_variables = accumulator_variables.clone();
 1036|     12|                    Box::new(
 1037|     12|                        errors
 1038|     12|                            .into_iter()
 1039|     12|                            .map(Err)
 1040|     12|                            .chain(accumulators_for_group.into_iter().map(
 1041|     12|                                move |(key, accumulators)| {
 1042|       |                                    let mut result = EncodedTuple::with_capacity(tuple_size);
 1043|       |                                    for (variable, value) in key_variables.iter().zip(key) {
 1044|       |                                        if let Some(value) = value {
 1045|       |                                            result.set(*variable, value);
 1046|       |                                        }
 1047|       |                                    }
 1048|       |                                    for (accumulator, variable) in
 1049|       |                                        accumulators.into_iter().zip(&accumulator_variables)
 1050|       |                                    {
 1051|       |                                        if let Some(value) = accumulator.state() {
 1052|       |                                            result.set(*variable, value);
 1053|       |                                        }
 1054|       |                                    }
 1055|       |                                    Ok(result)
 1056|     12|                                },
 1057|     12|                            )),
 1058|     12|                    )
 1059|     12|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators4_0Bb_:
 1171|     10|                Rc::new(move |tuple| {
 1172|     10|                    let mut error = false;
 1173|     20|                    for child in &*children {
 1174|     20|                        match child(tuple).and_then(|v| to_bool(&v)) {
 1175|      0|                            Some(true) => return Some(true.into()),
 1176|      0|                            Some(false) => continue,
 1177|     20|                            None => error = true,
 1178|       |                        }
 1179|       |                    }
 1180|     10|                    if error {
 1181|     10|                        None
 1182|       |                    } else {
 1183|      0|                        Some(false.into())
 1184|       |                    }
 1185|     10|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators7_0Bb_:
 1211|    301|                Rc::new(move |tuple| equals(&a(tuple)?, &b(tuple)?).map(Into::into))
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0s1_0Bd_:
 1041|     10|                                move |(key, accumulators)| {
 1042|     10|                                    let mut result = EncodedTuple::with_capacity(tuple_size);
 1043|     36|                                    for (variable, value) in key_variables.iter().zip(key) {
 1044|     36|                                        if let Some(value) = value {
 1045|      4|                                            result.set(*variable, value);
 1046|     32|                                        }
 1047|       |                                    }
 1048|      0|                                    for (accumulator, variable) in
 1049|     10|                                        accumulators.into_iter().zip(&accumulator_variables)
 1050|       |                                    {
 1051|      0|                                        if let Some(value) = accumulator.state() {
 1052|      0|                                            result.set(*variable, value);
 1053|      0|                                        }
 1054|       |                                    }
 1055|     10|                                    Ok(result)
 1056|     10|                                },
_RNCINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval11format_listRNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableRINtNtCsjOdcKtOMjJI_5alloc3vec3VecBV_EE0B8_:
 5845|  8.93k|        .map(|v| v.to_string())
_RNCNvXs4_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_28CartesianProductJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint0Bb_:
 4758|     67|            max.map(|v| v.saturating_mul(self.built.len())),
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorso_0Bb_:
 1466|      6|                        Rc::new(move |tuple| match e(tuple)? {
 1467|      0|                            EncodedTerm::SmallSmallLangStringLiteral { language, .. }
 1468|      0|                            | EncodedTerm::BigSmallLangStringLiteral { language, .. } => {
 1469|      0|                                Some(build_string_literal_from_id(language.into()))
 1470|       |                            }
 1471|      0|                            EncodedTerm::SmallBigLangStringLiteral { language_id, .. }
 1472|      0|                            | EncodedTerm::BigBigLangStringLiteral { language_id, .. } => {
 1473|      0|                                Some(build_string_literal_from_id(language_id.into()))
 1474|       |                            }
 1475|      0|                            e if e.is_literal() => Some(build_string_literal(&dataset, "")),
 1476|      0|                            _ => None,
 1477|      6|                        })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators8_0Bb_:
  666|  21.3k|                Rc::new(move |from| {
  667|  21.3k|                    let right = Rc::clone(&right);
  668|  21.3k|                    Box::new(left(from).flat_map(move |t| match t {
  669|       |                        Ok(t) => right(t),
  670|       |                        Err(e) => Box::new(once(Err(e))),
  671|  21.3k|                    }))
  672|  21.3k|                })
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkNtNtNtB9_7storage15numeric_encoder11EncodedQuadTNtB10_11EncodedTermB1K_EINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2Q_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator45get_subject_or_object_identity_pairs_in_graph0AIB3K_B1J_B49_Ej2_EB2I_4nextB9_:
 5235|  3.98k|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|  3.98k|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|  3.98k|            }
 5242|  3.98k|            self.current = None;
 5243|  3.98k|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|  3.98k|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsa_0Bb_:
  706|      1|                                .map(|v| encode_variable(encoded_variables, v))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsh_0Bb_:
 1387|     22|                Rc::new(move |tuple| match e(tuple)? {
 1388|      0|                    EncodedTerm::FloatLiteral(value) => Some(value.into()),
 1389|      0|                    EncodedTerm::DoubleLiteral(value) => Some(value.into()),
 1390|      4|                    EncodedTerm::IntegerLiteral(value) => Some(value.into()),
 1391|      0|                    EncodedTerm::DecimalLiteral(value) => Some(value.into()),
 1392|      0|                    EncodedTerm::DurationLiteral(value) => Some(value.into()),
 1393|      0|                    EncodedTerm::YearMonthDurationLiteral(value) => Some(value.into()),
 1394|      0|                    EncodedTerm::DayTimeDurationLiteral(value) => Some(value.into()),
 1395|      8|                    _ => None,
 1396|     22|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators0_0Bb_:
 1155|    416|                Rc::new(move |tuple| tuple.get(v).cloned())
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsb_0Bb_:
  708|      1|                            Rc::new(move |from| {
  709|      1|                                let mut right_values = EncodedTupleSet::new(keys.clone());
  710|      1|                                right_values.extend(right(from.clone()).filter_map(Result::ok));
  711|      1|                                Box::new(left(from).filter(move |left_tuple| {
  712|       |                                    if let Ok(left_tuple) = left_tuple {
  713|       |                                        !right_values.get(left_tuple).iter().any(|right_tuple| {
  714|       |                                            are_compatible_and_not_disjointed(
  715|       |                                                left_tuple,
  716|       |                                                right_tuple,
  717|       |                                            )
  718|       |                                        })
  719|       |                                    } else {
  720|       |                                        true
  721|       |                                    }
  722|      1|                                }))
  723|      1|                            })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorso_0Bb_:
  929|  3.36k|                    .map(|(new_variable, variable)| {
  930|  3.36k|                        (new_variable, encode_variable(encoded_variables, variable))
  931|  3.36k|                    })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators2_0Bb_:
 1164|      5|                Rc::new(move |tuple| Some(eval(tuple.clone()).next().is_some().into()))
_RNCNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next0Bb_:
 4824|     68|                    .filter_map(|right_tuple| left_tuple.combine_with(right_tuple))
_RNCNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nexts_0Bb_:
 4825|     68|                    .filter(|tuple| {
 4826|     68|                        (self.expression)(tuple)
 4827|     68|                            .and_then(|term| to_bool(&term))
 4828|     68|                            .unwrap_or(false)
 4829|     68|                    })
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureTNtNtNtB6_7storage15numeric_encoder11EncodedTermB10_B10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB21_6traits8iterator8Iteratorp4ItemINtNtB23_6result6ResultB10_NtNtB4_5error15EvaluationErrorEEL_ENCNCNvMs3_B2_NtB2_13PathEvaluator26eval_open_in_unknown_graphs2_00EIB2J_DB3i_p4ItemIB3Y_BZ_B4o_EEL_ENCB51_s2_0EB6_:
 5120|     24|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|     24|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|     24|    mut next: impl FnMut(T) -> NI,
 5123|     24|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|     24|    let mut errors = Vec::new();
 5125|     24|    let mut todo = start
 5126|     24|        .into_iter()
 5127|     24|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|     24|        })
 5134|     24|        .collect::<Vec<_>>();
 5135|     24|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|     24|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|     24|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|     24|}
_RINvXsx_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_15EncodedTupleSetINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect6ExtendNtB6_12EncodedTupleE6extendINtNtNtB1c_8adapters10filter_map9FilterMapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtB1a_8iterator8Iteratorp4ItemINtNtB1e_6result6ResultB1Y_NtNtB8_5error15EvaluationErrorEEL_ENvMB4e_B4b_2okEEBa_:
 5628|      1|    fn extend<T: IntoIterator<Item = EncodedTuple>>(&mut self, iter: T) {
 5629|      1|        let iter = iter.into_iter();
 5630|      1|        self.map.reserve(iter.size_hint().0);
 5631|      1|        for tuple in iter {
 5632|      0|            self.insert(tuple);
 5633|      0|        }
 5634|      1|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsm_0Bb_:
 1435|    238|                Rc::new(move |tuple| {
 1436|    238|                    if to_bool(&a(tuple)?)? {
 1437|      0|                        b(tuple)
 1438|       |                    } else {
 1439|      2|                        c(tuple)
 1440|       |                    }
 1441|    238|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators3_0Bb_:
 1169|     60|                    .map(|i| self.expression_evaluator(i, encoded_variables, stat_children))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsg_0Bb_:
 1374|    549|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1375|      0|                        NumericBinaryOperands::Float(v1, v2) => Some((v1 / v2).into()),
 1376|      0|                        NumericBinaryOperands::Double(v1, v2) => Some((v1 / v2).into()),
 1377|     62|                        NumericBinaryOperands::Integer(v1, v2) => {
 1378|     62|                            Some(Decimal::from(v1).checked_div(v2)?.into())
 1379|       |                        }
 1380|      2|                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_div(v2)?.into()),
 1381|      0|                        _ => None,
 1382|    549|                    },
_RNCNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_13PathEvaluator18eval_open_in_graphs_0Bb_:
 4492|      6|                    .map(|t| t.map(|(s, o)| (o, s))),
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureTNtNtNtB6_7storage15numeric_encoder11EncodedTermB10_B10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB21_6traits8iterator8Iteratorp4ItemINtNtB23_6result6ResultB10_NtNtB4_5error15EvaluationErrorEEL_ENCNCNvMs3_B2_NtB2_13PathEvaluator26eval_open_in_unknown_graphs1_00EINtB2_9FlatMapOkNtB12_11EncodedQuadBZ_IB2J_DB3i_p4ItemIB3Y_B6i_B4o_EEL_ENCNvB53_47get_subject_or_object_identity_pairs_in_dataset0AIB3Y_BZ_B4o_Ej2_ENCB51_s1_0EB6_:
 5120|     43|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|     43|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|     43|    mut next: impl FnMut(T) -> NI,
 5123|     43|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|     43|    let mut errors = Vec::new();
 5125|     43|    let mut todo = start
 5126|     43|        .into_iter()
 5127|     43|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|     43|        })
 5134|     43|        .collect::<Vec<_>>();
 5135|     43|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|     43|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|     43|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|     43|}
_RNCNCNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_13PathEvaluator18eval_open_in_graphs_00Bd_:
 4492|      6|                    .map(|t| t.map(|(s, o)| (o, s))),
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators6_0Bb_:
  615|     15|                            Rc::new(move |from| {
  616|     15|                                let mut errors = Vec::default();
  617|     15|                                let mut built_values = EncodedTupleSet::new(keys.clone());
  618|     15|                                built_values.extend(build(from.clone()).filter_map(|result| {
  619|       |                                    match result {
  620|       |                                        Ok(result) => Some(result),
  621|       |                                        Err(error) => {
  622|       |                                            errors.push(Err(error));
  623|       |                                            None
  624|       |                                        }
  625|       |                                    }
  626|     15|                                }));
  627|     15|                                Box::new(HashJoinIterator {
  628|     15|                                    probe_iter: probe(from),
  629|     15|                                    built: built_values,
  630|     15|                                    buffered_results: errors,
  631|     15|                                })
  632|     15|                            })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators7_0Bb_:
  655|     37|                        return Rc::new(move |from| {
  656|     37|                            Box::new(ForLoopLeftJoinIterator {
  657|     37|                                right_evaluator: Rc::clone(&right),
  658|     37|                                left_iter: left(from),
  659|     37|                                current_right: Box::new(empty()),
  660|     37|                            })
  661|     37|                        });
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator27run_if_term_is_a_graph_nodeNtNtNtBa_7storage15numeric_encoder11EncodedTermINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtB2m_3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterNtNtB8_5error15EvaluationErrorENcNtINtNtB2q_6result6ResultB1w_B4e_E3Err0EIB3a_INtNtNtNtCsc4CYCHgsNRQ_3std11collections4hash3set8IntoIterB1w_ENcNtB4N_2Ok0EENCNvB2_16eval_to_in_graphs0_0EBa_:
 4660|     37|    fn run_if_term_is_a_graph_node<
 4661|     37|        T: 'static,
 4662|     37|        I: Iterator<Item = Result<T, EvaluationError>> + 'static,
 4663|     37|    >(
 4664|     37|        &self,
 4665|     37|        term: &EncodedTerm,
 4666|     37|        graph_name: &EncodedTerm,
 4667|     37|        f: impl FnOnce() -> I,
 4668|     37|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4669|     37|        match self.is_subject_or_object_in_graph(term, graph_name) {
 4670|      0|            Ok(true) => Box::new(f()),
 4671|       |            Ok(false) => {
 4672|     37|                Box::new(empty()) // Not in the database
 4673|       |            }
 4674|      0|            Err(error) => Box::new(once(Err(error))),
 4675|       |        }
 4676|     37|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsj_0Bb_:
 1415|    664|                Rc::new(move |tuple| to_bool(&e(tuple)?).map(|v| (!v).into()))
_RNCNvMsw_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15EncodedTupleSet3get0Bb_:
 5609|     68|        self.map.get(&self.tuple_key(tuple)).map_or(&[], |v| v)
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsk_0Bb_:
  891|  1.42k|                Rc::new(move |from| Box::new(hash_deduplicate(child(from))))
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateTNtNtNtB6_7storage15numeric_encoder11EncodedTermBY_BY_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultBX_NtNtB4_5error15EvaluationErrorEEL_EB2I_EEB6_:
 5175|     57|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|     57|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|     57|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|     57|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|     57|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|     57|    })
 5191|     57|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureTNtNtNtB6_7storage15numeric_encoder11EncodedTermB10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultB10_NtNtB4_5error15EvaluationErrorEEL_ENCNCNvMs3_B2_NtB2_13PathEvaluator24eval_to_in_unknown_graphs1_00EIB2F_DB3e_p4ItemIB3U_BZ_B4k_EEL_ENCB4X_s1_0EB6_:
 5120|      1|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|      1|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|      1|    mut next: impl FnMut(T) -> NI,
 5123|      1|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|      1|    let mut errors = Vec::new();
 5125|      1|    let mut todo = start
 5126|      1|        .into_iter()
 5127|      1|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|      1|        })
 5134|      1|        .collect::<Vec<_>>();
 5135|      1|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|      1|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|      1|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|      1|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsl_0Bb_:
 1422|      5|                Rc::new(move |tuple| {
 1423|      5|                    for e in &l {
 1424|      0|                        if let Some(result) = e(tuple) {
 1425|      0|                            return Some(result);
 1426|      0|                        }
 1427|       |                    }
 1428|      5|                    None
 1429|      5|                })
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkTNtNtNtB9_7storage15numeric_encoder11EncodedTermBZ_BZ_EBY_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2C_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator26eval_open_in_unknown_graphs0_0INtNtNtB2A_8adapters3map3MapIB1V_DB2u_p4ItemIB3w_BZ_B3V_EEL_ENCNCB4w_s0_00EEB2u_4nextB9_:
 5235|    167|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|    167|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|    167|            }
 5242|    167|            self.current = None;
 5243|    167|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|    167|    }
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator29run_if_term_is_a_dataset_nodeTNtNtNtBa_7storage15numeric_encoder11EncodedTermB1z_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtB2u_5chain5ChainIB2q_INtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterNtNtB8_5error15EvaluationErrorENcNtINtNtB2y_6result6ResultB1z_B4r_E3Err0EIB2q_INtNtNtNtCsc4CYCHgsNRQ_3std11collections4hash3set8IntoIterB1z_ENcNtB50_2Ok0EENCNCNvB2_24eval_to_in_unknown_graphs0_0s_0ENCB70_s0_0EBa_:
 4697|      3|    fn run_if_term_is_a_dataset_node<
 4698|      3|        T: 'static,
 4699|      3|        I: IntoIterator<Item = Result<T, EvaluationError>> + 'static,
 4700|      3|    >(
 4701|      3|        &self,
 4702|      3|        term: &EncodedTerm,
 4703|      3|        f: impl FnMut(EncodedTerm) -> I + 'static,
 4704|      3|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4705|      3|        match self
 4706|      3|            .find_graphs_where_the_node_is_in(term)
 4707|      3|            .collect::<Result<HashSet<_>, _>>()
 4708|       |        {
 4709|      3|            Ok(graph_names) => Box::new(graph_names.into_iter().flat_map(f)),
 4710|      0|            Err(error) => Box::new(once(Err(error))),
 4711|       |        }
 4712|      3|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator20expression_evaluatorsj_00Bd_:
 1415|     56|                Rc::new(move |tuple| to_bool(&e(tuple)?).map(|v| (!v).into()))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators5_0Bb_:
 1190|    530|                    .map(|i| self.expression_evaluator(i, encoded_variables, stat_children))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators_0Bb_:
  298|  3.02k|                    .map(|row| {
  299|  3.02k|                        let mut result = EncodedTuple::with_capacity(variables.len());
  300|  8.99k|                        for (key, value) in row.iter().enumerate() {
  301|  8.99k|                            if let Some(term) = value {
  302|  6.56k|                                result.set(
  303|  6.56k|                                    encoding[key],
  304|  6.56k|                                    match term {
  305|  5.83k|                                        GroundTerm::NamedNode(node) => self.encode_term(node),
  306|    732|                                        GroundTerm::Literal(literal) => self.encode_term(literal),
  307|      0|                                        GroundTerm::Triple(triple) => self.encode_triple(triple),
  308|       |                                    },
  309|       |                                );
  310|  2.42k|                            }
  311|       |                        }
  312|  3.02k|                        result
  313|  3.02k|                    })
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateNtNtNtB6_7storage15numeric_encoder11EncodedTermINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1P_6traits8iterator8Iteratorp4ItemINtNtB1R_6result6ResultBX_NtNtB4_5error15EvaluationErrorEEL_EB2A_EEB6_:
 5175|    244|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|    244|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|    244|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|    244|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|    244|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|    244|    })
 5191|    244|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateTNtNtNtB6_7storage15numeric_encoder11EncodedTermBY_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtB2_9FlatMapOkNtB10_11EncodedQuadBX_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1U_6traits8iterator8Iteratorp4ItemINtNtB1W_6result6ResultB2V_NtNtB4_5error15EvaluationErrorEEL_ENCNvMs3_B2_NtB2_13PathEvaluator45get_subject_or_object_identity_pairs_in_graph0AIB4x_BX_B4X_Ej2_EIB3i_DB3R_p4ItemB6O_EL_EEEB6_:
 5175|  3.30k|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|  3.30k|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|  3.30k|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|  3.30k|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|  3.30k|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|  3.30k|    })
 5191|  3.30k|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorse_0Bb_:
  776|     44|                Rc::new(move |from| {
  777|     44|                    let expression = Rc::clone(&expression);
  778|     44|                    Box::new(child(from).filter(move |tuple| {
  779|       |                        match tuple {
  780|       |                            Ok(tuple) => expression(tuple)
  781|       |                                .and_then(|term| to_bool(&term))
  782|       |                                .unwrap_or(false),
  783|       |                            Err(_) => true,
  784|       |                        }
  785|     44|                    }))
  786|     44|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsk_0Bb_:
 1420|     16|                    .map(|e| self.expression_evaluator(e, encoded_variables, stat_children))
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkNtNtNtB9_7storage15numeric_encoder11EncodedQuadTNtB10_11EncodedTermB1K_B1K_EINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2U_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator47get_subject_or_object_identity_pairs_in_dataset0AIB3O_B1J_B4d_Ej2_EB2M_4nextB9_:
 5235|    118|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|    118|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|    118|            }
 5242|    118|            self.current = None;
 5243|    118|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|    118|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators6_0Bb_:
 1192|    101|                Rc::new(move |tuple| {
 1193|    101|                    let mut error = false;
 1194|    211|                    for child in &*children {
 1195|    211|                        match child(tuple).and_then(|v| to_bool(&v)) {
 1196|      0|                            Some(true) => continue,
 1197|      4|                            Some(false) => return Some(false.into()),
 1198|    207|                            None => error = true,
 1199|       |                        }
 1200|       |                    }
 1201|     97|                    if error {
 1202|     97|                        None
 1203|       |                    } else {
 1204|      0|                        Some(true.into())
 1205|       |                    }
 1206|    101|                })
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0s_0Bd_:
 1006|     10|                        .filter_map(|result| match result {
 1007|     10|                            Ok(result) => Some(result),
 1008|      0|                            Err(error) => {
 1009|      0|                                errors.push(error);
 1010|      0|                                None
 1011|       |                            }
 1012|     10|                        })
_RNCNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_13PathEvaluator18eval_open_in_graphs3_0Bb_:
 4542|     16|                        .filter_map(move |t| match t {
 4543|     16|                            Ok(t) => {
 4544|     16|                                if ps.iter().any(|p| *p == t.predicate) {
 4545|      2|                                    None
 4546|       |                                } else {
 4547|     14|                                    Some(Ok((t.subject, t.object)))
 4548|       |                                }
 4549|       |                            }
 4550|      0|                            Err(e) => Some(Err(e)),
 4551|     16|                        }),
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsh_0Bb_:
  819|    554|                Rc::new(move |from| {
  820|    554|                    let expression = Rc::clone(&expression);
  821|    554|                    Box::new(child(from).map(move |tuple| {
  822|       |                        let mut tuple = tuple?;
  823|       |                        if let Some(value) = expression(&tuple) {
  824|       |                            tuple.set(position, value);
  825|       |                        }
  826|       |                        Ok(tuple)
  827|    554|                    }))
  828|    554|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsl_0Bb_:
  896|  2.42k|                Rc::new(move |from| {
  897|  2.42k|                    Box::new(ConsecutiveDeduplication {
  898|  2.42k|                        inner: child(from),
  899|  2.42k|                        current: None,
  900|  2.42k|                    })
  901|  2.42k|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsq_0Bb_:
  973|     40|                    .map(|k| encode_variable(encoded_variables, k))
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator27run_if_term_is_a_graph_nodeNtNtNtBa_7storage15numeric_encoder11EncodedTermINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtB2m_3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterNtNtB8_5error15EvaluationErrorENcNtINtNtB2q_6result6ResultB1w_B4e_E3Err0EIB3a_INtNtNtNtCsc4CYCHgsNRQ_3std11collections4hash3set8IntoIterB1w_ENcNtB4N_2Ok0EENCNvB2_18eval_from_in_graphs0_0EBa_:
 4660|     19|    fn run_if_term_is_a_graph_node<
 4661|     19|        T: 'static,
 4662|     19|        I: Iterator<Item = Result<T, EvaluationError>> + 'static,
 4663|     19|    >(
 4664|     19|        &self,
 4665|     19|        term: &EncodedTerm,
 4666|     19|        graph_name: &EncodedTerm,
 4667|     19|        f: impl FnOnce() -> I,
 4668|     19|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4669|     19|        match self.is_subject_or_object_in_graph(term, graph_name) {
 4670|      0|            Ok(true) => Box::new(f()),
 4671|       |            Ok(false) => {
 4672|     19|                Box::new(empty()) // Not in the database
 4673|       |            }
 4674|      0|            Err(error) => Box::new(once(Err(error))),
 4675|       |        }
 4676|     19|    }
_RNCINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateTNtNtNtB8_7storage15numeric_encoder11EncodedTermB10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultBZ_NtNtB6_5error15EvaluationErrorEEL_EB2I_EE0B8_:
 5179|     14|    iter.filter(move |e| {
 5180|     14|        if let Ok(e) = e {
 5181|     14|            if already_seen.contains(e) {
 5182|      2|                false
 5183|       |            } else {
 5184|     12|                already_seen.insert(e.clone());
 5185|     12|                true
 5186|       |            }
 5187|       |        } else {
 5188|      0|            true
 5189|       |        }
 5190|     14|    })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators0_0Bb_:
  315|  2.28k|                Rc::new(move |from| {
  316|  2.28k|                    Box::new(
  317|  2.28k|                        encoded_tuples
  318|  2.28k|                            .iter()
  319|  2.28k|                            .filter_map(move |t| Some(Ok(t.combine_with(&from)?)))
  320|  2.28k|                            .collect::<Vec<_>>()
  321|  2.28k|                            .into_iter(),
  322|  2.28k|                    )
  323|  2.28k|                })
_RNCNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtBb_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0s0_00Bf_:
 1017|     36|                                .map(|v| tuple.get(*v).cloned())
_RINvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_15SimpleEvaluator11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralEBa_:
 2766|  4.64k|    fn encode_term<'b>(&self, term: impl Into<TermRef<'b>>) -> EncodedTerm {
 2767|  4.64k|        self.dataset.encode_term(term)
 2768|  4.64k|    }
_RNCNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtBb_15SimpleEvaluator29build_graph_pattern_evaluatorse_000Bf_:
  781|      3|                                .and_then(|term| to_bool(&term))
_RINvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_15SimpleEvaluator11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeEBa_:
 2766|  45.6k|    fn encode_term<'b>(&self, term: impl Into<TermRef<'b>>) -> EncodedTerm {
 2767|  45.6k|        self.dataset.encode_term(term)
 2768|  45.6k|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators9_00Bd_:
  690|     36|                                Box::new(left(from).filter(move |left_tuple| {
  691|     36|                                    if let Ok(left_tuple) = left_tuple {
  692|     36|                                        !right.iter().any(|right_tuple| {
  693|       |                                            are_compatible_and_not_disjointed(
  694|       |                                                left_tuple,
  695|       |                                                right_tuple,
  696|       |                                            )
  697|     36|                                        })
  698|       |                                    } else {
  699|      0|                                        true
  700|       |                                    }
  701|     36|                                }))
_RNCNCNvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_13PathEvaluator18eval_open_in_graphs3_00Bd_:
 4544|     34|                                if ps.iter().any(|p| *p == t.predicate) {
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsg_0Bb_:
  799|     38|                Rc::new(move |from| {
  800|     38|                    Box::new(UnionIterator {
  801|     38|                        plans: children.clone(),
  802|     38|                        input: from,
  803|     38|                        current_iterator: Box::new(empty()),
  804|     38|                        current_plan: 0,
  805|     38|                    })
  806|     38|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators9_0Bb_:
  687|     39|                            Rc::new(move |from| {
  688|     39|                                let right: Vec<_> =
  689|     39|                                    right(from.clone()).filter_map(Result::ok).collect();
  690|     39|                                Box::new(left(from).filter(move |left_tuple| {
  691|       |                                    if let Ok(left_tuple) = left_tuple {
  692|       |                                        !right.iter().any(|right_tuple| {
  693|       |                                            are_compatible_and_not_disjointed(
  694|       |                                                left_tuple,
  695|       |                                                right_tuple,
  696|       |                                            )
  697|       |                                        })
  698|       |                                    } else {
  699|       |                                        true
  700|       |                                    }
  701|     39|                                }))
  702|     39|                            })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsf_0Bb_:
 1361|    101|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1362|      0|                        NumericBinaryOperands::Float(v1, v2) => Some((v1 * v2).into()),
 1363|      0|                        NumericBinaryOperands::Double(v1, v2) => Some((v1 * v2).into()),
 1364|      2|                        NumericBinaryOperands::Integer(v1, v2) => Some(v1.checked_mul(v2)?.into()),
 1365|     12|                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_mul(v2)?.into()),
 1366|      0|                        _ => None,
 1367|    101|                    },
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators3_0s0_0Bd_:
  491|     12|                                    .filter_map(move |so| match so {
  492|     12|                                        Ok((s, o)) => {
  493|     12|                                            let mut new_tuple = from.clone();
  494|     12|                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  495|     12|                                            put_pattern_value(&object, o, &mut new_tuple)?;
  496|     12|                                            Some(Ok(new_tuple))
  497|       |                                        }
  498|      0|                                        Err(error) => Some(Err(error)),
  499|     12|                                    }),
_RNCNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtBb_15SimpleEvaluator29build_graph_pattern_evaluators9_000Bf_:
  692|      4|                                        !right.iter().any(|right_tuple| {
  693|      4|                                            are_compatible_and_not_disjointed(
  694|      4|                                                left_tuple,
  695|      4|                                                right_tuple,
  696|      4|                                            )
  697|      4|                                        })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators14_0Bb_:
 2286|     10|                        Rc::new(move |tuple| Some(e(tuple)?.is_blank_node().into()))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20encode_property_path0Bb_:
 2809|  15.9k|                PropertyPath::NegatedPropertySet(ps.iter().map(|p| self.encode_term(p)).collect())
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorse_0Bb_:
 1314|    508|                Rc::new(move |tuple| {
 1315|    508|                    Some(match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1316|      0|                        NumericBinaryOperands::Float(v1, v2) => (v1 - v2).into(),
 1317|      0|                        NumericBinaryOperands::Double(v1, v2) => (v1 - v2).into(),
 1318|      0|                        NumericBinaryOperands::Integer(v1, v2) => v1.checked_sub(v2)?.into(),
 1319|     22|                        NumericBinaryOperands::Decimal(v1, v2) => v1.checked_sub(v2)?.into(),
 1320|      0|                        NumericBinaryOperands::DateTime(v1, v2) => v1.checked_sub(v2)?.into(),
 1321|      0|                        NumericBinaryOperands::Date(v1, v2) => v1.checked_sub(v2)?.into(),
 1322|      0|                        NumericBinaryOperands::Time(v1, v2) => v1.checked_sub(v2)?.into(),
 1323|      0|                        NumericBinaryOperands::Duration(v1, v2) => v1.checked_sub(v2)?.into(),
 1324|      0|                        NumericBinaryOperands::YearMonthDuration(v1, v2) => {
 1325|      0|                            v1.checked_sub(v2)?.into()
 1326|       |                        }
 1327|      0|                        NumericBinaryOperands::DayTimeDuration(v1, v2) => {
 1328|      0|                            v1.checked_sub(v2)?.into()
 1329|       |                        }
 1330|      0|                        NumericBinaryOperands::DateTimeDuration(v1, v2) => {
 1331|      0|                            v1.checked_sub_duration(v2)?.into()
 1332|       |                        }
 1333|      0|                        NumericBinaryOperands::DateTimeYearMonthDuration(v1, v2) => {
 1334|      0|                            v1.checked_sub_year_month_duration(v2)?.into()
 1335|       |                        }
 1336|      0|                        NumericBinaryOperands::DateTimeDayTimeDuration(v1, v2) => {
 1337|      0|                            v1.checked_sub_day_time_duration(v2)?.into()
 1338|       |                        }
 1339|      0|                        NumericBinaryOperands::DateDuration(v1, v2) => {
 1340|      0|                            v1.checked_sub_duration(v2)?.into()
 1341|       |                        }
 1342|      0|                        NumericBinaryOperands::DateYearMonthDuration(v1, v2) => {
 1343|      0|                            v1.checked_sub_year_month_duration(v2)?.into()
 1344|       |                        }
 1345|      0|                        NumericBinaryOperands::DateDayTimeDuration(v1, v2) => {
 1346|      0|                            v1.checked_sub_day_time_duration(v2)?.into()
 1347|       |                        }
 1348|      0|                        NumericBinaryOperands::TimeDuration(v1, v2) => {
 1349|      0|                            v1.checked_sub_duration(v2)?.into()
 1350|       |                        }
 1351|      0|                        NumericBinaryOperands::TimeDayTimeDuration(v1, v2) => {
 1352|      0|                            v1.checked_sub_day_time_duration(v2)?.into()
 1353|       |                        }
 1354|       |                    })
 1355|    508|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators2_0Bb_:
  387|  20.5k|                Rc::new(move |from| {
  388|  20.5k|                    let iter = dataset.encoded_quads_for_pattern(
  389|  20.5k|                        subject.get_pattern_value(&from).as_ref(),
  390|  20.5k|                        predicate.get_pattern_value(&from).as_ref(),
  391|  20.5k|                        object.get_pattern_value(&from).as_ref(),
  392|  20.5k|                        graph_name.get_pattern_value(&from).as_ref(),
  393|  20.5k|                    );
  394|  20.5k|                    let subject = subject.clone();
  395|  20.5k|                    let predicate = predicate.clone();
  396|  20.5k|                    let object = object.clone();
  397|  20.5k|                    let graph_name = graph_name.clone();
  398|  20.5k|                    Box::new(iter.filter_map(move |quad| match quad {
  399|       |                        Ok(quad) => {
  400|       |                            let mut new_tuple = from.clone();
  401|       |                            put_pattern_value(&subject, quad.subject, &mut new_tuple)?;
  402|       |                            put_pattern_value(&predicate, quad.predicate, &mut new_tuple)?;
  403|       |                            put_pattern_value(&object, quad.object, &mut new_tuple)?;
  404|       |                            put_pattern_value(&graph_name, quad.graph_name, &mut new_tuple)?;
  405|       |                            Some(Ok(new_tuple))
  406|       |                        }
  407|       |                        Err(error) => Some(Err(error)),
  408|  20.5k|                    }))
  409|  20.5k|                })
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateTNtNtNtB6_7storage15numeric_encoder11EncodedTermBY_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1U_6traits8iterator8Iteratorp4ItemINtNtB1W_6result6ResultBX_NtNtB4_5error15EvaluationErrorEEL_EB2F_EEB6_:
 5175|  1.20k|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|  1.20k|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|  1.20k|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|  1.20k|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|  1.20k|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|  1.20k|    })
 5191|  1.20k|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval11format_listRNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableRINtNtCsjOdcKtOMjJI_5alloc3vec3VecBT_EEB6_:
 5842|  28.9k|fn format_list<T: ToString>(values: impl IntoIterator<Item = T>) -> String {
 5843|  28.9k|    values
 5844|  28.9k|        .into_iter()
 5845|  28.9k|        .map(|v| v.to_string())
 5846|  28.9k|        .collect::<Vec<_>>()
 5847|  28.9k|        .join(", ")
 5848|  28.9k|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsp_0Bb_:
  933|  1.86k|                Rc::new(move |from| {
  934|  1.86k|                    let mapping = Rc::clone(&mapping);
  935|  1.86k|                    let mut input_tuple = EncodedTuple::with_capacity(mapping.len());
  936|  3.19k|                    for (input_key, output_key) in &*mapping {
  937|  3.19k|                        if let Some(value) = from.get(*output_key) {
  938|      0|                            input_tuple.set(*input_key, value.clone());
  939|  3.19k|                        }
  940|       |                    }
  941|  1.86k|                    Box::new(child(input_tuple).filter_map(move |tuple| {
  942|       |                        match tuple {
  943|       |                            Ok(tuple) => {
  944|       |                                let mut output_tuple = from.clone();
  945|       |                                for (input_key, output_key) in &*mapping {
  946|       |                                    if let Some(value) = tuple.get(*input_key) {
  947|       |                                        if let Some(existing_value) = output_tuple.get(*output_key)
  948|       |                                        {
  949|       |                                            if existing_value != value {
  950|       |                                                return None; // Conflict
  951|       |                                            }
  952|       |                                        } else {
  953|       |                                            output_tuple.set(*output_key, value.clone());
  954|       |                                        }
  955|       |                                    }
  956|       |                                }
  957|       |                                Some(Ok(output_tuple))
  958|       |                            }
  959|       |                            Err(e) => Some(Err(e)),
  960|       |                        }
  961|  1.86k|                    }))
  962|  1.86k|                })
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateNtB2_12EncodedTupleINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB1Y_6result6ResultBX_NtNtB4_5error15EvaluationErrorEEL_EEB6_:
 5175|  1.42k|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|  1.42k|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|  1.42k|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|  1.42k|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|  1.42k|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|  1.42k|    })
 5191|  1.42k|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators_0Bb_:
 1151|    416|                Rc::new(move |_| Some(t.clone()))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators9_0Bb_:
 1222|     22|                Rc::new(move |tuple| {
 1223|     22|                    Some(
 1224|     22|                        (partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? == Ordering::Greater)
 1225|      0|                            .into(),
 1226|       |                    )
 1227|     22|                })
_RNCNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtBb_15SimpleEvaluator29build_graph_pattern_evaluatorsu_0s0_0s_0Bf_:
 1021|     10|                                accumulators_for_group.entry(key).or_insert_with(|| {
 1022|     10|                                    accumulator_builders.iter().map(|c| c()).collect::<Vec<_>>()
 1023|     10|                                });
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsc_0Bb_:
 1255|     15|                Rc::new(move |tuple| {
 1256|     15|                    Some(
 1257|     15|                        match partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? {
 1258|      0|                            Ordering::Less | Ordering::Equal => true,
 1259|      0|                            Ordering::Greater => false,
 1260|       |                        }
 1261|      0|                        .into(),
 1262|       |                    )
 1263|     15|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsb_0Bb_:
 1247|      4|                Rc::new(move |tuple| {
 1248|      4|                    Some((partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? == Ordering::Less).into())
 1249|      4|                })
_RNCNCNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4nexts_00Bd_:
 4827|     68|                            .and_then(|term| to_bool(&term))
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureNtNtNtB6_7storage15numeric_encoder11EncodedTermINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2s_6result6ResultBZ_NtNtB4_5error15EvaluationErrorEEL_EB1K_NCNvMs3_B2_NtB2_13PathEvaluator16eval_to_in_graphs1_0EB6_:
 5120|     24|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|     24|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|     24|    mut next: impl FnMut(T) -> NI,
 5123|     24|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|     24|    let mut errors = Vec::new();
 5125|     24|    let mut todo = start
 5126|     24|        .into_iter()
 5127|     24|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|     24|        })
 5134|     24|        .collect::<Vec<_>>();
 5135|     24|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|     24|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|     24|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|     24|}
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator27run_if_term_is_a_graph_nodeNtNtNtBa_7storage15numeric_encoder11EncodedTermINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters6filter6FilterINtNtB2m_5chain5ChainINtNtNtB2o_7sources4once4OnceINtNtB2q_6result6ResultB1w_NtNtB8_5error15EvaluationErrorEEINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB2o_6traits8iterator8Iteratorp4ItemB3Z_EL_EENCINvB6_16hash_deduplicateB1w_B3b_E0ENCNvB2_16eval_to_in_graphs2_0EBa_:
 4660|     94|    fn run_if_term_is_a_graph_node<
 4661|     94|        T: 'static,
 4662|     94|        I: Iterator<Item = Result<T, EvaluationError>> + 'static,
 4663|     94|    >(
 4664|     94|        &self,
 4665|     94|        term: &EncodedTerm,
 4666|     94|        graph_name: &EncodedTerm,
 4667|     94|        f: impl FnOnce() -> I,
 4668|     94|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4669|     94|        match self.is_subject_or_object_in_graph(term, graph_name) {
 4670|      0|            Ok(true) => Box::new(f()),
 4671|       |            Ok(false) => {
 4672|     94|                Box::new(empty()) // Not in the database
 4673|       |            }
 4674|      0|            Err(error) => Box::new(once(Err(error))),
 4675|       |        }
 4676|     94|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsn_0Bb_:
 1452|      4|                        Rc::new(move |tuple| {
 1453|      4|                            Some(build_string_literal_from_id(to_string_id(
 1454|      4|                                &dataset,
 1455|      4|                                &e(tuple)?,
 1456|      0|                            )?))
 1457|      4|                        })
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator29run_if_term_is_a_dataset_nodeTNtNtNtBa_7storage15numeric_encoder11EncodedTermB1z_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtB2u_6filter6FilterINtNtB2u_5chain5ChainINtNtNtB2w_7sources4once4OnceINtNtB2y_6result6ResultB1z_NtNtB8_5error15EvaluationErrorEEINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB2w_6traits8iterator8Iteratorp4ItemB4o_EL_EENCINvB6_16hash_deduplicateB1z_B3A_E0ENCNCNvB2_26eval_from_in_unknown_graphs2_00ENCB7o_s2_0EBa_:
 4697|      1|    fn run_if_term_is_a_dataset_node<
 4698|      1|        T: 'static,
 4699|      1|        I: IntoIterator<Item = Result<T, EvaluationError>> + 'static,
 4700|      1|    >(
 4701|      1|        &self,
 4702|      1|        term: &EncodedTerm,
 4703|      1|        f: impl FnMut(EncodedTerm) -> I + 'static,
 4704|      1|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4705|      1|        match self
 4706|      1|            .find_graphs_where_the_node_is_in(term)
 4707|      1|            .collect::<Result<HashSet<_>, _>>()
 4708|       |        {
 4709|      1|            Ok(graph_names) => Box::new(graph_names.into_iter().flat_map(f)),
 4710|      0|            Err(error) => Box::new(once(Err(error))),
 4711|       |        }
 4712|      1|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators2_00Bd_:
  398|     68|                    Box::new(iter.filter_map(move |quad| match quad {
  399|     68|                        Ok(quad) => {
  400|     68|                            let mut new_tuple = from.clone();
  401|     68|                            put_pattern_value(&subject, quad.subject, &mut new_tuple)?;
  402|     68|                            put_pattern_value(&predicate, quad.predicate, &mut new_tuple)?;
  403|     68|                            put_pattern_value(&object, quad.object, &mut new_tuple)?;
  404|     66|                            put_pattern_value(&graph_name, quad.graph_name, &mut new_tuple)?;
  405|     64|                            Some(Ok(new_tuple))
  406|       |                        }
  407|      0|                        Err(error) => Some(Err(error)),
  408|     68|                    }))
_RNCINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateNtB4_12EncodedTupleINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB20_6result6ResultBZ_NtNtB6_5error15EvaluationErrorEEL_EE0B8_:
 5179|    867|    iter.filter(move |e| {
 5180|    867|        if let Ok(e) = e {
 5181|    867|            if already_seen.contains(e) {
 5182|    186|                false
 5183|       |            } else {
 5184|    681|                already_seen.insert(e.clone());
 5185|    681|                true
 5186|       |            }
 5187|       |        } else {
 5188|      0|            true
 5189|       |        }
 5190|    867|    })
_RINvXsI_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_12EncodedTupleNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEBa_:
   43|    949|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsp_00Bd_:
  941|  1.17k|                    Box::new(child(input_tuple).filter_map(move |tuple| {
  942|  1.17k|                        match tuple {
  943|  1.17k|                            Ok(tuple) => {
  944|  1.17k|                                let mut output_tuple = from.clone();
  945|  1.45k|                                for (input_key, output_key) in &*mapping {
  946|  1.45k|                                    if let Some(value) = tuple.get(*input_key) {
  947|    528|                                        if let Some(existing_value) = output_tuple.get(*output_key)
  948|       |                                        {
  949|      0|                                            if existing_value != value {
  950|      0|                                                return None; // Conflict
  951|      0|                                            }
  952|    528|                                        } else {
  953|    528|                                            output_tuple.set(*output_key, value.clone());
  954|    528|                                        }
  955|    926|                                    }
  956|       |                                }
  957|  1.17k|                                Some(Ok(output_tuple))
  958|       |                            }
  959|      0|                            Err(e) => Some(Err(e)),
  960|       |                        }
  961|  1.17k|                    }))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsf_0Bb_:
  791|     76|                    .map(|child| {
  792|     76|                        let (child, child_stats) =
  793|     76|                            self.graph_pattern_evaluator(child, encoded_variables);
  794|     76|                        stat_children.push(child_stats);
  795|     76|                        child
  796|     76|                    })
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval9slice_keyNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableEB6_:
 5520|   126k|fn slice_key<T: Eq>(slice: &[T], element: &T) -> Option<usize> {
 5521|  1.53M|    for (i, item) in slice.iter().enumerate() {
 5522|  1.53M|        if item == element {
 5523|  83.6k|            return Some(i);
 5524|  1.44M|        }
 5525|       |    }
 5526|  42.5k|    None
 5527|   126k|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluator0Bb_:
  294|  5.54k|                    .map(|v| encode_variable(encoded_variables, v))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators3_0Bb_:
  435|  5.77k|                Rc::new(move |from| {
  436|  5.77k|                    let input_subject = subject.get_pattern_value(&from);
  437|  5.77k|                    let input_object = object.get_pattern_value(&from);
  438|  5.77k|                    let input_graph_name = graph_name.get_pattern_value(&from);
  439|  5.77k|                    let path_eval = PathEvaluator {
  440|  5.77k|                        dataset: Rc::clone(&dataset),
  441|  5.77k|                    };
  442|  5.77k|                    match (input_subject, input_object, input_graph_name) {
  443|     14|                        (Some(input_subject), Some(input_object), Some(input_graph_name)) => {
  444|     14|                            match path_eval.eval_closed_in_graph(
  445|     14|                                &path,
  446|     14|                                &input_subject,
  447|     14|                                &input_object,
  448|     14|                                &input_graph_name,
  449|     14|                            ) {
  450|      0|                                Ok(true) => Box::new(once(Ok(from))),
  451|     14|                                Ok(false) => Box::new(empty()),
  452|      0|                                Err(e) => Box::new(once(Err(e))),
  453|       |                            }
  454|       |                        }
  455|    223|                        (Some(input_subject), None, Some(input_graph_name)) => {
  456|    223|                            let object = object.clone();
  457|    223|                            Box::new(
  458|    223|                                path_eval
  459|    223|                                    .eval_from_in_graph(&path, &input_subject, &input_graph_name)
  460|    223|                                    .filter_map(move |o| match o {
  461|       |                                        Ok(o) => {
  462|       |                                            let mut new_tuple = from.clone();
  463|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  464|       |                                            Some(Ok(new_tuple))
  465|       |                                        }
  466|       |                                        Err(error) => Some(Err(error)),
  467|    223|                                    }),
  468|    223|                            )
  469|       |                        }
  470|    182|                        (None, Some(input_object), Some(input_graph_name)) => {
  471|    182|                            let subject = subject.clone();
  472|    182|                            Box::new(
  473|    182|                                path_eval
  474|    182|                                    .eval_to_in_graph(&path, &input_object, &input_graph_name)
  475|    182|                                    .filter_map(move |s| match s {
  476|       |                                        Ok(s) => {
  477|       |                                            let mut new_tuple = from.clone();
  478|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  479|       |                                            Some(Ok(new_tuple))
  480|       |                                        }
  481|       |                                        Err(error) => Some(Err(error)),
  482|    182|                                    }),
  483|    182|                            )
  484|       |                        }
  485|  5.17k|                        (None, None, Some(input_graph_name)) => {
  486|  5.17k|                            let subject = subject.clone();
  487|  5.17k|                            let object = object.clone();
  488|  5.17k|                            Box::new(
  489|  5.17k|                                path_eval
  490|  5.17k|                                    .eval_open_in_graph(&path, &input_graph_name)
  491|  5.17k|                                    .filter_map(move |so| match so {
  492|       |                                        Ok((s, o)) => {
  493|       |                                            let mut new_tuple = from.clone();
  494|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  495|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  496|       |                                            Some(Ok(new_tuple))
  497|       |                                        }
  498|       |                                        Err(error) => Some(Err(error)),
  499|  5.17k|                                    }),
  500|  5.17k|                            )
  501|       |                        }
  502|      0|                        (Some(input_subject), Some(input_object), None) => {
  503|      0|                            let graph_name = graph_name.clone();
  504|      0|                            Box::new(
  505|      0|                                path_eval
  506|      0|                                    .eval_closed_in_unknown_graph(
  507|      0|                                        &path,
  508|      0|                                        &input_subject,
  509|      0|                                        &input_object,
  510|      0|                                    )
  511|      0|                                    .filter_map(move |r| match r {
  512|       |                                        Ok(g) => {
  513|       |                                            let mut new_tuple = from.clone();
  514|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  515|       |                                            Some(Ok(new_tuple))
  516|       |                                        }
  517|       |                                        Err(error) => Some(Err(error)),
  518|      0|                                    }),
  519|      0|                            )
  520|       |                        }
  521|      5|                        (Some(input_subject), None, None) => {
  522|      5|                            let object = object.clone();
  523|      5|                            let graph_name = graph_name.clone();
  524|      5|                            Box::new(
  525|      5|                                path_eval
  526|      5|                                    .eval_from_in_unknown_graph(&path, &input_subject)
  527|      5|                                    .filter_map(move |r| match r {
  528|       |                                        Ok((o, g)) => {
  529|       |                                            let mut new_tuple = from.clone();
  530|       |                                            put_pattern_value(&object, o, &mut new_tuple)?;
  531|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  532|       |                                            Some(Ok(new_tuple))
  533|       |                                        }
  534|       |                                        Err(error) => Some(Err(error)),
  535|      5|                                    }),
  536|      5|                            )
  537|       |                        }
  538|     11|                        (None, Some(input_object), None) => {
  539|     11|                            let subject = subject.clone();
  540|     11|                            let graph_name = graph_name.clone();
  541|     11|                            Box::new(
  542|     11|                                path_eval
  543|     11|                                    .eval_to_in_unknown_graph(&path, &input_object)
  544|     11|                                    .filter_map(move |r| match r {
  545|       |                                        Ok((s, g)) => {
  546|       |                                            let mut new_tuple = from.clone();
  547|       |                                            put_pattern_value(&subject, s, &mut new_tuple)?;
  548|       |                                            put_pattern_value(&graph_name, g, &mut new_tuple)?;
  549|       |
  550|       |                                            Some(Ok(new_tuple))
  551|       |                                        }
  552|       |                                        Err(error) => Some(Err(error)),
  553|     11|                                    }),
  554|     11|                            )
  555|       |                        }
  556|       |                        (None, None, None) => {
  557|    165|                            let subject = subject.clone();
  558|    165|                            let object = object.clone();
  559|    165|                            let graph_name = graph_name.clone();
  560|    165|                            Box::new(path_eval.eval_open_in_unknown_graph(&path).filter_map(
  561|    165|                                move |r| match r {
  562|       |                                    Ok((s, o, g)) => {
  563|       |                                        let mut new_tuple = from.clone();
  564|       |                                        put_pattern_value(&subject, s, &mut new_tuple)?;
  565|       |                                        put_pattern_value(&object, o, &mut new_tuple)?;
  566|       |                                        put_pattern_value(&graph_name, g, &mut new_tuple)?;
  567|       |                                        Some(Ok(new_tuple))
  568|       |                                    }
  569|       |                                    Err(error) => Some(Err(error)),
  570|    165|                                },
  571|    165|                            ))
  572|       |                        }
  573|       |                    }
  574|  5.77k|                })
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsh_00Bd_:
  821|    496|                    Box::new(child(from).map(move |tuple| {
  822|    496|                        let mut tuple = tuple?;
  823|    496|                        if let Some(value) = expression(&tuple) {
  824|     14|                            tuple.set(position, value);
  825|    482|                        }
  826|    496|                        Ok(tuple)
  827|    496|                    }))
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators0_00Bd_:
  319|  2.95k|                            .filter_map(move |t| Some(Ok(t.combine_with(&from)?)))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators8_0Bb_:
 1216|      1|                Rc::new(move |tuple| Some((a(tuple)? == b(tuple)?).into()))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluators1_0Bb_:
 1159|     45|                Rc::new(move |tuple| Some(tuple.contains(v).into()))
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval16hash_deduplicateTNtNtNtB6_7storage15numeric_encoder11EncodedTermBY_BY_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtB2_9FlatMapOkNtB10_11EncodedQuadBX_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultB2Y_NtNtB4_5error15EvaluationErrorEEL_ENCNvMs3_B2_NtB2_13PathEvaluator47get_subject_or_object_identity_pairs_in_dataset0AIB4A_BX_B50_Ej2_EIB3l_DB3U_p4ItemB6T_EL_EEEB6_:
 5175|     75|fn hash_deduplicate<T: Eq + Hash + Clone>(
 5176|     75|    iter: impl Iterator<Item = Result<T, EvaluationError>>,
 5177|     75|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5178|     75|    let mut already_seen = HashSet::with_capacity(iter.size_hint().0);
 5179|     75|    iter.filter(move |e| {
 5180|       |        if let Ok(e) = e {
 5181|       |            if already_seen.contains(e) {
 5182|       |                false
 5183|       |            } else {
 5184|       |                already_seen.insert(e.clone());
 5185|       |                true
 5186|       |            }
 5187|       |        } else {
 5188|       |            true
 5189|       |        }
 5190|     75|    })
 5191|     75|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsd_0Bb_:
 1269|     96|                    move |tuple| match NumericBinaryOperands::new(a(tuple)?, b(tuple)?)? {
 1270|      0|                        NumericBinaryOperands::Float(v1, v2) => Some((v1 + v2).into()),
 1271|      0|                        NumericBinaryOperands::Double(v1, v2) => Some((v1 + v2).into()),
 1272|      0|                        NumericBinaryOperands::Integer(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1273|      3|                        NumericBinaryOperands::Decimal(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1274|      0|                        NumericBinaryOperands::Duration(v1, v2) => Some(v1.checked_add(v2)?.into()),
 1275|      0|                        NumericBinaryOperands::YearMonthDuration(v1, v2) => {
 1276|      0|                            Some(v1.checked_add(v2)?.into())
 1277|       |                        }
 1278|      0|                        NumericBinaryOperands::DayTimeDuration(v1, v2) => {
 1279|      0|                            Some(v1.checked_add(v2)?.into())
 1280|       |                        }
 1281|      0|                        NumericBinaryOperands::DateTimeDuration(v1, v2) => {
 1282|      0|                            Some(v1.checked_add_duration(v2)?.into())
 1283|       |                        }
 1284|      0|                        NumericBinaryOperands::DateTimeYearMonthDuration(v1, v2) => {
 1285|      0|                            Some(v1.checked_add_year_month_duration(v2)?.into())
 1286|       |                        }
 1287|      0|                        NumericBinaryOperands::DateTimeDayTimeDuration(v1, v2) => {
 1288|      0|                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1289|       |                        }
 1290|      0|                        NumericBinaryOperands::DateDuration(v1, v2) => {
 1291|      0|                            Some(v1.checked_add_duration(v2)?.into())
 1292|       |                        }
 1293|      0|                        NumericBinaryOperands::DateYearMonthDuration(v1, v2) => {
 1294|      0|                            Some(v1.checked_add_year_month_duration(v2)?.into())
 1295|       |                        }
 1296|      0|                        NumericBinaryOperands::DateDayTimeDuration(v1, v2) => {
 1297|      0|                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1298|       |                        }
 1299|      0|                        NumericBinaryOperands::TimeDuration(v1, v2) => {
 1300|      0|                            Some(v1.checked_add_duration(v2)?.into())
 1301|       |                        }
 1302|      0|                        NumericBinaryOperands::TimeDayTimeDuration(v1, v2) => {
 1303|      0|                            Some(v1.checked_add_day_time_duration(v2)?.into())
 1304|       |                        }
 1305|       |                        NumericBinaryOperands::DateTime(_, _)
 1306|       |                        | NumericBinaryOperands::Time(_, _)
 1307|      0|                        | NumericBinaryOperands::Date(_, _) => None,
 1308|     96|                    },
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureNtNtNtB6_7storage15numeric_encoder11EncodedTermINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2s_6result6ResultBZ_NtNtB4_5error15EvaluationErrorEEL_EB1K_NCNvMs3_B2_NtB2_13PathEvaluator18eval_from_in_graphs1_0EB6_:
 5120|     62|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|     62|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|     62|    mut next: impl FnMut(T) -> NI,
 5123|     62|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|     62|    let mut errors = Vec::new();
 5125|     62|    let mut todo = start
 5126|     62|        .into_iter()
 5127|     62|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|     62|        })
 5134|     62|        .collect::<Vec<_>>();
 5135|     62|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|     62|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|     62|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|     62|}
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsc_0Bb_:
  746|      6|                            .map(|v| encode_variable(encoded_variables, v))
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkNtNtNtB9_7storage15numeric_encoder11EncodedTermBY_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2u_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator18eval_from_in_graphs_0B1M_EB2m_4nextB9_:
 5235|    188|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|    188|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|    188|            }
 5242|    188|            self.current = None;
 5243|    188|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|    188|    }
_RINvMs3_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_13PathEvaluator29run_if_term_is_a_dataset_nodeTNtNtNtBa_7storage15numeric_encoder11EncodedTermB1z_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtB2u_6filter6FilterINtNtB2u_5chain5ChainINtNtNtB2w_7sources4once4OnceINtNtB2y_6result6ResultB1z_NtNtB8_5error15EvaluationErrorEEINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB2w_6traits8iterator8Iteratorp4ItemB4o_EL_EENCINvB6_16hash_deduplicateB1z_B3A_E0ENCNCNvB2_24eval_to_in_unknown_graphs2_00ENCB7o_s2_0EBa_:
 4697|      5|    fn run_if_term_is_a_dataset_node<
 4698|      5|        T: 'static,
 4699|      5|        I: IntoIterator<Item = Result<T, EvaluationError>> + 'static,
 4700|      5|    >(
 4701|      5|        &self,
 4702|      5|        term: &EncodedTerm,
 4703|      5|        f: impl FnMut(EncodedTerm) -> I + 'static,
 4704|      5|    ) -> Box<dyn Iterator<Item = Result<T, EvaluationError>>> {
 4705|      5|        match self
 4706|      5|            .find_graphs_where_the_node_is_in(term)
 4707|      5|            .collect::<Result<HashSet<_>, _>>()
 4708|       |        {
 4709|      5|            Ok(graph_names) => Box::new(graph_names.into_iter().flat_map(f)),
 4710|      0|            Err(error) => Box::new(once(Err(error))),
 4711|       |        }
 4712|      5|    }
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval18transitive_closureTNtNtNtB6_7storage15numeric_encoder11EncodedTermB10_EINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtB1X_6traits8iterator8Iteratorp4ItemINtNtB1Z_6result6ResultB10_NtNtB4_5error15EvaluationErrorEEL_ENCNCNvMs3_B2_NtB2_13PathEvaluator18eval_open_in_graphs1_00EINtB2_9FlatMapOkNtB12_11EncodedQuadBZ_IB2F_DB3e_p4ItemIB3U_B66_B4k_EEL_ENCNvB4Z_45get_subject_or_object_identity_pairs_in_graph0AIB3U_BZ_B4k_Ej2_ENCB4X_s1_0EB6_:
 5120|    680|fn transitive_closure<T: Clone + Eq + Hash, NI: Iterator<Item = Result<T, EvaluationError>>>(
 5121|    680|    start: impl IntoIterator<Item = Result<T, EvaluationError>>,
 5122|    680|    mut next: impl FnMut(T) -> NI,
 5123|    680|) -> impl Iterator<Item = Result<T, EvaluationError>> {
 5124|    680|    let mut errors = Vec::new();
 5125|    680|    let mut todo = start
 5126|    680|        .into_iter()
 5127|    680|        .filter_map(|e| match e {
 5128|       |            Ok(e) => Some(e),
 5129|       |            Err(e) => {
 5130|       |                errors.push(e);
 5131|       |                None
 5132|       |            }
 5133|    680|        })
 5134|    680|        .collect::<Vec<_>>();
 5135|    680|    let mut all = todo.iter().cloned().collect::<HashSet<_>>();
 5136|    680|    while let Some(e) = todo.pop() {
 5137|      0|        for e in next(e) {
 5138|      0|            match e {
 5139|      0|                Ok(e) => {
 5140|      0|                    if all.insert(e.clone()) {
 5141|      0|                        todo.push(e)
 5142|      0|                    }
 5143|       |                }
 5144|      0|                Err(e) => errors.push(e),
 5145|       |            }
 5146|       |        }
 5147|       |    }
 5148|    680|    errors.into_iter().map(Err).chain(all.into_iter().map(Ok))
 5149|    680|}
_RINvXsx_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_15EncodedTupleSetINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect6ExtendNtB6_12EncodedTupleE6extendINtNtNtB1c_8adapters10filter_map9FilterMapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtB1a_8iterator8Iteratorp4ItemINtNtB1e_6result6ResultB1Y_NtNtB8_5error15EvaluationErrorEEL_ENCNCNvMs0_B6_NtB6_15SimpleEvaluator29build_graph_pattern_evaluators6_00EEBa_:
 5628|     15|    fn extend<T: IntoIterator<Item = EncodedTuple>>(&mut self, iter: T) {
 5629|     15|        let iter = iter.into_iter();
 5630|     15|        self.map.reserve(iter.size_hint().0);
 5631|     16|        for tuple in iter {
 5632|      1|            self.insert(tuple);
 5633|      1|        }
 5634|     15|    }
_RINvXsx_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB6_15EncodedTupleSetINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect6ExtendNtB6_12EncodedTupleE6extendINtNtNtB1c_8adapters10filter_map9FilterMapINtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtB1a_8iterator8Iteratorp4ItemINtNtB1e_6result6ResultB1Y_NtNtB8_5error15EvaluationErrorEEL_ENCNCNvMs0_B6_NtB6_15SimpleEvaluator29build_graph_pattern_evaluatorsd_00EEBa_:
 5628|    355|    fn extend<T: IntoIterator<Item = EncodedTuple>>(&mut self, iter: T) {
 5629|    355|        let iter = iter.into_iter();
 5630|    355|        self.map.reserve(iter.size_hint().0);
 5631|    449|        for tuple in iter {
 5632|     94|            self.insert(tuple);
 5633|     94|        }
 5634|    355|    }
_RINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval11format_listNtNtCsjOdcKtOMjJI_5alloc6string6StringINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtB1z_3map3MapINtNtNtB1D_5slice4iter4IterNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableENvYB34_NtBU_8ToString9to_stringEIB2n_IB2E_TB34_NtNtCsaDAmlQ5xRbD_7sparopt7algebra19AggregateExpressionEENCNvB2_15eval_node_label0EEEB6_:
 5842|     12|fn format_list<T: ToString>(values: impl IntoIterator<Item = T>) -> String {
 5843|     12|    values
 5844|     12|        .into_iter()
 5845|     12|        .map(|v| v.to_string())
 5846|     12|        .collect::<Vec<_>>()
 5847|     12|        .join(", ")
 5848|     12|}
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkTNtNtNtB9_7storage15numeric_encoder11EncodedTermBZ_EBY_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2z_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator18eval_open_in_graphs0_0INtNtNtB2x_8adapters3map3MapIB1S_DB2r_p4ItemIB3t_BZ_B3S_EEL_ENCNCB4t_s0_00EEB2r_4nextB9_:
 5235|  2.09k|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|  2.09k|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|  2.09k|            }
 5242|  2.09k|            self.current = None;
 5243|  2.09k|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|  2.09k|    }
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsq_0Bb_:
 1525|      2|                        Rc::new(move |tuple| datatype(&dataset, &e(tuple)?))
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorsd_00Bd_:
  752|     94|                                |result| match result {
  753|     94|                                    Ok(result) => Some(result),
  754|      0|                                    Err(error) => {
  755|      0|                                        errors.push(Err(error));
  756|      0|                                        None
  757|       |                                    }
  758|     94|                                },
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluatorsd_0Bb_:
  748|    355|                        Rc::new(move |from| {
  749|    355|                            let mut errors = Vec::default();
  750|    355|                            let mut right_values = EncodedTupleSet::new(keys.clone());
  751|    355|                            right_values.extend(right(from.clone()).filter_map(
  752|    355|                                |result| match result {
  753|       |                                    Ok(result) => Some(result),
  754|       |                                    Err(error) => {
  755|       |                                        errors.push(Err(error));
  756|       |                                        None
  757|       |                                    }
  758|    355|                                },
  759|    355|                            ));
  760|    355|                            Box::new(HashLeftJoinIterator {
  761|    355|                                left_iter: left(from),
  762|    355|                                right: right_values,
  763|    355|                                buffered_results: errors,
  764|    355|                                expression: Rc::clone(&expression),
  765|    355|                            })
  766|    355|                        })
_RNvXsf_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalINtB5_9FlatMapOkNtNtNtB9_7storage15numeric_encoder11EncodedTermBY_INtNtCsjOdcKtOMjJI_5alloc5boxed3BoxDNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iteratorp4ItemINtNtB2u_6result6ResultBY_NtNtB7_5error15EvaluationErrorEEL_ENCNvMs3_B5_NtB5_13PathEvaluator16eval_to_in_graphs_0B1M_EB2m_4nextB9_:
 5235|    105|    fn next(&mut self) -> Option<Self::Item> {
 5236|       |        loop {
 5237|    105|            if let Some(current) = &mut self.current {
 5238|      0|                if let Some(next) = current.next() {
 5239|      0|                    return Some(next);
 5240|      0|                }
 5241|    105|            }
 5242|    105|            self.current = None;
 5243|    105|            match self.inner.next()? {
 5244|      0|                Ok(e) => self.current = Some((self.f)(e).into_iter()),
 5245|      0|                Err(error) => return Some(Err(error)),
 5246|       |            }
 5247|       |        }
 5248|    105|    }
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluatorse_00Bd_:
  778|     22|                    Box::new(child(from).filter(move |tuple| {
  779|     22|                        match tuple {
  780|     22|                            Ok(tuple) => expression(tuple)
  781|     22|                                .and_then(|term| to_bool(&term))
  782|     22|                                .unwrap_or(false),
  783|      0|                            Err(_) => true,
  784|       |                        }
  785|     22|                    }))
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluator0Bb_:
 1147|     80|                Rc::new(move |_| Some(t.clone()))
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator29build_graph_pattern_evaluators6_00Bd_:
  618|      1|                                built_values.extend(build(from.clone()).filter_map(|result| {
  619|      1|                                    match result {
  620|      1|                                        Ok(result) => Some(result),
  621|      0|                                        Err(error) => {
  622|      0|                                            errors.push(Err(error));
  623|      0|                                            None
  624|       |                                        }
  625|       |                                    }
  626|      1|                                }));
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsi_0Bb_:
 1400|    342|                Rc::new(move |tuple| match e(tuple)? {
 1401|      0|                    EncodedTerm::FloatLiteral(value) => Some((-value).into()),
 1402|      0|                    EncodedTerm::DoubleLiteral(value) => Some((-value).into()),
 1403|    151|                    EncodedTerm::IntegerLiteral(value) => Some(value.checked_neg()?.into()),
 1404|     30|                    EncodedTerm::DecimalLiteral(value) => Some(value.checked_neg()?.into()),
 1405|      0|                    EncodedTerm::DurationLiteral(value) => Some(value.checked_neg()?.into()),
 1406|      0|                    EncodedTerm::YearMonthDurationLiteral(value) => {
 1407|      0|                        Some(value.checked_neg()?.into())
 1408|       |                    }
 1409|      0|                    EncodedTerm::DayTimeDurationLiteral(value) => Some(value.checked_neg()?.into()),
 1410|    139|                    _ => None,
 1411|    342|                })
_RNCNvXs6_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_20HashLeftJoinIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator9size_hint0Bb_:
 4845|    297|                .map(|v| v.saturating_mul(self.right.len())),
_RNCNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB9_15SimpleEvaluator20expression_evaluators6_00Bd_:
 1195|      4|                        match child(tuple).and_then(|v| to_bool(&v)) {
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator20expression_evaluatorsa_0Bb_:
 1233|     86|                Rc::new(move |tuple| {
 1234|     86|                    Some(
 1235|     86|                        match partial_cmp(&dataset, &a(tuple)?, &b(tuple)?)? {
 1236|      6|                            Ordering::Greater | Ordering::Equal => true,
 1237|      0|                            Ordering::Less => false,
 1238|       |                        }
 1239|      6|                        .into(),
 1240|       |                    )
 1241|     86|                })
_RNCNvMs0_NtNtCs2ek33vt1YA5_8oxigraph6sparql4evalNtB7_15SimpleEvaluator29build_graph_pattern_evaluators5_0Bb_:
  613|     17|                                .map(|v| encode_variable(encoded_variables, v))
_RNCINvNtNtCs2ek33vt1YA5_8oxigraph6sparql4eval11format_listNtNtCsjOdcKtOMjJI_5alloc6string6StringINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters5chain5ChainINtNtB1B_3map3MapINtNtNtB1F_5slice4iter4IterNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableENvYB36_NtBW_8ToString9to_stringEIB2p_IB2G_TB36_NtNtCsaDAmlQ5xRbD_7sparopt7algebra19AggregateExpressionEENCNvB4_15eval_node_label0EEE0B8_:
 5845|     40|        .map(|v| v.to_string())

_RNvMNtNtNtCs2ek33vt1YA5_8oxigraph6sparql4http5dummyNtB2_6Client3new:
    9|  4.99k|    pub fn new(_timeout: Option<Duration>, _redirection_limit: usize) -> Self {
   10|  4.99k|        Self
   11|  4.99k|    }

_RNvXs2_NtCs2ek33vt1YA5_8oxigraph6sparqlNtB5_12QueryOptionsNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  157|  2.49k|#[derive(Clone, Default)]
_RNvMNtCs2ek33vt1YA5_8oxigraph6sparqlNtB2_12QueryOptions21without_optimizationsCslmM25dSh1d8_18sparql_update_eval:
  259|  2.49k|    pub fn without_optimizations(mut self) -> Self {
  260|  2.49k|        self.without_optimizations = true;
  261|  2.49k|        self
  262|  2.49k|    }
_RNvXs3_NtCs2ek33vt1YA5_8oxigraph6sparqlNtB5_12QueryOptionsNtNtCs9nhK3FOW46N_4core7default7Default7defaultCslmM25dSh1d8_18sparql_update_eval:
  157|  2.49k|#[derive(Clone, Default)]
_RNvXs_NtCs2ek33vt1YA5_8oxigraph6sparqlNtB4_13UpdateOptionsINtNtCs9nhK3FOW46N_4core7convert4FromNtB4_12QueryOptionsE4fromCslmM25dSh1d8_18sparql_update_eval:
  273|  4.99k|    fn from(query_options: QueryOptions) -> Self {
  274|  4.99k|        Self { query_options }
  275|  4.99k|    }
_RNvXs2_NtCs2ek33vt1YA5_8oxigraph6sparqlNtB5_12QueryOptionsNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  157|  4.99k|#[derive(Clone, Default)]
_RNvXs4_NtCs2ek33vt1YA5_8oxigraph6sparqlNtB5_13UpdateOptionsNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  266|  4.99k|#[derive(Clone, Default)]
_RNvMNtCs2ek33vt1YA5_8oxigraph6sparqlNtB2_12QueryOptions15service_handler:
  243|  4.89k|    fn service_handler(&self) -> Arc<dyn ServiceHandler<Error = EvaluationError>> {
  244|  4.89k|        self.service_handler.clone().unwrap_or_else(|| {
  245|       |            if cfg!(feature = "http-client") {
  246|       |                Arc::new(service::SimpleServiceHandler::new(
  247|       |                    self.http_timeout,
  248|       |                    self.http_redirection_limit,
  249|       |                ))
  250|       |            } else {
  251|       |                Arc::new(EmptyServiceHandler)
  252|       |            }
  253|  4.89k|        })
  254|  4.89k|    }
_RNCNvMNtCs2ek33vt1YA5_8oxigraph6sparqlNtB4_12QueryOptions15service_handler0B6_:
  244|  4.89k|        self.service_handler.clone().unwrap_or_else(|| {
  245|  4.89k|            if cfg!(feature = "http-client") {
  246|      0|                Arc::new(service::SimpleServiceHandler::new(
  247|      0|                    self.http_timeout,
  248|      0|                    self.http_redirection_limit,
  249|      0|                ))
  250|       |            } else {
  251|  4.89k|                Arc::new(EmptyServiceHandler)
  252|       |            }
  253|  4.89k|        })

_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator8eval_all:
   49|  4.99k|    fn eval_all(
   50|  4.99k|        &mut self,
   51|  4.99k|        updates: &[GraphUpdateOperation],
   52|  4.99k|        using_datasets: &[Option<QueryDataset>],
   53|  4.99k|    ) -> Result<(), EvaluationError> {
   54|  9.18k|        for (update, using_dataset) in updates.iter().zip(using_datasets) {
   55|  9.18k|            self.eval(update, using_dataset)?;
   56|       |        }
   57|  4.68k|        Ok(())
   58|  4.99k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator20convert_quad_pattern:
  321|  2.68k|    fn convert_quad_pattern(
  322|  2.68k|        quad: &QuadPattern,
  323|  2.68k|        variables: &[Variable],
  324|  2.68k|        values: &EncodedTuple,
  325|  2.68k|        dataset: &DatasetView,
  326|  2.68k|        bnodes: &mut HashMap<BlankNode, BlankNode>,
  327|  2.68k|    ) -> Result<Option<OxQuad>, EvaluationError> {
  328|  2.68k|        Ok(Some(OxQuad {
  329|  2.68k|            subject: match Self::convert_term_or_var(
  330|  2.68k|                &quad.subject,
  331|  2.68k|                variables,
  332|  2.68k|                values,
  333|  2.68k|                dataset,
  334|  2.68k|                bnodes,
  335|  2.68k|            )? {
  336|  1.91k|                Some(Term::NamedNode(node)) => node.into(),
  337|      0|                Some(Term::BlankNode(node)) => node.into(),
  338|      0|                Some(Term::Triple(triple)) => triple.into(),
  339|    773|                Some(Term::Literal(_)) | None => return Ok(None),
  340|       |            },
  341|  1.78k|            predicate: if let Some(predicate) =
  342|  1.91k|                Self::convert_named_node_or_var(&quad.predicate, variables, values, dataset)?
  343|       |            {
  344|  1.78k|                predicate
  345|       |            } else {
  346|    130|                return Ok(None);
  347|       |            },
  348|    488|            object: if let Some(object) =
  349|  1.78k|                Self::convert_term_or_var(&quad.object, variables, values, dataset, bnodes)?
  350|       |            {
  351|    488|                object
  352|       |            } else {
  353|  1.29k|                return Ok(None);
  354|       |            },
  355|    398|            graph_name: if let Some(graph_name) =
  356|    488|                Self::convert_graph_name_or_var(&quad.graph_name, variables, values, dataset)?
  357|       |            {
  358|    398|                graph_name
  359|       |            } else {
  360|     88|                return Ok(None);
  361|       |            },
  362|       |        }))
  363|  2.68k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator4eval:
   60|  9.18k|    fn eval(
   61|  9.18k|        &mut self,
   62|  9.18k|        update: &GraphUpdateOperation,
   63|  9.18k|        using_dataset: &Option<QueryDataset>,
   64|  9.18k|    ) -> Result<(), EvaluationError> {
   65|  9.18k|        match update {
   66|    464|            GraphUpdateOperation::InsertData { data } => self.eval_insert_data(data),
   67|    130|            GraphUpdateOperation::DeleteData { data } => self.eval_delete_data(data),
   68|       |            GraphUpdateOperation::DeleteInsert {
   69|  4.89k|                delete,
   70|  4.89k|                insert,
   71|  4.89k|                pattern,
   72|  4.89k|                ..
   73|  4.89k|            } => self.eval_delete_insert(
   74|  4.89k|                delete,
   75|  4.89k|                insert,
   76|  4.89k|                using_dataset.as_ref().unwrap_or(&QueryDataset::new()),
   77|  4.89k|                pattern,
   78|  4.89k|            ),
   79|       |            GraphUpdateOperation::Load {
   80|      0|                silent,
   81|      0|                source,
   82|      0|                destination,
   83|       |            } => {
   84|      0|                if let Err(error) = self.eval_load(source, destination) {
   85|      0|                    if *silent {
   86|      0|                        Ok(())
   87|       |                    } else {
   88|      0|                        Err(error)
   89|       |                    }
   90|       |                } else {
   91|      0|                    Ok(())
   92|       |                }
   93|       |            }
   94|  2.17k|            GraphUpdateOperation::Clear { graph, silent } => self.eval_clear(graph, *silent),
   95|    446|            GraphUpdateOperation::Create { graph, silent } => self.eval_create(graph, *silent),
   96|  1.08k|            GraphUpdateOperation::Drop { graph, silent } => self.eval_drop(graph, *silent),
   97|       |        }
   98|  9.18k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator25convert_graph_name_or_var:
  400|  1.57k|    fn convert_graph_name_or_var(
  401|  1.57k|        term: &GraphNamePattern,
  402|  1.57k|        variables: &[Variable],
  403|  1.57k|        values: &EncodedTuple,
  404|  1.57k|        dataset: &DatasetView,
  405|  1.57k|    ) -> Result<Option<OxGraphName>, EvaluationError> {
  406|  1.57k|        match term {
  407|  1.24k|            GraphNamePattern::NamedNode(term) => Ok(Some(term.clone().into())),
  408|     36|            GraphNamePattern::DefaultGraph => Ok(Some(OxGraphName::DefaultGraph)),
  409|    293|            GraphNamePattern::Variable(v) => Self::lookup_variable(v, variables, values)
  410|    293|                .map(|node| {
  411|       |                    Ok(if node == EncodedTerm::DefaultGraph {
  412|       |                        OxGraphName::DefaultGraph
  413|       |                    } else {
  414|       |                        dataset.decode_named_node(&node)?.into()
  415|       |                    })
  416|    293|                })
  417|    293|                .transpose(),
  418|       |        }
  419|  1.57k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator16eval_insert_data:
  100|    464|    fn eval_insert_data(&mut self, data: &[Quad]) -> Result<(), EvaluationError> {
  101|    464|        let mut bnodes = HashMap::new();
  102|  5.17k|        for quad in data {
  103|  4.70k|            let quad = Self::convert_quad(quad, &mut bnodes);
  104|  4.70k|            self.transaction.insert(quad.as_ref())?;
  105|       |        }
  106|    464|        Ok(())
  107|    464|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph6sparql6update15evaluate_update:
   24|  4.99k|pub fn evaluate_update<'a, 'b: 'a>(
   25|  4.99k|    transaction: &'a mut StorageWriter<'b>,
   26|  4.99k|    update: &Update,
   27|  4.99k|    options: &UpdateOptions,
   28|  4.99k|) -> Result<(), EvaluationError> {
   29|  4.99k|    SimpleUpdateEvaluator {
   30|  4.99k|        transaction,
   31|  4.99k|        base_iri: update.inner.base_iri.clone().map(Rc::new),
   32|  4.99k|        options: options.clone(),
   33|  4.99k|        client: Client::new(
   34|  4.99k|            options.query_options.http_timeout,
   35|  4.99k|            options.query_options.http_redirection_limit,
   36|  4.99k|        ),
   37|  4.99k|    }
   38|  4.99k|    .eval_all(&update.inner.operations, &update.using_datasets)
   39|  4.99k|}
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator11eval_create:
  193|    446|    fn eval_create(&mut self, graph_name: &NamedNode, silent: bool) -> Result<(), EvaluationError> {
  194|    446|        if self.transaction.insert_named_graph(graph_name.into())? || silent {
  195|    444|            Ok(())
  196|       |        } else {
  197|      2|            Err(EvaluationError::GraphAlreadyExists(graph_name.clone()))
  198|       |        }
  199|    446|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator19convert_ground_quad:
  287|  2.33k|    fn convert_ground_quad(quad: &GroundQuad) -> OxQuad {
  288|  2.33k|        OxQuad {
  289|  2.33k|            subject: match &quad.subject {
  290|  2.33k|                GroundSubject::NamedNode(subject) => subject.clone().into(),
  291|      0|                GroundSubject::Triple(subject) => Self::convert_ground_triple(subject).into(),
  292|       |            },
  293|  2.33k|            predicate: quad.predicate.clone(),
  294|  2.33k|            object: match &quad.object {
  295|  1.06k|                GroundTerm::NamedNode(object) => object.clone().into(),
  296|  1.27k|                GroundTerm::Literal(object) => object.clone().into(),
  297|      0|                GroundTerm::Triple(subject) => Self::convert_ground_triple(subject).into(),
  298|       |            },
  299|  2.33k|            graph_name: match &quad.graph_name {
  300|  2.20k|                GraphName::NamedNode(graph_name) => graph_name.clone().into(),
  301|    126|                GraphName::DefaultGraph => OxGraphName::DefaultGraph,
  302|       |            },
  303|       |        }
  304|  2.33k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator15lookup_variable:
  554|  9.94k|    fn lookup_variable(
  555|  9.94k|        v: &Variable,
  556|  9.94k|        variables: &[Variable],
  557|  9.94k|        values: &EncodedTuple,
  558|  9.94k|    ) -> Option<EncodedTerm> {
  559|  9.94k|        variables
  560|  9.94k|            .iter()
  561|  9.94k|            .position(|v2| v == v2)
  562|  9.94k|            .and_then(|i| values.get(i))
  563|  9.94k|            .cloned()
  564|  9.94k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator26convert_ground_term_or_var:
  500|  13.5k|    fn convert_ground_term_or_var(
  501|  13.5k|        term: &GroundTermPattern,
  502|  13.5k|        variables: &[Variable],
  503|  13.5k|        values: &EncodedTuple,
  504|  13.5k|        dataset: &DatasetView,
  505|  13.5k|    ) -> Result<Option<Term>, EvaluationError> {
  506|  13.5k|        Ok(match term {
  507|  6.29k|            GroundTermPattern::NamedNode(term) => Some(term.clone().into()),
  508|    388|            GroundTermPattern::Literal(term) => Some(term.clone().into()),
  509|      0|            GroundTermPattern::Triple(triple) => {
  510|      0|                Self::convert_ground_triple_pattern(triple, variables, values, dataset)?
  511|      0|                    .map(Into::into)
  512|       |            }
  513|  6.90k|            GroundTermPattern::Variable(v) => Self::lookup_variable(v, variables, values)
  514|  6.90k|                .map(|node| dataset.decode_term(&node))
  515|  6.90k|                .transpose()?,
  516|       |        })
  517|  13.5k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator10eval_clear:
  201|  2.17k|    fn eval_clear(&mut self, graph: &GraphTarget, silent: bool) -> Result<(), EvaluationError> {
  202|  2.17k|        match graph {
  203|  1.38k|            GraphTarget::NamedNode(graph_name) => {
  204|  1.38k|                if self
  205|  1.38k|                    .transaction
  206|  1.38k|                    .reader()
  207|  1.38k|                    .contains_named_graph(&graph_name.as_ref().into())?
  208|       |                {
  209|     82|                    Ok(self.transaction.clear_graph(graph_name.into())?)
  210|  1.30k|                } else if silent {
  211|  1.02k|                    Ok(())
  212|       |                } else {
  213|    280|                    Err(EvaluationError::GraphDoesNotExist(graph_name.clone()))
  214|       |                }
  215|       |            }
  216|       |            GraphTarget::DefaultGraph => {
  217|    408|                self.transaction.clear_graph(GraphNameRef::DefaultGraph)?;
  218|    408|                Ok(())
  219|       |            }
  220|     76|            GraphTarget::NamedGraphs => Ok(self.transaction.clear_all_named_graphs()?),
  221|    304|            GraphTarget::AllGraphs => Ok(self.transaction.clear_all_graphs()?),
  222|       |        }
  223|  2.17k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator9eval_drop:
  225|  1.08k|    fn eval_drop(&mut self, graph: &GraphTarget, silent: bool) -> Result<(), EvaluationError> {
  226|  1.08k|        match graph {
  227|    614|            GraphTarget::NamedNode(graph_name) => {
  228|    614|                if self.transaction.remove_named_graph(graph_name.into())? || silent {
  229|    582|                    Ok(())
  230|       |                } else {
  231|     32|                    Err(EvaluationError::GraphDoesNotExist(graph_name.clone()))
  232|       |                }
  233|       |            }
  234|       |            GraphTarget::DefaultGraph => {
  235|    288|                Ok(self.transaction.clear_graph(GraphNameRef::DefaultGraph)?)
  236|       |            }
  237|     16|            GraphTarget::NamedGraphs => Ok(self.transaction.remove_all_named_graphs()?),
  238|    166|            GraphTarget::AllGraphs => Ok(self.transaction.clear()?),
  239|       |        }
  240|  1.08k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator12convert_quad:
  242|  4.70k|    fn convert_quad(quad: &Quad, bnodes: &mut HashMap<BlankNode, BlankNode>) -> OxQuad {
  243|  4.70k|        OxQuad {
  244|  4.70k|            subject: match &quad.subject {
  245|  4.70k|                Subject::NamedNode(subject) => subject.clone().into(),
  246|      0|                Subject::BlankNode(subject) => Self::convert_blank_node(subject, bnodes).into(),
  247|      0|                Subject::Triple(subject) => Self::convert_triple(subject, bnodes).into(),
  248|       |            },
  249|  4.70k|            predicate: quad.predicate.clone(),
  250|  4.70k|            object: match &quad.object {
  251|  1.30k|                Term::NamedNode(object) => object.clone().into(),
  252|      0|                Term::BlankNode(object) => Self::convert_blank_node(object, bnodes).into(),
  253|  3.40k|                Term::Literal(object) => object.clone().into(),
  254|      0|                Term::Triple(subject) => Self::convert_triple(subject, bnodes).into(),
  255|       |            },
  256|  4.70k|            graph_name: match &quad.graph_name {
  257|  4.26k|                GraphName::NamedNode(graph_name) => graph_name.clone().into(),
  258|    444|                GraphName::DefaultGraph => OxGraphName::DefaultGraph,
  259|       |            },
  260|       |        }
  261|  4.70k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator19convert_term_or_var:
  365|  4.47k|    fn convert_term_or_var(
  366|  4.47k|        term: &TermPattern,
  367|  4.47k|        variables: &[Variable],
  368|  4.47k|        values: &EncodedTuple,
  369|  4.47k|        dataset: &DatasetView,
  370|  4.47k|        bnodes: &mut HashMap<BlankNode, BlankNode>,
  371|  4.47k|    ) -> Result<Option<Term>, EvaluationError> {
  372|  4.47k|        Ok(match term {
  373|  2.06k|            TermPattern::NamedNode(term) => Some(term.clone().into()),
  374|      0|            TermPattern::BlankNode(bnode) => Some(Self::convert_blank_node(bnode, bnodes).into()),
  375|    256|            TermPattern::Literal(term) => Some(term.clone().into()),
  376|      0|            TermPattern::Triple(triple) => {
  377|      0|                Self::convert_triple_pattern(triple, variables, values, dataset, bnodes)?
  378|      0|                    .map(Into::into)
  379|       |            }
  380|  2.14k|            TermPattern::Variable(v) => Self::lookup_variable(v, variables, values)
  381|  2.14k|                .map(|node| dataset.decode_term(&node))
  382|  2.14k|                .transpose()?,
  383|       |        })
  384|  4.47k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator16eval_delete_data:
  109|    130|    fn eval_delete_data(&mut self, data: &[GroundQuad]) -> Result<(), EvaluationError> {
  110|  2.46k|        for quad in data {
  111|  2.33k|            let quad = Self::convert_ground_quad(quad);
  112|  2.33k|            self.transaction.remove(quad.as_ref())?;
  113|       |        }
  114|    130|        Ok(())
  115|    130|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator25convert_named_node_or_var:
  386|  7.83k|    fn convert_named_node_or_var(
  387|  7.83k|        term: &NamedNodePattern,
  388|  7.83k|        variables: &[Variable],
  389|  7.83k|        values: &EncodedTuple,
  390|  7.83k|        dataset: &DatasetView,
  391|  7.83k|    ) -> Result<Option<NamedNode>, EvaluationError> {
  392|  7.83k|        Ok(match term {
  393|  7.23k|            NamedNodePattern::NamedNode(term) => Some(term.clone()),
  394|    597|            NamedNodePattern::Variable(v) => Self::lookup_variable(v, variables, values)
  395|    597|                .map(|node| dataset.decode_named_node(&node))
  396|    597|                .transpose()?,
  397|       |        })
  398|  7.83k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator18eval_delete_insert:
  117|  4.89k|    fn eval_delete_insert(
  118|  4.89k|        &mut self,
  119|  4.89k|        delete: &[GroundQuadPattern],
  120|  4.89k|        insert: &[QuadPattern],
  121|  4.89k|        using: &QueryDataset,
  122|  4.89k|        algebra: &GraphPattern,
  123|  4.89k|    ) -> Result<(), EvaluationError> {
  124|  4.89k|        let dataset = Rc::new(DatasetView::new(self.transaction.reader(), using));
  125|  4.89k|        let mut pattern = sparopt::algebra::GraphPattern::from(algebra);
  126|  4.89k|        if !self.options.query_options.without_optimizations {
  127|  2.44k|            pattern = Optimizer::optimize_graph_pattern(sparopt::algebra::GraphPattern::Reduced {
  128|  2.44k|                inner: Box::new(pattern),
  129|  2.44k|            });
  130|  2.44k|        }
  131|  4.89k|        let evaluator = SimpleEvaluator::new(
  132|  4.89k|            Rc::clone(&dataset),
  133|  4.89k|            self.base_iri.clone(),
  134|  4.89k|            self.options.query_options.service_handler(),
  135|  4.89k|            Arc::new(self.options.query_options.custom_functions.clone()),
  136|  4.89k|            false,
  137|  4.89k|        );
  138|  4.89k|        let mut variables = Vec::new();
  139|  4.89k|        let mut bnodes = HashMap::new();
  140|  4.89k|        let (eval, _) = evaluator.graph_pattern_evaluator(&pattern, &mut variables);
  141|  4.89k|        let tuples =
  142|  4.89k|            eval(EncodedTuple::with_capacity(variables.len())).collect::<Result<Vec<_>, _>>()?; // TODO: would be much better to stream
  143|  6.65k|        for tuple in tuples {
  144|  9.87k|            for quad in delete {
  145|    899|                if let Some(quad) =
  146|  8.10k|                    Self::convert_ground_quad_pattern(quad, &variables, &tuple, &dataset)?
  147|       |                {
  148|    899|                    self.transaction.remove(quad.as_ref())?;
  149|  7.20k|                }
  150|       |            }
  151|  4.45k|            for quad in insert {
  152|    398|                if let Some(quad) =
  153|  2.68k|                    Self::convert_quad_pattern(quad, &variables, &tuple, &dataset, &mut bnodes)?
  154|       |                {
  155|    398|                    self.transaction.insert(quad.as_ref())?;
  156|  2.28k|                }
  157|       |            }
  158|  1.76k|            bnodes.clear();
  159|       |        }
  160|  4.88k|        Ok(())
  161|  4.89k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB2_21SimpleUpdateEvaluator27convert_ground_quad_pattern:
  458|  8.10k|    fn convert_ground_quad_pattern(
  459|  8.10k|        quad: &GroundQuadPattern,
  460|  8.10k|        variables: &[Variable],
  461|  8.10k|        values: &EncodedTuple,
  462|  8.10k|        dataset: &DatasetView,
  463|  8.10k|    ) -> Result<Option<OxQuad>, EvaluationError> {
  464|  8.10k|        Ok(Some(OxQuad {
  465|  8.10k|            subject: match Self::convert_ground_term_or_var(
  466|  8.10k|                &quad.subject,
  467|  8.10k|                variables,
  468|  8.10k|                values,
  469|  8.10k|                dataset,
  470|  8.10k|            )? {
  471|  5.91k|                Some(Term::NamedNode(node)) => node.into(),
  472|      0|                Some(Term::BlankNode(node)) => node.into(),
  473|      0|                Some(Term::Triple(triple)) => triple.into(),
  474|  2.18k|                Some(Term::Literal(_)) | None => return Ok(None),
  475|       |            },
  476|  5.48k|            predicate: if let Some(predicate) =
  477|  5.91k|                Self::convert_named_node_or_var(&quad.predicate, variables, values, dataset)?
  478|       |            {
  479|  5.48k|                predicate
  480|       |            } else {
  481|    434|                return Ok(None);
  482|       |            },
  483|  1.08k|            object: if let Some(object) =
  484|  5.48k|                Self::convert_ground_term_or_var(&quad.object, variables, values, dataset)?
  485|       |            {
  486|  1.08k|                object
  487|       |            } else {
  488|  4.39k|                return Ok(None);
  489|       |            },
  490|    899|            graph_name: if let Some(graph_name) =
  491|  1.08k|                Self::convert_graph_name_or_var(&quad.graph_name, variables, values, dataset)?
  492|       |            {
  493|    899|                graph_name
  494|       |            } else {
  495|    189|                return Ok(None);
  496|       |            },
  497|       |        }))
  498|  8.10k|    }
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator25convert_named_node_or_var0B8_:
  395|     33|                .map(|node| dataset.decode_named_node(&node))
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator25convert_graph_name_or_var0B8_:
  410|     16|                .map(|node| {
  411|     16|                    Ok(if node == EncodedTerm::DefaultGraph {
  412|      0|                        OxGraphName::DefaultGraph
  413|       |                    } else {
  414|     16|                        dataset.decode_named_node(&node)?.into()
  415|       |                    })
  416|     16|                })
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator15lookup_variable0B8_:
  561|  12.0k|            .position(|v2| v == v2)
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator26convert_ground_term_or_var0B8_:
  514|    339|                .map(|node| dataset.decode_term(&node))
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator15lookup_variables_0B8_:
  562|  1.68k|            .and_then(|i| values.get(i))
_RNCNvMNtNtCs2ek33vt1YA5_8oxigraph6sparql6updateNtB4_21SimpleUpdateEvaluator19convert_term_or_var0B8_:
  381|     80|                .map(|node| dataset.decode_term(&node))

_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder14write_osp_quad:
  457|    444|pub fn write_osp_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  458|    444|    write_term(sink, &quad.object);
  459|    444|    write_term(sink, &quad.subject);
  460|    444|    write_term(sink, &quad.predicate);
  461|    444|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_gpos_quad:
  431|  2.57k|pub fn write_gpos_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  432|  2.57k|    write_term(sink, &quad.graph_name);
  433|  2.57k|    write_term(sink, &quad.predicate);
  434|  2.57k|    write_term(sink, &quad.object);
  435|  2.57k|    write_term(sink, &quad.subject);
  436|  2.57k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder16encode_term_pair:
  469|  11.7k|pub fn encode_term_pair(t1: &EncodedTerm, t2: &EncodedTerm) -> Vec<u8> {
  470|  11.7k|    let mut vec = Vec::with_capacity(2 * WRITTEN_TERM_MAX_SIZE);
  471|  11.7k|    write_term(&mut vec, t1);
  472|  11.7k|    write_term(&mut vec, t2);
  473|  11.7k|    vec
  474|  11.7k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_spog_quad:
  403|  7.79k|pub fn write_spog_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  404|  7.79k|    write_term(sink, &quad.subject);
  405|  7.79k|    write_term(sink, &quad.predicate);
  406|  7.79k|    write_term(sink, &quad.object);
  407|  7.79k|    write_term(sink, &quad.graph_name);
  408|  7.79k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder14write_spo_quad:
  445|    606|pub fn write_spo_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  446|    606|    write_term(sink, &quad.subject);
  447|    606|    write_term(sink, &quad.predicate);
  448|    606|    write_term(sink, &quad.object);
  449|    606|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder16encode_term_quad:
  484|    496|pub fn encode_term_quad(
  485|    496|    t1: &EncodedTerm,
  486|    496|    t2: &EncodedTerm,
  487|    496|    t3: &EncodedTerm,
  488|    496|    t4: &EncodedTerm,
  489|    496|) -> Vec<u8> {
  490|    496|    let mut vec = Vec::with_capacity(4 * WRITTEN_TERM_MAX_SIZE);
  491|    496|    write_term(&mut vec, t1);
  492|    496|    write_term(&mut vec, t2);
  493|    496|    write_term(&mut vec, t3);
  494|    496|    write_term(&mut vec, t4);
  495|    496|    vec
  496|    496|}
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoderNtB2_12QuadEncoding6decode:
   65|  2.93k|    pub fn decode(self, mut buffer: &[u8]) -> Result<EncodedQuad, StorageError> {
   66|  2.93k|        match self {
   67|      2|            Self::Spog => buffer.read_spog_quad(),
   68|      3|            Self::Posg => buffer.read_posg_quad(),
   69|      0|            Self::Ospg => buffer.read_ospg_quad(),
   70|  2.48k|            Self::Gspo => buffer.read_gspo_quad(),
   71|      7|            Self::Gpos => buffer.read_gpos_quad(),
   72|      0|            Self::Gosp => buffer.read_gosp_quad(),
   73|    440|            Self::Dspo => buffer.read_dspo_quad(),
   74|      1|            Self::Dpos => buffer.read_dpos_quad(),
   75|      0|            Self::Dosp => buffer.read_dosp_quad(),
   76|       |        }
   77|  2.93k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10write_term:
  498|   138k|pub fn write_term(sink: &mut Vec<u8>, term: &EncodedTerm) {
  499|   138k|    match term {
  500|      0|        EncodedTerm::DefaultGraph => (),
  501|   122k|        EncodedTerm::NamedNode { iri_id } => {
  502|   122k|            sink.push(TYPE_NAMED_NODE_ID);
  503|   122k|            sink.extend_from_slice(&iri_id.to_be_bytes());
  504|   122k|        }
  505|      0|        EncodedTerm::NumericalBlankNode { id } => {
  506|      0|            sink.push(TYPE_NUMERICAL_BLANK_NODE_ID);
  507|      0|            sink.extend_from_slice(&id.to_be_bytes())
  508|       |        }
  509|      0|        EncodedTerm::SmallBlankNode(id) => {
  510|      0|            sink.push(TYPE_SMALL_BLANK_NODE_ID);
  511|      0|            sink.extend_from_slice(&id.to_be_bytes())
  512|       |        }
  513|      0|        EncodedTerm::BigBlankNode { id_id } => {
  514|      0|            sink.push(TYPE_BIG_BLANK_NODE_ID);
  515|      0|            sink.extend_from_slice(&id_id.to_be_bytes());
  516|      0|        }
  517|    897|        EncodedTerm::SmallStringLiteral(value) => {
  518|    897|            sink.push(TYPE_SMALL_STRING_LITERAL);
  519|    897|            sink.extend_from_slice(&value.to_be_bytes())
  520|       |        }
  521|      0|        EncodedTerm::BigStringLiteral { value_id } => {
  522|      0|            sink.push(TYPE_BIG_STRING_LITERAL);
  523|      0|            sink.extend_from_slice(&value_id.to_be_bytes());
  524|      0|        }
  525|  4.80k|        EncodedTerm::SmallSmallLangStringLiteral { value, language } => {
  526|  4.80k|            sink.push(TYPE_SMALL_SMALL_LANG_STRING_LITERAL);
  527|  4.80k|            sink.extend_from_slice(&language.to_be_bytes());
  528|  4.80k|            sink.extend_from_slice(&value.to_be_bytes());
  529|  4.80k|        }
  530|      0|        EncodedTerm::SmallBigLangStringLiteral { value, language_id } => {
  531|      0|            sink.push(TYPE_SMALL_BIG_LANG_STRING_LITERAL);
  532|      0|            sink.extend_from_slice(&language_id.to_be_bytes());
  533|      0|            sink.extend_from_slice(&value.to_be_bytes());
  534|      0|        }
  535|      0|        EncodedTerm::BigSmallLangStringLiteral { value_id, language } => {
  536|      0|            sink.push(TYPE_BIG_SMALL_LANG_STRING_LITERAL);
  537|      0|            sink.extend_from_slice(&language.to_be_bytes());
  538|      0|            sink.extend_from_slice(&value_id.to_be_bytes());
  539|      0|        }
  540|       |        EncodedTerm::BigBigLangStringLiteral {
  541|      0|            value_id,
  542|      0|            language_id,
  543|      0|        } => {
  544|      0|            sink.push(TYPE_BIG_BIG_LANG_STRING_LITERAL);
  545|      0|            sink.extend_from_slice(&language_id.to_be_bytes());
  546|      0|            sink.extend_from_slice(&value_id.to_be_bytes());
  547|      0|        }
  548|      0|        EncodedTerm::SmallTypedLiteral { value, datatype_id } => {
  549|      0|            sink.push(TYPE_SMALL_TYPED_LITERAL);
  550|      0|            sink.extend_from_slice(&datatype_id.to_be_bytes());
  551|      0|            sink.extend_from_slice(&value.to_be_bytes());
  552|      0|        }
  553|       |        EncodedTerm::BigTypedLiteral {
  554|      0|            value_id,
  555|      0|            datatype_id,
  556|      0|        } => {
  557|      0|            sink.push(TYPE_BIG_TYPED_LITERAL);
  558|      0|            sink.extend_from_slice(&datatype_id.to_be_bytes());
  559|      0|            sink.extend_from_slice(&value_id.to_be_bytes());
  560|      0|        }
  561|  2.12k|        EncodedTerm::BooleanLiteral(value) => sink.push(if bool::from(*value) {
  562|    531|            TYPE_BOOLEAN_LITERAL_TRUE
  563|       |        } else {
  564|  1.59k|            TYPE_BOOLEAN_LITERAL_FALSE
  565|       |        }),
  566|      0|        EncodedTerm::FloatLiteral(value) => {
  567|      0|            sink.push(TYPE_FLOAT_LITERAL);
  568|      0|            sink.extend_from_slice(&value.to_be_bytes())
  569|       |        }
  570|  1.18k|        EncodedTerm::DoubleLiteral(value) => {
  571|  1.18k|            sink.push(TYPE_DOUBLE_LITERAL);
  572|  1.18k|            sink.extend_from_slice(&value.to_be_bytes())
  573|       |        }
  574|  2.32k|        EncodedTerm::IntegerLiteral(value) => {
  575|  2.32k|            sink.push(TYPE_INTEGER_LITERAL);
  576|  2.32k|            sink.extend_from_slice(&value.to_be_bytes())
  577|       |        }
  578|  4.80k|        EncodedTerm::DecimalLiteral(value) => {
  579|  4.80k|            sink.push(TYPE_DECIMAL_LITERAL);
  580|  4.80k|            sink.extend_from_slice(&value.to_be_bytes())
  581|       |        }
  582|      0|        EncodedTerm::DateTimeLiteral(value) => {
  583|      0|            sink.push(TYPE_DATE_TIME_LITERAL);
  584|      0|            sink.extend_from_slice(&value.to_be_bytes())
  585|       |        }
  586|      0|        EncodedTerm::TimeLiteral(value) => {
  587|      0|            sink.push(TYPE_TIME_LITERAL);
  588|      0|            sink.extend_from_slice(&value.to_be_bytes())
  589|       |        }
  590|      0|        EncodedTerm::DurationLiteral(value) => {
  591|      0|            sink.push(TYPE_DURATION_LITERAL);
  592|      0|            sink.extend_from_slice(&value.to_be_bytes())
  593|       |        }
  594|      0|        EncodedTerm::DateLiteral(value) => {
  595|      0|            sink.push(TYPE_DATE_LITERAL);
  596|      0|            sink.extend_from_slice(&value.to_be_bytes())
  597|       |        }
  598|      0|        EncodedTerm::GYearMonthLiteral(value) => {
  599|      0|            sink.push(TYPE_G_YEAR_MONTH_LITERAL);
  600|      0|            sink.extend_from_slice(&value.to_be_bytes())
  601|       |        }
  602|      0|        EncodedTerm::GYearLiteral(value) => {
  603|      0|            sink.push(TYPE_G_YEAR_LITERAL);
  604|      0|            sink.extend_from_slice(&value.to_be_bytes())
  605|       |        }
  606|      0|        EncodedTerm::GMonthDayLiteral(value) => {
  607|      0|            sink.push(TYPE_G_MONTH_DAY_LITERAL);
  608|      0|            sink.extend_from_slice(&value.to_be_bytes())
  609|       |        }
  610|      0|        EncodedTerm::GDayLiteral(value) => {
  611|      0|            sink.push(TYPE_G_DAY_LITERAL);
  612|      0|            sink.extend_from_slice(&value.to_be_bytes())
  613|       |        }
  614|      0|        EncodedTerm::GMonthLiteral(value) => {
  615|      0|            sink.push(TYPE_G_MONTH_LITERAL);
  616|      0|            sink.extend_from_slice(&value.to_be_bytes())
  617|       |        }
  618|      0|        EncodedTerm::YearMonthDurationLiteral(value) => {
  619|      0|            sink.push(TYPE_YEAR_MONTH_DURATION_LITERAL);
  620|      0|            sink.extend_from_slice(&value.to_be_bytes())
  621|       |        }
  622|      0|        EncodedTerm::DayTimeDurationLiteral(value) => {
  623|      0|            sink.push(TYPE_DAY_TIME_DURATION_LITERAL);
  624|      0|            sink.extend_from_slice(&value.to_be_bytes())
  625|       |        }
  626|      0|        EncodedTerm::Triple(value) => {
  627|      0|            sink.push(TYPE_TRIPLE);
  628|      0|            write_term(sink, &value.subject);
  629|      0|            write_term(sink, &value.predicate);
  630|      0|            write_term(sink, &value.object);
  631|      0|        }
  632|       |    }
  633|   138k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_gspo_quad:
  424|  2.57k|pub fn write_gspo_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  425|  2.57k|    write_term(sink, &quad.graph_name);
  426|  2.57k|    write_term(sink, &quad.subject);
  427|  2.57k|    write_term(sink, &quad.predicate);
  428|  2.57k|    write_term(sink, &quad.object);
  429|  2.57k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder11encode_term:
  463|  15.0k|pub fn encode_term(t: &EncodedTerm) -> Vec<u8> {
  464|  15.0k|    let mut vec = Vec::with_capacity(WRITTEN_TERM_MAX_SIZE);
  465|  15.0k|    write_term(&mut vec, t);
  466|  15.0k|    vec
  467|  15.0k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_gosp_quad:
  438|  2.57k|pub fn write_gosp_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  439|  2.57k|    write_term(sink, &quad.graph_name);
  440|  2.57k|    write_term(sink, &quad.object);
  441|  2.57k|    write_term(sink, &quad.subject);
  442|  2.57k|    write_term(sink, &quad.predicate);
  443|  2.57k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder18encode_term_triple:
  476|  3.60k|pub fn encode_term_triple(t1: &EncodedTerm, t2: &EncodedTerm, t3: &EncodedTerm) -> Vec<u8> {
  477|  3.60k|    let mut vec = Vec::with_capacity(3 * WRITTEN_TERM_MAX_SIZE);
  478|  3.60k|    write_term(&mut vec, t1);
  479|  3.60k|    write_term(&mut vec, t2);
  480|  3.60k|    write_term(&mut vec, t3);
  481|  3.60k|    vec
  482|  3.60k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_posg_quad:
  410|  2.57k|pub fn write_posg_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  411|  2.57k|    write_term(sink, &quad.predicate);
  412|  2.57k|    write_term(sink, &quad.object);
  413|  2.57k|    write_term(sink, &quad.subject);
  414|  2.57k|    write_term(sink, &quad.graph_name);
  415|  2.57k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder14write_pos_quad:
  451|    444|pub fn write_pos_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  452|    444|    write_term(sink, &quad.predicate);
  453|    444|    write_term(sink, &quad.object);
  454|    444|    write_term(sink, &quad.subject);
  455|    444|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder15write_ospg_quad:
  417|  2.57k|pub fn write_ospg_quad(sink: &mut Vec<u8>, quad: &EncodedQuad) {
  418|  2.57k|    write_term(sink, &quad.object);
  419|  2.57k|    write_term(sink, &quad.subject);
  420|  2.57k|    write_term(sink, &quad.predicate);
  421|  2.57k|    write_term(sink, &quad.graph_name);
  422|  2.57k|}
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_gspo_quadBb_:
  127|  2.48k|    fn read_gspo_quad(&mut self) -> Result<EncodedQuad, StorageError> {
  128|  2.48k|        let graph_name = self.read_term()?;
  129|  2.48k|        let subject = self.read_term()?;
  130|  2.48k|        let predicate = self.read_term()?;
  131|  2.48k|        let object = self.read_term()?;
  132|  2.48k|        Ok(EncodedQuad {
  133|  2.48k|            subject,
  134|  2.48k|            predicate,
  135|  2.48k|            object,
  136|  2.48k|            graph_name,
  137|  2.48k|        })
  138|  2.48k|    }
_RNvXs_NtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoderRShNtB4_10TermReader9read_termB8_:
  204|  11.2k|    fn read_term(&mut self) -> Result<EncodedTerm, StorageError> {
  205|  11.2k|        let mut type_buffer = [0];
  206|  11.2k|        self.read_exact(&mut type_buffer)?;
  207|  11.2k|        match type_buffer[0] {
  208|       |            TYPE_NAMED_NODE_ID => {
  209|  9.38k|                let mut buffer = [0; 16];
  210|  9.38k|                self.read_exact(&mut buffer)?;
  211|  9.38k|                Ok(EncodedTerm::NamedNode {
  212|  9.38k|                    iri_id: StrHash::from_be_bytes(buffer),
  213|  9.38k|                })
  214|       |            }
  215|       |            TYPE_NUMERICAL_BLANK_NODE_ID => {
  216|      0|                let mut buffer = [0; 16];
  217|      0|                self.read_exact(&mut buffer)?;
  218|      0|                Ok(EncodedTerm::NumericalBlankNode {
  219|      0|                    id: u128::from_be_bytes(buffer),
  220|      0|                })
  221|       |            }
  222|       |            TYPE_SMALL_BLANK_NODE_ID => {
  223|      0|                let mut buffer = [0; 16];
  224|      0|                self.read_exact(&mut buffer)?;
  225|       |                Ok(EncodedTerm::SmallBlankNode(
  226|      0|                    SmallString::from_be_bytes(buffer).map_err(CorruptionError::new)?,
  227|       |                ))
  228|       |            }
  229|       |            TYPE_BIG_BLANK_NODE_ID => {
  230|      0|                let mut buffer = [0; 16];
  231|      0|                self.read_exact(&mut buffer)?;
  232|      0|                Ok(EncodedTerm::BigBlankNode {
  233|      0|                    id_id: StrHash::from_be_bytes(buffer),
  234|      0|                })
  235|       |            }
  236|       |            TYPE_SMALL_SMALL_LANG_STRING_LITERAL => {
  237|    607|                let mut language_buffer = [0; 16];
  238|    607|                self.read_exact(&mut language_buffer)?;
  239|    607|                let mut value_buffer = [0; 16];
  240|    607|                self.read_exact(&mut value_buffer)?;
  241|       |                Ok(EncodedTerm::SmallSmallLangStringLiteral {
  242|    607|                    value: SmallString::from_be_bytes(value_buffer)
  243|    607|                        .map_err(CorruptionError::new)?,
  244|    607|                    language: SmallString::from_be_bytes(language_buffer)
  245|    607|                        .map_err(CorruptionError::new)?,
  246|       |                })
  247|       |            }
  248|       |            TYPE_SMALL_BIG_LANG_STRING_LITERAL => {
  249|      0|                let mut language_buffer = [0; 16];
  250|      0|                self.read_exact(&mut language_buffer)?;
  251|      0|                let mut value_buffer = [0; 16];
  252|      0|                self.read_exact(&mut value_buffer)?;
  253|       |                Ok(EncodedTerm::SmallBigLangStringLiteral {
  254|      0|                    value: SmallString::from_be_bytes(value_buffer)
  255|      0|                        .map_err(CorruptionError::new)?,
  256|      0|                    language_id: StrHash::from_be_bytes(language_buffer),
  257|       |                })
  258|       |            }
  259|       |            TYPE_BIG_SMALL_LANG_STRING_LITERAL => {
  260|      0|                let mut language_buffer = [0; 16];
  261|      0|                self.read_exact(&mut language_buffer)?;
  262|      0|                let mut value_buffer = [0; 16];
  263|      0|                self.read_exact(&mut value_buffer)?;
  264|       |                Ok(EncodedTerm::BigSmallLangStringLiteral {
  265|      0|                    value_id: StrHash::from_be_bytes(value_buffer),
  266|      0|                    language: SmallString::from_be_bytes(language_buffer)
  267|      0|                        .map_err(CorruptionError::new)?,
  268|       |                })
  269|       |            }
  270|       |            TYPE_BIG_BIG_LANG_STRING_LITERAL => {
  271|      0|                let mut language_buffer = [0; 16];
  272|      0|                self.read_exact(&mut language_buffer)?;
  273|      0|                let mut value_buffer = [0; 16];
  274|      0|                self.read_exact(&mut value_buffer)?;
  275|      0|                Ok(EncodedTerm::BigBigLangStringLiteral {
  276|      0|                    value_id: StrHash::from_be_bytes(value_buffer),
  277|      0|                    language_id: StrHash::from_be_bytes(language_buffer),
  278|      0|                })
  279|       |            }
  280|       |            TYPE_SMALL_TYPED_LITERAL => {
  281|      0|                let mut datatype_buffer = [0; 16];
  282|      0|                self.read_exact(&mut datatype_buffer)?;
  283|      0|                let mut value_buffer = [0; 16];
  284|      0|                self.read_exact(&mut value_buffer)?;
  285|       |                Ok(EncodedTerm::SmallTypedLiteral {
  286|      0|                    datatype_id: StrHash::from_be_bytes(datatype_buffer),
  287|      0|                    value: SmallString::from_be_bytes(value_buffer)
  288|      0|                        .map_err(CorruptionError::new)?,
  289|       |                })
  290|       |            }
  291|       |            TYPE_BIG_TYPED_LITERAL => {
  292|      0|                let mut datatype_buffer = [0; 16];
  293|      0|                self.read_exact(&mut datatype_buffer)?;
  294|      0|                let mut value_buffer = [0; 16];
  295|      0|                self.read_exact(&mut value_buffer)?;
  296|      0|                Ok(EncodedTerm::BigTypedLiteral {
  297|      0|                    datatype_id: StrHash::from_be_bytes(datatype_buffer),
  298|      0|                    value_id: StrHash::from_be_bytes(value_buffer),
  299|      0|                })
  300|       |            }
  301|       |            TYPE_SMALL_STRING_LITERAL => {
  302|     76|                let mut buffer = [0; 16];
  303|     76|                self.read_exact(&mut buffer)?;
  304|       |                Ok(EncodedTerm::SmallStringLiteral(
  305|     76|                    SmallString::from_be_bytes(buffer).map_err(CorruptionError::new)?,
  306|       |                ))
  307|       |            }
  308|       |            TYPE_BIG_STRING_LITERAL => {
  309|      0|                let mut buffer = [0; 16];
  310|      0|                self.read_exact(&mut buffer)?;
  311|      0|                Ok(EncodedTerm::BigStringLiteral {
  312|      0|                    value_id: StrHash::from_be_bytes(buffer),
  313|      0|                })
  314|       |            }
  315|     42|            TYPE_BOOLEAN_LITERAL_TRUE => Ok(true.into()),
  316|    184|            TYPE_BOOLEAN_LITERAL_FALSE => Ok(false.into()),
  317|       |            TYPE_FLOAT_LITERAL => {
  318|      0|                let mut buffer = [0; 4];
  319|      0|                self.read_exact(&mut buffer)?;
  320|      0|                Ok(Float::from_be_bytes(buffer).into())
  321|       |            }
  322|       |            TYPE_DOUBLE_LITERAL => {
  323|     66|                let mut buffer = [0; 8];
  324|     66|                self.read_exact(&mut buffer)?;
  325|     66|                Ok(Double::from_be_bytes(buffer).into())
  326|       |            }
  327|       |            TYPE_INTEGER_LITERAL => {
  328|    260|                let mut buffer = [0; 8];
  329|    260|                self.read_exact(&mut buffer)?;
  330|    260|                Ok(Integer::from_be_bytes(buffer).into())
  331|       |            }
  332|       |            TYPE_DECIMAL_LITERAL => {
  333|    669|                let mut buffer = [0; 16];
  334|    669|                self.read_exact(&mut buffer)?;
  335|    669|                Ok(Decimal::from_be_bytes(buffer).into())
  336|       |            }
  337|       |            TYPE_DATE_TIME_LITERAL => {
  338|      0|                let mut buffer = [0; 18];
  339|      0|                self.read_exact(&mut buffer)?;
  340|      0|                Ok(DateTime::from_be_bytes(buffer).into())
  341|       |            }
  342|       |            TYPE_TIME_LITERAL => {
  343|      0|                let mut buffer = [0; 18];
  344|      0|                self.read_exact(&mut buffer)?;
  345|      0|                Ok(Time::from_be_bytes(buffer).into())
  346|       |            }
  347|       |            TYPE_DATE_LITERAL => {
  348|      0|                let mut buffer = [0; 18];
  349|      0|                self.read_exact(&mut buffer)?;
  350|      0|                Ok(Date::from_be_bytes(buffer).into())
  351|       |            }
  352|       |            TYPE_G_YEAR_MONTH_LITERAL => {
  353|      0|                let mut buffer = [0; 18];
  354|      0|                self.read_exact(&mut buffer)?;
  355|      0|                Ok(GYearMonth::from_be_bytes(buffer).into())
  356|       |            }
  357|       |            TYPE_G_YEAR_LITERAL => {
  358|      0|                let mut buffer = [0; 18];
  359|      0|                self.read_exact(&mut buffer)?;
  360|      0|                Ok(GYear::from_be_bytes(buffer).into())
  361|       |            }
  362|       |            TYPE_G_MONTH_DAY_LITERAL => {
  363|      0|                let mut buffer = [0; 18];
  364|      0|                self.read_exact(&mut buffer)?;
  365|      0|                Ok(GMonthDay::from_be_bytes(buffer).into())
  366|       |            }
  367|       |            TYPE_G_DAY_LITERAL => {
  368|      0|                let mut buffer = [0; 18];
  369|      0|                self.read_exact(&mut buffer)?;
  370|      0|                Ok(GDay::from_be_bytes(buffer).into())
  371|       |            }
  372|       |            TYPE_G_MONTH_LITERAL => {
  373|      0|                let mut buffer = [0; 18];
  374|      0|                self.read_exact(&mut buffer)?;
  375|      0|                Ok(GMonth::from_be_bytes(buffer).into())
  376|       |            }
  377|       |            TYPE_DURATION_LITERAL => {
  378|      0|                let mut buffer = [0; 24];
  379|      0|                self.read_exact(&mut buffer)?;
  380|      0|                Ok(Duration::from_be_bytes(buffer).into())
  381|       |            }
  382|       |            TYPE_YEAR_MONTH_DURATION_LITERAL => {
  383|      0|                let mut buffer = [0; 8];
  384|      0|                self.read_exact(&mut buffer)?;
  385|      0|                Ok(YearMonthDuration::from_be_bytes(buffer).into())
  386|       |            }
  387|       |            TYPE_DAY_TIME_DURATION_LITERAL => {
  388|      0|                let mut buffer = [0; 16];
  389|      0|                self.read_exact(&mut buffer)?;
  390|      0|                Ok(DayTimeDuration::from_be_bytes(buffer).into())
  391|       |            }
  392|       |            TYPE_TRIPLE => Ok(EncodedTriple {
  393|      0|                subject: self.read_term()?,
  394|      0|                predicate: self.read_term()?,
  395|      0|                object: self.read_term()?,
  396|       |            }
  397|      0|            .into()),
  398|      0|            _ => Err(CorruptionError::msg("the term buffer has an invalid type id").into()),
  399|       |        }
  400|  11.2k|    }
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_gpos_quadBb_:
  140|      7|    fn read_gpos_quad(&mut self) -> Result<EncodedQuad, StorageError> {
  141|      7|        let graph_name = self.read_term()?;
  142|      7|        let predicate = self.read_term()?;
  143|      7|        let object = self.read_term()?;
  144|      7|        let subject = self.read_term()?;
  145|      7|        Ok(EncodedQuad {
  146|      7|            subject,
  147|      7|            predicate,
  148|      7|            object,
  149|      7|            graph_name,
  150|      7|        })
  151|      7|    }
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_spog_quadBb_:
   88|      2|    fn read_spog_quad(&mut self) -> Result<EncodedQuad, StorageError> {
   89|      2|        let subject = self.read_term()?;
   90|      2|        let predicate = self.read_term()?;
   91|      2|        let object = self.read_term()?;
   92|      2|        let graph_name = self.read_term()?;
   93|      2|        Ok(EncodedQuad {
   94|      2|            subject,
   95|      2|            predicate,
   96|      2|            object,
   97|      2|            graph_name,
   98|      2|        })
   99|      2|    }
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_dspo_quadBb_:
  166|    440|    fn read_dspo_quad(&mut self) -> Result<EncodedQuad, StorageError> {
  167|    440|        let subject = self.read_term()?;
  168|    440|        let predicate = self.read_term()?;
  169|    440|        let object = self.read_term()?;
  170|    440|        Ok(EncodedQuad {
  171|    440|            subject,
  172|    440|            predicate,
  173|    440|            object,
  174|    440|            graph_name: EncodedTerm::DefaultGraph,
  175|    440|        })
  176|    440|    }
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_posg_quadBb_:
  101|      3|    fn read_posg_quad(&mut self) -> Result<EncodedQuad, StorageError> {
  102|      3|        let predicate = self.read_term()?;
  103|      3|        let object = self.read_term()?;
  104|      3|        let subject = self.read_term()?;
  105|      3|        let graph_name = self.read_term()?;
  106|      3|        Ok(EncodedQuad {
  107|      3|            subject,
  108|      3|            predicate,
  109|      3|            object,
  110|      3|            graph_name,
  111|      3|        })
  112|      3|    }
_RNvYRShNtNtNtCs2ek33vt1YA5_8oxigraph7storage14binary_encoder10TermReader14read_dpos_quadBb_:
  178|      1|    fn read_dpos_quad(&mut self) -> Result<EncodedQuad, StorageError> {
  179|      1|        let predicate = self.read_term()?;
  180|      1|        let object = self.read_term()?;
  181|      1|        let subject = self.read_term()?;
  182|      1|        Ok(EncodedQuad {
  183|      1|            subject,
  184|      1|            predicate,
  185|      1|            object,
  186|      1|            graph_name: EncodedTerm::DefaultGraph,
  187|      1|        })
  188|      1|    }

_RNvXs7_NtNtCs2ek33vt1YA5_8oxigraph7storage5errorNtB5_12StorageErrorINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_15CorruptionErrorE4from:
    9|      2|#[derive(Debug, thiserror::Error)]
_RINvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage5errorNtB5_15CorruptionError3msgReEB9_:
   70|      2|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   71|      2|        Self(CorruptionErrorKind::Msg(msg.into()))
   72|      2|    }

_RINvMNtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB3_13MemoryStorage11transactionuNtNtNtB7_6sparql5error15EvaluationErrorNCINvMB5_NtB5_7Storage11transactionuB1h_NCINvMNtB7_5storeNtB2E_5Store10update_optNtNtCs9nhK3FOW46N_4core7convert10InfallibleNtNtB1l_7algebra6UpdateNtB1l_12QueryOptionsE0E0ECslmM25dSh1d8_18sparql_update_eval:
   67|  4.99k|    pub fn transaction<'a, 'b: 'a, T, E: Error + 'static + From<StorageError>>(
   68|  4.99k|        &'b self,
   69|  4.99k|        f: impl Fn(MemoryStorageWriter<'a>) -> Result<T, E>,
   70|  4.99k|    ) -> Result<T, E> {
   71|  4.99k|        f(MemoryStorageWriter {
   72|  4.99k|            content: Rc::new(RefCell::new(
   73|  4.99k|                self.content.write().map_err(poison_corruption_error)?,
   74|       |            )),
   75|  4.99k|            id2str: Arc::clone(&self.id2str),
   76|       |        })
   77|  4.99k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10posg_quads:
  314|    438|    fn posg_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  315|    438|        Self::inner_quads(&self.content().unwrap().posg, prefix, QuadEncoding::Posg)
  316|    438|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter14remove_encoded:
  638|  3.29k|    fn remove_encoded(&mut self, quad: &EncodedQuad) -> Result<bool, StorageError> {
  639|  3.29k|        let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  640|  3.29k|        let mut buffer = Vec::new();
  641|  3.29k|        Ok(if quad.graph_name.is_default_graph() {
  642|    144|            write_spo_quad(&mut buffer, quad);
  643|    144|            if content.dspo.remove(&buffer) {
  644|      0|                buffer.clear();
  645|      0|                write_pos_quad(&mut buffer, quad);
  646|      0|                content.dpos.remove(&buffer);
  647|      0|
  648|      0|                buffer.clear();
  649|      0|                write_osp_quad(&mut buffer, quad);
  650|      0|                content.dosp.remove(&buffer);
  651|      0|
  652|      0|                true
  653|       |            } else {
  654|    144|                false
  655|       |            }
  656|       |        } else {
  657|  3.15k|            write_spog_quad(&mut buffer, quad);
  658|  3.15k|            if content.spog.remove(&buffer) {
  659|     66|                buffer.clear();
  660|     66|                write_posg_quad(&mut buffer, quad);
  661|     66|                content.posg.remove(&buffer);
  662|     66|
  663|     66|                buffer.clear();
  664|     66|                write_ospg_quad(&mut buffer, quad);
  665|     66|                content.ospg.remove(&buffer);
  666|     66|
  667|     66|                buffer.clear();
  668|     66|                write_gspo_quad(&mut buffer, quad);
  669|     66|                content.gspo.remove(&buffer);
  670|     66|
  671|     66|                buffer.clear();
  672|     66|                write_gpos_quad(&mut buffer, quad);
  673|     66|                content.gpos.remove(&buffer);
  674|     66|
  675|     66|                buffer.clear();
  676|     66|                write_gosp_quad(&mut buffer, quad);
  677|     66|                content.gosp.remove(&buffer);
  678|     66|
  679|     66|                true
  680|       |            } else {
  681|  3.08k|                false
  682|       |            }
  683|       |        })
  684|  3.29k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader25quads_for_predicate_graph:
  256|  10.0k|    pub fn quads_for_predicate_graph(
  257|  10.0k|        &self,
  258|  10.0k|        predicate: &EncodedTerm,
  259|  10.0k|        graph_name: &EncodedTerm,
  260|  10.0k|    ) -> MemoryChainedDecodingQuadIterator {
  261|  10.0k|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  262|    952|            self.dpos_quads(encode_term(predicate))
  263|       |        } else {
  264|  9.13k|            self.gpos_quads(encode_term_pair(graph_name, predicate))
  265|       |        })
  266|  10.0k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter23remove_all_named_graphs:
  754|     16|    pub fn remove_all_named_graphs(&mut self) -> Result<(), StorageError> {
  755|     16|        let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  756|     16|        content.gspo.clear();
  757|     16|        content.gpos.clear();
  758|     16|        content.gosp.clear();
  759|     16|        content.spog.clear();
  760|     16|        content.posg.clear();
  761|     16|        content.ospg.clear();
  762|     16|        content.graphs.clear();
  763|     16|        Ok(())
  764|     16|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter5clear:
  766|  5.16k|    pub fn clear(&mut self) -> Result<(), StorageError> {
  767|  5.16k|        {
  768|  5.16k|            let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  769|  5.16k|            content.dspo.clear();
  770|  5.16k|            content.dpos.clear();
  771|  5.16k|            content.dosp.clear();
  772|  5.16k|            content.gspo.clear();
  773|  5.16k|            content.gpos.clear();
  774|  5.16k|            content.gosp.clear();
  775|  5.16k|            content.spog.clear();
  776|  5.16k|            content.posg.clear();
  777|  5.16k|            content.ospg.clear();
  778|  5.16k|            content.graphs.clear();
  779|  5.16k|        }
  780|  5.16k|        self.id2str
  781|  5.16k|            .write()
  782|  5.16k|            .map_err(poison_corruption_error)?
  783|  5.16k|            .clear();
  784|  5.16k|        Ok(())
  785|  5.16k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter6insert:
  518|  5.10k|    pub fn insert(&mut self, quad: QuadRef<'_>) -> Result<bool, StorageError> {
  519|  5.10k|        let encoded = quad.into();
  520|  5.10k|        Ok(if quad.graph_name.is_default_graph() {
  521|    462|            let mut buffer = Vec::new();
  522|    462|            write_spo_quad(&mut buffer, &encoded);
  523|    462|            if self.content.borrow_mut().dspo.insert(buffer) {
  524|    444|                let mut buffer = Vec::new();
  525|    444|                write_pos_quad(&mut buffer, &encoded);
  526|    444|                self.content.borrow_mut().dpos.insert(buffer);
  527|    444|
  528|    444|                let mut buffer = Vec::new();
  529|    444|                write_osp_quad(&mut buffer, &encoded);
  530|    444|                self.content.borrow_mut().dosp.insert(buffer);
  531|    444|
  532|    444|                self.insert_term(quad.subject.into(), &encoded.subject)?;
  533|    444|                self.insert_term(quad.predicate.into(), &encoded.predicate)?;
  534|    444|                self.insert_term(quad.object, &encoded.object)?;
  535|       |
  536|    444|                true
  537|       |            } else {
  538|     18|                false
  539|       |            }
  540|       |        } else {
  541|  4.64k|            let mut buffer = Vec::new();
  542|  4.64k|            write_spog_quad(&mut buffer, &encoded);
  543|  4.64k|            if self.content.borrow_mut().spog.insert(buffer) {
  544|  2.51k|                let mut buffer = Vec::new();
  545|  2.51k|                write_posg_quad(&mut buffer, &encoded);
  546|  2.51k|                self.content.borrow_mut().posg.insert(buffer);
  547|  2.51k|
  548|  2.51k|                let mut buffer = Vec::new();
  549|  2.51k|                write_ospg_quad(&mut buffer, &encoded);
  550|  2.51k|                self.content.borrow_mut().ospg.insert(buffer);
  551|  2.51k|
  552|  2.51k|                let mut buffer = Vec::new();
  553|  2.51k|                write_gspo_quad(&mut buffer, &encoded);
  554|  2.51k|                self.content.borrow_mut().gspo.insert(buffer);
  555|  2.51k|
  556|  2.51k|                let mut buffer = Vec::new();
  557|  2.51k|                write_gpos_quad(&mut buffer, &encoded);
  558|  2.51k|                self.content.borrow_mut().gpos.insert(buffer);
  559|  2.51k|
  560|  2.51k|                let mut buffer = Vec::new();
  561|  2.51k|                write_gosp_quad(&mut buffer, &encoded);
  562|  2.51k|                self.content.borrow_mut().gosp.insert(buffer);
  563|  2.51k|
  564|  2.51k|                self.insert_term(quad.subject.into(), &encoded.subject)?;
  565|  2.51k|                self.insert_term(quad.predicate.into(), &encoded.predicate)?;
  566|  2.51k|                self.insert_term(quad.object, &encoded.object)?;
  567|       |
  568|  2.51k|                if self
  569|  2.51k|                    .content
  570|  2.51k|                    .borrow_mut()
  571|  2.51k|                    .graphs
  572|  2.51k|                    .insert(encoded.graph_name.clone())
  573|       |                {
  574|  1.19k|                    match quad.graph_name {
  575|  1.19k|                        GraphNameRef::NamedNode(graph_name) => {
  576|  1.19k|                            self.insert_term(graph_name.into(), &encoded.graph_name)?;
  577|       |                        }
  578|      0|                        GraphNameRef::BlankNode(graph_name) => {
  579|      0|                            self.insert_term(graph_name.into(), &encoded.graph_name)?;
  580|       |                        }
  581|      0|                        GraphNameRef::DefaultGraph => (),
  582|       |                    }
  583|  1.31k|                }
  584|  2.51k|                true
  585|       |            } else {
  586|  2.13k|                false
  587|       |            }
  588|       |        })
  589|  5.10k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter6remove:
  634|  3.23k|    pub fn remove(&mut self, quad: QuadRef<'_>) -> Result<bool, StorageError> {
  635|  3.23k|        self.remove_encoded(&quad.into())
  636|  3.23k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10dosp_quads:
  342|    548|    fn dosp_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  343|    548|        Self::inner_quads(&self.content().unwrap().dosp, prefix, QuadEncoding::Dosp)
  344|    548|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter26remove_encoded_named_graph:
  732|    614|    fn remove_encoded_named_graph(
  733|    614|        &mut self,
  734|    614|        graph_name: &EncodedTerm,
  735|    614|    ) -> Result<bool, StorageError> {
  736|    614|        Ok(
  737|    614|            if self
  738|    614|                .content
  739|    614|                .try_borrow_mut()
  740|    614|                .map_err(borrow_mut_error)?
  741|       |                .graphs
  742|    614|                .remove(graph_name)
  743|       |            {
  744|     12|                for quad in self.reader().quads_for_graph(graph_name) {
  745|     10|                    self.remove_encoded(&quad?)?;
  746|       |                }
  747|     12|                true
  748|       |            } else {
  749|    602|                false
  750|       |            },
  751|       |        )
  752|    614|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter22clear_all_named_graphs:
  700|     76|    pub fn clear_all_named_graphs(&mut self) -> Result<(), StorageError> {
  701|     76|        let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  702|     76|        content.gspo.clear();
  703|     76|        content.gpos.clear();
  704|     76|        content.gosp.clear();
  705|     76|        content.spog.clear();
  706|     76|        content.posg.clear();
  707|     76|        content.ospg.clear();
  708|     76|        Ok(())
  709|     76|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10dpos_quads:
  338|  1.54k|    fn dpos_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  339|  1.54k|        Self::inner_quads(&self.content().unwrap().dpos, prefix, QuadEncoding::Dpos)
  340|  1.54k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter6reader:
  509|  6.36k|    pub fn reader(&self) -> MemoryStorageReader {
  510|  6.36k|        // SAFETY: This transmute is safe because we take a weak reference and the only Rc reference used is guarded by the lifetime.
  511|  6.36k|        let content = unsafe { transmute(&self.content) };
  512|  6.36k|        MemoryStorageReader {
  513|  6.36k|            content: MemoryStorageReaderContent::Transaction(Rc::downgrade(content)),
  514|  6.36k|            id2str: Arc::clone(&self.id2str),
  515|  6.36k|        }
  516|  6.36k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader5quads:
  120|  5.48k|    pub fn quads(&self) -> MemoryChainedDecodingQuadIterator {
  121|  5.48k|        MemoryChainedDecodingQuadIterator::pair(
  122|  5.48k|            self.dspo_quads(Vec::new()),
  123|  5.48k|            self.gspo_quads(Vec::new()),
  124|  5.48k|        )
  125|  5.48k|    }
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_33MemoryChainedDecodingQuadIterator3new:
  448|  29.9k|    fn new(first: MemoryDecodingQuadIterator) -> Self {
  449|  29.9k|        Self {
  450|  29.9k|            first,
  451|  29.9k|            second: None,
  452|  29.9k|        }
  453|  29.9k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader26quads_for_predicate_object:
  178|     98|    pub fn quads_for_predicate_object(
  179|     98|        &self,
  180|     98|        predicate: &EncodedTerm,
  181|     98|        object: &EncodedTerm,
  182|     98|    ) -> MemoryChainedDecodingQuadIterator {
  183|     98|        MemoryChainedDecodingQuadIterator::pair(
  184|     98|            self.dpos_quads(encode_term_pair(predicate, object)),
  185|     98|            self.posg_quads(encode_term_pair(predicate, object)),
  186|     98|        )
  187|     98|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader30quads_for_subject_object_graph:
  243|    151|    pub fn quads_for_subject_object_graph(
  244|    151|        &self,
  245|    151|        subject: &EncodedTerm,
  246|    151|        object: &EncodedTerm,
  247|    151|        graph_name: &EncodedTerm,
  248|    151|    ) -> MemoryChainedDecodingQuadIterator {
  249|    151|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  250|     52|            self.dosp_quads(encode_term_pair(object, subject))
  251|       |        } else {
  252|     99|            self.gosp_quads(encode_term_triple(graph_name, object, subject))
  253|       |        })
  254|    151|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter11insert_term:
  611|  10.2k|    fn insert_term(
  612|  10.2k|        &mut self,
  613|  10.2k|        term: TermRef<'_>,
  614|  10.2k|        encoded: &EncodedTerm,
  615|  10.2k|    ) -> Result<(), StorageError> {
  616|  10.2k|        insert_term(term, encoded, &mut |key, value| self.insert_str(key, value))
  617|  10.2k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader7content:
  389|  44.6k|    fn content<'a>(&'a self) -> Result<ContentRef<'a>, StorageError> {
  390|  44.6k|        Ok(match &self.content {
  391|  9.99k|            MemoryStorageReaderContent::Simple(reader) => {
  392|  9.99k|                ContentRef::Simple(reader.read().map_err(poison_corruption_error)?)
  393|       |            }
  394|  34.6k|            MemoryStorageReaderContent::Transaction(reader) => {
  395|  34.6k|                let Some(rc) = reader.upgrade() else {
  396|      0|                    return Err(StorageError::Other(
  397|      0|                        "The transaction is already ended".into(),
  398|      0|                    ));
  399|       |                };
  400|  34.6k|                let element: Ref<'_, _> = rc.as_ref().borrow();
  401|  34.6k|                // SAFETY: ok because we keep the Rc too inside of ContentRef
  402|  34.6k|                let element = unsafe { transmute::<_, Ref<'a, _>>(element) };
  403|  34.6k|                ContentRef::Transaction {
  404|  34.6k|                    _rc: Rc::clone(&rc),
  405|  34.6k|                    element,
  406|  34.6k|                }
  407|       |            }
  408|       |        })
  409|  44.6k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter11clear_graph:
  686|    778|    pub fn clear_graph(&mut self, graph_name: GraphNameRef<'_>) -> Result<(), StorageError> {
  687|    778|        if graph_name.is_default_graph() {
  688|    696|            let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  689|    696|            content.dspo.clear();
  690|    696|            content.dpos.clear();
  691|    696|            content.dosp.clear();
  692|       |        } else {
  693|     82|            for quad in self.reader().quads_for_graph(&graph_name.into()) {
  694|     54|                self.remove_encoded(&quad?)?;
  695|       |            }
  696|       |        }
  697|    778|        Ok(())
  698|    778|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader24quads_for_subject_object:
  157|     84|    pub fn quads_for_subject_object(
  158|     84|        &self,
  159|     84|        subject: &EncodedTerm,
  160|     84|        object: &EncodedTerm,
  161|     84|    ) -> MemoryChainedDecodingQuadIterator {
  162|     84|        MemoryChainedDecodingQuadIterator::pair(
  163|     84|            self.dosp_quads(encode_term_pair(object, subject)),
  164|     84|            self.ospg_quads(encode_term_pair(object, subject)),
  165|     84|        )
  166|     84|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10spog_quads:
  310|    432|    fn spog_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  311|    432|        Self::inner_quads(&self.content().unwrap().spog, prefix, QuadEncoding::Spog)
  312|    432|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10dspo_quads:
  334|  7.75k|    fn dspo_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  335|  7.75k|        Self::inner_quads(&self.content().unwrap().dspo, prefix, QuadEncoding::Dspo)
  336|  7.75k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter18insert_named_graph:
  591|    446|    pub fn insert_named_graph(
  592|    446|        &mut self,
  593|    446|        graph_name: NamedOrBlankNodeRef<'_>,
  594|    446|    ) -> Result<bool, StorageError> {
  595|    446|        let encoded_graph_name = EncodedTerm::from(graph_name);
  596|    446|        Ok(
  597|    446|            if self
  598|    446|                .content
  599|    446|                .borrow_mut()
  600|    446|                .graphs
  601|    446|                .insert(encoded_graph_name.clone())
  602|       |            {
  603|    206|                self.insert_term(graph_name.into(), &encoded_graph_name)?;
  604|    206|                true
  605|       |            } else {
  606|    240|                false
  607|       |            },
  608|       |        )
  609|    446|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader19quads_for_predicate:
  168|    340|    pub fn quads_for_predicate(
  169|    340|        &self,
  170|    340|        predicate: &EncodedTerm,
  171|    340|    ) -> MemoryChainedDecodingQuadIterator {
  172|    340|        MemoryChainedDecodingQuadIterator::pair(
  173|    340|            self.dpos_quads(encode_term(predicate)),
  174|    340|            self.posg_quads(encode_term(predicate)),
  175|    340|        )
  176|    340|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader40quads_for_subject_predicate_object_graph:
  229|    656|    pub fn quads_for_subject_predicate_object_graph(
  230|    656|        &self,
  231|    656|        subject: &EncodedTerm,
  232|    656|        predicate: &EncodedTerm,
  233|    656|        object: &EncodedTerm,
  234|    656|        graph_name: &EncodedTerm,
  235|    656|    ) -> MemoryChainedDecodingQuadIterator {
  236|    656|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  237|    160|            self.dspo_quads(encode_term_triple(subject, predicate, object))
  238|       |        } else {
  239|    496|            self.gspo_quads(encode_term_quad(graph_name, subject, predicate, object))
  240|       |        })
  241|    656|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader20contains_named_graph:
  306|  1.38k|    pub fn contains_named_graph(&self, graph_name: &EncodedTerm) -> Result<bool, StorageError> {
  307|  1.38k|        Ok(self.content()?.graphs.contains(graph_name))
  308|  1.38k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB2_13MemoryStorage8snapshot:
   60|  4.99k|    pub fn snapshot(&self) -> MemoryStorageReader {
   61|  4.99k|        MemoryStorageReader {
   62|  4.99k|            content: MemoryStorageReaderContent::Simple(Arc::clone(&self.content)),
   63|  4.99k|            id2str: Arc::clone(&self.id2str),
   64|  4.99k|        }
   65|  4.99k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10gosp_quads:
  330|    968|    fn gosp_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  331|    968|        Self::inner_quads(&self.content().unwrap().gosp, prefix, QuadEncoding::Gosp)
  332|    968|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader33quads_for_subject_predicate_graph:
  216|  1.23k|    pub fn quads_for_subject_predicate_graph(
  217|  1.23k|        &self,
  218|  1.23k|        subject: &EncodedTerm,
  219|  1.23k|        predicate: &EncodedTerm,
  220|  1.23k|        graph_name: &EncodedTerm,
  221|  1.23k|    ) -> MemoryChainedDecodingQuadIterator {
  222|  1.23k|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  223|    182|            self.dspo_quads(encode_term_pair(subject, predicate))
  224|       |        } else {
  225|  1.05k|            self.gspo_quads(encode_term_triple(graph_name, subject, predicate))
  226|       |        })
  227|  1.23k|    }
_RNvXs3_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_33MemoryChainedDecodingQuadIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
  466|  39.5k|    fn next(&mut self) -> Option<Self::Item> {
  467|  39.5k|        if let Some(result) = self.first.next() {
  468|    570|            Some(result)
  469|  38.9k|        } else if let Some(second) = self.second.as_mut() {
  470|  9.01k|            second.next()
  471|       |        } else {
  472|  29.9k|            None
  473|       |        }
  474|  39.5k|    }
_RNvXs4_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_26MemoryDecodingQuadIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
  485|  48.5k|    fn next(&mut self) -> Option<Self::Item> {
  486|  48.5k|        Some(self.encoding.decode(&self.iter.next()?))
  487|  48.5k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader34quads_for_subject_predicate_object:
  145|    145|    pub fn quads_for_subject_predicate_object(
  146|    145|        &self,
  147|    145|        subject: &EncodedTerm,
  148|    145|        predicate: &EncodedTerm,
  149|    145|        object: &EncodedTerm,
  150|    145|    ) -> MemoryChainedDecodingQuadIterator {
  151|    145|        MemoryChainedDecodingQuadIterator::pair(
  152|    145|            self.dspo_quads(encode_term_triple(subject, predicate, object)),
  153|    145|            self.spog_quads(encode_term_triple(subject, predicate, object)),
  154|    145|        )
  155|    145|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader23quads_for_subject_graph:
  204|    563|    pub fn quads_for_subject_graph(
  205|    563|        &self,
  206|    563|        subject: &EncodedTerm,
  207|    563|        graph_name: &EncodedTerm,
  208|    563|    ) -> MemoryChainedDecodingQuadIterator {
  209|    563|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  210|    100|            self.dspo_quads(encode_term(subject))
  211|       |        } else {
  212|    463|            self.gspo_quads(encode_term_pair(graph_name, subject))
  213|       |        })
  214|    563|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader22quads_for_object_graph:
  281|  1.07k|    pub fn quads_for_object_graph(
  282|  1.07k|        &self,
  283|  1.07k|        object: &EncodedTerm,
  284|  1.07k|        graph_name: &EncodedTerm,
  285|  1.07k|    ) -> MemoryChainedDecodingQuadIterator {
  286|  1.07k|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  287|    204|            self.dosp_quads(encode_term(object))
  288|       |        } else {
  289|    869|            self.gosp_quads(encode_term_pair(graph_name, object))
  290|       |        })
  291|  1.07k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB2_13MemoryStorage3new:
   42|      1|    pub fn new() -> Self {
   43|      1|        Self {
   44|      1|            content: Arc::new(RwLock::new(Content {
   45|      1|                spog: BTreeSet::new(),
   46|      1|                posg: BTreeSet::new(),
   47|      1|                ospg: BTreeSet::new(),
   48|      1|                gspo: BTreeSet::new(),
   49|      1|                gpos: BTreeSet::new(),
   50|      1|                gosp: BTreeSet::new(),
   51|      1|                dspo: BTreeSet::new(),
   52|      1|                dpos: BTreeSet::new(),
   53|      1|                dosp: BTreeSet::new(),
   54|      1|                graphs: HashSet::new(),
   55|      1|            })),
   56|      1|            id2str: Arc::new(RwLock::new(HashMap::new())),
   57|      1|        }
   58|      1|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10gpos_quads:
  326|  11.1k|    fn gpos_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  327|  11.1k|        Self::inner_quads(&self.content().unwrap().gpos, prefix, QuadEncoding::Gpos)
  328|  11.1k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader12contains_str:
  374|  13.9k|    pub fn contains_str(&self, key: &StrHash) -> Result<bool, StorageError> {
  375|  13.9k|        Ok(self
  376|  13.9k|            .id2str
  377|  13.9k|            .read()
  378|  13.9k|            .map_err(poison_corruption_error)?
  379|  13.9k|            .contains_key(key))
  380|  13.9k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader27quads_for_subject_predicate:
  134|    240|    pub fn quads_for_subject_predicate(
  135|    240|        &self,
  136|    240|        subject: &EncodedTerm,
  137|    240|        predicate: &EncodedTerm,
  138|    240|    ) -> MemoryChainedDecodingQuadIterator {
  139|    240|        MemoryChainedDecodingQuadIterator::pair(
  140|    240|            self.dspo_quads(encode_term_pair(subject, predicate)),
  141|    240|            self.spog_quads(encode_term_pair(subject, predicate)),
  142|    240|        )
  143|    240|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader15quads_for_graph:
  196|  14.0k|    pub fn quads_for_graph(&self, graph_name: &EncodedTerm) -> MemoryChainedDecodingQuadIterator {
  197|  14.0k|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  198|  1.39k|            self.dspo_quads(Vec::new())
  199|       |        } else {
  200|  12.6k|            self.gspo_quads(encode_term(graph_name))
  201|       |        })
  202|  14.0k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader32quads_for_predicate_object_graph:
  268|  2.14k|    pub fn quads_for_predicate_object_graph(
  269|  2.14k|        &self,
  270|  2.14k|        predicate: &EncodedTerm,
  271|  2.14k|        object: &EncodedTerm,
  272|  2.14k|        graph_name: &EncodedTerm,
  273|  2.14k|    ) -> MemoryChainedDecodingQuadIterator {
  274|  2.14k|        MemoryChainedDecodingQuadIterator::new(if graph_name.is_default_graph() {
  275|    151|            self.dpos_quads(encode_term_pair(predicate, object))
  276|       |        } else {
  277|  1.99k|            self.gpos_quads(encode_term_triple(graph_name, predicate, object))
  278|       |        })
  279|  2.14k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10ospg_quads:
  318|    292|    fn ospg_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  319|    292|        Self::inner_quads(&self.content().unwrap().ospg, prefix, QuadEncoding::Ospg)
  320|    292|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter10insert_str:
  619|  8.33k|    fn insert_str(&mut self, key: &StrHash, value: &str) -> Result<(), StorageError> {
  620|  8.33k|        if self
  621|  8.33k|            .id2str
  622|  8.33k|            .write()
  623|  8.33k|            .map_err(poison_corruption_error)?
  624|  8.33k|            .entry(*key)
  625|  8.33k|            .or_insert_with(|| value.into())
  626|  8.33k|            == value
  627|       |        {
  628|  8.33k|            Ok(())
  629|       |        } else {
  630|      0|            Err(StorageError::Other("Hash conflict for two strings".into()))
  631|       |        }
  632|  8.33k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter16clear_all_graphs:
  711|    304|    pub fn clear_all_graphs(&mut self) -> Result<(), StorageError> {
  712|    304|        let mut content = self.content.try_borrow_mut().map_err(borrow_mut_error)?;
  713|    304|        content.dspo.clear();
  714|    304|        content.dpos.clear();
  715|    304|        content.dosp.clear();
  716|    304|        content.gspo.clear();
  717|    304|        content.gpos.clear();
  718|    304|        content.gosp.clear();
  719|    304|        content.spog.clear();
  720|    304|        content.posg.clear();
  721|    304|        content.ospg.clear();
  722|    304|        Ok(())
  723|    304|    }
_RNvXs1_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_10ContentRefNtNtNtCs9nhK3FOW46N_4core3ops5deref5Deref5deref:
  434|  44.6k|    fn deref(&self) -> &Content {
  435|  44.6k|        match self {
  436|  9.99k|            ContentRef::Simple(r) => r,
  437|  34.6k|            ContentRef::Transaction { element, .. } => element,
  438|       |        }
  439|  44.6k|    }
_RNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageWriter18remove_named_graph:
  725|    614|    pub fn remove_named_graph(
  726|    614|        &mut self,
  727|    614|        graph_name: NamedOrBlankNodeRef<'_>,
  728|    614|    ) -> Result<bool, StorageError> {
  729|    614|        self.remove_encoded_named_graph(&graph_name.into())
  730|    614|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader11inner_quads:
  346|  43.2k|    fn inner_quads(
  347|  43.2k|        set: &BTreeSet<Vec<u8>>,
  348|  43.2k|        prefix: Vec<u8>,
  349|  43.2k|        encoding: QuadEncoding,
  350|  43.2k|    ) -> MemoryDecodingQuadIterator {
  351|  43.2k|        let start = prefix.clone();
  352|  43.2k|
  353|  43.2k|        // We compute the end
  354|  43.2k|        let mut end = prefix;
  355|  43.2k|        let mut i = 1;
  356|  43.2k|        while i <= end.len() && end[end.len() - i] == u8::MAX {
  357|      0|            i += 1;
  358|      0|        }
  359|       |
  360|  43.2k|        let range = if i > end.len() {
  361|       |            // No end
  362|  12.3k|            set.range(start..)
  363|       |        } else {
  364|  30.8k|            let k = end.len() - i;
  365|  30.8k|            end[k] += 1;
  366|  30.8k|            set.range(start..end)
  367|       |        };
  368|  43.2k|        MemoryDecodingQuadIterator {
  369|  43.2k|            iter: range.cloned().collect::<Vec<_>>().into_iter(),
  370|  43.2k|            encoding,
  371|  43.2k|        }
  372|  43.2k|    }
_RNvXs0_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_19MemoryStorageReaderNtNtB7_15numeric_encoder9StrLookup7get_str:
  413|  8.94k|    fn get_str(&self, key: &StrHash) -> Result<Option<String>, StorageError> {
  414|  8.94k|        Ok(self
  415|  8.94k|            .id2str
  416|  8.94k|            .read()
  417|  8.94k|            .map_err(poison_corruption_error)?
  418|  8.94k|            .get(key)
  419|  8.94k|            .cloned())
  420|  8.94k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader10gspo_quads:
  322|  20.1k|    fn gspo_quads(&self, prefix: Vec<u8>) -> MemoryDecodingQuadIterator {
  323|  20.1k|        Self::inner_quads(&self.content().unwrap().gspo, prefix, QuadEncoding::Gspo)
  324|  20.1k|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader17quads_for_subject:
  127|     47|    pub fn quads_for_subject(&self, subject: &EncodedTerm) -> MemoryChainedDecodingQuadIterator {
  128|     47|        MemoryChainedDecodingQuadIterator::pair(
  129|     47|            self.dspo_quads(encode_term(subject)),
  130|     47|            self.spog_quads(encode_term(subject)),
  131|     47|        )
  132|     47|    }
_RNvMs_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB4_19MemoryStorageReader16quads_for_object:
  189|    208|    pub fn quads_for_object(&self, object: &EncodedTerm) -> MemoryChainedDecodingQuadIterator {
  190|    208|        MemoryChainedDecodingQuadIterator::pair(
  191|    208|            self.dosp_quads(encode_term(object)),
  192|    208|            self.ospg_quads(encode_term(object)),
  193|    208|        )
  194|    208|    }
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB5_33MemoryChainedDecodingQuadIterator4pair:
  455|  6.64k|    fn pair(first: MemoryDecodingQuadIterator, second: MemoryDecodingQuadIterator) -> Self {
  456|  6.64k|        Self {
  457|  6.64k|            first,
  458|  6.64k|            second: Some(second),
  459|  6.64k|        }
  460|  6.64k|    }
_RNCNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB7_19MemoryStorageWriter11insert_term0Bb_:
  616|  8.33k|        insert_term(term, encoded, &mut |key, value| self.insert_str(key, value))
_RNCNvMs6_NtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB7_19MemoryStorageWriter10insert_str0Bb_:
  625|  2.18k|            .or_insert_with(|| value.into())
_RINvMNtNtCs2ek33vt1YA5_8oxigraph7storage6memoryNtB3_13MemoryStorage11transactionuNtNtB5_5error12StorageErrorNCINvMB5_NtB5_7Storage11transactionuB1h_NCINvMNtB7_5storeNtB2s_5Store11transactionuB1h_NCNvB2r_5clear0E0E0EB7_:
   67|  4.99k|    pub fn transaction<'a, 'b: 'a, T, E: Error + 'static + From<StorageError>>(
   68|  4.99k|        &'b self,
   69|  4.99k|        f: impl Fn(MemoryStorageWriter<'a>) -> Result<T, E>,
   70|  4.99k|    ) -> Result<T, E> {
   71|  4.99k|        f(MemoryStorageWriter {
   72|  4.99k|            content: Rc::new(RefCell::new(
   73|  4.99k|                self.content.write().map_err(poison_corruption_error)?,
   74|       |            )),
   75|  4.99k|            id2str: Arc::clone(&self.id2str),
   76|       |        })
   77|  4.99k|    }

_RINvMNtCs2ek33vt1YA5_8oxigraph7storageNtB3_7Storage11transactionuNtNtNtB5_6sparql5error15EvaluationErrorNCINvMNtB5_5storeNtB1K_5Store10update_optNtNtCs9nhK3FOW46N_4core7convert10InfallibleNtNtB15_7algebra6UpdateNtB15_12QueryOptionsE0ECslmM25dSh1d8_18sparql_update_eval:
  107|  4.99k|    pub fn transaction<'a, 'b: 'a, T, E: Error + 'static + From<StorageError>>(
  108|  4.99k|        &'b self,
  109|  4.99k|        f: impl Fn(StorageWriter<'a>) -> Result<T, E>,
  110|  4.99k|    ) -> Result<T, E> {
  111|  4.99k|        match &self.kind {
  112|  4.99k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  113|  4.99k|            StorageKind::RocksDb(storage) => storage.transaction(|transaction| {
  114|  4.99k|                f(StorageWriter {
  115|  4.99k|                    kind: StorageWriterKind::RocksDb(transaction),
  116|  4.99k|                })
  117|  4.99k|            }),
  118|  4.99k|            StorageKind::Memory(storage) => storage.transaction(|transaction| {
  119|       |                f(StorageWriter {
  120|       |                    kind: StorageWriterKind::Memory(transaction),
  121|       |                })
  122|  4.99k|            }),
  123|  4.99k|        }
  124|  4.99k|    }
_RNCINvMNtCs2ek33vt1YA5_8oxigraph7storageNtB5_7Storage11transactionuNtNtNtB7_6sparql5error15EvaluationErrorNCINvMNtB7_5storeNtB1M_5Store10update_optNtNtCs9nhK3FOW46N_4core7convert10InfallibleNtNtB17_7algebra6UpdateNtB17_12QueryOptionsE0E0CslmM25dSh1d8_18sparql_update_eval:
  118|  4.99k|            StorageKind::Memory(storage) => storage.transaction(|transaction| {
  119|  4.99k|                f(StorageWriter {
  120|  4.99k|                    kind: StorageWriterKind::Memory(transaction),
  121|  4.99k|                })
  122|  4.99k|            }),
_RNCINvMNtCs2ek33vt1YA5_8oxigraph7storageNtB5_7Storage11transactionuNtNtB5_5error12StorageErrorNCINvMNtB7_5storeNtB1A_5Store11transactionuB13_NCNvB1z_5clear0E0E0B7_:
  118|  4.99k|            StorageKind::Memory(storage) => storage.transaction(|transaction| {
  119|  4.99k|                f(StorageWriter {
  120|  4.99k|                    kind: StorageWriterKind::Memory(transaction),
  121|  4.99k|                })
  122|  4.99k|            }),
_RINvMNtCs2ek33vt1YA5_8oxigraph7storageNtB3_7Storage11transactionuNtNtB3_5error12StorageErrorNCINvMNtB5_5storeNtB1y_5Store11transactionuB11_NCNvB1x_5clear0E0EB5_:
  107|  4.99k|    pub fn transaction<'a, 'b: 'a, T, E: Error + 'static + From<StorageError>>(
  108|  4.99k|        &'b self,
  109|  4.99k|        f: impl Fn(StorageWriter<'a>) -> Result<T, E>,
  110|  4.99k|    ) -> Result<T, E> {
  111|  4.99k|        match &self.kind {
  112|  4.99k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  113|  4.99k|            StorageKind::RocksDb(storage) => storage.transaction(|transaction| {
  114|  4.99k|                f(StorageWriter {
  115|  4.99k|                    kind: StorageWriterKind::RocksDb(transaction),
  116|  4.99k|                })
  117|  4.99k|            }),
  118|  4.99k|            StorageKind::Memory(storage) => storage.transaction(|transaction| {
  119|       |                f(StorageWriter {
  120|       |                    kind: StorageWriterKind::Memory(transaction),
  121|       |                })
  122|  4.99k|            }),
  123|  4.99k|        }
  124|  4.99k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader25quads_for_predicate_graph:
  495|  10.0k|    fn quads_for_predicate_graph(
  496|  10.0k|        &self,
  497|  10.0k|        predicate: &EncodedTerm,
  498|  10.0k|        graph_name: &EncodedTerm,
  499|  10.0k|    ) -> DecodingQuadIterator {
  500|  10.0k|        match &self.kind {
  501|  10.0k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  502|  10.0k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  503|  10.0k|                kind: DecodingQuadIteratorKind::RocksDb(
  504|  10.0k|                    reader.quads_for_predicate_graph(predicate, graph_name),
  505|  10.0k|                ),
  506|  10.0k|            },
  507|  10.0k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  508|  10.0k|                kind: DecodingQuadIteratorKind::Memory(
  509|  10.0k|                    reader.quads_for_predicate_graph(predicate, graph_name),
  510|  10.0k|                ),
  511|  10.0k|            },
  512|  10.0k|        }
  513|  10.0k|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph7storageNtB2_7Storage8snapshot:
   95|  4.99k|    pub fn snapshot(&self) -> StorageReader {
   96|  4.99k|        match &self.kind {
   97|  4.99k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
   98|  4.99k|            StorageKind::RocksDb(storage) => StorageReader {
   99|  4.99k|                kind: StorageReaderKind::RocksDb(storage.snapshot()),
  100|  4.99k|            },
  101|  4.99k|            StorageKind::Memory(storage) => StorageReader {
  102|  4.99k|                kind: StorageReaderKind::Memory(storage.snapshot()),
  103|  4.99k|            },
  104|  4.99k|        }
  105|  4.99k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader34quads_for_subject_predicate_object:
  310|    145|    fn quads_for_subject_predicate_object(
  311|    145|        &self,
  312|    145|        subject: &EncodedTerm,
  313|    145|        predicate: &EncodedTerm,
  314|    145|        object: &EncodedTerm,
  315|    145|    ) -> DecodingQuadIterator {
  316|    145|        match &self.kind {
  317|    145|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  318|    145|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  319|    145|                kind: DecodingQuadIteratorKind::RocksDb(
  320|    145|                    reader.quads_for_subject_predicate_object(subject, predicate, object),
  321|    145|                ),
  322|    145|            },
  323|    145|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  324|    145|                kind: DecodingQuadIteratorKind::Memory(
  325|    145|                    reader.quads_for_subject_predicate_object(subject, predicate, object),
  326|    145|                ),
  327|    145|            },
  328|    145|        }
  329|    145|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader23quads_for_subject_graph:
  407|    563|    fn quads_for_subject_graph(
  408|    563|        &self,
  409|    563|        subject: &EncodedTerm,
  410|    563|        graph_name: &EncodedTerm,
  411|    563|    ) -> DecodingQuadIterator {
  412|    563|        match &self.kind {
  413|    563|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  414|    563|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  415|    563|                kind: DecodingQuadIteratorKind::RocksDb(
  416|    563|                    reader.quads_for_subject_graph(subject, graph_name),
  417|    563|                ),
  418|    563|            },
  419|    563|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  420|    563|                kind: DecodingQuadIteratorKind::Memory(
  421|    563|                    reader.quads_for_subject_graph(subject, graph_name),
  422|    563|                ),
  423|    563|            },
  424|    563|        }
  425|    563|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter11clear_graph:
  698|    778|    pub fn clear_graph(&mut self, graph_name: GraphNameRef<'_>) -> Result<(), StorageError> {
  699|    778|        match &mut self.kind {
  700|    778|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  701|    778|            StorageWriterKind::RocksDb(writer) => writer.clear_graph(graph_name),
  702|    778|            StorageWriterKind::Memory(writer) => writer.clear_graph(graph_name),
  703|    778|        }
  704|    778|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter18insert_named_graph:
  679|    446|    pub fn insert_named_graph(
  680|    446|        &mut self,
  681|    446|        graph_name: NamedOrBlankNodeRef<'_>,
  682|    446|    ) -> Result<bool, StorageError> {
  683|    446|        match &mut self.kind {
  684|    446|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  685|    446|            StorageWriterKind::RocksDb(writer) => writer.insert_named_graph(graph_name),
  686|    446|            StorageWriterKind::Memory(writer) => writer.insert_named_graph(graph_name),
  687|    446|        }
  688|    446|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader33quads_for_subject_predicate_graph:
  427|  1.23k|    fn quads_for_subject_predicate_graph(
  428|  1.23k|        &self,
  429|  1.23k|        subject: &EncodedTerm,
  430|  1.23k|        predicate: &EncodedTerm,
  431|  1.23k|        graph_name: &EncodedTerm,
  432|  1.23k|    ) -> DecodingQuadIterator {
  433|  1.23k|        match &self.kind {
  434|  1.23k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  435|  1.23k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  436|  1.23k|                kind: DecodingQuadIteratorKind::RocksDb(
  437|  1.23k|                    reader.quads_for_subject_predicate_graph(subject, predicate, graph_name),
  438|  1.23k|                ),
  439|  1.23k|            },
  440|  1.23k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  441|  1.23k|                kind: DecodingQuadIteratorKind::Memory(
  442|  1.23k|                    reader.quads_for_subject_predicate_graph(subject, predicate, graph_name),
  443|  1.23k|                ),
  444|  1.23k|            },
  445|  1.23k|        }
  446|  1.23k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader5quads:
  266|  5.48k|    pub fn quads(&self) -> DecodingQuadIterator {
  267|  5.48k|        match &self.kind {
  268|  5.48k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  269|  5.48k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  270|  5.48k|                kind: DecodingQuadIteratorKind::RocksDb(reader.quads()),
  271|  5.48k|            },
  272|  5.48k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  273|  5.48k|                kind: DecodingQuadIteratorKind::Memory(reader.quads()),
  274|  5.48k|            },
  275|  5.48k|        }
  276|  5.48k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader26quads_for_predicate_object:
  363|     98|    fn quads_for_predicate_object(
  364|     98|        &self,
  365|     98|        predicate: &EncodedTerm,
  366|     98|        object: &EncodedTerm,
  367|     98|    ) -> DecodingQuadIterator {
  368|     98|        match &self.kind {
  369|     98|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  370|     98|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  371|     98|                kind: DecodingQuadIteratorKind::RocksDb(
  372|     98|                    reader.quads_for_predicate_object(predicate, object),
  373|     98|                ),
  374|     98|            },
  375|     98|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  376|     98|                kind: DecodingQuadIteratorKind::Memory(
  377|     98|                    reader.quads_for_predicate_object(predicate, object),
  378|     98|                ),
  379|     98|            },
  380|     98|        }
  381|     98|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader30quads_for_subject_object_graph:
  474|    151|    fn quads_for_subject_object_graph(
  475|    151|        &self,
  476|    151|        subject: &EncodedTerm,
  477|    151|        object: &EncodedTerm,
  478|    151|        graph_name: &EncodedTerm,
  479|    151|    ) -> DecodingQuadIterator {
  480|    151|        match &self.kind {
  481|    151|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  482|    151|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  483|    151|                kind: DecodingQuadIteratorKind::RocksDb(
  484|    151|                    reader.quads_for_subject_object_graph(subject, object, graph_name),
  485|    151|                ),
  486|    151|            },
  487|    151|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  488|    151|                kind: DecodingQuadIteratorKind::Memory(
  489|    151|                    reader.quads_for_subject_object_graph(subject, object, graph_name),
  490|    151|                ),
  491|    151|            },
  492|    151|        }
  493|    151|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph7storageNtB2_7Storage13new_in_memory:
   55|      1|    pub fn new_in_memory() -> Result<Self, StorageError> {
   56|      1|        Ok(Self {
   57|      1|            kind: StorageKind::Memory(MemoryStorage::new()),
   58|      1|        })
   59|      1|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader27quads_for_subject_predicate:
  290|    240|    fn quads_for_subject_predicate(
  291|    240|        &self,
  292|    240|        subject: &EncodedTerm,
  293|    240|        predicate: &EncodedTerm,
  294|    240|    ) -> DecodingQuadIterator {
  295|    240|        match &self.kind {
  296|    240|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  297|    240|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  298|    240|                kind: DecodingQuadIteratorKind::RocksDb(
  299|    240|                    reader.quads_for_subject_predicate(subject, predicate),
  300|    240|                ),
  301|    240|            },
  302|    240|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  303|    240|                kind: DecodingQuadIteratorKind::Memory(
  304|    240|                    reader.quads_for_subject_predicate(subject, predicate),
  305|    240|                ),
  306|    240|            },
  307|    240|        }
  308|    240|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader15quads_for_graph:
  395|  13.9k|    fn quads_for_graph(&self, graph_name: &EncodedTerm) -> DecodingQuadIterator {
  396|  13.9k|        match &self.kind {
  397|  13.9k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  398|  13.9k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  399|  13.9k|                kind: DecodingQuadIteratorKind::RocksDb(reader.quads_for_graph(graph_name)),
  400|  13.9k|            },
  401|  13.9k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  402|  13.9k|                kind: DecodingQuadIteratorKind::Memory(reader.quads_for_graph(graph_name)),
  403|  13.9k|            },
  404|  13.9k|        }
  405|  13.9k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader24quads_for_subject_object:
  331|     84|    fn quads_for_subject_object(
  332|     84|        &self,
  333|     84|        subject: &EncodedTerm,
  334|     84|        object: &EncodedTerm,
  335|     84|    ) -> DecodingQuadIterator {
  336|     84|        match &self.kind {
  337|     84|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  338|     84|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  339|     84|                kind: DecodingQuadIteratorKind::RocksDb(
  340|     84|                    reader.quads_for_subject_object(subject, object),
  341|     84|                ),
  342|     84|            },
  343|     84|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  344|     84|                kind: DecodingQuadIteratorKind::Memory(
  345|     84|                    reader.quads_for_subject_object(subject, object),
  346|     84|                ),
  347|     84|            },
  348|     84|        }
  349|     84|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader32quads_for_predicate_object_graph:
  515|  2.14k|    fn quads_for_predicate_object_graph(
  516|  2.14k|        &self,
  517|  2.14k|        predicate: &EncodedTerm,
  518|  2.14k|        object: &EncodedTerm,
  519|  2.14k|        graph_name: &EncodedTerm,
  520|  2.14k|    ) -> DecodingQuadIterator {
  521|  2.14k|        match &self.kind {
  522|  2.14k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  523|  2.14k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  524|  2.14k|                kind: DecodingQuadIteratorKind::RocksDb(
  525|  2.14k|                    reader.quads_for_predicate_object_graph(predicate, object, graph_name),
  526|  2.14k|                ),
  527|  2.14k|            },
  528|  2.14k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  529|  2.14k|                kind: DecodingQuadIteratorKind::Memory(
  530|  2.14k|                    reader.quads_for_predicate_object_graph(predicate, object, graph_name),
  531|  2.14k|                ),
  532|  2.14k|            },
  533|  2.14k|        }
  534|  2.14k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader12contains_str:
  576|  13.9k|    pub fn contains_str(&self, key: &StrHash) -> Result<bool, StorageError> {
  577|  13.9k|        match &self.kind {
  578|  13.9k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  579|  13.9k|            StorageReaderKind::RocksDb(reader) => reader.contains_str(key),
  580|  13.9k|            StorageReaderKind::Memory(reader) => reader.contains_str(key),
  581|  13.9k|        }
  582|  13.9k|    }
_RNvXs0_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_20DecodingQuadIteratorNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
  607|  39.3k|    fn next(&mut self) -> Option<Self::Item> {
  608|  39.3k|        match &mut self.kind {
  609|  39.3k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  610|  39.3k|            DecodingQuadIteratorKind::RocksDb(iter) => iter.next(),
  611|  39.3k|            DecodingQuadIteratorKind::Memory(iter) => iter.next(),
  612|  39.3k|        }
  613|  39.3k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader22quads_for_object_graph:
  536|  1.07k|    fn quads_for_object_graph(
  537|  1.07k|        &self,
  538|  1.07k|        object: &EncodedTerm,
  539|  1.07k|        graph_name: &EncodedTerm,
  540|  1.07k|    ) -> DecodingQuadIterator {
  541|  1.07k|        match &self.kind {
  542|  1.07k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  543|  1.07k|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  544|  1.07k|                kind: DecodingQuadIteratorKind::RocksDb(
  545|  1.07k|                    reader.quads_for_object_graph(object, graph_name),
  546|  1.07k|                ),
  547|  1.07k|            },
  548|  1.07k|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  549|  1.07k|                kind: DecodingQuadIteratorKind::Memory(
  550|  1.07k|                    reader.quads_for_object_graph(object, graph_name),
  551|  1.07k|                ),
  552|  1.07k|            },
  553|  1.07k|        }
  554|  1.07k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader17quads_for_pattern:
  203|  36.4k|    pub fn quads_for_pattern(
  204|  36.4k|        &self,
  205|  36.4k|        subject: Option<&EncodedTerm>,
  206|  36.4k|        predicate: Option<&EncodedTerm>,
  207|  36.4k|        object: Option<&EncodedTerm>,
  208|  36.4k|        graph_name: Option<&EncodedTerm>,
  209|  36.4k|    ) -> DecodingQuadIterator {
  210|  36.4k|        match subject {
  211|  3.12k|            Some(subject) => match predicate {
  212|  2.27k|                Some(predicate) => match object {
  213|    801|                    Some(object) => match graph_name {
  214|    656|                        Some(graph_name) => self.quads_for_subject_predicate_object_graph(
  215|    656|                            subject, predicate, object, graph_name,
  216|    656|                        ),
  217|    145|                        None => self.quads_for_subject_predicate_object(subject, predicate, object),
  218|       |                    },
  219|  1.47k|                    None => match graph_name {
  220|  1.23k|                        Some(graph_name) => {
  221|  1.23k|                            self.quads_for_subject_predicate_graph(subject, predicate, graph_name)
  222|       |                        }
  223|    240|                        None => self.quads_for_subject_predicate(subject, predicate),
  224|       |                    },
  225|       |                },
  226|    845|                None => match object {
  227|    235|                    Some(object) => match graph_name {
  228|    151|                        Some(graph_name) => {
  229|    151|                            self.quads_for_subject_object_graph(subject, object, graph_name)
  230|       |                        }
  231|     84|                        None => self.quads_for_subject_object(subject, object),
  232|       |                    },
  233|    610|                    None => match graph_name {
  234|    563|                        Some(graph_name) => self.quads_for_subject_graph(subject, graph_name),
  235|     47|                        None => self.quads_for_subject(subject),
  236|       |                    },
  237|       |                },
  238|       |            },
  239|  33.3k|            None => match predicate {
  240|  12.6k|                Some(predicate) => match object {
  241|  2.24k|                    Some(object) => match graph_name {
  242|  2.14k|                        Some(graph_name) => {
  243|  2.14k|                            self.quads_for_predicate_object_graph(predicate, object, graph_name)
  244|       |                        }
  245|     98|                        None => self.quads_for_predicate_object(predicate, object),
  246|       |                    },
  247|  10.4k|                    None => match graph_name {
  248|  10.0k|                        Some(graph_name) => self.quads_for_predicate_graph(predicate, graph_name),
  249|    340|                        None => self.quads_for_predicate(predicate),
  250|       |                    },
  251|       |                },
  252|  20.6k|                None => match object {
  253|  1.28k|                    Some(object) => match graph_name {
  254|  1.07k|                        Some(graph_name) => self.quads_for_object_graph(object, graph_name),
  255|    208|                        None => self.quads_for_object(object),
  256|       |                    },
  257|  19.4k|                    None => match graph_name {
  258|  13.9k|                        Some(graph_name) => self.quads_for_graph(graph_name),
  259|  5.48k|                        None => self.quads(),
  260|       |                    },
  261|       |                },
  262|       |            },
  263|       |        }
  264|  36.4k|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader19quads_for_predicate:
  351|    340|    fn quads_for_predicate(&self, predicate: &EncodedTerm) -> DecodingQuadIterator {
  352|    340|        match &self.kind {
  353|    340|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  354|    340|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  355|    340|                kind: DecodingQuadIteratorKind::RocksDb(reader.quads_for_predicate(predicate)),
  356|    340|            },
  357|    340|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  358|    340|                kind: DecodingQuadIteratorKind::Memory(reader.quads_for_predicate(predicate)),
  359|    340|            },
  360|    340|        }
  361|    340|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader40quads_for_subject_predicate_object_graph:
  448|    656|    fn quads_for_subject_predicate_object_graph(
  449|    656|        &self,
  450|    656|        subject: &EncodedTerm,
  451|    656|        predicate: &EncodedTerm,
  452|    656|        object: &EncodedTerm,
  453|    656|        graph_name: &EncodedTerm,
  454|    656|    ) -> DecodingQuadIterator {
  455|    656|        match &self.kind {
  456|    656|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  457|    656|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  458|    656|                kind: DecodingQuadIteratorKind::RocksDb(
  459|    656|                    reader.quads_for_subject_predicate_object_graph(
  460|    656|                        subject, predicate, object, graph_name,
  461|    656|                    ),
  462|    656|                ),
  463|    656|            },
  464|    656|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  465|    656|                kind: DecodingQuadIteratorKind::Memory(
  466|    656|                    reader.quads_for_subject_predicate_object_graph(
  467|    656|                        subject, predicate, object, graph_name,
  468|    656|                    ),
  469|    656|                ),
  470|    656|            },
  471|    656|        }
  472|    656|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader20contains_named_graph:
  568|  1.38k|    pub fn contains_named_graph(&self, graph_name: &EncodedTerm) -> Result<bool, StorageError> {
  569|  1.38k|        match &self.kind {
  570|  1.38k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  571|  1.38k|            StorageReaderKind::RocksDb(reader) => reader.contains_named_graph(graph_name),
  572|  1.38k|            StorageReaderKind::Memory(reader) => reader.contains_named_graph(graph_name),
  573|  1.38k|        }
  574|  1.38k|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph7storageNtB2_7Storage3new:
   50|      1|    pub fn new() -> Result<Self, StorageError> {
   51|      1|        Self::new_in_memory()
   52|      1|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader16quads_for_object:
  383|    208|    fn quads_for_object(&self, object: &EncodedTerm) -> DecodingQuadIterator {
  384|    208|        match &self.kind {
  385|    208|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  386|    208|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  387|    208|                kind: DecodingQuadIteratorKind::RocksDb(reader.quads_for_object(object)),
  388|    208|            },
  389|    208|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  390|    208|                kind: DecodingQuadIteratorKind::Memory(reader.quads_for_object(object)),
  391|    208|            },
  392|    208|        }
  393|    208|    }
_RNvMs_NtCs2ek33vt1YA5_8oxigraph7storageNtB4_13StorageReader17quads_for_subject:
  278|     47|    fn quads_for_subject(&self, subject: &EncodedTerm) -> DecodingQuadIterator {
  279|     47|        match &self.kind {
  280|     47|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  281|     47|            StorageReaderKind::RocksDb(reader) => DecodingQuadIterator {
  282|     47|                kind: DecodingQuadIteratorKind::RocksDb(reader.quads_for_subject(subject)),
  283|     47|            },
  284|     47|            StorageReaderKind::Memory(reader) => DecodingQuadIterator {
  285|     47|                kind: DecodingQuadIteratorKind::Memory(reader.quads_for_subject(subject)),
  286|     47|            },
  287|     47|        }
  288|     47|    }
_RNvXs2_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageReaderNtNtB5_15numeric_encoder9StrLookup7get_str:
  639|  8.94k|    fn get_str(&self, key: &StrHash) -> Result<Option<String>, StorageError> {
  640|  8.94k|        match &self.kind {
  641|  8.94k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  642|  8.94k|            StorageReaderKind::RocksDb(reader) => reader.get_str(key),
  643|  8.94k|            StorageReaderKind::Memory(reader) => reader.get_str(key),
  644|  8.94k|        }
  645|  8.94k|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter6reader:
  659|  6.27k|    pub fn reader(&self) -> StorageReader {
  660|  6.27k|        match &self.kind {
  661|  6.27k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  662|  6.27k|            StorageWriterKind::RocksDb(writer) => StorageReader {
  663|  6.27k|                kind: StorageReaderKind::RocksDb(writer.reader()),
  664|  6.27k|            },
  665|  6.27k|            StorageWriterKind::Memory(writer) => StorageReader {
  666|  6.27k|                kind: StorageReaderKind::Memory(writer.reader()),
  667|  6.27k|            },
  668|  6.27k|        }
  669|  6.27k|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter6remove:
  690|  3.23k|    pub fn remove(&mut self, quad: QuadRef<'_>) -> Result<bool, StorageError> {
  691|  3.23k|        match &mut self.kind {
  692|  3.23k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  693|  3.23k|            StorageWriterKind::RocksDb(writer) => writer.remove(quad),
  694|  3.23k|            StorageWriterKind::Memory(writer) => writer.remove(quad),
  695|  3.23k|        }
  696|  3.23k|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter22clear_all_named_graphs:
  706|     76|    pub fn clear_all_named_graphs(&mut self) -> Result<(), StorageError> {
  707|     76|        match &mut self.kind {
  708|     76|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  709|     76|            StorageWriterKind::RocksDb(writer) => writer.clear_all_named_graphs(),
  710|     76|            StorageWriterKind::Memory(writer) => writer.clear_all_named_graphs(),
  711|     76|        }
  712|     76|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter16clear_all_graphs:
  714|    304|    pub fn clear_all_graphs(&mut self) -> Result<(), StorageError> {
  715|    304|        match &mut self.kind {
  716|    304|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  717|    304|            StorageWriterKind::RocksDb(writer) => writer.clear_all_graphs(),
  718|    304|            StorageWriterKind::Memory(writer) => writer.clear_all_graphs(),
  719|    304|        }
  720|    304|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter6insert:
  671|  5.10k|    pub fn insert(&mut self, quad: QuadRef<'_>) -> Result<bool, StorageError> {
  672|  5.10k|        match &mut self.kind {
  673|  5.10k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  674|  5.10k|            StorageWriterKind::RocksDb(writer) => writer.insert(quad),
  675|  5.10k|            StorageWriterKind::Memory(writer) => writer.insert(quad),
  676|  5.10k|        }
  677|  5.10k|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter23remove_all_named_graphs:
  733|     16|    pub fn remove_all_named_graphs(&mut self) -> Result<(), StorageError> {
  734|     16|        match &mut self.kind {
  735|     16|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  736|     16|            StorageWriterKind::RocksDb(writer) => writer.remove_all_named_graphs(),
  737|     16|            StorageWriterKind::Memory(writer) => writer.remove_all_named_graphs(),
  738|     16|        }
  739|     16|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter5clear:
  741|  5.16k|    pub fn clear(&mut self) -> Result<(), StorageError> {
  742|  5.16k|        match &mut self.kind {
  743|  5.16k|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  744|  5.16k|            StorageWriterKind::RocksDb(writer) => writer.clear(),
  745|  5.16k|            StorageWriterKind::Memory(writer) => writer.clear(),
  746|  5.16k|        }
  747|  5.16k|    }
_RNvMs3_NtCs2ek33vt1YA5_8oxigraph7storageNtB5_13StorageWriter18remove_named_graph:
  722|    614|    pub fn remove_named_graph(
  723|    614|        &mut self,
  724|    614|        graph_name: NamedOrBlankNodeRef<'_>,
  725|    614|    ) -> Result<bool, StorageError> {
  726|    614|        match &mut self.kind {
  727|    614|            #[cfg(all(not(target_family = "wasm"), feature = "rocksdb"))]
  728|    614|            StorageWriterKind::RocksDb(writer) => writer.remove_named_graph(graph_name),
  729|    614|            StorageWriterKind::Memory(writer) => writer.remove_named_graph(graph_name),
  730|    614|        }
  731|    614|    }

_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder11insert_termNCINvMNtNtB6_6sparql7datasetNtB1b_11DatasetView11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE0EB6_:
  706|  74.4k|pub fn insert_term<F: FnMut(&StrHash, &str) -> Result<(), StorageError>>(
  707|  74.4k|    term: TermRef<'_>,
  708|  74.4k|    encoded: &EncodedTerm,
  709|  74.4k|    insert_str: &mut F,
  710|  74.4k|) -> Result<(), StorageError> {
  711|  74.4k|    match term {
  712|  74.4k|        TermRef::NamedNode(node) => {
  713|  74.4k|            if let EncodedTerm::NamedNode { iri_id } = encoded {
  714|  74.4k|                insert_str(iri_id, node.as_str())
  715|       |            } else {
  716|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  717|       |            }
  718|       |        }
  719|      0|        TermRef::BlankNode(node) => match encoded {
  720|      0|            EncodedTerm::BigBlankNode { id_id } => insert_str(id_id, node.as_str()),
  721|      0|            EncodedTerm::SmallBlankNode(..) | EncodedTerm::NumericalBlankNode { .. } => Ok(()),
  722|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  723|       |        },
  724|      0|        TermRef::Literal(literal) => match encoded {
  725|      0|            EncodedTerm::BigStringLiteral { value_id }
  726|      0|            | EncodedTerm::BigSmallLangStringLiteral { value_id, .. } => {
  727|      0|                insert_str(value_id, literal.value())
  728|       |            }
  729|      0|            EncodedTerm::SmallBigLangStringLiteral { language_id, .. } => {
  730|      0|                if let Some(language) = literal.language() {
  731|      0|                    insert_str(language_id, language)
  732|       |                } else {
  733|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  734|       |                }
  735|       |            }
  736|       |            EncodedTerm::BigBigLangStringLiteral {
  737|      0|                value_id,
  738|      0|                language_id,
  739|      0|            } => {
  740|      0|                insert_str(value_id, literal.value())?;
  741|      0|                if let Some(language) = literal.language() {
  742|      0|                    insert_str(language_id, language)
  743|       |                } else {
  744|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  745|       |                }
  746|       |            }
  747|      0|            EncodedTerm::SmallTypedLiteral { datatype_id, .. } => {
  748|      0|                insert_str(datatype_id, literal.datatype().as_str())
  749|       |            }
  750|       |            EncodedTerm::BigTypedLiteral {
  751|      0|                value_id,
  752|      0|                datatype_id,
  753|      0|            } => {
  754|      0|                insert_str(value_id, literal.value())?;
  755|      0|                insert_str(datatype_id, literal.datatype().as_str())
  756|       |            }
  757|       |            EncodedTerm::SmallStringLiteral(..)
  758|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
  759|       |            | EncodedTerm::BooleanLiteral(..)
  760|       |            | EncodedTerm::FloatLiteral(..)
  761|       |            | EncodedTerm::DoubleLiteral(..)
  762|       |            | EncodedTerm::IntegerLiteral(..)
  763|       |            | EncodedTerm::DecimalLiteral(..)
  764|       |            | EncodedTerm::DateTimeLiteral(..)
  765|       |            | EncodedTerm::TimeLiteral(..)
  766|       |            | EncodedTerm::DateLiteral(..)
  767|       |            | EncodedTerm::GYearMonthLiteral(..)
  768|       |            | EncodedTerm::GYearLiteral(..)
  769|       |            | EncodedTerm::GMonthDayLiteral(..)
  770|       |            | EncodedTerm::GDayLiteral(..)
  771|       |            | EncodedTerm::GMonthLiteral(..)
  772|       |            | EncodedTerm::DurationLiteral(..)
  773|       |            | EncodedTerm::YearMonthDurationLiteral(..)
  774|      0|            | EncodedTerm::DayTimeDurationLiteral(..) => Ok(()),
  775|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  776|       |        },
  777|      0|        TermRef::Triple(triple) => {
  778|      0|            if let EncodedTerm::Triple(encoded) = encoded {
  779|      0|                insert_term(triple.subject.as_ref().into(), &encoded.subject, insert_str)?;
  780|      0|                insert_term(
  781|      0|                    triple.predicate.as_ref().into(),
  782|      0|                    &encoded.predicate,
  783|      0|                    insert_str,
  784|      0|                )?;
  785|      0|                insert_term(triple.object.as_ref(), &encoded.object, insert_str)
  786|       |            } else {
  787|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  788|       |            }
  789|       |        }
  790|       |    }
  791|  74.4k|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder16get_required_strNtB4_13StorageReaderEB6_:
 1025|  8.88k|fn get_required_str<L: StrLookup>(lookup: &L, id: &StrHash) -> Result<String, StorageError> {
 1026|  8.88k|    Ok(lookup.get_str(id)?.ok_or_else(|| {
 1027|       |        CorruptionError::new(format!(
 1028|       |            "Not able to find the string with id {id:?} in the string store"
 1029|       |        ))
 1030|  8.88k|    })?)
 1031|  8.88k|}
_RINvXsL_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB6_7StrHashNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEBa_:
   13|   104k|#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]
_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder11insert_termNCINvMNtNtB6_6sparql7datasetNtB1b_11DatasetView11encode_termRNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE0EB6_:
  706|  5.96k|pub fn insert_term<F: FnMut(&StrHash, &str) -> Result<(), StorageError>>(
  707|  5.96k|    term: TermRef<'_>,
  708|  5.96k|    encoded: &EncodedTerm,
  709|  5.96k|    insert_str: &mut F,
  710|  5.96k|) -> Result<(), StorageError> {
  711|  5.96k|    match term {
  712|      0|        TermRef::NamedNode(node) => {
  713|      0|            if let EncodedTerm::NamedNode { iri_id } = encoded {
  714|      0|                insert_str(iri_id, node.as_str())
  715|       |            } else {
  716|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  717|       |            }
  718|       |        }
  719|      0|        TermRef::BlankNode(node) => match encoded {
  720|      0|            EncodedTerm::BigBlankNode { id_id } => insert_str(id_id, node.as_str()),
  721|      0|            EncodedTerm::SmallBlankNode(..) | EncodedTerm::NumericalBlankNode { .. } => Ok(()),
  722|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  723|       |        },
  724|  5.96k|        TermRef::Literal(literal) => match encoded {
  725|      0|            EncodedTerm::BigStringLiteral { value_id }
  726|      0|            | EncodedTerm::BigSmallLangStringLiteral { value_id, .. } => {
  727|      0|                insert_str(value_id, literal.value())
  728|       |            }
  729|      0|            EncodedTerm::SmallBigLangStringLiteral { language_id, .. } => {
  730|      0|                if let Some(language) = literal.language() {
  731|      0|                    insert_str(language_id, language)
  732|       |                } else {
  733|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  734|       |                }
  735|       |            }
  736|       |            EncodedTerm::BigBigLangStringLiteral {
  737|      0|                value_id,
  738|      0|                language_id,
  739|      0|            } => {
  740|      0|                insert_str(value_id, literal.value())?;
  741|      0|                if let Some(language) = literal.language() {
  742|      0|                    insert_str(language_id, language)
  743|       |                } else {
  744|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  745|       |                }
  746|       |            }
  747|      0|            EncodedTerm::SmallTypedLiteral { datatype_id, .. } => {
  748|      0|                insert_str(datatype_id, literal.datatype().as_str())
  749|       |            }
  750|       |            EncodedTerm::BigTypedLiteral {
  751|      0|                value_id,
  752|      0|                datatype_id,
  753|      0|            } => {
  754|      0|                insert_str(value_id, literal.value())?;
  755|      0|                insert_str(datatype_id, literal.datatype().as_str())
  756|       |            }
  757|       |            EncodedTerm::SmallStringLiteral(..)
  758|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
  759|       |            | EncodedTerm::BooleanLiteral(..)
  760|       |            | EncodedTerm::FloatLiteral(..)
  761|       |            | EncodedTerm::DoubleLiteral(..)
  762|       |            | EncodedTerm::IntegerLiteral(..)
  763|       |            | EncodedTerm::DecimalLiteral(..)
  764|       |            | EncodedTerm::DateTimeLiteral(..)
  765|       |            | EncodedTerm::TimeLiteral(..)
  766|       |            | EncodedTerm::DateLiteral(..)
  767|       |            | EncodedTerm::GYearMonthLiteral(..)
  768|       |            | EncodedTerm::GYearLiteral(..)
  769|       |            | EncodedTerm::GMonthDayLiteral(..)
  770|       |            | EncodedTerm::GDayLiteral(..)
  771|       |            | EncodedTerm::GMonthLiteral(..)
  772|       |            | EncodedTerm::DurationLiteral(..)
  773|       |            | EncodedTerm::YearMonthDurationLiteral(..)
  774|  5.96k|            | EncodedTerm::DayTimeDurationLiteral(..) => Ok(()),
  775|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  776|       |        },
  777|      0|        TermRef::Triple(triple) => {
  778|      0|            if let EncodedTerm::Triple(encoded) = encoded {
  779|      0|                insert_term(triple.subject.as_ref().into(), &encoded.subject, insert_str)?;
  780|      0|                insert_term(
  781|      0|                    triple.predicate.as_ref().into(),
  782|      0|                    &encoded.predicate,
  783|      0|                    insert_str,
  784|      0|                )?;
  785|      0|                insert_term(triple.object.as_ref(), &encoded.object, insert_str)
  786|       |            } else {
  787|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  788|       |            }
  789|       |        }
  790|       |    }
  791|  5.96k|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder11insert_termNCNvMs6_NtB4_6memoryNtB1d_19MemoryStorageWriter11insert_term0EB6_:
  706|  10.2k|pub fn insert_term<F: FnMut(&StrHash, &str) -> Result<(), StorageError>>(
  707|  10.2k|    term: TermRef<'_>,
  708|  10.2k|    encoded: &EncodedTerm,
  709|  10.2k|    insert_str: &mut F,
  710|  10.2k|) -> Result<(), StorageError> {
  711|  10.2k|    match term {
  712|  8.33k|        TermRef::NamedNode(node) => {
  713|  8.33k|            if let EncodedTerm::NamedNode { iri_id } = encoded {
  714|  8.33k|                insert_str(iri_id, node.as_str())
  715|       |            } else {
  716|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  717|       |            }
  718|       |        }
  719|      0|        TermRef::BlankNode(node) => match encoded {
  720|      0|            EncodedTerm::BigBlankNode { id_id } => insert_str(id_id, node.as_str()),
  721|      0|            EncodedTerm::SmallBlankNode(..) | EncodedTerm::NumericalBlankNode { .. } => Ok(()),
  722|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  723|       |        },
  724|  1.92k|        TermRef::Literal(literal) => match encoded {
  725|      0|            EncodedTerm::BigStringLiteral { value_id }
  726|      0|            | EncodedTerm::BigSmallLangStringLiteral { value_id, .. } => {
  727|      0|                insert_str(value_id, literal.value())
  728|       |            }
  729|      0|            EncodedTerm::SmallBigLangStringLiteral { language_id, .. } => {
  730|      0|                if let Some(language) = literal.language() {
  731|      0|                    insert_str(language_id, language)
  732|       |                } else {
  733|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  734|       |                }
  735|       |            }
  736|       |            EncodedTerm::BigBigLangStringLiteral {
  737|      0|                value_id,
  738|      0|                language_id,
  739|      0|            } => {
  740|      0|                insert_str(value_id, literal.value())?;
  741|      0|                if let Some(language) = literal.language() {
  742|      0|                    insert_str(language_id, language)
  743|       |                } else {
  744|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  745|       |                }
  746|       |            }
  747|      0|            EncodedTerm::SmallTypedLiteral { datatype_id, .. } => {
  748|      0|                insert_str(datatype_id, literal.datatype().as_str())
  749|       |            }
  750|       |            EncodedTerm::BigTypedLiteral {
  751|      0|                value_id,
  752|      0|                datatype_id,
  753|      0|            } => {
  754|      0|                insert_str(value_id, literal.value())?;
  755|      0|                insert_str(datatype_id, literal.datatype().as_str())
  756|       |            }
  757|       |            EncodedTerm::SmallStringLiteral(..)
  758|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
  759|       |            | EncodedTerm::BooleanLiteral(..)
  760|       |            | EncodedTerm::FloatLiteral(..)
  761|       |            | EncodedTerm::DoubleLiteral(..)
  762|       |            | EncodedTerm::IntegerLiteral(..)
  763|       |            | EncodedTerm::DecimalLiteral(..)
  764|       |            | EncodedTerm::DateTimeLiteral(..)
  765|       |            | EncodedTerm::TimeLiteral(..)
  766|       |            | EncodedTerm::DateLiteral(..)
  767|       |            | EncodedTerm::GYearMonthLiteral(..)
  768|       |            | EncodedTerm::GYearLiteral(..)
  769|       |            | EncodedTerm::GMonthDayLiteral(..)
  770|       |            | EncodedTerm::GDayLiteral(..)
  771|       |            | EncodedTerm::GMonthLiteral(..)
  772|       |            | EncodedTerm::DurationLiteral(..)
  773|       |            | EncodedTerm::YearMonthDurationLiteral(..)
  774|  1.92k|            | EncodedTerm::DayTimeDurationLiteral(..) => Ok(()),
  775|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  776|       |        },
  777|      0|        TermRef::Triple(triple) => {
  778|      0|            if let EncodedTerm::Triple(encoded) = encoded {
  779|      0|                insert_term(triple.subject.as_ref().into(), &encoded.subject, insert_str)?;
  780|      0|                insert_term(
  781|      0|                    triple.predicate.as_ref().into(),
  782|      0|                    &encoded.predicate,
  783|      0|                    insert_str,
  784|      0|                )?;
  785|      0|                insert_term(triple.object.as_ref(), &encoded.object, insert_str)
  786|       |            } else {
  787|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  788|       |            }
  789|       |        }
  790|       |    }
  791|  10.2k|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder16get_required_strNtNtNtB6_6sparql7dataset11DatasetViewEB6_:
 1025|    369|fn get_required_str<L: StrLookup>(lookup: &L, id: &StrHash) -> Result<String, StorageError> {
 1026|    369|    Ok(lookup.get_str(id)?.ok_or_else(|| {
 1027|       |        CorruptionError::new(format!(
 1028|       |            "Not able to find the string with id {id:?} in the string store"
 1029|       |        ))
 1030|    369|    })?)
 1031|    369|}
_RINvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder11insert_termNCINvMNtNtB6_6sparql7datasetNtB1b_11DatasetView11encode_termNtNtCshJ9d6mhVUZV_5oxrdf10named_node12NamedNodeRefE0EB6_:
  706|      2|pub fn insert_term<F: FnMut(&StrHash, &str) -> Result<(), StorageError>>(
  707|      2|    term: TermRef<'_>,
  708|      2|    encoded: &EncodedTerm,
  709|      2|    insert_str: &mut F,
  710|      2|) -> Result<(), StorageError> {
  711|      2|    match term {
  712|      2|        TermRef::NamedNode(node) => {
  713|      2|            if let EncodedTerm::NamedNode { iri_id } = encoded {
  714|      2|                insert_str(iri_id, node.as_str())
  715|       |            } else {
  716|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  717|       |            }
  718|       |        }
  719|      0|        TermRef::BlankNode(node) => match encoded {
  720|      0|            EncodedTerm::BigBlankNode { id_id } => insert_str(id_id, node.as_str()),
  721|      0|            EncodedTerm::SmallBlankNode(..) | EncodedTerm::NumericalBlankNode { .. } => Ok(()),
  722|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  723|       |        },
  724|      0|        TermRef::Literal(literal) => match encoded {
  725|      0|            EncodedTerm::BigStringLiteral { value_id }
  726|      0|            | EncodedTerm::BigSmallLangStringLiteral { value_id, .. } => {
  727|      0|                insert_str(value_id, literal.value())
  728|       |            }
  729|      0|            EncodedTerm::SmallBigLangStringLiteral { language_id, .. } => {
  730|      0|                if let Some(language) = literal.language() {
  731|      0|                    insert_str(language_id, language)
  732|       |                } else {
  733|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  734|       |                }
  735|       |            }
  736|       |            EncodedTerm::BigBigLangStringLiteral {
  737|      0|                value_id,
  738|      0|                language_id,
  739|      0|            } => {
  740|      0|                insert_str(value_id, literal.value())?;
  741|      0|                if let Some(language) = literal.language() {
  742|      0|                    insert_str(language_id, language)
  743|       |                } else {
  744|      0|                    Err(CorruptionError::from_encoded_term(encoded, &term).into())
  745|       |                }
  746|       |            }
  747|      0|            EncodedTerm::SmallTypedLiteral { datatype_id, .. } => {
  748|      0|                insert_str(datatype_id, literal.datatype().as_str())
  749|       |            }
  750|       |            EncodedTerm::BigTypedLiteral {
  751|      0|                value_id,
  752|      0|                datatype_id,
  753|      0|            } => {
  754|      0|                insert_str(value_id, literal.value())?;
  755|      0|                insert_str(datatype_id, literal.datatype().as_str())
  756|       |            }
  757|       |            EncodedTerm::SmallStringLiteral(..)
  758|       |            | EncodedTerm::SmallSmallLangStringLiteral { .. }
  759|       |            | EncodedTerm::BooleanLiteral(..)
  760|       |            | EncodedTerm::FloatLiteral(..)
  761|       |            | EncodedTerm::DoubleLiteral(..)
  762|       |            | EncodedTerm::IntegerLiteral(..)
  763|       |            | EncodedTerm::DecimalLiteral(..)
  764|       |            | EncodedTerm::DateTimeLiteral(..)
  765|       |            | EncodedTerm::TimeLiteral(..)
  766|       |            | EncodedTerm::DateLiteral(..)
  767|       |            | EncodedTerm::GYearMonthLiteral(..)
  768|       |            | EncodedTerm::GYearLiteral(..)
  769|       |            | EncodedTerm::GMonthDayLiteral(..)
  770|       |            | EncodedTerm::GDayLiteral(..)
  771|       |            | EncodedTerm::GMonthLiteral(..)
  772|       |            | EncodedTerm::DurationLiteral(..)
  773|       |            | EncodedTerm::YearMonthDurationLiteral(..)
  774|      0|            | EncodedTerm::DayTimeDurationLiteral(..) => Ok(()),
  775|      0|            _ => Err(CorruptionError::from_encoded_term(encoded, &term).into()),
  776|       |        },
  777|      0|        TermRef::Triple(triple) => {
  778|      0|            if let EncodedTerm::Triple(encoded) = encoded {
  779|      0|                insert_term(triple.subject.as_ref().into(), &encoded.subject, insert_str)?;
  780|      0|                insert_term(
  781|      0|                    triple.predicate.as_ref().into(),
  782|      0|                    &encoded.predicate,
  783|      0|                    insert_str,
  784|      0|                )?;
  785|      0|                insert_term(triple.object.as_ref(), &encoded.object, insert_str)
  786|       |            } else {
  787|      0|                Err(CorruptionError::from_encoded_term(encoded, &term).into())
  788|       |            }
  789|       |        }
  790|       |    }
  791|      2|}
_RNCNvXst_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB7_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal10LiteralRefE4from0Bb_:
  508|  2.77k|                literal.language().map(|language| {
  509|  2.77k|                    if let Ok(value) = SmallString::try_from(value) {
  510|  2.77k|                        if let Ok(language) = SmallString::try_from(language) {
  511|  2.77k|                            Self::SmallSmallLangStringLiteral { value, language }
  512|       |                        } else {
  513|      0|                            Self::SmallBigLangStringLiteral {
  514|      0|                                value,
  515|      0|                                language_id: StrHash::new(language),
  516|      0|                            }
  517|       |                        }
  518|      0|                    } else if let Ok(language) = SmallString::try_from(language) {
  519|      0|                        Self::BigSmallLangStringLiteral {
  520|      0|                            value_id: StrHash::new(value),
  521|      0|                            language,
  522|      0|                        }
  523|       |                    } else {
  524|      0|                        Self::BigBigLangStringLiteral {
  525|      0|                            value_id: StrHash::new(value),
  526|      0|                            language_id: StrHash::new(language),
  527|      0|                        }
  528|       |                    }
  529|  2.77k|                })
_RINvXs1_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB6_11EncodedTermNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEBa_:
  213|  4.51k|    fn hash<H: Hasher>(&self, state: &mut H) {
  214|  4.51k|        match self {
  215|  4.38k|            Self::NamedNode { iri_id } => iri_id.hash(state),
  216|      0|            Self::NumericalBlankNode { id } => id.hash(state),
  217|      0|            Self::SmallBlankNode(id) => id.hash(state),
  218|      0|            Self::BigBlankNode { id_id } => id_id.hash(state),
  219|      0|            Self::DefaultGraph => (),
  220|     16|            Self::SmallStringLiteral(value) => value.hash(state),
  221|      0|            Self::BigStringLiteral { value_id } => value_id.hash(state),
  222|     32|            Self::SmallSmallLangStringLiteral { value, language } => {
  223|     32|                value.hash(state);
  224|     32|                language.hash(state);
  225|     32|            }
  226|      0|            Self::SmallBigLangStringLiteral { value, language_id } => {
  227|      0|                value.hash(state);
  228|      0|                language_id.hash(state);
  229|      0|            }
  230|      0|            Self::BigSmallLangStringLiteral { value_id, language } => {
  231|      0|                value_id.hash(state);
  232|      0|                language.hash(state);
  233|      0|            }
  234|       |            Self::BigBigLangStringLiteral {
  235|      0|                value_id,
  236|      0|                language_id,
  237|      0|            } => {
  238|      0|                value_id.hash(state);
  239|      0|                language_id.hash(state);
  240|      0|            }
  241|      0|            Self::SmallTypedLiteral { value, datatype_id } => {
  242|      0|                value.hash(state);
  243|      0|                datatype_id.hash(state);
  244|      0|            }
  245|       |            Self::BigTypedLiteral {
  246|      0|                value_id,
  247|      0|                datatype_id,
  248|      0|            } => {
  249|      0|                value_id.hash(state);
  250|      0|                datatype_id.hash(state);
  251|      0|            }
  252|     38|            Self::BooleanLiteral(value) => value.hash(state),
  253|      0|            Self::FloatLiteral(value) => value.to_be_bytes().hash(state),
  254|      4|            Self::DoubleLiteral(value) => value.to_be_bytes().hash(state),
  255|     22|            Self::IntegerLiteral(value) => value.hash(state),
  256|     20|            Self::DecimalLiteral(value) => value.hash(state),
  257|      0|            Self::DateTimeLiteral(value) => value.hash(state),
  258|      0|            Self::TimeLiteral(value) => value.hash(state),
  259|      0|            Self::DateLiteral(value) => value.hash(state),
  260|      0|            Self::GYearMonthLiteral(value) => value.hash(state),
  261|      0|            Self::GYearLiteral(value) => value.hash(state),
  262|      0|            Self::GMonthDayLiteral(value) => value.hash(state),
  263|      0|            Self::GDayLiteral(value) => value.hash(state),
  264|      0|            Self::GMonthLiteral(value) => value.hash(state),
  265|      0|            Self::DurationLiteral(value) => value.hash(state),
  266|      0|            Self::YearMonthDurationLiteral(value) => value.hash(state),
  267|      0|            Self::DayTimeDurationLiteral(value) => value.hash(state),
  268|      0|            Self::Triple(value) => value.hash(state),
  269|       |        }
  270|  4.51k|    }
_RNvYNtNtNtCs2ek33vt1YA5_8oxigraph6sparql7dataset11DatasetViewNtNtNtB8_7storage15numeric_encoder7Decoder17decode_named_nodeB8_:
  893|     49|    fn decode_named_node(&self, encoded: &EncodedTerm) -> Result<NamedNode, StorageError> {
  894|     49|        match self.decode_term(encoded)? {
  895|     47|            Term::NamedNode(named_node) => Ok(named_node),
  896|      0|            Term::BlankNode(_) => Err(CorruptionError::msg(
  897|      0|                "A blank node has been found instead of a named node",
  898|      0|            )
  899|      0|            .into()),
  900|       |            Term::Literal(_) => {
  901|      2|                Err(CorruptionError::msg("A literal has been found instead of a named node").into())
  902|       |            }
  903|       |            Term::Triple(_) => {
  904|      0|                Err(CorruptionError::msg("A triple has been found instead of a named node").into())
  905|       |            }
  906|       |        }
  907|     49|    }
_RNvXsD_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtNtNtB9_6sparql7dataset11DatasetViewNtB5_7Decoder11decode_termB9_:
  945|    468|    fn decode_term(&self, encoded: &EncodedTerm) -> Result<Term, StorageError> {
  946|    468|        match encoded {
  947|       |            EncodedTerm::DefaultGraph => {
  948|      0|                Err(CorruptionError::msg("The default graph tag is not a valid term").into())
  949|       |            }
  950|    369|            EncodedTerm::NamedNode { iri_id } => {
  951|    369|                Ok(NamedNode::new_unchecked(get_required_str(self, iri_id)?).into())
  952|       |            }
  953|      0|            EncodedTerm::NumericalBlankNode { id } => Ok(BlankNode::new_from_unique_id(*id).into()),
  954|      0|            EncodedTerm::SmallBlankNode(id) => Ok(BlankNode::new_unchecked(id.as_str()).into()),
  955|      0|            EncodedTerm::BigBlankNode { id_id } => {
  956|      0|                Ok(BlankNode::new_unchecked(get_required_str(self, id_id)?).into())
  957|       |            }
  958|      5|            EncodedTerm::SmallStringLiteral(value) => {
  959|      5|                Ok(Literal::new_simple_literal(*value).into())
  960|       |            }
  961|      0|            EncodedTerm::BigStringLiteral { value_id } => {
  962|      0|                Ok(Literal::new_simple_literal(get_required_str(self, value_id)?).into())
  963|       |            }
  964|     26|            EncodedTerm::SmallSmallLangStringLiteral { value, language } => {
  965|     26|                Ok(Literal::new_language_tagged_literal_unchecked(*value, *language).into())
  966|       |            }
  967|      0|            EncodedTerm::SmallBigLangStringLiteral { value, language_id } => {
  968|      0|                Ok(Literal::new_language_tagged_literal_unchecked(
  969|      0|                    *value,
  970|      0|                    get_required_str(self, language_id)?,
  971|       |                )
  972|      0|                .into())
  973|       |            }
  974|      0|            EncodedTerm::BigSmallLangStringLiteral { value_id, language } => {
  975|      0|                Ok(Literal::new_language_tagged_literal_unchecked(
  976|      0|                    get_required_str(self, value_id)?,
  977|      0|                    *language,
  978|      0|                )
  979|      0|                .into())
  980|       |            }
  981|       |            EncodedTerm::BigBigLangStringLiteral {
  982|      0|                value_id,
  983|      0|                language_id,
  984|      0|            } => Ok(Literal::new_language_tagged_literal_unchecked(
  985|      0|                get_required_str(self, value_id)?,
  986|      0|                get_required_str(self, language_id)?,
  987|       |            )
  988|      0|            .into()),
  989|      0|            EncodedTerm::SmallTypedLiteral { value, datatype_id } => {
  990|      0|                Ok(Literal::new_typed_literal(
  991|      0|                    *value,
  992|      0|                    NamedNode::new_unchecked(get_required_str(self, datatype_id)?),
  993|       |                )
  994|      0|                .into())
  995|       |            }
  996|       |            EncodedTerm::BigTypedLiteral {
  997|      0|                value_id,
  998|      0|                datatype_id,
  999|      0|            } => Ok(Literal::new_typed_literal(
 1000|      0|                get_required_str(self, value_id)?,
 1001|      0|                NamedNode::new_unchecked(get_required_str(self, datatype_id)?),
 1002|       |            )
 1003|      0|            .into()),
 1004|     20|            EncodedTerm::BooleanLiteral(value) => Ok(Literal::from(*value).into()),
 1005|      0|            EncodedTerm::FloatLiteral(value) => Ok(Literal::from(*value).into()),
 1006|      4|            EncodedTerm::DoubleLiteral(value) => Ok(Literal::from(*value).into()),
 1007|     30|            EncodedTerm::IntegerLiteral(value) => Ok(Literal::from(*value).into()),
 1008|     14|            EncodedTerm::DecimalLiteral(value) => Ok(Literal::from(*value).into()),
 1009|      0|            EncodedTerm::DateTimeLiteral(value) => Ok(Literal::from(*value).into()),
 1010|      0|            EncodedTerm::DateLiteral(value) => Ok(Literal::from(*value).into()),
 1011|      0|            EncodedTerm::TimeLiteral(value) => Ok(Literal::from(*value).into()),
 1012|      0|            EncodedTerm::GYearMonthLiteral(value) => Ok(Literal::from(*value).into()),
 1013|      0|            EncodedTerm::GYearLiteral(value) => Ok(Literal::from(*value).into()),
 1014|      0|            EncodedTerm::GMonthDayLiteral(value) => Ok(Literal::from(*value).into()),
 1015|      0|            EncodedTerm::GDayLiteral(value) => Ok(Literal::from(*value).into()),
 1016|      0|            EncodedTerm::GMonthLiteral(value) => Ok(Literal::from(*value).into()),
 1017|      0|            EncodedTerm::DurationLiteral(value) => Ok(Literal::from(*value).into()),
 1018|      0|            EncodedTerm::YearMonthDurationLiteral(value) => Ok(Literal::from(*value).into()),
 1019|      0|            EncodedTerm::DayTimeDurationLiteral(value) => Ok(Literal::from(*value).into()),
 1020|      0|            EncodedTerm::Triple(triple) => Ok(self.decode_triple(triple)?.into()),
 1021|       |        }
 1022|    468|    }
_RNvXsD_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB7_13StorageReaderNtB5_7Decoder11decode_termB9_:
  945|  10.7k|    fn decode_term(&self, encoded: &EncodedTerm) -> Result<Term, StorageError> {
  946|  10.7k|        match encoded {
  947|       |            EncodedTerm::DefaultGraph => {
  948|      0|                Err(CorruptionError::msg("The default graph tag is not a valid term").into())
  949|       |            }
  950|  8.88k|            EncodedTerm::NamedNode { iri_id } => {
  951|  8.88k|                Ok(NamedNode::new_unchecked(get_required_str(self, iri_id)?).into())
  952|       |            }
  953|      0|            EncodedTerm::NumericalBlankNode { id } => Ok(BlankNode::new_from_unique_id(*id).into()),
  954|      0|            EncodedTerm::SmallBlankNode(id) => Ok(BlankNode::new_unchecked(id.as_str()).into()),
  955|      0|            EncodedTerm::BigBlankNode { id_id } => {
  956|      0|                Ok(BlankNode::new_unchecked(get_required_str(self, id_id)?).into())
  957|       |            }
  958|     70|            EncodedTerm::SmallStringLiteral(value) => {
  959|     70|                Ok(Literal::new_simple_literal(*value).into())
  960|       |            }
  961|      0|            EncodedTerm::BigStringLiteral { value_id } => {
  962|      0|                Ok(Literal::new_simple_literal(get_required_str(self, value_id)?).into())
  963|       |            }
  964|    578|            EncodedTerm::SmallSmallLangStringLiteral { value, language } => {
  965|    578|                Ok(Literal::new_language_tagged_literal_unchecked(*value, *language).into())
  966|       |            }
  967|      0|            EncodedTerm::SmallBigLangStringLiteral { value, language_id } => {
  968|      0|                Ok(Literal::new_language_tagged_literal_unchecked(
  969|      0|                    *value,
  970|      0|                    get_required_str(self, language_id)?,
  971|       |                )
  972|      0|                .into())
  973|       |            }
  974|      0|            EncodedTerm::BigSmallLangStringLiteral { value_id, language } => {
  975|      0|                Ok(Literal::new_language_tagged_literal_unchecked(
  976|      0|                    get_required_str(self, value_id)?,
  977|      0|                    *language,
  978|      0|                )
  979|      0|                .into())
  980|       |            }
  981|       |            EncodedTerm::BigBigLangStringLiteral {
  982|      0|                value_id,
  983|      0|                language_id,
  984|      0|            } => Ok(Literal::new_language_tagged_literal_unchecked(
  985|      0|                get_required_str(self, value_id)?,
  986|      0|                get_required_str(self, language_id)?,
  987|       |            )
  988|      0|            .into()),
  989|      0|            EncodedTerm::SmallTypedLiteral { value, datatype_id } => {
  990|      0|                Ok(Literal::new_typed_literal(
  991|      0|                    *value,
  992|      0|                    NamedNode::new_unchecked(get_required_str(self, datatype_id)?),
  993|       |                )
  994|      0|                .into())
  995|       |            }
  996|       |            EncodedTerm::BigTypedLiteral {
  997|      0|                value_id,
  998|      0|                datatype_id,
  999|      0|            } => Ok(Literal::new_typed_literal(
 1000|      0|                get_required_str(self, value_id)?,
 1001|      0|                NamedNode::new_unchecked(get_required_str(self, datatype_id)?),
 1002|       |            )
 1003|      0|            .into()),
 1004|    212|            EncodedTerm::BooleanLiteral(value) => Ok(Literal::from(*value).into()),
 1005|      0|            EncodedTerm::FloatLiteral(value) => Ok(Literal::from(*value).into()),
 1006|     64|            EncodedTerm::DoubleLiteral(value) => Ok(Literal::from(*value).into()),
 1007|    258|            EncodedTerm::IntegerLiteral(value) => Ok(Literal::from(*value).into()),
 1008|    646|            EncodedTerm::DecimalLiteral(value) => Ok(Literal::from(*value).into()),
 1009|      0|            EncodedTerm::DateTimeLiteral(value) => Ok(Literal::from(*value).into()),
 1010|      0|            EncodedTerm::DateLiteral(value) => Ok(Literal::from(*value).into()),
 1011|      0|            EncodedTerm::TimeLiteral(value) => Ok(Literal::from(*value).into()),
 1012|      0|            EncodedTerm::GYearMonthLiteral(value) => Ok(Literal::from(*value).into()),
 1013|      0|            EncodedTerm::GYearLiteral(value) => Ok(Literal::from(*value).into()),
 1014|      0|            EncodedTerm::GMonthDayLiteral(value) => Ok(Literal::from(*value).into()),
 1015|      0|            EncodedTerm::GDayLiteral(value) => Ok(Literal::from(*value).into()),
 1016|      0|            EncodedTerm::GMonthLiteral(value) => Ok(Literal::from(*value).into()),
 1017|      0|            EncodedTerm::DurationLiteral(value) => Ok(Literal::from(*value).into()),
 1018|      0|            EncodedTerm::YearMonthDurationLiteral(value) => Ok(Literal::from(*value).into()),
 1019|      0|            EncodedTerm::DayTimeDurationLiteral(value) => Ok(Literal::from(*value).into()),
 1020|      0|            EncodedTerm::Triple(triple) => Ok(self.decode_triple(triple)?.into()),
 1021|       |        }
 1022|  10.7k|    }
_RNvYNtNtCs2ek33vt1YA5_8oxigraph7storage13StorageReaderNtNtB4_15numeric_encoder7Decoder17decode_named_nodeB6_:
  893|  2.78k|    fn decode_named_node(&self, encoded: &EncodedTerm) -> Result<NamedNode, StorageError> {
  894|  2.78k|        match self.decode_term(encoded)? {
  895|  2.78k|            Term::NamedNode(named_node) => Ok(named_node),
  896|      0|            Term::BlankNode(_) => Err(CorruptionError::msg(
  897|      0|                "A blank node has been found instead of a named node",
  898|      0|            )
  899|      0|            .into()),
  900|       |            Term::Literal(_) => {
  901|      0|                Err(CorruptionError::msg("A literal has been found instead of a named node").into())
  902|       |            }
  903|       |            Term::Triple(_) => {
  904|      0|                Err(CorruptionError::msg("A triple has been found instead of a named node").into())
  905|       |            }
  906|       |        }
  907|  2.78k|    }
_RNvYNtNtCs2ek33vt1YA5_8oxigraph7storage13StorageReaderNtNtB4_15numeric_encoder7Decoder11decode_quadB6_:
  917|  2.78k|    fn decode_quad(&self, encoded: &EncodedQuad) -> Result<Quad, StorageError> {
  918|  2.78k|        Ok(Quad::new(
  919|  2.78k|            self.decode_subject(&encoded.subject)?,
  920|  2.78k|            self.decode_named_node(&encoded.predicate)?,
  921|  2.78k|            self.decode_term(&encoded.object)?,
  922|  2.78k|            if encoded.graph_name == EncodedTerm::DefaultGraph {
  923|    426|                GraphName::DefaultGraph
  924|       |            } else {
  925|  2.35k|                match self.decode_term(&encoded.graph_name)? {
  926|  2.35k|                    Term::NamedNode(named_node) => named_node.into(),
  927|      0|                    Term::BlankNode(blank_node) => blank_node.into(),
  928|       |                    Term::Literal(_) => {
  929|      0|                        return Err(
  930|      0|                            CorruptionError::msg("A literal is not a valid graph name").into()
  931|      0|                        )
  932|       |                    }
  933|       |                    Term::Triple(_) => {
  934|      0|                        return Err(
  935|      0|                            CorruptionError::msg("A triple is not a valid graph name").into()
  936|      0|                        )
  937|       |                    }
  938|       |                }
  939|       |            },
  940|       |        ))
  941|  2.78k|    }
_RNvYNtNtCs2ek33vt1YA5_8oxigraph7storage13StorageReaderNtNtB4_15numeric_encoder7Decoder14decode_subjectB6_:
  863|  2.78k|    fn decode_subject(&self, encoded: &EncodedTerm) -> Result<Subject, StorageError> {
  864|  2.78k|        match self.decode_term(encoded)? {
  865|  2.78k|            Term::NamedNode(named_node) => Ok(named_node.into()),
  866|      0|            Term::BlankNode(blank_node) => Ok(blank_node.into()),
  867|      0|            Term::Literal(_) => Err(CorruptionError::msg(
  868|      0|                "A literal has been found instead of a subject node",
  869|      0|            )
  870|      0|            .into()),
  871|      0|            Term::Triple(triple) => Ok(Subject::Triple(triple)),
  872|       |        }
  873|  2.78k|    }
_RNvXse_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes7decimal7DecimalE4from:
  400|    786|    fn from(value: Decimal) -> Self {
  401|    786|        Self::DecimalLiteral(value)
  402|    786|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB2_7StrHash11to_be_bytesB6_:
   36|   122k|    pub fn to_be_bytes(self) -> [u8; 16] {
   37|   122k|        self.hash.to_be_bytes()
   38|   122k|    }
_RNvXsr_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node12NamedNodeRefE4from:
  478|   107k|    fn from(named_node: NamedNodeRef<'_>) -> Self {
  479|   107k|        Self::NamedNode {
  480|   107k|            iri_id: StrHash::new(named_node.as_str()),
  481|   107k|        }
  482|   107k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder16parse_double_str:
  801|    962|pub fn parse_double_str(value: &str) -> Option<EncodedTerm> {
  802|    962|    value.parse().map(EncodedTerm::DoubleLiteral).ok()
  803|    962|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder17parse_decimal_str:
  809|  1.85k|pub fn parse_decimal_str(value: &str) -> Option<EncodedTerm> {
  810|  1.85k|    value.parse().map(EncodedTerm::DecimalLiteral).ok()
  811|  1.85k|}
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder17parse_integer_str:
  805|  2.01k|pub fn parse_integer_str(value: &str) -> Option<EncodedTerm> {
  806|  2.01k|    value.parse().map(EncodedTerm::IntegerLiteral).ok()
  807|  2.01k|}
_RNvXsH_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_7StrHashNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB9_:
   13|  79.2k|#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]
_RNvXsC_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedQuadINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple7QuadRefE4from:
  692|  8.33k|    fn from(quad: QuadRef<'_>) -> Self {
  693|  8.33k|        Self {
  694|  8.33k|            subject: quad.subject.into(),
  695|  8.33k|            predicate: quad.predicate.into(),
  696|  8.33k|            object: quad.object.into(),
  697|  8.33k|            graph_name: quad.graph_name.into(),
  698|  8.33k|        }
  699|  8.33k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB2_7StrHash3new:
   20|   107k|    pub fn new(value: &str) -> Self {
   21|   107k|        let mut hasher = SipHasher24::new();
   22|   107k|        hasher.write(value.as_bytes());
   23|   107k|        Self {
   24|   107k|            hash: hasher.finish128().into(),
   25|   107k|        }
   26|   107k|    }
_RNvXsx_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple12GraphNameRefE4from:
  625|  13.3k|    fn from(name: GraphNameRef<'_>) -> Self {
  626|  13.3k|        match name {
  627|  11.1k|            GraphNameRef::NamedNode(named_node) => named_node.into(),
  628|      0|            GraphNameRef::BlankNode(blank_node) => blank_node.into(),
  629|  2.12k|            GraphNameRef::DefaultGraph => Self::DefaultGraph,
  630|       |        }
  631|  13.3k|    }
_RNvXsd_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes7integer7IntegerE4from:
  394|    417|    fn from(value: Integer) -> Self {
  395|    417|        Self::IntegerLiteral(value)
  396|    417|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB2_7StrHash13from_be_bytesB6_:
   29|  9.38k|    pub fn from_be_bytes(bytes: [u8; 16]) -> Self {
   30|  9.38k|        Self {
   31|  9.38k|            hash: u128::from_be_bytes(bytes),
   32|  9.38k|        }
   33|  9.38k|    }
_RNvXs3_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FrombE4from:
  334|    354|    fn from(value: bool) -> Self {
  335|    354|        Self::BooleanLiteral(value.into())
  336|    354|    }
_RNvXsv_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple10SubjectRefE4from:
  604|  8.33k|    fn from(term: SubjectRef<'_>) -> Self {
  605|  8.33k|        match term {
  606|  8.33k|            SubjectRef::NamedNode(named_node) => named_node.into(),
  607|      0|            SubjectRef::BlankNode(blank_node) => blank_node.into(),
  608|      0|            SubjectRef::Triple(triple) => triple.as_ref().into(),
  609|       |        }
  610|  8.33k|    }
_RNvNtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoder17parse_boolean_str:
  793|  2.97k|pub fn parse_boolean_str(value: &str) -> Option<EncodedTerm> {
  794|  2.97k|    value.parse().map(EncodedTerm::BooleanLiteral).ok()
  795|  2.97k|}
_RNvMsB_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedQuad3new:
  676|     57|    pub fn new(
  677|     57|        subject: EncodedTerm,
  678|     57|        predicate: EncodedTerm,
  679|     57|        object: EncodedTerm,
  680|     57|        graph_name: EncodedTerm,
  681|     57|    ) -> Self {
  682|     57|        Self {
  683|     57|            subject,
  684|     57|            predicate,
  685|     57|            object,
  686|     57|            graph_name,
  687|     57|        }
  688|     57|    }
_RNvXs_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB4_11EncodedTermNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eq:
  102|  4.72k|    fn eq(&self, other: &Self) -> bool {
  103|  4.72k|        match (self, other) {
  104|    467|            (Self::DefaultGraph, Self::DefaultGraph) => true,
  105|  1.84k|            (Self::NamedNode { iri_id: iri_id_a }, Self::NamedNode { iri_id: iri_id_b }) => {
  106|  1.84k|                iri_id_a == iri_id_b
  107|       |            }
  108|      0|            (Self::NumericalBlankNode { id: id_a }, Self::NumericalBlankNode { id: id_b }) => {
  109|      0|                id_a == id_b
  110|       |            }
  111|      0|            (Self::SmallBlankNode(id_a), Self::SmallBlankNode(id_b)) => id_a == id_b,
  112|      0|            (Self::BigBlankNode { id_id: id_a }, Self::BigBlankNode { id_id: id_b }) => {
  113|      0|                id_a == id_b
  114|       |            }
  115|      1|            (Self::SmallStringLiteral(a), Self::SmallStringLiteral(b)) => a == b,
  116|       |            (
  117|       |                Self::BigStringLiteral {
  118|      0|                    value_id: value_id_a,
  119|      0|                },
  120|      0|                Self::BigStringLiteral {
  121|      0|                    value_id: value_id_b,
  122|      0|                },
  123|      0|            ) => value_id_a == value_id_b,
  124|       |            (
  125|       |                Self::SmallSmallLangStringLiteral {
  126|      0|                    value: value_a,
  127|      0|                    language: language_a,
  128|      0|                },
  129|      0|                Self::SmallSmallLangStringLiteral {
  130|      0|                    value: value_b,
  131|      0|                    language: language_b,
  132|      0|                },
  133|      0|            ) => value_a == value_b && language_a == language_b,
  134|       |            (
  135|       |                Self::SmallBigLangStringLiteral {
  136|      0|                    value: value_a,
  137|      0|                    language_id: language_id_a,
  138|      0|                },
  139|      0|                Self::SmallBigLangStringLiteral {
  140|      0|                    value: value_b,
  141|      0|                    language_id: language_id_b,
  142|      0|                },
  143|      0|            ) => value_a == value_b && language_id_a == language_id_b,
  144|       |            (
  145|       |                Self::BigSmallLangStringLiteral {
  146|      0|                    value_id: value_id_a,
  147|      0|                    language: language_a,
  148|      0|                },
  149|      0|                Self::BigSmallLangStringLiteral {
  150|      0|                    value_id: value_id_b,
  151|      0|                    language: language_b,
  152|      0|                },
  153|      0|            ) => value_id_a == value_id_b && language_a == language_b,
  154|       |            (
  155|       |                Self::BigBigLangStringLiteral {
  156|      0|                    value_id: value_id_a,
  157|      0|                    language_id: language_id_a,
  158|      0|                },
  159|      0|                Self::BigBigLangStringLiteral {
  160|      0|                    value_id: value_id_b,
  161|      0|                    language_id: language_id_b,
  162|      0|                },
  163|      0|            ) => value_id_a == value_id_b && language_id_a == language_id_b,
  164|       |            (
  165|       |                Self::SmallTypedLiteral {
  166|      0|                    value: value_a,
  167|      0|                    datatype_id: datatype_id_a,
  168|      0|                },
  169|      0|                Self::SmallTypedLiteral {
  170|      0|                    value: value_b,
  171|      0|                    datatype_id: datatype_id_b,
  172|      0|                },
  173|      0|            ) => value_a == value_b && datatype_id_a == datatype_id_b,
  174|       |            (
  175|       |                Self::BigTypedLiteral {
  176|      0|                    value_id: value_id_a,
  177|      0|                    datatype_id: datatype_id_a,
  178|      0|                },
  179|      0|                Self::BigTypedLiteral {
  180|      0|                    value_id: value_id_b,
  181|      0|                    datatype_id: datatype_id_b,
  182|      0|                },
  183|      0|            ) => value_id_a == value_id_b && datatype_id_a == datatype_id_b,
  184|      4|            (Self::BooleanLiteral(a), Self::BooleanLiteral(b)) => a == b,
  185|      0|            (Self::FloatLiteral(a), Self::FloatLiteral(b)) => a.is_identical_with(*b),
  186|      0|            (Self::DoubleLiteral(a), Self::DoubleLiteral(b)) => a.is_identical_with(*b),
  187|      4|            (Self::IntegerLiteral(a), Self::IntegerLiteral(b)) => a.is_identical_with(*b),
  188|      8|            (Self::DecimalLiteral(a), Self::DecimalLiteral(b)) => a.is_identical_with(*b),
  189|      0|            (Self::DateTimeLiteral(a), Self::DateTimeLiteral(b)) => a.is_identical_with(*b),
  190|      0|            (Self::TimeLiteral(a), Self::TimeLiteral(b)) => a.is_identical_with(*b),
  191|      0|            (Self::DateLiteral(a), Self::DateLiteral(b)) => a.is_identical_with(*b),
  192|      0|            (Self::GYearMonthLiteral(a), Self::GYearMonthLiteral(b)) => a.is_identical_with(*b),
  193|      0|            (Self::GYearLiteral(a), Self::GYearLiteral(b)) => a.is_identical_with(*b),
  194|      0|            (Self::GMonthDayLiteral(a), Self::GMonthDayLiteral(b)) => a.is_identical_with(*b),
  195|      0|            (Self::GMonthLiteral(a), Self::GMonthLiteral(b)) => a.is_identical_with(*b),
  196|      0|            (Self::GDayLiteral(a), Self::GDayLiteral(b)) => a.is_identical_with(*b),
  197|      0|            (Self::DurationLiteral(a), Self::DurationLiteral(b)) => a.is_identical_with(*b),
  198|      0|            (Self::YearMonthDurationLiteral(a), Self::YearMonthDurationLiteral(b)) => {
  199|      0|                a.is_identical_with(*b)
  200|       |            }
  201|      0|            (Self::DayTimeDurationLiteral(a), Self::DayTimeDurationLiteral(b)) => {
  202|      0|                a.is_identical_with(*b)
  203|       |            }
  204|      0|            (Self::Triple(a), Self::Triple(b)) => a == b,
  205|  2.38k|            (_, _) => false,
  206|       |        }
  207|  4.72k|    }
_RNvXsJ_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_7StrHashNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
   13|  40.8k|#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]
_RNvXsw_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple7TermRefE4from:
  614|  88.7k|    fn from(term: TermRef<'_>) -> Self {
  615|  88.7k|        match term {
  616|  77.4k|            TermRef::NamedNode(named_node) => named_node.into(),
  617|      0|            TermRef::BlankNode(blank_node) => blank_node.into(),
  618|  11.3k|            TermRef::Literal(literal) => literal.into(),
  619|      0|            TermRef::Triple(triple) => triple.as_ref().into(),
  620|       |        }
  621|  88.7k|    }
_RNvXsN_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
   41|  87.6k|#[derive(Debug, Clone)]
_RNvXsc_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes6double6DoubleE4from:
  388|     66|    fn from(value: Double) -> Self {
  389|     66|        Self::DoubleLiteral(value)
  390|     66|    }
_RNvXsu_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple19NamedOrBlankNodeRefE4from:
  595|  1.06k|    fn from(term: NamedOrBlankNodeRef<'_>) -> Self {
  596|  1.06k|        match term {
  597|  1.06k|            NamedOrBlankNodeRef::NamedNode(named_node) => named_node.into(),
  598|      0|            NamedOrBlankNodeRef::BlankNode(blank_node) => blank_node.into(),
  599|       |        }
  600|  1.06k|    }
_RNvXst_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal10LiteralRefE4from:
  503|  11.3k|    fn from(literal: LiteralRef<'_>) -> Self {
  504|  11.3k|        let value = literal.value();
  505|  11.3k|        let datatype = literal.datatype().as_str();
  506|  11.3k|        let native_encoding = match datatype {
  507|  11.3k|            "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" => {
  508|  2.77k|                literal.language().map(|language| {
  509|       |                    if let Ok(value) = SmallString::try_from(value) {
  510|       |                        if let Ok(language) = SmallString::try_from(language) {
  511|       |                            Self::SmallSmallLangStringLiteral { value, language }
  512|       |                        } else {
  513|       |                            Self::SmallBigLangStringLiteral {
  514|       |                                value,
  515|       |                                language_id: StrHash::new(language),
  516|       |                            }
  517|       |                        }
  518|       |                    } else if let Ok(language) = SmallString::try_from(language) {
  519|       |                        Self::BigSmallLangStringLiteral {
  520|       |                            value_id: StrHash::new(value),
  521|       |                            language,
  522|       |                        }
  523|       |                    } else {
  524|       |                        Self::BigBigLangStringLiteral {
  525|       |                            value_id: StrHash::new(value),
  526|       |                            language_id: StrHash::new(language),
  527|       |                        }
  528|       |                    }
  529|  2.77k|                })
  530|       |            }
  531|  8.55k|            "http://www.w3.org/2001/XMLSchema#boolean" => parse_boolean_str(value),
  532|  5.58k|            "http://www.w3.org/2001/XMLSchema#string" => {
  533|    750|                Some(if let Ok(value) = SmallString::try_from(value) {
  534|    750|                    Self::SmallStringLiteral(value)
  535|       |                } else {
  536|      0|                    Self::BigStringLiteral {
  537|      0|                        value_id: StrHash::new(value),
  538|      0|                    }
  539|       |                })
  540|       |            }
  541|  4.83k|            "http://www.w3.org/2001/XMLSchema#float" => parse_float_str(value),
  542|  4.83k|            "http://www.w3.org/2001/XMLSchema#double" => parse_double_str(value),
  543|  3.87k|            "http://www.w3.org/2001/XMLSchema#integer"
  544|  1.85k|            | "http://www.w3.org/2001/XMLSchema#byte"
  545|  1.85k|            | "http://www.w3.org/2001/XMLSchema#short"
  546|  1.85k|            | "http://www.w3.org/2001/XMLSchema#int"
  547|  1.85k|            | "http://www.w3.org/2001/XMLSchema#long"
  548|  1.85k|            | "http://www.w3.org/2001/XMLSchema#unsignedByte"
  549|  1.85k|            | "http://www.w3.org/2001/XMLSchema#unsignedShort"
  550|  1.85k|            | "http://www.w3.org/2001/XMLSchema#unsignedInt"
  551|  1.85k|            | "http://www.w3.org/2001/XMLSchema#unsignedLong"
  552|  1.85k|            | "http://www.w3.org/2001/XMLSchema#positiveInteger"
  553|  1.85k|            | "http://www.w3.org/2001/XMLSchema#negativeInteger"
  554|  1.85k|            | "http://www.w3.org/2001/XMLSchema#nonPositiveInteger"
  555|  2.01k|            | "http://www.w3.org/2001/XMLSchema#nonNegativeInteger" => parse_integer_str(value),
  556|  1.85k|            "http://www.w3.org/2001/XMLSchema#decimal" => parse_decimal_str(value),
  557|      0|            "http://www.w3.org/2001/XMLSchema#dateTime"
  558|      0|            | "http://www.w3.org/2001/XMLSchema#dateTimeStamp" => parse_date_time_str(value),
  559|      0|            "http://www.w3.org/2001/XMLSchema#time" => parse_time_str(value),
  560|      0|            "http://www.w3.org/2001/XMLSchema#date" => parse_date_str(value),
  561|      0|            "http://www.w3.org/2001/XMLSchema#gYearMonth" => parse_g_year_month_str(value),
  562|      0|            "http://www.w3.org/2001/XMLSchema#gYear" => parse_g_year_str(value),
  563|      0|            "http://www.w3.org/2001/XMLSchema#gMonthDay" => parse_g_month_day_str(value),
  564|      0|            "http://www.w3.org/2001/XMLSchema#gDay" => parse_g_day_str(value),
  565|      0|            "http://www.w3.org/2001/XMLSchema#gMonth" => parse_g_month_str(value),
  566|      0|            "http://www.w3.org/2001/XMLSchema#duration" => parse_duration_str(value),
  567|      0|            "http://www.w3.org/2001/XMLSchema#yearMonthDuration" => {
  568|      0|                parse_year_month_duration_str(value)
  569|       |            }
  570|      0|            "http://www.w3.org/2001/XMLSchema#dayTimeDuration" => {
  571|      0|                parse_day_time_duration_str(value)
  572|       |            }
  573|      0|            _ => None,
  574|       |        };
  575|  11.3k|        match native_encoding {
  576|  11.3k|            Some(term) => term,
  577|       |            None => {
  578|      0|                if let Ok(value) = SmallString::try_from(value) {
  579|      0|                    Self::SmallTypedLiteral {
  580|      0|                        value,
  581|      0|                        datatype_id: StrHash::new(datatype),
  582|      0|                    }
  583|       |                } else {
  584|      0|                    Self::BigTypedLiteral {
  585|      0|                        value_id: StrHash::new(value),
  586|      0|                        datatype_id: StrHash::new(datatype),
  587|      0|                    }
  588|       |                }
  589|       |            }
  590|       |        }
  591|  11.3k|    }
_RNvMs2_NtNtCs2ek33vt1YA5_8oxigraph7storage15numeric_encoderNtB5_11EncodedTerm16is_default_graph:
  324|  63.0k|    pub fn is_default_graph(&self) -> bool {
  325|  63.0k|        matches!(self, Self::DefaultGraph)
  326|  63.0k|    }

_RNvXs9_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtNtCsjOdcKtOMjJI_5alloc6string6StringINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_11SmallStringE4fromB9_:
  131|  1.28k|    fn from(value: SmallString) -> Self {
  132|  1.28k|        value.as_str().into()
  133|  1.28k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString11to_be_bytesB6_:
   57|  10.5k|    pub fn to_be_bytes(self) -> [u8; 16] {
   58|  10.5k|        self.inner
   59|  10.5k|    }
_RNvXsd_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB5_11SmallStringNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB9_:
    9|    972|#[derive(Clone, Copy, Default)]
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString13from_be_bytesB6_:
   27|  1.29k|    pub fn from_be_bytes(bytes: [u8; 16]) -> Result<Self, BadSmallStringError> {
   28|  1.29k|        // We check that it is valid UTF-8
   29|  1.29k|        str::from_utf8(&bytes.as_ref()[..bytes[15].into()])
   30|  1.29k|            .map_err(BadSmallStringError::BadUtf8)?;
   31|  1.29k|        Ok(Self { inner: bytes })
   32|  1.29k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString3lenB6_:
   35|  1.36k|    pub fn len(&self) -> usize {
   36|  1.36k|        self.inner[15].into()
   37|  1.36k|    }
_RNvXsb_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB5_11SmallStringNtNtNtCs9nhK3FOW46N_4core3str6traits7FromStr8from_strB9_:
  147|  6.29k|    fn from_str(value: &str) -> Result<Self, Self::Err> {
  148|  6.29k|        if value.len() <= 15 {
  149|  6.29k|            let mut inner = [0; 16];
  150|  6.29k|            inner[..value.len()].copy_from_slice(value.as_bytes());
  151|  6.29k|            inner[15] = value
  152|  6.29k|                .len()
  153|  6.29k|                .try_into()
  154|  6.29k|                .map_err(|_| Self::Err::TooLong(value.len()))?;
  155|  6.29k|            Ok(Self { inner })
  156|       |        } else {
  157|      0|            Err(Self::Err::TooLong(value.len()))
  158|       |        }
  159|  6.29k|    }
_RNvXs4_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB5_11SmallStringNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB9_:
  101|      1|    fn eq(&self, other: &Self) -> bool {
  102|      1|        self.as_str() == other.as_str()
  103|      1|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString6as_strB6_:
   46|  1.36k|    pub fn as_str(&self) -> &str {
   47|  1.36k|        // SAFETY: safe because we ensured it in constructors
   48|  1.36k|        unsafe { str::from_utf8_unchecked(self.as_bytes()) }
   49|  1.36k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString8as_bytesB6_:
   52|  1.36k|    pub fn as_bytes(&self) -> &[u8] {
   53|  1.36k|        &self.inner[..self.len()]
   54|  1.36k|    }
_RNvMNtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB2_11SmallString8is_emptyB6_:
   40|      3|    pub fn is_empty(&self) -> bool {
   41|      3|        self.len() == 0
   42|      3|    }
_RNvXsc_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB5_11SmallStringINtNtCs9nhK3FOW46N_4core7convert7TryFromReE8try_fromB9_:
  166|  6.29k|    fn try_from(value: &'a str) -> Result<Self, Self::Error> {
  167|  6.29k|        Self::from_str(value)
  168|  6.29k|    }
_RINvXs8_NtNtCs2ek33vt1YA5_8oxigraph7storage12small_stringNtB6_11SmallStringNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEBa_:
  124|     80|    fn hash<H: Hasher>(&self, state: &mut H) {
  125|     80|        self.as_str().hash(state)
  126|     80|    }

_RINvMNtCs2ek33vt1YA5_8oxigraph5storeNtB3_5Store10update_optNtNtCs9nhK3FOW46N_4core7convert10InfallibleNtNtNtB5_6sparql7algebra6UpdateNtB1G_12QueryOptionsECslmM25dSh1d8_18sparql_update_eval:
  456|  4.99k|    pub fn update_opt(
  457|  4.99k|        &self,
  458|  4.99k|        update: impl TryInto<Update, Error = impl Into<EvaluationError>>,
  459|  4.99k|        options: impl Into<UpdateOptions>,
  460|  4.99k|    ) -> Result<(), EvaluationError> {
  461|  4.99k|        let update = update.try_into().map_err(Into::into)?;
  462|  4.99k|        let options = options.into();
  463|  4.99k|        self.storage
  464|  4.99k|            .transaction(|mut t| evaluate_update(&mut t, &update, &options))
  465|  4.99k|    }
_RNCINvMNtCs2ek33vt1YA5_8oxigraph5storeNtB5_5Store10update_optNtNtCs9nhK3FOW46N_4core7convert10InfallibleNtNtNtB7_6sparql7algebra6UpdateNtB1I_12QueryOptionsE0CslmM25dSh1d8_18sparql_update_eval:
  464|  4.99k|            .transaction(|mut t| evaluate_update(&mut t, &update, &options))
_RNvMNtCs2ek33vt1YA5_8oxigraph5storeNtB2_5Store3new:
   89|      1|    pub fn new() -> Result<Self, StorageError> {
   90|      1|        Ok(Self {
   91|      1|            storage: Storage::new()?,
   92|       |        })
   93|      1|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph5storeNtB2_5Store4iter:
  317|  4.99k|    pub fn iter(&self) -> QuadIter {
  318|  4.99k|        self.quads_for_pattern(None, None, None, None)
  319|  4.99k|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph5storeNtB2_5Store5clear:
  931|  4.99k|    pub fn clear(&self) -> Result<(), StorageError> {
  932|  4.99k|        self.transaction(|mut t| t.clear())
  933|  4.99k|    }
_RNvXs3_NtCs2ek33vt1YA5_8oxigraph5storeNtB5_8QuadIterNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 1550|  7.78k|    fn next(&mut self) -> Option<Self::Item> {
 1551|  7.78k|        Some(match self.iter.next()? {
 1552|  2.78k|            Ok(quad) => self.reader.decode_quad(&quad),
 1553|      0|            Err(error) => Err(error),
 1554|       |        })
 1555|  7.78k|    }
_RNvMNtCs2ek33vt1YA5_8oxigraph5storeNtB2_5Store17quads_for_pattern:
  279|  4.99k|    pub fn quads_for_pattern(
  280|  4.99k|        &self,
  281|  4.99k|        subject: Option<SubjectRef<'_>>,
  282|  4.99k|        predicate: Option<NamedNodeRef<'_>>,
  283|  4.99k|        object: Option<TermRef<'_>>,
  284|  4.99k|        graph_name: Option<GraphNameRef<'_>>,
  285|  4.99k|    ) -> QuadIter {
  286|  4.99k|        let reader = self.storage.snapshot();
  287|  4.99k|        QuadIter {
  288|  4.99k|            iter: reader.quads_for_pattern(
  289|  4.99k|                subject.map(EncodedTerm::from).as_ref(),
  290|  4.99k|                predicate.map(EncodedTerm::from).as_ref(),
  291|  4.99k|                object.map(EncodedTerm::from).as_ref(),
  292|  4.99k|                graph_name.map(EncodedTerm::from).as_ref(),
  293|  4.99k|            ),
  294|  4.99k|            reader,
  295|  4.99k|        }
  296|  4.99k|    }
_RNvMs1_NtCs2ek33vt1YA5_8oxigraph5storeNtB5_11Transaction5clear:
 1526|  4.99k|    pub fn clear(&mut self) -> Result<(), StorageError> {
 1527|  4.99k|        self.writer.clear()
 1528|  4.99k|    }
_RNCINvMNtCs2ek33vt1YA5_8oxigraph5storeNtB5_5Store11transactionuNtNtNtB7_7storage5error12StorageErrorNCNvB4_5clear0E0B7_:
  411|  4.99k|        self.storage.transaction(|writer| f(Transaction { writer }))
_RINvMNtCs2ek33vt1YA5_8oxigraph5storeNtB3_5Store11transactionuNtNtNtB5_7storage5error12StorageErrorNCNvB2_5clear0EB5_:
  407|  4.99k|    pub fn transaction<'a, 'b: 'a, T, E: Error + 'static + From<StorageError>>(
  408|  4.99k|        &'b self,
  409|  4.99k|        f: impl Fn(Transaction<'a>) -> Result<T, E>,
  410|  4.99k|    ) -> Result<T, E> {
  411|  4.99k|        self.storage.transaction(|writer| f(Transaction { writer }))
  412|  4.99k|    }
_RNCNvMNtCs2ek33vt1YA5_8oxigraph5storeNtB4_5Store5clear0B6_:
  932|  4.99k|        self.transaction(|mut t| t.clear())

_RNvXsH_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStrNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  249|  9.91k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsk_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_16BlankNodeContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   22|  9.91k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsd_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_9BlankNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   19|  9.91k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsH_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStrNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
  249|  71.6k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsb_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_9BlankNodeNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   19|  42.6k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsd_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_9BlankNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   19|  71.6k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsg_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_16BlankNodeContentNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   22|  42.6k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsD_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStrNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
  249|  40.3k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsk_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_16BlankNodeContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   22|  71.6k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RINvXsl_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB6_16BlankNodeContentNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECshSv3hUzq9FP_9spargebra:
   22|   108k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RINvXse_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB6_9BlankNodeNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECshSv3hUzq9FP_9spargebra:
   19|   108k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXsI_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB6_5IdStrNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECshSv3hUzq9FP_9spargebra:
  249|   108k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsH_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStrNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
  249|  52.6k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvMs7_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStr3newCshSv3hUzq9FP_9spargebra:
  254|  47.0k|    fn new(id: u128) -> Self {
  255|  47.0k|        let mut str = [0; 32];
  256|  47.0k|        write!(&mut str[..], "{id:x}").unwrap();
  257|  47.0k|        Self(str)
  258|  47.0k|    }
_RNvXsk_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_16BlankNodeContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   22|  52.6k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvMs7_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_5IdStr6as_strCshSv3hUzq9FP_9spargebra:
  261|  47.0k|    fn as_str(&self) -> &str {
  262|  47.0k|        let len = self.0.iter().position(|x| x == &0).unwrap_or(32);
  263|  47.0k|        str::from_utf8(&self.0[..len]).unwrap()
  264|  47.0k|    }
_RNvXsd_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_9BlankNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   19|  52.6k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs0_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB5_9BlankNodeNtNtCs9nhK3FOW46N_4core7default7Default7defaultCshSv3hUzq9FP_9spargebra:
  108|  18.8k|    fn default() -> Self {
  109|       |        // We ensure the ID does not start with a number to be also valid with RDF/XML
  110|  47.0k|        loop {
  111|  47.0k|            let id = random();
  112|  47.0k|            let str = IdStr::new(id);
  113|  47.0k|            if matches!(str.as_str().as_bytes().first(), Some(b'a'..=b'f')) {
  114|  18.8k|                return Self(BlankNodeContent::Anonymous { id, str });
  115|  28.1k|            }
  116|       |        }
  117|  18.8k|    }
_RNCNvMs7_NtCshJ9d6mhVUZV_5oxrdf10blank_nodeNtB7_5IdStr6as_str0B9_:
  262|  1.50M|        let len = self.0.iter().position(|x| x == &0).unwrap_or(32);

_RINvXs4_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB6_7DatasetINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect6ExtendNtNtB8_6triple4QuadE6extendINtNtBU_8adapters12GenericShuntNtNtCs2ek33vt1YA5_8oxigraph5store8QuadIterINtNtBW_6result6ResultNtNtBW_7convert10InfallibleNtNtNtB2G_7storage5error12StorageErrorEEECslmM25dSh1d8_18sparql_update_eval:
  973|  4.99k|    fn extend<I: IntoIterator<Item = Quad>>(&mut self, iter: I) {
  974|  7.78k|        for t in iter {
  975|  2.78k|            self.insert(&t);
  976|  2.78k|        }
  977|  4.99k|    }
_RINvXs2_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB6_7DatasetINtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect12FromIteratorNtNtB8_6triple4QuadE9from_iterINtNtBU_8adapters12GenericShuntNtNtCs2ek33vt1YA5_8oxigraph5store8QuadIterINtNtBW_6result6ResultNtNtBW_7convert10InfallibleNtNtNtB2Q_7storage5error12StorageErrorEEECslmM25dSh1d8_18sparql_update_eval:
  957|  4.99k|    fn from_iter<I: IntoIterator<Item = Quad>>(iter: I) -> Self {
  958|  4.99k|        let mut g = Self::new();
  959|  4.99k|        g.extend(iter);
  960|  4.99k|        g
  961|  4.99k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset6insertRNtNtB5_6triple4QuadECslmM25dSh1d8_18sparql_update_eval:
  360|  2.78k|    pub fn insert<'a>(&mut self, quad: impl Into<QuadRef<'a>>) -> bool {
  361|  2.78k|        let quad = self.encode_quad(quad.into());
  362|  2.78k|        self.insert_encoded(quad)
  363|  2.78k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset12canonicalize:
  539|  4.99k|    pub fn canonicalize(&mut self, algorithm: CanonicalizationAlgorithm) {
  540|  4.99k|        let bnode_mapping = self.canonicalize_interned_blank_nodes(algorithm);
  541|  4.99k|        let new_quads = self.map_blank_nodes(&bnode_mapping);
  542|  4.99k|        self.clear();
  543|  7.78k|        for quad in new_quads {
  544|  2.78k|            self.insert_encoded(quad);
  545|  2.78k|        }
  546|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset11blank_nodes:
  582|  4.99k|    fn blank_nodes(&self) -> HashSet<InternedBlankNode> {
  583|  4.99k|        let mut bnodes = HashSet::new();
  584|  7.78k|        for (g, s, _, o) in &self.gspo {
  585|  2.78k|            if let InternedSubject::BlankNode(bnode) = s {
  586|      0|                bnodes.insert(*bnode);
  587|  2.78k|            }
  588|       |            #[cfg(feature = "rdf-star")]
  589|  2.78k|            if let InternedSubject::Triple(triple) = s {
  590|      0|                Self::triple_blank_nodes(triple, &mut bnodes);
  591|  2.78k|            }
  592|  2.78k|            if let InternedTerm::BlankNode(bnode) = o {
  593|      0|                bnodes.insert(*bnode);
  594|  2.78k|            }
  595|       |            #[cfg(feature = "rdf-star")]
  596|  2.78k|            if let InternedTerm::Triple(triple) = o {
  597|      0|                Self::triple_blank_nodes(triple, &mut bnodes);
  598|  2.78k|            }
  599|  2.78k|            if let InternedGraphName::BlankNode(bnode) = g {
  600|      0|                bnodes.insert(*bnode);
  601|  2.78k|            }
  602|       |        }
  603|  4.99k|        bnodes
  604|  4.99k|    }
_RNvXsg_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB5_4IterNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next:
 1551|  3.89k|    fn next(&mut self) -> Option<Self::Item> {
 1552|  3.89k|        self.inner
 1553|  3.89k|            .next()
 1554|  3.89k|            .map(|(s, p, o, g)| self.dataset.decode_spog((s, p, o, g)))
 1555|  3.89k|    }
_RNvXsj_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB5_7DatasetNtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
   66|  4.99k|#[derive(Debug, Default, Clone)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset11decode_spog:
  479|  1.39k|    fn decode_spog(
  480|  1.39k|        &self,
  481|  1.39k|        quad: (
  482|  1.39k|            &InternedSubject,
  483|  1.39k|            &InternedNamedNode,
  484|  1.39k|            &InternedTerm,
  485|  1.39k|            &InternedGraphName,
  486|  1.39k|        ),
  487|  1.39k|    ) -> QuadRef<'_> {
  488|  1.39k|        QuadRef {
  489|  1.39k|            subject: quad.0.decode_from(&self.interner),
  490|  1.39k|            predicate: quad.1.decode_from(&self.interner),
  491|  1.39k|            object: quad.2.decode_from(&self.interner),
  492|  1.39k|            graph_name: quad.3.decode_from(&self.interner),
  493|  1.39k|        }
  494|  1.39k|    }
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB4_7DatasetNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eq:
  932|  2.49k|    fn eq(&self, other: &Self) -> bool {
  933|  2.49k|        if self.len() != other.len() {
  934|      0|            return false;
  935|  2.49k|        }
  936|  3.89k|        for q in self {
  937|  1.39k|            if !other.contains(q) {
  938|      0|                return false;
  939|  1.39k|            }
  940|       |        }
  941|  2.49k|        true
  942|  2.49k|    }
_RNvXs1_NtCshJ9d6mhVUZV_5oxrdf7datasetRNtB5_7DatasetNtNtNtNtCs9nhK3FOW46N_4core4iter6traits7collect12IntoIterator9into_iter:
  951|  2.49k|    fn into_iter(self) -> Self::IntoIter {
  952|  2.49k|        self.iter()
  953|  2.49k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset3len:
  350|  4.99k|    pub fn len(&self) -> usize {
  351|  4.99k|        self.gspo.len()
  352|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset33canonicalize_interned_blank_nodes:
  562|  4.99k|    fn canonicalize_interned_blank_nodes(
  563|  4.99k|        &self,
  564|  4.99k|        algorithm: CanonicalizationAlgorithm,
  565|  4.99k|    ) -> HashMap<InternedBlankNode, BlankNode> {
  566|  4.99k|        match algorithm {
  567|  4.99k|            CanonicalizationAlgorithm::Unstable => {
  568|  4.99k|                let bnodes = self.blank_nodes();
  569|  4.99k|                let quads_per_blank_node = self.quads_per_blank_nodes();
  570|  4.99k|                let (hash, partition) = self.hash_bnodes(
  571|  4.99k|                    bnodes.into_iter().map(|bnode| (bnode, 0)).collect(),
  572|  4.99k|                    &quads_per_blank_node,
  573|  4.99k|                );
  574|  4.99k|                self.distinguish(hash, &partition, &quads_per_blank_node)
  575|  4.99k|                    .into_iter()
  576|  4.99k|                    .map(|(from, to)| (from, BlankNode::new_from_unique_id(to.into())))
  577|  4.99k|                    .collect()
  578|  4.99k|            }
  579|  4.99k|        }
  580|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset11hash_bnodes:
  669|  4.99k|    fn hash_bnodes(
  670|  4.99k|        &self,
  671|  4.99k|        mut hashes: HashMap<InternedBlankNode, u64>,
  672|  4.99k|        quads_per_blank_node: &QuadsPerBlankNode,
  673|  4.99k|    ) -> (
  674|  4.99k|        HashMap<InternedBlankNode, u64>,
  675|  4.99k|        Vec<(u64, Vec<InternedBlankNode>)>,
  676|  4.99k|    ) {
  677|  4.99k|        let mut to_hash = Vec::new();
  678|  4.99k|        let mut to_do = hashes
  679|  4.99k|            .keys()
  680|  4.99k|            .map(|bnode| (*bnode, true))
  681|  4.99k|            .collect::<HashMap<_, _>>();
  682|  4.99k|        let mut partition = HashMap::<_, Vec<_>>::with_capacity(hashes.len());
  683|  4.99k|        let mut old_partition_count = usize::MAX;
  684|  9.99k|        while old_partition_count != partition.len() {
  685|  4.99k|            old_partition_count = partition.len();
  686|  4.99k|            partition.clear();
  687|  4.99k|            let mut new_hashes = hashes.clone();
  688|  4.99k|            for bnode in hashes.keys() {
  689|      0|                let hash = if to_do.contains_key(bnode) {
  690|      0|                    for (s, p, o, g) in &quads_per_blank_node[bnode] {
  691|      0|                        to_hash.push((
  692|      0|                            self.hash_subject(s, *bnode, &hashes),
  693|      0|                            self.hash_named_node(*p),
  694|      0|                            self.hash_term(o, *bnode, &hashes),
  695|      0|                            self.hash_graph_name(g, *bnode, &hashes),
  696|      0|                        ));
  697|      0|                    }
  698|      0|                    to_hash.sort_unstable();
  699|      0|                    let hash = Self::hash_tuple((&to_hash, hashes[bnode]));
  700|      0|                    to_hash.clear();
  701|      0|                    if hash == hashes[bnode] {
  702|      0|                        to_do.insert(*bnode, false);
  703|      0|                    } else {
  704|      0|                        new_hashes.insert(*bnode, hash);
  705|      0|                    }
  706|      0|                    hash
  707|       |                } else {
  708|      0|                    hashes[bnode]
  709|       |                };
  710|      0|                partition.entry(hash).or_default().push(*bnode);
  711|       |            }
  712|  4.99k|            hashes = new_hashes;
  713|       |        }
  714|  4.99k|        let mut partition: Vec<_> = partition.into_iter().collect();
  715|  4.99k|        partition.sort_unstable_by(|(h1, b1), (h2, b2)| (b1.len(), h1).cmp(&(b2.len(), h2)));
  716|  4.99k|        (hashes, partition)
  717|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset4iter:
  169|  2.49k|    pub fn iter(&self) -> Iter<'_> {
  170|  2.49k|        let iter = self.spog.iter();
  171|  2.49k|        Iter {
  172|  2.49k|            dataset: self,
  173|  2.49k|            inner: iter,
  174|  2.49k|        }
  175|  2.49k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset3new:
  109|  4.99k|    pub fn new() -> Self {
  110|  4.99k|        Self::default()
  111|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset21quads_per_blank_nodes:
  620|  4.99k|    fn quads_per_blank_nodes(&self) -> QuadsPerBlankNode {
  621|  4.99k|        let mut map: HashMap<_, Vec<_>> = HashMap::new();
  622|  7.78k|        for quad in &self.spog {
  623|  2.78k|            if let InternedSubject::BlankNode(bnode) = &quad.0 {
  624|      0|                map.entry(*bnode).or_default().push(quad.clone());
  625|  2.78k|            }
  626|       |            #[cfg(feature = "rdf-star")]
  627|  2.78k|            if let InternedSubject::Triple(t) = &quad.0 {
  628|      0|                Self::add_quad_with_quoted_triple_to_quad_per_blank_nodes_map(quad, t, &mut map);
  629|  2.78k|            }
  630|  2.78k|            if let InternedTerm::BlankNode(bnode) = &quad.2 {
  631|      0|                map.entry(*bnode).or_default().push(quad.clone());
  632|  2.78k|            }
  633|       |            #[cfg(feature = "rdf-star")]
  634|  2.78k|            if let InternedTerm::Triple(t) = &quad.2 {
  635|      0|                Self::add_quad_with_quoted_triple_to_quad_per_blank_nodes_map(quad, t, &mut map);
  636|  2.78k|            }
  637|  2.78k|            if let InternedGraphName::BlankNode(bnode) = &quad.3 {
  638|      0|                map.entry(*bnode).or_default().push(quad.clone());
  639|  2.78k|            }
  640|       |        }
  641|  4.99k|        map
  642|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset11distinguish:
  809|  4.99k|    fn distinguish(
  810|  4.99k|        &self,
  811|  4.99k|        hash: HashMap<InternedBlankNode, u64>,
  812|  4.99k|        partition: &[(u64, Vec<InternedBlankNode>)],
  813|  4.99k|        quads_per_blank_node: &QuadsPerBlankNode,
  814|  4.99k|    ) -> HashMap<InternedBlankNode, u64> {
  815|  4.99k|        let b_prime = partition.iter().map(|(_, b)| b).find(|b| b.len() > 1);
  816|  4.99k|        if let Some(b_prime) = b_prime {
  817|      0|            b_prime
  818|      0|                .iter()
  819|      0|                .map(|b| {
  820|       |                    let mut hash_prime = hash.clone();
  821|       |                    hash_prime.insert(*b, Self::hash_tuple((hash_prime[b], 22)));
  822|       |                    let (hash_prime_prime, partition_prime) =
  823|       |                        self.hash_bnodes(hash_prime, quads_per_blank_node);
  824|       |                    self.distinguish(hash_prime_prime, &partition_prime, quads_per_blank_node)
  825|      0|                })
  826|      0|                .reduce(|a, b| {
  827|       |                    let mut a_hashes = a.values().collect::<Vec<_>>();
  828|       |                    a_hashes.sort();
  829|       |                    let mut b_hashes = a.values().collect::<Vec<_>>();
  830|       |                    b_hashes.sort();
  831|       |                    if a_hashes <= b_hashes {
  832|       |                        a
  833|       |                    } else {
  834|       |                        b
  835|       |                    }
  836|      0|                })
  837|      0|                .unwrap_or_default()
  838|       |        } else {
  839|  4.99k|            hash
  840|       |        }
  841|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset11encode_quad:
  420|  2.78k|    fn encode_quad(
  421|  2.78k|        &mut self,
  422|  2.78k|        quad: QuadRef<'_>,
  423|  2.78k|    ) -> (
  424|  2.78k|        InternedSubject,
  425|  2.78k|        InternedNamedNode,
  426|  2.78k|        InternedTerm,
  427|  2.78k|        InternedGraphName,
  428|  2.78k|    ) {
  429|  2.78k|        (
  430|  2.78k|            InternedSubject::encoded_into(quad.subject, &mut self.interner),
  431|  2.78k|            InternedNamedNode::encoded_into(quad.predicate, &mut self.interner),
  432|  2.78k|            InternedTerm::encoded_into(quad.object, &mut self.interner),
  433|  2.78k|            InternedGraphName::encoded_into(quad.graph_name, &mut self.interner),
  434|  2.78k|        )
  435|  2.78k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset14insert_encoded:
  365|  5.56k|    fn insert_encoded(
  366|  5.56k|        &mut self,
  367|  5.56k|        quad: (
  368|  5.56k|            InternedSubject,
  369|  5.56k|            InternedNamedNode,
  370|  5.56k|            InternedTerm,
  371|  5.56k|            InternedGraphName,
  372|  5.56k|        ),
  373|  5.56k|    ) -> bool {
  374|  5.56k|        let (s, p, o, g) = quad;
  375|  5.56k|        self.gspo.insert((g.clone(), s.clone(), p, o.clone()));
  376|  5.56k|        self.gpos.insert((g.clone(), p, o.clone(), s.clone()));
  377|  5.56k|        self.gosp.insert((g.clone(), o.clone(), s.clone(), p));
  378|  5.56k|        self.spog.insert((s.clone(), p, o.clone(), g.clone()));
  379|  5.56k|        self.posg.insert((p, o.clone(), s.clone(), g.clone()));
  380|  5.56k|        self.ospg.insert((o, s, p, g))
  381|  5.56k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset12encoded_quad:
  437|  1.39k|    fn encoded_quad(
  438|  1.39k|        &self,
  439|  1.39k|        quad: QuadRef<'_>,
  440|  1.39k|    ) -> Option<(
  441|  1.39k|        InternedSubject,
  442|  1.39k|        InternedNamedNode,
  443|  1.39k|        InternedTerm,
  444|  1.39k|        InternedGraphName,
  445|  1.39k|    )> {
  446|  1.39k|        Some((
  447|  1.39k|            self.encoded_subject(quad.subject)?,
  448|  1.39k|            self.encoded_named_node(quad.predicate)?,
  449|  1.39k|            self.encoded_term(quad.object)?,
  450|  1.39k|            self.encoded_graph_name(quad.graph_name)?,
  451|       |        ))
  452|  1.39k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset5clear:
  411|  4.99k|    pub fn clear(&mut self) {
  412|  4.99k|        self.gspo.clear();
  413|  4.99k|        self.gpos.clear();
  414|  4.99k|        self.gosp.clear();
  415|  4.99k|        self.spog.clear();
  416|  4.99k|        self.posg.clear();
  417|  4.99k|        self.ospg.clear();
  418|  4.99k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB2_7Dataset15map_blank_nodes:
  844|  4.99k|    fn map_blank_nodes(
  845|  4.99k|        &mut self,
  846|  4.99k|        bnode_mapping: &HashMap<InternedBlankNode, BlankNode>,
  847|  4.99k|    ) -> Vec<(
  848|  4.99k|        InternedSubject,
  849|  4.99k|        InternedNamedNode,
  850|  4.99k|        InternedTerm,
  851|  4.99k|        InternedGraphName,
  852|  4.99k|    )> {
  853|  4.99k|        let old_quads: Vec<_> = self.spog.iter().cloned().collect();
  854|  4.99k|        old_quads
  855|  4.99k|            .into_iter()
  856|  4.99k|            .map(|(s, p, o, g)| {
  857|       |                (
  858|       |                    match s {
  859|       |                        InternedSubject::NamedNode(_) => s,
  860|       |                        InternedSubject::BlankNode(bnode) => {
  861|       |                            InternedSubject::BlankNode(InternedBlankNode::encoded_into(
  862|       |                                bnode_mapping[&bnode].as_ref(),
  863|       |                                &mut self.interner,
  864|       |                            ))
  865|       |                        }
  866|       |                        #[cfg(feature = "rdf-star")]
  867|       |                        InternedSubject::Triple(triple) => {
  868|       |                            InternedSubject::Triple(Box::new(InternedTriple::encoded_into(
  869|       |                                self.map_triple_blank_nodes(&triple, bnode_mapping).as_ref(),
  870|       |                                &mut self.interner,
  871|       |                            )))
  872|       |                        }
  873|       |                    },
  874|       |                    p,
  875|       |                    match o {
  876|       |                        InternedTerm::NamedNode(_) | InternedTerm::Literal(_) => o,
  877|       |                        InternedTerm::BlankNode(bnode) => {
  878|       |                            InternedTerm::BlankNode(InternedBlankNode::encoded_into(
  879|       |                                bnode_mapping[&bnode].as_ref(),
  880|       |                                &mut self.interner,
  881|       |                            ))
  882|       |                        }
  883|       |                        #[cfg(feature = "rdf-star")]
  884|       |                        InternedTerm::Triple(triple) => {
  885|       |                            InternedTerm::Triple(Box::new(InternedTriple::encoded_into(
  886|       |                                self.map_triple_blank_nodes(&triple, bnode_mapping).as_ref(),
  887|       |                                &mut self.interner,
  888|       |                            )))
  889|       |                        }
  890|       |                    },
  891|       |                    match g {
  892|       |                        InternedGraphName::NamedNode(_) | InternedGraphName::DefaultGraph => g,
  893|       |                        InternedGraphName::BlankNode(bnode) => {
  894|       |                            InternedGraphName::BlankNode(InternedBlankNode::encoded_into(
  895|       |                                bnode_mapping[&bnode].as_ref(),
  896|       |                                &mut self.interner,
  897|       |                            ))
  898|       |                        }
  899|       |                    },
  900|       |                )
  901|  4.99k|            })
  902|  4.99k|            .collect()
  903|  4.99k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset18encoded_graph_nameNtNtB5_6triple12GraphNameRefEB5_:
  472|  1.39k|    pub(super) fn encoded_graph_name<'a>(
  473|  1.39k|        &self,
  474|  1.39k|        graph_name: impl Into<GraphNameRef<'a>>,
  475|  1.39k|    ) -> Option<InternedGraphName> {
  476|  1.39k|        InternedGraphName::encoded_from(graph_name.into(), &self.interner)
  477|  1.39k|    }
_RNCNvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB4_7Dataset15map_blank_nodes0B6_:
  856|  2.78k|            .map(|(s, p, o, g)| {
  857|  2.78k|                (
  858|  2.78k|                    match s {
  859|  2.78k|                        InternedSubject::NamedNode(_) => s,
  860|      0|                        InternedSubject::BlankNode(bnode) => {
  861|      0|                            InternedSubject::BlankNode(InternedBlankNode::encoded_into(
  862|      0|                                bnode_mapping[&bnode].as_ref(),
  863|      0|                                &mut self.interner,
  864|      0|                            ))
  865|       |                        }
  866|       |                        #[cfg(feature = "rdf-star")]
  867|      0|                        InternedSubject::Triple(triple) => {
  868|      0|                            InternedSubject::Triple(Box::new(InternedTriple::encoded_into(
  869|      0|                                self.map_triple_blank_nodes(&triple, bnode_mapping).as_ref(),
  870|      0|                                &mut self.interner,
  871|      0|                            )))
  872|       |                        }
  873|       |                    },
  874|  2.78k|                    p,
  875|  2.78k|                    match o {
  876|  2.78k|                        InternedTerm::NamedNode(_) | InternedTerm::Literal(_) => o,
  877|      0|                        InternedTerm::BlankNode(bnode) => {
  878|      0|                            InternedTerm::BlankNode(InternedBlankNode::encoded_into(
  879|      0|                                bnode_mapping[&bnode].as_ref(),
  880|      0|                                &mut self.interner,
  881|      0|                            ))
  882|       |                        }
  883|       |                        #[cfg(feature = "rdf-star")]
  884|      0|                        InternedTerm::Triple(triple) => {
  885|      0|                            InternedTerm::Triple(Box::new(InternedTriple::encoded_into(
  886|      0|                                self.map_triple_blank_nodes(&triple, bnode_mapping).as_ref(),
  887|      0|                                &mut self.interner,
  888|      0|                            )))
  889|       |                        }
  890|       |                    },
  891|  2.78k|                    match g {
  892|  2.78k|                        InternedGraphName::NamedNode(_) | InternedGraphName::DefaultGraph => g,
  893|      0|                        InternedGraphName::BlankNode(bnode) => {
  894|      0|                            InternedGraphName::BlankNode(InternedBlankNode::encoded_into(
  895|      0|                                bnode_mapping[&bnode].as_ref(),
  896|      0|                                &mut self.interner,
  897|      0|                            ))
  898|       |                        }
  899|       |                    },
  900|       |                )
  901|  2.78k|            })
_RNCNvXsg_NtCshJ9d6mhVUZV_5oxrdf7datasetNtB7_4IterNtNtNtNtCs9nhK3FOW46N_4core4iter6traits8iterator8Iterator4next0B9_:
 1554|  1.39k|            .map(|(s, p, o, g)| self.dataset.decode_spog((s, p, o, g)))
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset18encoded_named_nodeNtNtB5_10named_node12NamedNodeRefEB5_:
  454|  1.39k|    pub(super) fn encoded_named_node<'a>(
  455|  1.39k|        &self,
  456|  1.39k|        node: impl Into<NamedNodeRef<'a>>,
  457|  1.39k|    ) -> Option<InternedNamedNode> {
  458|  1.39k|        InternedNamedNode::encoded_from(node.into(), &self.interner)
  459|  1.39k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset15encoded_subjectNtNtB5_6triple10SubjectRefEB5_:
  461|  1.39k|    pub(super) fn encoded_subject<'a>(
  462|  1.39k|        &self,
  463|  1.39k|        node: impl Into<SubjectRef<'a>>,
  464|  1.39k|    ) -> Option<InternedSubject> {
  465|  1.39k|        InternedSubject::encoded_from(node.into(), &self.interner)
  466|  1.39k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset12encoded_termNtNtB5_6triple7TermRefEB5_:
  468|  1.39k|    pub(super) fn encoded_term<'a>(&self, term: impl Into<TermRef<'a>>) -> Option<InternedTerm> {
  469|  1.39k|        InternedTerm::encoded_from(term.into(), &self.interner)
  470|  1.39k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7datasetNtB3_7Dataset8containsNtNtB5_6triple7QuadRefEB5_:
  341|  1.39k|    pub fn contains<'a>(&self, quad: impl Into<QuadRef<'a>>) -> bool {
  342|  1.39k|        if let Some(q) = self.encoded_quad(quad.into()) {
  343|  1.39k|            self.spog.contains(&q)
  344|       |        } else {
  345|      0|            false
  346|       |        }
  347|  1.39k|    }

_RNvMNtCshJ9d6mhVUZV_5oxrdf9interningNtB2_8Interner4hash:
   53|  18.7k|    fn hash(&self, value: &str) -> u64 {
   54|  18.7k|        let mut hasher = self.hasher.build_hasher();
   55|  18.7k|        hasher.write(value.as_bytes());
   56|  18.7k|        let hash = hasher.finish();
   57|  18.7k|        if hash == u64::MAX {
   58|      0|            0
   59|       |        } else {
   60|  18.7k|            hash
   61|       |        }
   62|  18.7k|    }
_RNvMs5_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_12InternedTerm11decode_from:
  436|  1.39k|    pub fn decode_from<'a>(&self, interner: &'a Interner) -> TermRef<'a> {
  437|  1.39k|        match self {
  438|    478|            Self::NamedNode(term) => TermRef::NamedNode(term.decode_from(interner)),
  439|      0|            Self::BlankNode(term) => TermRef::BlankNode(term.decode_from(interner)),
  440|    914|            Self::Literal(term) => TermRef::Literal(term.decode_from(interner)),
  441|       |            #[cfg(feature = "rdf-star")]
  442|      0|            Self::Triple(triple) => TermRef::Triple(&interner.triples[triple.as_ref()]),
  443|       |        }
  444|  1.39k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf9interningNtB2_8Interner13get_or_intern:
   18|  12.4k|    fn get_or_intern(&mut self, value: &str) -> Key {
   19|  12.4k|        let mut hash = self.hash(value);
   20|  12.4k|        loop {
   21|  12.4k|            match self.string_for_hash.entry(hash) {
   22|  3.67k|                Entry::Vacant(e) => {
   23|  3.67k|                    e.insert(value.into());
   24|  3.67k|                    return Key(hash);
   25|       |                }
   26|  8.79k|                Entry::Occupied(e) => loop {
   27|  8.79k|                    if e.get() == value {
   28|  8.79k|                        return Key(hash);
   29|      0|                    } else if hash == u64::MAX - 1 {
   30|      0|                        hash = 0;
   31|      0|                    } else {
   32|      0|                        hash += 1;
   33|      0|                    }
   34|       |                },
   35|       |            }
   36|       |        }
   37|  12.4k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf9interningNtB2_8Interner3get:
   39|  6.23k|    fn get(&self, value: &str) -> Option<Key> {
   40|  6.23k|        let mut hash = self.hash(value);
   41|       |        loop {
   42|  6.23k|            let v = self.string_for_hash.get(&hash)?;
   43|  6.23k|            if v == value {
   44|  6.23k|                return Some(Key(hash));
   45|      0|            } else if hash == u64::MAX - 1 {
   46|      0|                hash = 0;
   47|      0|            } else {
   48|      0|                hash += 1;
   49|      0|            }
   50|       |        }
   51|  6.23k|    }
_RNvMs5_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_12InternedTerm12encoded_from:
  419|  1.39k|    pub fn encoded_from(term: TermRef<'_>, interner: &Interner) -> Option<Self> {
  420|  1.39k|        Some(match term {
  421|    478|            TermRef::NamedNode(term) => {
  422|    478|                Self::NamedNode(InternedNamedNode::encoded_from(term, interner)?)
  423|       |            }
  424|      0|            TermRef::BlankNode(term) => {
  425|      0|                Self::BlankNode(InternedBlankNode::encoded_from(term, interner)?)
  426|       |            }
  427|    914|            TermRef::Literal(term) => Self::Literal(InternedLiteral::encoded_from(term, interner)?),
  428|       |            #[cfg(feature = "rdf-star")]
  429|      0|            TermRef::Triple(triple) => Self::Triple(Box::new(InternedTriple::encoded_from(
  430|      0|                triple.as_ref(),
  431|      0|                interner,
  432|      0|            )?)),
  433|       |        })
  434|  1.39k|    }
_RNvXs7_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_21IdentityHasherBuilderNtNtCs9nhK3FOW46N_4core4hash11BuildHasher12build_hasher:
  513|  27.6k|    fn build_hasher(&self) -> Self::Hasher {
  514|  27.6k|        Self::Hasher::default()
  515|  27.6k|    }
_RNvXsX_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedSubjectNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  267|  30.6k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXs1c_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_12InternedTermNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB8_:
  392|  31.8k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedGraphName11decode_from:
  367|  1.39k|    pub fn decode_from<'a>(&self, interner: &'a Interner) -> GraphNameRef<'a> {
  368|  1.39k|        match self {
  369|    213|            Self::DefaultGraph => GraphNameRef::DefaultGraph,
  370|  1.17k|            Self::NamedNode(node) => GraphNameRef::NamedNode(node.decode_from(interner)),
  371|      0|            Self::BlankNode(node) => GraphNameRef::BlankNode(node.decode_from(interner)),
  372|       |        }
  373|  1.39k|    }
_RNvMs5_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_12InternedTerm12encoded_into:
  402|  2.78k|    pub fn encoded_into(term: TermRef<'_>, interner: &mut Interner) -> Self {
  403|  2.78k|        match term {
  404|    956|            TermRef::NamedNode(term) => {
  405|    956|                Self::NamedNode(InternedNamedNode::encoded_into(term, interner))
  406|       |            }
  407|      0|            TermRef::BlankNode(term) => {
  408|      0|                Self::BlankNode(InternedBlankNode::encoded_into(term, interner))
  409|       |            }
  410|  1.82k|            TermRef::Literal(term) => Self::Literal(InternedLiteral::encoded_into(term, interner)),
  411|       |            #[cfg(feature = "rdf-star")]
  412|      0|            TermRef::Triple(triple) => Self::Triple(Box::new(InternedTriple::encoded_into(
  413|      0|                triple.as_ref(),
  414|      0|                interner,
  415|      0|            ))),
  416|       |        }
  417|  2.78k|    }
_RNvXsq_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedNamedNodeNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB7_:
   86|   108k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvXst_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedNamedNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
   86|  69.8k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvXs1f_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_12InternedTermNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  392|  30.6k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsK_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedLiteralNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB7_:
  174|  15.1k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvXsN_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedLiteralNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  174|  20.1k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedGraphName12encoded_from:
  355|  1.39k|    pub fn encoded_from(node: GraphNameRef<'_>, interner: &Interner) -> Option<Self> {
  356|  1.39k|        Some(match node {
  357|    213|            GraphNameRef::DefaultGraph => Self::DefaultGraph,
  358|  1.17k|            GraphNameRef::NamedNode(node) => {
  359|  1.17k|                Self::NamedNode(InternedNamedNode::encoded_from(node, interner)?)
  360|       |            }
  361|      0|            GraphNameRef::BlankNode(node) => {
  362|      0|                Self::BlankNode(InternedBlankNode::encoded_from(node, interner)?)
  363|       |            }
  364|       |        })
  365|  1.39k|    }
_RNvMs2_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedLiteral11decode_from:
  228|    914|    pub fn decode_from<'a>(&self, interner: &'a Interner) -> LiteralRef<'a> {
  229|    914|        match self {
  230|     35|            Self::String { value_id } => {
  231|     35|                LiteralRef::new_simple_literal(interner.resolve(*value_id))
  232|       |            }
  233|       |            Self::LanguageTaggedString {
  234|    289|                value_id,
  235|    289|                language_id,
  236|    289|            } => LiteralRef::new_language_tagged_literal_unchecked(
  237|    289|                interner.resolve(*value_id),
  238|    289|                interner.resolve(*language_id),
  239|    289|            ),
  240|    590|            Self::TypedLiteral { value_id, datatype } => LiteralRef::new_typed_literal(
  241|    590|                interner.resolve(*value_id),
  242|    590|                datatype.decode_from(interner),
  243|    590|            ),
  244|       |        }
  245|    914|    }
_RNvMs3_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedSubject11decode_from:
  308|  1.39k|    pub fn decode_from<'a>(&self, interner: &'a Interner) -> SubjectRef<'a> {
  309|  1.39k|        match self {
  310|  1.39k|            Self::NamedNode(node) => SubjectRef::NamedNode(node.decode_from(interner)),
  311|      0|            Self::BlankNode(node) => SubjectRef::BlankNode(node.decode_from(interner)),
  312|       |            #[cfg(feature = "rdf-star")]
  313|      0|            Self::Triple(triple) => SubjectRef::Triple(&interner.triples[triple.as_ref()]),
  314|       |        }
  315|  1.39k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedGraphName12encoded_into:
  343|  2.78k|    pub fn encoded_into(node: GraphNameRef<'_>, interner: &mut Interner) -> Self {
  344|  2.78k|        match node {
  345|    426|            GraphNameRef::DefaultGraph => Self::DefaultGraph,
  346|  2.35k|            GraphNameRef::NamedNode(node) => {
  347|  2.35k|                Self::NamedNode(InternedNamedNode::encoded_into(node, interner))
  348|       |            }
  349|      0|            GraphNameRef::BlankNode(node) => {
  350|      0|                Self::BlankNode(InternedBlankNode::encoded_into(node, interner))
  351|       |            }
  352|       |        }
  353|  2.78k|    }
_RNvMs0_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedNamedNode12encoded_from:
   98|  5.03k|    pub fn encoded_from(named_node: NamedNodeRef<'_>, interner: &Interner) -> Option<Self> {
   99|  5.03k|        Some(Self {
  100|  5.03k|            id: interner.get(named_node.as_str())?,
  101|       |        })
  102|  5.03k|    }
_RNvMs0_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedNamedNode11decode_from:
  104|  5.03k|    pub fn decode_from(self, interner: &Interner) -> NamedNodeRef<'_> {
  105|  5.03k|        NamedNodeRef::new_unchecked(interner.resolve(self.id))
  106|  5.03k|    }
_RNvXs8_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_14IdentityHasherNtNtCs9nhK3FOW46N_4core4hash6Hasher9write_u64:
  532|  27.6k|    fn write_u64(&mut self, i: u64) {
  533|  27.6k|        self.value = i
  534|  27.6k|    }
_RNvMs2_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedLiteral12encoded_from:
  209|    914|    pub fn encoded_from(literal: LiteralRef<'_>, interner: &Interner) -> Option<Self> {
  210|    914|        let value_id = interner.get(literal.value())?;
  211|    914|        Some(if literal.is_plain() {
  212|    324|            if let Some(language) = literal.language() {
  213|       |                Self::LanguageTaggedString {
  214|    289|                    value_id,
  215|    289|                    language_id: interner.get(language)?,
  216|       |                }
  217|       |            } else {
  218|     35|                Self::String { value_id }
  219|       |            }
  220|       |        } else {
  221|       |            Self::TypedLiteral {
  222|    590|                value_id,
  223|    590|                datatype: InternedNamedNode::encoded_from(literal.datatype(), interner)?,
  224|       |            }
  225|       |        })
  226|    914|    }
_RNvMs3_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedSubject12encoded_from:
  292|  1.39k|    pub fn encoded_from(node: SubjectRef<'_>, interner: &Interner) -> Option<Self> {
  293|  1.39k|        Some(match node {
  294|  1.39k|            SubjectRef::NamedNode(node) => {
  295|  1.39k|                Self::NamedNode(InternedNamedNode::encoded_from(node, interner)?)
  296|       |            }
  297|      0|            SubjectRef::BlankNode(node) => {
  298|      0|                Self::BlankNode(InternedBlankNode::encoded_from(node, interner)?)
  299|       |            }
  300|       |            #[cfg(feature = "rdf-star")]
  301|      0|            SubjectRef::Triple(triple) => Self::Triple(Box::new(InternedTriple::encoded_from(
  302|      0|                triple.as_ref(),
  303|      0|                interner,
  304|      0|            )?)),
  305|       |        })
  306|  1.39k|    }
_RNvXsa_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_8InternerNtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
    7|  4.99k|#[derive(Debug, Default, Clone)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf9interningNtB2_8Interner7resolve:
   64|  6.23k|    fn resolve(&self, key: Key) -> &str {
   65|  6.23k|        &self.string_for_hash[&key.0]
   66|  6.23k|    }
_RNvXsg_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_3KeyNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB7_:
   69|   120k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvMs2_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedLiteral12encoded_into:
  190|  1.82k|    pub fn encoded_into(literal: LiteralRef<'_>, interner: &mut Interner) -> Self {
  191|  1.82k|        let value_id = interner.get_or_intern(literal.value());
  192|  1.82k|        if literal.is_plain() {
  193|    648|            if let Some(language) = literal.language() {
  194|    578|                Self::LanguageTaggedString {
  195|    578|                    value_id,
  196|    578|                    language_id: interner.get_or_intern(language),
  197|    578|                }
  198|       |            } else {
  199|     70|                Self::String { value_id }
  200|       |            }
  201|       |        } else {
  202|  1.18k|            Self::TypedLiteral {
  203|  1.18k|                value_id,
  204|  1.18k|                datatype: InternedNamedNode::encoded_into(literal.datatype(), interner),
  205|  1.18k|            }
  206|       |        }
  207|  1.82k|    }
_RNvMs3_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedSubject12encoded_into:
  276|  2.78k|    pub fn encoded_into(node: SubjectRef<'_>, interner: &mut Interner) -> Self {
  277|  2.78k|        match node {
  278|  2.78k|            SubjectRef::NamedNode(node) => {
  279|  2.78k|                Self::NamedNode(InternedNamedNode::encoded_into(node, interner))
  280|       |            }
  281|      0|            SubjectRef::BlankNode(node) => {
  282|      0|                Self::BlankNode(InternedBlankNode::encoded_into(node, interner))
  283|       |            }
  284|       |            #[cfg(feature = "rdf-star")]
  285|      0|            SubjectRef::Triple(triple) => Self::Triple(Box::new(InternedTriple::encoded_into(
  286|      0|                triple.as_ref(),
  287|      0|                interner,
  288|      0|            ))),
  289|       |        }
  290|  2.78k|    }
_RNvXs1q_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_21IdentityHasherBuilderNtNtCs9nhK3FOW46N_4core7default7Default7defaultB8_:
  507|  4.99k|#[derive(Default, Clone)]
_RNvXs1s_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_14IdentityHasherNtNtCs9nhK3FOW46N_4core7default7Default7defaultB8_:
  518|  27.6k|#[derive(Default)]
_RNvXs13_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_17InternedGraphNameNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB8_:
  335|  46.0k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXs16_NtCshJ9d6mhVUZV_5oxrdf9interningNtB6_17InternedGraphNameNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  335|  30.6k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsU_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_15InternedSubjectNtNtCs9nhK3FOW46N_4core3cmp3Ord3cmpB7_:
  267|  33.2k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMs0_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_17InternedNamedNode12encoded_into:
   92|  10.0k|    pub fn encoded_into(named_node: NamedNodeRef<'_>, interner: &mut Interner) -> Self {
   93|  10.0k|        Self {
   94|  10.0k|            id: interner.get_or_intern(named_node.as_str()),
   95|  10.0k|        }
   96|  10.0k|    }
_RNvXs8_NtCshJ9d6mhVUZV_5oxrdf9interningNtB5_14IdentityHasherNtNtCs9nhK3FOW46N_4core4hash6Hasher6finish:
  524|  27.6k|    fn finish(&self) -> u64 {
  525|  27.6k|        self.value
  526|  27.6k|    }

_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal6as_refCslmM25dSh1d8_18sparql_update_eval:
  129|  1.82k|    pub fn as_ref(&self) -> LiteralRef<'_> {
  130|  1.82k|        LiteralRef(match &self.0 {
  131|     70|            LiteralContent::String(value) => LiteralRefContent::String(value),
  132|    578|            LiteralContent::LanguageTaggedString { value, language } => {
  133|    578|                LiteralRefContent::LanguageTaggedString { value, language }
  134|       |            }
  135|  1.18k|            LiteralContent::TypedLiteral { value, datatype } => LiteralRefContent::TypedLiteral {
  136|  1.18k|                value,
  137|  1.18k|                datatype: datatype.as_ref(),
  138|  1.18k|            },
  139|       |        })
  140|  1.82k|    }
_RNvXsM_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_14LiteralContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   37|  3.73k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXsF_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   34|  3.73k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal6as_refCs2ek33vt1YA5_8oxigraph:
  129|  12.6k|    pub fn as_ref(&self) -> LiteralRef<'_> {
  130|  12.6k|        LiteralRef(match &self.0 {
  131|    848|            LiteralContent::String(value) => LiteralRefContent::String(value),
  132|  2.89k|            LiteralContent::LanguageTaggedString { value, language } => {
  133|  2.89k|                LiteralRefContent::LanguageTaggedString { value, language }
  134|       |            }
  135|  8.90k|            LiteralContent::TypedLiteral { value, datatype } => LiteralRefContent::TypedLiteral {
  136|  8.90k|                value,
  137|  8.90k|                datatype: datatype.as_ref(),
  138|  8.90k|            },
  139|       |        })
  140|  12.6k|    }
_RNvXsM_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_14LiteralContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   37|  6.41k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef5valueCs2ek33vt1YA5_8oxigraph:
  488|  11.3k|    pub const fn value(self) -> &'a str {
  489|  11.3k|        match self.0 {
  490|    750|            LiteralRefContent::String(value)
  491|  2.77k|            | LiteralRefContent::LanguageTaggedString { value, .. }
  492|  11.3k|            | LiteralRefContent::TypedLiteral { value, .. } => value,
  493|  11.3k|        }
  494|  11.3k|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8languageCs2ek33vt1YA5_8oxigraph:
  501|  2.77k|    pub const fn language(self) -> Option<&'a str> {
  502|  2.77k|        match self.0 {
  503|  2.77k|            LiteralRefContent::LanguageTaggedString { language, .. } => Some(language),
  504|      0|            _ => None,
  505|       |        }
  506|  2.77k|    }
_RNvXsu_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  565|  1.32k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  566|  1.32k|        match self.0 {
  567|     98|            LiteralRefContent::String(value) => print_quoted_str(value, f),
  568|    122|            LiteralRefContent::LanguageTaggedString { value, language } => {
  569|    122|                print_quoted_str(value, f)?;
  570|    122|                write!(f, "@{language}")
  571|       |            }
  572|  1.10k|            LiteralRefContent::TypedLiteral { value, datatype } => {
  573|  1.10k|                print_quoted_str(value, f)?;
  574|  1.10k|                write!(f, "^^{datatype}")
  575|       |            }
  576|       |        }
  577|  1.32k|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8datatypeCs2ek33vt1YA5_8oxigraph:
  513|  11.3k|    pub const fn datatype(self) -> NamedNodeRef<'a> {
  514|  11.3k|        match self.0 {
  515|    750|            LiteralRefContent::String(_) => xsd::STRING,
  516|  2.77k|            LiteralRefContent::LanguageTaggedString { .. } => rdf::LANG_STRING,
  517|  7.80k|            LiteralRefContent::TypedLiteral { datatype, .. } => datatype,
  518|       |        }
  519|  11.3k|    }
_RNvXsh_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes7decimal7DecimalE4fromCs2ek33vt1YA5_8oxigraph:
  330|    660|    fn from(value: Decimal) -> Self {
  331|    660|        Self::new_typed_literal(value.to_string(), xsd::DECIMAL)
  332|    660|    }
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf7literalNtB4_7LiteralNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  157|  1.32k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  158|  1.32k|        self.as_ref().fmt(f)
  159|  1.32k|    }
_RNvXsf_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes6double6DoubleE4fromCs2ek33vt1YA5_8oxigraph:
  314|     68|    fn from(value: Double) -> Self {
  315|     68|        Self::new_typed_literal(value.to_string(), xsd::DOUBLE)
  316|     68|    }
_RNvXsF_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   34|  6.41k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsd_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes7boolean7BooleanE4fromCs2ek33vt1YA5_8oxigraph:
  298|    232|    fn from(value: Boolean) -> Self {
  299|    232|        Self::new_typed_literal(value.to_string(), xsd::BOOLEAN)
  300|    232|    }
_RNvXsg_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCsaP05r1vbY5r_12oxsdatatypes7integer7IntegerE4fromCs2ek33vt1YA5_8oxigraph:
  322|    288|    fn from(value: Integer) -> Self {
  323|    288|        Self::new_typed_literal(value.to_string(), xsd::INTEGER)
  324|    288|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal37new_language_tagged_literal_uncheckedNtNtNtCs2ek33vt1YA5_8oxigraph7storage12small_string11SmallStringB1n_EB1t_:
   85|    604|    pub fn new_language_tagged_literal_unchecked(
   86|    604|        value: impl Into<String>,
   87|    604|        language: impl Into<String>,
   88|    604|    ) -> Self {
   89|    604|        Self(LiteralContent::LanguageTaggedString {
   90|    604|            value: value.into(),
   91|    604|            language: language.into(),
   92|    604|        })
   93|    604|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal18new_simple_literalNtNtNtCs2ek33vt1YA5_8oxigraph7storage12small_string11SmallStringEB1a_:
   47|     75|    pub fn new_simple_literal(value: impl Into<String>) -> Self {
   48|     75|        Self(LiteralContent::String(value.into()))
   49|     75|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal17new_typed_literalNtNtCsjOdcKtOMjJI_5alloc6string6StringNtNtB5_10named_node12NamedNodeRefECs2ek33vt1YA5_8oxigraph:
   53|  1.24k|    pub fn new_typed_literal(value: impl Into<String>, datatype: impl Into<NamedNode>) -> Self {
   54|  1.24k|        let value = value.into();
   55|  1.24k|        let datatype = datatype.into();
   56|  1.24k|        Self(if datatype == xsd::STRING {
   57|      0|            LiteralContent::String(value)
   58|       |        } else {
   59|  1.24k|            LiteralContent::TypedLiteral { value, datatype }
   60|       |        })
   61|  1.24k|    }
_RNvXsD_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   34|      5|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal5valueCsaDAmlQ5xRbD_7sparopt:
   97|  27.2k|    pub fn value(&self) -> &str {
   98|  27.2k|        self.as_ref().value()
   99|  27.2k|    }
_RNvXsM_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_14LiteralContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   37|  9.42k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvXs3_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralINtNtCs9nhK3FOW46N_4core7convert4FrombE4fromCsaDAmlQ5xRbD_7sparopt:
  185|  29.0k|    fn from(value: bool) -> Self {
  186|  29.0k|        Self(LiteralContent::TypedLiteral {
  187|  29.0k|            value: value.to_string(),
  188|  29.0k|            datatype: xsd::BOOLEAN.into(),
  189|  29.0k|        })
  190|  29.0k|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef5valueCsaDAmlQ5xRbD_7sparopt:
  488|  27.2k|    pub const fn value(self) -> &'a str {
  489|  27.2k|        match self.0 {
  490|      6|            LiteralRefContent::String(value)
  491|      0|            | LiteralRefContent::LanguageTaggedString { value, .. }
  492|  27.2k|            | LiteralRefContent::TypedLiteral { value, .. } => value,
  493|  27.2k|        }
  494|  27.2k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal8datatypeCsaDAmlQ5xRbD_7sparopt:
  115|  27.3k|    pub fn datatype(&self) -> NamedNodeRef<'_> {
  116|  27.3k|        self.as_ref().datatype()
  117|  27.3k|    }
_RNvXsI_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_14LiteralContentNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   37|      5|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8datatypeCsaDAmlQ5xRbD_7sparopt:
  513|  27.3k|    pub const fn datatype(self) -> NamedNodeRef<'a> {
  514|  27.3k|        match self.0 {
  515|      6|            LiteralRefContent::String(_) => xsd::STRING,
  516|     30|            LiteralRefContent::LanguageTaggedString { .. } => rdf::LANG_STRING,
  517|  27.3k|            LiteralRefContent::TypedLiteral { datatype, .. } => datatype,
  518|       |        }
  519|  27.3k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal6as_refCsaDAmlQ5xRbD_7sparopt:
  129|  54.6k|    pub fn as_ref(&self) -> LiteralRef<'_> {
  130|  54.6k|        LiteralRef(match &self.0 {
  131|     12|            LiteralContent::String(value) => LiteralRefContent::String(value),
  132|     30|            LiteralContent::LanguageTaggedString { value, language } => {
  133|     30|                LiteralRefContent::LanguageTaggedString { value, language }
  134|       |            }
  135|  54.5k|            LiteralContent::TypedLiteral { value, datatype } => LiteralRefContent::TypedLiteral {
  136|  54.5k|                value,
  137|  54.5k|                datatype: datatype.as_ref(),
  138|  54.5k|            },
  139|       |        })
  140|  54.6k|    }
_RNvXsF_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   34|  9.42k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXsN_NtCshJ9d6mhVUZV_5oxrdf7literalNtB6_14LiteralContentNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
   37|  4.17k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RINvXsG_NtCshJ9d6mhVUZV_5oxrdf7literalNtB6_7LiteralNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
   34|  4.17k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsu_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
  565|  4.16k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  566|  4.16k|        match self.0 {
  567|    168|            LiteralRefContent::String(value) => print_quoted_str(value, f),
  568|    908|            LiteralRefContent::LanguageTaggedString { value, language } => {
  569|    908|                print_quoted_str(value, f)?;
  570|    908|                write!(f, "@{language}")
  571|       |            }
  572|  3.08k|            LiteralRefContent::TypedLiteral { value, datatype } => {
  573|  3.08k|                print_quoted_str(value, f)?;
  574|  3.08k|                write!(f, "^^{datatype}")
  575|       |            }
  576|       |        }
  577|  4.16k|    }
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf7literalNtB4_7LiteralNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
  157|  4.16k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  158|  4.16k|        self.as_ref().fmt(f)
  159|  4.16k|    }
_RNvXsF_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_7LiteralNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   34|  1.26k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB2_7Literal6as_refCshSv3hUzq9FP_9spargebra:
  129|  4.16k|    pub fn as_ref(&self) -> LiteralRef<'_> {
  130|  4.16k|        LiteralRef(match &self.0 {
  131|    168|            LiteralContent::String(value) => LiteralRefContent::String(value),
  132|    908|            LiteralContent::LanguageTaggedString { value, language } => {
  133|    908|                LiteralRefContent::LanguageTaggedString { value, language }
  134|       |            }
  135|  3.08k|            LiteralContent::TypedLiteral { value, datatype } => LiteralRefContent::TypedLiteral {
  136|  3.08k|                value,
  137|  3.08k|                datatype: datatype.as_ref(),
  138|  3.08k|            },
  139|       |        })
  140|  4.16k|    }
_RNvXsM_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_14LiteralContentNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   37|  1.26k|#[derive(PartialEq, Eq, Debug, Clone, Hash)]
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal17new_typed_literalNtNtCsjOdcKtOMjJI_5alloc6string6StringNtNtB5_10named_node9NamedNodeEB5_:
   53|    194|    pub fn new_typed_literal(value: impl Into<String>, datatype: impl Into<NamedNode>) -> Self {
   54|    194|        let value = value.into();
   55|    194|        let datatype = datatype.into();
   56|    194|        Self(if datatype == xsd::STRING {
   57|    194|            LiteralContent::String(value)
   58|       |        } else {
   59|      0|            LiteralContent::TypedLiteral { value, datatype }
   60|       |        })
   61|    194|    }
_RINvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB6_10LiteralRef17new_typed_literalNtNtB8_10named_node12NamedNodeRefEB8_:
  465|    590|    pub fn new_typed_literal(value: &'a str, datatype: impl Into<NamedNodeRef<'a>>) -> Self {
  466|    590|        let datatype = datatype.into();
  467|    590|        LiteralRef(if datatype == xsd::STRING {
  468|      0|            LiteralRefContent::String(value)
  469|       |        } else {
  470|    590|            LiteralRefContent::TypedLiteral { value, datatype }
  471|       |        })
  472|    590|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal37new_language_tagged_literal_uncheckedNtNtCsjOdcKtOMjJI_5alloc6string6StringB1n_EB5_:
   85|  1.97k|    pub fn new_language_tagged_literal_unchecked(
   86|  1.97k|        value: impl Into<String>,
   87|  1.97k|        language: impl Into<String>,
   88|  1.97k|    ) -> Self {
   89|  1.97k|        Self(LiteralContent::LanguageTaggedString {
   90|  1.97k|            value: value.into(),
   91|  1.97k|            language: language.into(),
   92|  1.97k|        })
   93|  1.97k|    }
_RINvNtCshJ9d6mhVUZV_5oxrdf7literal16print_quoted_strNtNtCs9nhK3FOW46N_4core3fmt9FormatterEB4_:
  616|  5.48k|pub fn print_quoted_str(string: &str, f: &mut impl Write) -> fmt::Result {
  617|  5.48k|    f.write_char('"')?;
  618|  18.5k|    for c in string.chars() {
  619|  18.5k|        match c {
  620|      0|            '\u{08}' => f.write_str("\\b"),
  621|      0|            '\t' => f.write_str("\\t"),
  622|      0|            '\n' => f.write_str("\\n"),
  623|      0|            '\u{0C}' => f.write_str("\\f"),
  624|      0|            '\r' => f.write_str("\\r"),
  625|      0|            '"' => f.write_str("\\\""),
  626|      0|            '\\' => f.write_str("\\\\"),
  627|  18.5k|            '\0'..='\u{1F}' | '\u{7F}' => write!(f, "\\u{:04X}", u32::from(c)),
  628|  18.5k|            _ => f.write_char(c),
  629|      0|        }?;
  630|       |    }
  631|  5.48k|    f.write_char('"')
  632|  5.48k|}
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal17new_typed_literalReNtNtB5_10named_node12NamedNodeRefEB5_:
   53|  5.12k|    pub fn new_typed_literal(value: impl Into<String>, datatype: impl Into<NamedNode>) -> Self {
   54|  5.12k|        let value = value.into();
   55|  5.12k|        let datatype = datatype.into();
   56|  5.12k|        Self(if datatype == xsd::STRING {
   57|      0|            LiteralContent::String(value)
   58|       |        } else {
   59|  5.12k|            LiteralContent::TypedLiteral { value, datatype }
   60|       |        })
   61|  5.12k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf7literalNtB3_7Literal18new_simple_literalNtNtCsjOdcKtOMjJI_5alloc6string6StringEB5_:
   47|    373|    pub fn new_simple_literal(value: impl Into<String>) -> Self {
   48|    373|        Self(LiteralContent::String(value.into()))
   49|    373|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8languageB7_:
  501|    972|    pub const fn language(self) -> Option<&'a str> {
  502|    972|        match self.0 {
  503|    867|            LiteralRefContent::LanguageTaggedString { language, .. } => Some(language),
  504|    105|            _ => None,
  505|       |        }
  506|    972|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8datatypeB7_:
  513|  1.77k|    pub const fn datatype(self) -> NamedNodeRef<'a> {
  514|  1.77k|        match self.0 {
  515|      0|            LiteralRefContent::String(_) => xsd::STRING,
  516|      0|            LiteralRefContent::LanguageTaggedString { .. } => rdf::LANG_STRING,
  517|  1.77k|            LiteralRefContent::TypedLiteral { datatype, .. } => datatype,
  518|       |        }
  519|  1.77k|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef18new_simple_literalB7_:
  459|     35|    pub const fn new_simple_literal(value: &'a str) -> Self {
  460|     35|        LiteralRef(LiteralRefContent::String(value))
  461|     35|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef8is_plainB7_:
  526|  2.74k|    pub const fn is_plain(self) -> bool {
  527|  1.77k|        matches!(
  528|  2.74k|            self.0,
  529|       |            LiteralRefContent::String(_) | LiteralRefContent::LanguageTaggedString { .. }
  530|       |        )
  531|  2.74k|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef37new_language_tagged_literal_uncheckedB7_:
  482|    289|    pub const fn new_language_tagged_literal_unchecked(value: &'a str, language: &'a str) -> Self {
  483|    289|        LiteralRef(LiteralRefContent::LanguageTaggedString { value, language })
  484|    289|    }
_RNvMst_NtCshJ9d6mhVUZV_5oxrdf7literalNtB5_10LiteralRef5valueB7_:
  488|  2.74k|    pub const fn value(self) -> &'a str {
  489|  2.74k|        match self.0 {
  490|    105|            LiteralRefContent::String(value)
  491|    867|            | LiteralRefContent::LanguageTaggedString { value, .. }
  492|  2.74k|            | LiteralRefContent::TypedLiteral { value, .. } => value,
  493|  2.74k|        }
  494|  2.74k|    }

_RNvXsp_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   17|  46.1k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_refCslmM25dSh1d8_18sparql_update_eval:
   54|  10.0k|    pub fn as_ref(&self) -> NamedNodeRef<'_> {
   55|  10.0k|        NamedNodeRef::new_unchecked(&self.iri)
   56|  10.0k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef13new_uncheckedCslmM25dSh1d8_18sparql_update_eval:
  128|  10.0k|    pub const fn new_unchecked(iri: &'a str) -> Self {
  129|  10.0k|        Self { iri }
  130|  10.0k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_strCs2ek33vt1YA5_8oxigraph:
   44|  1.24k|    pub fn as_str(&self) -> &str {
   45|  1.24k|        self.iri.as_str()
   46|  1.24k|    }
_RNvXsp_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   17|  47.8k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_refCs2ek33vt1YA5_8oxigraph:
   54|   125k|    pub fn as_ref(&self) -> NamedNodeRef<'_> {
   55|   125k|        NamedNodeRef::new_unchecked(&self.iri)
   56|   125k|    }
_RNvXs5_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  145|  10.0k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  146|  10.0k|        write!(f, "<{}>", self.as_str())
  147|  10.0k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef13new_uncheckedCs2ek33vt1YA5_8oxigraph:
  128|   125k|    pub const fn new_unchecked(iri: &'a str) -> Self {
  129|   125k|        Self { iri }
  130|   125k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef6as_strCs2ek33vt1YA5_8oxigraph:
  133|   213k|    pub const fn as_str(self) -> &'a str {
  134|   213k|        self.iri
  135|   213k|    }
_RNvXs9_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeINtNtCs9nhK3FOW46N_4core3cmp9PartialEqNtB5_12NamedNodeRefE2eqCs2ek33vt1YA5_8oxigraph:
  173|  1.24k|    fn eq(&self, other: &NamedNodeRef<'_>) -> bool {
  174|  1.24k|        self.as_str() == other.as_str()
  175|  1.24k|    }
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB4_9NamedNodeNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
   61|  8.91k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   62|  8.91k|        self.as_ref().fmt(f)
   63|  8.91k|    }
_RINvXsq_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB6_9NamedNodeNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
   17|  7.53k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef13new_uncheckedCsaDAmlQ5xRbD_7sparopt:
  128|  54.5k|    pub const fn new_unchecked(iri: &'a str) -> Self {
  129|  54.5k|        Self { iri }
  130|  54.5k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_refCsaDAmlQ5xRbD_7sparopt:
   54|  54.5k|    pub fn as_ref(&self) -> NamedNodeRef<'_> {
   55|  54.5k|        NamedNodeRef::new_unchecked(&self.iri)
   56|  54.5k|    }
_RNvXsl_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   17|      2|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsu_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRefNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
  106|     57|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvXsp_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   17|  60.1k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB4_9NamedNodeNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
   61|  62.0k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   62|  62.0k|        self.as_ref().fmt(f)
   63|  62.0k|    }
_RNvXs5_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
  145|  65.1k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  146|  65.1k|        write!(f, "<{}>", self.as_str())
  147|  65.1k|    }
_RNvXsp_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   17|   166k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsg_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeINtNtCs9nhK3FOW46N_4core7convert4FromINtCsbOXESBDtkxG_5oxiri3IriNtNtCsjOdcKtOMjJI_5alloc6string6StringEE4fromCshSv3hUzq9FP_9spargebra:
  222|  55.7k|    fn from(iri: Iri<String>) -> Self {
  223|  55.7k|        Self {
  224|  55.7k|            iri: iri.into_inner(),
  225|  55.7k|        }
  226|  55.7k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef13new_uncheckedCshSv3hUzq9FP_9spargebra:
  128|  65.1k|    pub const fn new_unchecked(iri: &'a str) -> Self {
  129|  65.1k|        Self { iri }
  130|  65.1k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef6as_strCshSv3hUzq9FP_9spargebra:
  133|  65.1k|    pub const fn as_str(self) -> &'a str {
  134|  65.1k|        self.iri
  135|  65.1k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_refCshSv3hUzq9FP_9spargebra:
   54|  65.1k|    pub fn as_ref(&self) -> NamedNodeRef<'_> {
   55|  65.1k|        NamedNodeRef::new_unchecked(&self.iri)
   56|  65.1k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef10into_ownedCshSv3hUzq9FP_9spargebra:
  138|  20.7k|    pub fn into_owned(self) -> NamedNode {
  139|  20.7k|        NamedNode::new_unchecked(self.iri)
  140|  20.7k|    }
_RNvXsl_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCshSv3hUzq9FP_9spargebra:
   17|    486|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RINvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB3_9NamedNode13new_uncheckedReEB5_:
   39|  59.9k|    pub fn new_unchecked(iri: impl Into<String>) -> Self {
   40|  59.9k|        Self { iri: iri.into() }
   41|  59.9k|    }
_RINvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB3_9NamedNode13new_uncheckedNtNtCsjOdcKtOMjJI_5alloc6string6StringEB5_:
   39|  9.25k|    pub fn new_unchecked(iri: impl Into<String>) -> Self {
   40|  9.25k|        Self { iri: iri.into() }
   41|  9.25k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef6as_strB7_:
  133|  20.4k|    pub const fn as_str(self) -> &'a str {
  134|  20.4k|        self.iri
  135|  20.4k|    }
_RNvXsu_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRefNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB7_:
  106|    590|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash)]
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef10into_ownedB7_:
  138|  39.2k|    pub fn into_owned(self) -> NamedNode {
  139|  39.2k|        NamedNode::new_unchecked(self.iri)
  140|  39.2k|    }
_RNvXs9_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeINtNtCs9nhK3FOW46N_4core3cmp9PartialEqNtB5_12NamedNodeRefE2eqB7_:
  173|  5.32k|    fn eq(&self, other: &NamedNodeRef<'_>) -> bool {
  174|  5.32k|        self.as_str() == other.as_str()
  175|  5.32k|    }
_RNvMNtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB2_9NamedNode6as_strB4_:
   44|  5.32k|    pub fn as_str(&self) -> &str {
   45|  5.32k|        self.iri.as_str()
   46|  5.32k|    }
_RNvMs4_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_12NamedNodeRef13new_uncheckedB7_:
  128|  5.03k|    pub const fn new_unchecked(iri: &'a str) -> Self {
  129|  5.03k|        Self { iri }
  130|  5.03k|    }
_RNvXs6_NtCshJ9d6mhVUZV_5oxrdf10named_nodeNtB5_9NamedNodeINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_12NamedNodeRefE4fromB7_:
  152|  39.2k|    fn from(node: NamedNodeRef<'_>) -> Self {
  153|  39.2k|        node.into_owned()
  154|  39.2k|    }

_RNvXs2c_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_4TermNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  385|  2.38k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMs1u_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_4Quad6as_refCslmM25dSh1d8_18sparql_update_eval:
 1182|  2.78k|    pub fn as_ref(&self) -> QuadRef<'_> {
 1183|  2.78k|        QuadRef {
 1184|  2.78k|            subject: self.subject.as_ref(),
 1185|  2.78k|            predicate: self.predicate.as_ref(),
 1186|  2.78k|            object: self.object.as_ref(),
 1187|  2.78k|            graph_name: self.graph_name.as_ref(),
 1188|  2.78k|        }
 1189|  2.78k|    }
_RNvMs1c_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_9GraphName6as_refCslmM25dSh1d8_18sparql_update_eval:
  965|  2.78k|    pub fn as_ref(&self) -> GraphNameRef<'_> {
  966|  2.78k|        match self {
  967|  2.35k|            Self::NamedNode(node) => GraphNameRef::NamedNode(node.as_ref()),
  968|      0|            Self::BlankNode(node) => GraphNameRef::BlankNode(node.as_ref()),
  969|    426|            Self::DefaultGraph => GraphNameRef::DefaultGraph,
  970|       |        }
  971|  2.78k|    }
_RNvXs1X_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_7SubjectNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  155|  2.38k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2G_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_9GraphNameNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  940|  2.53k|#[derive(Eq, PartialEq, Debug, Clone, Hash, Default)]
_RNvMsc_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7Subject6as_refCslmM25dSh1d8_18sparql_update_eval:
  181|  2.78k|    pub fn as_ref(&self) -> SubjectRef<'_> {
  182|  2.78k|        match self {
  183|  2.78k|            Self::NamedNode(node) => SubjectRef::NamedNode(node.as_ref()),
  184|      0|            Self::BlankNode(node) => SubjectRef::BlankNode(node.as_ref()),
  185|       |            #[cfg(feature = "rdf-star")]
  186|      0|            Self::Triple(triple) => SubjectRef::Triple(triple),
  187|       |        }
  188|  2.78k|    }
_RNvMsy_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_4Term6as_refCslmM25dSh1d8_18sparql_update_eval:
  417|  2.78k|    pub fn as_ref(&self) -> TermRef<'_> {
  418|  2.78k|        match self {
  419|    956|            Self::NamedNode(node) => TermRef::NamedNode(node.as_ref()),
  420|      0|            Self::BlankNode(node) => TermRef::BlankNode(node.as_ref()),
  421|  1.82k|            Self::Literal(literal) => TermRef::Literal(literal.as_ref()),
  422|       |            #[cfg(feature = "rdf-star")]
  423|      0|            Self::Triple(triple) => TermRef::Triple(triple),
  424|       |        }
  425|  2.78k|    }
_RNvXs1A_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_7QuadRefINtNtCs9nhK3FOW46N_4core7convert4FromRNtB6_4QuadE4fromCslmM25dSh1d8_18sparql_update_eval:
 1298|  2.78k|    fn from(quad: &'a Quad) -> Self {
 1299|  2.78k|        quad.as_ref()
 1300|  2.78k|    }
_RNvMs1c_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_9GraphName6as_refCs2ek33vt1YA5_8oxigraph:
  965|  13.2k|    pub fn as_ref(&self) -> GraphNameRef<'_> {
  966|  13.2k|        match self {
  967|  11.0k|            Self::NamedNode(node) => GraphNameRef::NamedNode(node.as_ref()),
  968|      0|            Self::BlankNode(node) => GraphNameRef::BlankNode(node.as_ref()),
  969|  2.12k|            Self::DefaultGraph => GraphNameRef::DefaultGraph,
  970|       |        }
  971|  13.2k|    }
_RNvMsc_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7Subject6as_refCs2ek33vt1YA5_8oxigraph:
  181|  8.33k|    pub fn as_ref(&self) -> SubjectRef<'_> {
  182|  8.33k|        match self {
  183|  8.33k|            Self::NamedNode(node) => SubjectRef::NamedNode(node.as_ref()),
  184|      0|            Self::BlankNode(node) => SubjectRef::BlankNode(node.as_ref()),
  185|       |            #[cfg(feature = "rdf-star")]
  186|      0|            Self::Triple(triple) => SubjectRef::Triple(triple),
  187|       |        }
  188|  8.33k|    }
_RNvXs1n_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_12GraphNameRefINtNtCs9nhK3FOW46N_4core7convert4FromRNtNtB8_10named_node9NamedNodeE4fromCs2ek33vt1YA5_8oxigraph:
 1082|     82|    fn from(node: &'a NamedNode) -> Self {
 1083|     82|        node.as_ref().into()
 1084|     82|    }
_RNvXsU_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromRNtNtB7_10named_node9NamedNodeE4fromCs2ek33vt1YA5_8oxigraph:
  672|  74.4k|    fn from(node: &'a NamedNode) -> Self {
  673|  74.4k|        node.as_ref().into()
  674|  74.4k|    }
_RNvMs1u_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_4Quad6as_refCs2ek33vt1YA5_8oxigraph:
 1182|  8.33k|    pub fn as_ref(&self) -> QuadRef<'_> {
 1183|  8.33k|        QuadRef {
 1184|  8.33k|            subject: self.subject.as_ref(),
 1185|  8.33k|            predicate: self.predicate.as_ref(),
 1186|  8.33k|            object: self.object.as_ref(),
 1187|  8.33k|            graph_name: self.graph_name.as_ref(),
 1188|  8.33k|        }
 1189|  8.33k|    }
_RNvMs1k_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_12GraphNameRef16is_default_graphCs2ek33vt1YA5_8oxigraph:
 1048|  5.88k|    pub fn is_default_graph(&self) -> bool {
 1049|  5.88k|        matches!(self, Self::DefaultGraph)
 1050|  5.88k|    }
_RNvXs1m_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_12GraphNameRefINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB8_10named_node12NamedNodeRefE4fromCs2ek33vt1YA5_8oxigraph:
 1075|     82|    fn from(node: NamedNodeRef<'a>) -> Self {
 1076|     82|        Self::NamedNode(node)
 1077|     82|    }
_RNvXsX_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7literal10LiteralRefE4fromCs2ek33vt1YA5_8oxigraph:
  693|  5.96k|    fn from(literal: LiteralRef<'a>) -> Self {
  694|  5.96k|        Self::Literal(literal)
  695|  5.96k|    }
_RNvXsY_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromRNtNtB7_7literal7LiteralE4fromCs2ek33vt1YA5_8oxigraph:
  700|  5.96k|    fn from(literal: &'a Literal) -> Self {
  701|  5.96k|        literal.as_ref().into()
  702|  5.96k|    }
_RNvXs6_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_19NamedOrBlankNodeRefINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_10named_node12NamedNodeRefE4fromCs2ek33vt1YA5_8oxigraph:
  114|  1.06k|    fn from(node: NamedNodeRef<'a>) -> Self {
  115|  1.06k|        Self::NamedNode(node)
  116|  1.06k|    }
_RNvXs7_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_19NamedOrBlankNodeRefINtNtCs9nhK3FOW46N_4core7convert4FromRNtNtB7_10named_node9NamedNodeE4fromCs2ek33vt1YA5_8oxigraph:
  121|  1.06k|    fn from(node: &'a NamedNode) -> Self {
  122|  1.06k|        node.as_ref().into()
  123|  1.06k|    }
_RNvMsy_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_4Term6as_refCs2ek33vt1YA5_8oxigraph:
  417|  8.33k|    pub fn as_ref(&self) -> TermRef<'_> {
  418|  8.33k|        match self {
  419|  2.97k|            Self::NamedNode(node) => TermRef::NamedNode(node.as_ref()),
  420|      0|            Self::BlankNode(node) => TermRef::BlankNode(node.as_ref()),
  421|  5.36k|            Self::Literal(literal) => TermRef::Literal(literal.as_ref()),
  422|       |            #[cfg(feature = "rdf-star")]
  423|      0|            Self::Triple(triple) => TermRef::Triple(triple),
  424|       |        }
  425|  8.33k|    }
_RNvXs10_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromNtB6_19NamedOrBlankNodeRefE4fromCs2ek33vt1YA5_8oxigraph:
  715|    206|    fn from(node: NamedOrBlankNodeRef<'a>) -> Self {
  716|    206|        match node {
  717|    206|            NamedOrBlankNodeRef::NamedNode(node) => node.into(),
  718|      0|            NamedOrBlankNodeRef::BlankNode(node) => node.into(),
  719|       |        }
  720|    206|    }
_RNvXs12_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromNtB6_10SubjectRefE4fromCs1tT6kGyeNZe_10sparesults:
  732|  2.95k|    fn from(node: SubjectRef<'a>) -> Self {
  733|  2.95k|        match node {
  734|  2.95k|            SubjectRef::NamedNode(node) => node.into(),
  735|      0|            SubjectRef::BlankNode(node) => node.into(),
  736|       |            #[cfg(feature = "rdf-star")]
  737|      0|            SubjectRef::Triple(triple) => triple.into(),
  738|       |        }
  739|  2.95k|    }
_RNvXsT_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7TermRefINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_10named_node12NamedNodeRefE4fromCs1tT6kGyeNZe_10sparesults:
  665|  81.7k|    fn from(node: NamedNodeRef<'a>) -> Self {
  666|  81.7k|        Self::NamedNode(node)
  667|  81.7k|    }
_RINvMs1u_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB7_4Quad3newNtB7_7SubjectNtNtB9_10named_node9NamedNodeNtB7_4TermNtB7_9GraphNameECsgRlx6Emv1GO_5oxttl:
 1167|  2.78k|    pub fn new(
 1168|  2.78k|        subject: impl Into<Subject>,
 1169|  2.78k|        predicate: impl Into<NamedNode>,
 1170|  2.78k|        object: impl Into<Term>,
 1171|  2.78k|        graph_name: impl Into<GraphName>,
 1172|  2.78k|    ) -> Self {
 1173|  2.78k|        Self {
 1174|  2.78k|            subject: subject.into(),
 1175|  2.78k|            predicate: predicate.into(),
 1176|  2.78k|            object: object.into(),
 1177|  2.78k|            graph_name: graph_name.into(),
 1178|  2.78k|        }
 1179|  2.78k|    }
_RNvXs1e_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB6_9GraphNameINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB8_10named_node9NamedNodeE4fromCsgRlx6Emv1GO_5oxttl:
  983|  11.8k|    fn from(node: NamedNode) -> Self {
  984|  11.8k|        Self::NamedNode(node)
  985|  11.8k|    }
_RNvXsA_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_4TermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_10named_node9NamedNodeE4fromB7_:
  437|  39.9k|    fn from(node: NamedNode) -> Self {
  438|  39.9k|        Self::NamedNode(node)
  439|  39.9k|    }
_RNvXse_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_7SubjectINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_10named_node9NamedNodeE4fromB7_:
  200|  21.2k|    fn from(node: NamedNode) -> Self {
  201|  21.2k|        Self::NamedNode(node)
  202|  21.2k|    }
_RNvXsE_NtCshJ9d6mhVUZV_5oxrdf6tripleNtB5_4TermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7literal7LiteralE4fromB7_:
  465|  13.5k|    fn from(literal: Literal) -> Self {
  466|  13.5k|        Self::Literal(literal)
  467|  13.5k|    }

_RNvXsf_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   13|  16.6k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf8variableNtB4_8VariableNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
   57|  88.4k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   58|  88.4k|        self.as_ref().fmt(f)
   59|  88.4k|    }
_RNvXsf_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   13|  47.9k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf8variableNtB2_8Variable6as_refCs2ek33vt1YA5_8oxigraph:
   50|  88.4k|    pub fn as_ref(&self) -> VariableRef<'_> {
   51|  88.4k|        VariableRef { name: &self.name }
   52|  88.4k|    }
_RNvXs1_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_11VariableRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  116|  88.4k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  117|  88.4k|        write!(f, "?{}", self.name)
  118|  88.4k|    }
_RNvXsb_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCsaDAmlQ5xRbD_7sparopt:
   13|     82|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsf_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   13|   324M|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RINvMNtCshJ9d6mhVUZV_5oxrdf8variableNtB3_8Variable13new_uncheckedReECshSv3hUzq9FP_9spargebra:
   35|  48.8k|    pub fn new_unchecked(name: impl Into<String>) -> Self {
   36|  48.8k|        Self { name: name.into() }
   37|  48.8k|    }
_RINvXsg_NtCshJ9d6mhVUZV_5oxrdf8variableNtB6_8VariableNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECshSv3hUzq9FP_9spargebra:
   13|   804M|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXs_NtCshJ9d6mhVUZV_5oxrdf8variableNtB4_8VariableNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
   57|  40.4k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   58|  40.4k|        self.as_ref().fmt(f)
   59|  40.4k|    }
_RNvXsd_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core3cmp10PartialOrd11partial_cmpCshSv3hUzq9FP_9spargebra:
   13|  1.22k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsf_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCshSv3hUzq9FP_9spargebra:
   13|  50.3k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvMNtCshJ9d6mhVUZV_5oxrdf8variableNtB2_8Variable6as_refCshSv3hUzq9FP_9spargebra:
   50|  40.4k|    pub fn as_ref(&self) -> VariableRef<'_> {
   51|  40.4k|        VariableRef { name: &self.name }
   52|  40.4k|    }
_RNvXs1_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_11VariableRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCshSv3hUzq9FP_9spargebra:
  116|  40.4k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  117|  40.4k|        write!(f, "?{}", self.name)
  118|  40.4k|    }
_RNvXsb_NtCshJ9d6mhVUZV_5oxrdf8variableNtB5_8VariableNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCshSv3hUzq9FP_9spargebra:
   13|   447M|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RINvMNtCshJ9d6mhVUZV_5oxrdf8variableNtB3_8Variable13new_uncheckedNtNtCsjOdcKtOMjJI_5alloc6string6StringEB5_:
   35|  31.3k|    pub fn new_unchecked(name: impl Into<String>) -> Self {
   36|  31.3k|        Self { name: name.into() }
   37|  31.3k|    }

_RINvXsh_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB6_7BooleanNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECs2ek33vt1YA5_8oxigraph:
    8|     38|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs4_NtCsaP05r1vbY5r_12oxsdatatypes7booleanbINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_7BooleanE4fromCs2ek33vt1YA5_8oxigraph:
   60|  2.25k|    fn from(value: Boolean) -> Self {
   61|  2.25k|        value.value
   62|  2.25k|    }
_RNvXs1_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7decimal7DecimalE4fromCs2ek33vt1YA5_8oxigraph:
   39|      2|    fn from(value: Decimal) -> Self {
   40|      2|        (value != Decimal::from(0)).into()
   41|      2|    }
_RNvXs8_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
    8|    798|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB4_7BooleanINtNtCs9nhK3FOW46N_4core7convert4FrombE4fromCs2ek33vt1YA5_8oxigraph:
   25|  3.33k|    fn from(value: bool) -> Self {
   26|  3.33k|        Self { value }
   27|  3.33k|    }
_RNvXs0_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7integer7IntegerE4fromCs2ek33vt1YA5_8oxigraph:
   32|      2|    fn from(value: Integer) -> Self {
   33|      2|        (value != Integer::from(0)).into()
   34|      2|    }
_RNvXs5_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanNtNtNtCs9nhK3FOW46N_4core3str6traits7FromStr8from_strCs2ek33vt1YA5_8oxigraph:
   69|  2.97k|    fn from_str(input: &str) -> Result<Self, Self::Err> {
   70|  2.97k|        Ok(match input {
   71|  2.97k|            "true" | "1" => true,
   72|  2.09k|            "false" | "0" => false,
   73|      0|            _ => bool::from_str(input)?,
   74|       |        }
   75|  2.97k|        .into())
   76|  2.97k|    }
_RNvXse_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCs2ek33vt1YA5_8oxigraph:
    8|     16|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs6_NtCsaP05r1vbY5r_12oxsdatatypes7booleanNtB5_7BooleanNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
   81|    232|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   82|    232|        self.value.fmt(f)
   83|    232|    }

_RNvMsN_NtCsaP05r1vbY5r_12oxsdatatypes9date_timeNtB5_9Timestamp3nowCs2ek33vt1YA5_8oxigraph:
 1640|  4.89k|    fn now() -> Self {
 1641|  4.89k|        Self::new(
 1642|  4.89k|            &date_time_plus_duration(
 1643|  4.89k|                since_unix_epoch(),
 1644|  4.89k|                &DateTimeSevenPropertyModel {
 1645|  4.89k|                    year: Some(1970),
 1646|  4.89k|                    month: Some(1),
 1647|  4.89k|                    day: Some(1),
 1648|  4.89k|                    hour: Some(0),
 1649|  4.89k|                    minute: Some(0),
 1650|  4.89k|                    second: Some(Decimal::default()),
 1651|  4.89k|                    timezone_offset: Some(TimezoneOffset::UTC),
 1652|  4.89k|                },
 1653|  4.89k|            )
 1654|  4.89k|            .expect("The current time seems way in the future, it's strange"),
 1655|  4.89k|        )
 1656|  4.89k|        .expect("The current time seems way in the future, it's strange")
 1657|  4.89k|    }
_RNvMsN_NtCsaP05r1vbY5r_12oxsdatatypes9date_timeNtB5_9Timestamp3newCs2ek33vt1YA5_8oxigraph:
 1632|  4.89k|    fn new(props: &DateTimeSevenPropertyModel) -> Result<Self, DateTimeOverflowError> {
 1633|  4.89k|        Ok(Self {
 1634|  4.89k|            timezone_offset: props.timezone_offset,
 1635|  4.89k|            value: time_on_timeline(props).ok_or(DateTimeOverflowError)?,
 1636|       |        })
 1637|  4.89k|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes9date_timeNtB2_8DateTime3nowCs2ek33vt1YA5_8oxigraph:
   51|  4.89k|    pub fn now() -> Self {
   52|  4.89k|        Self {
   53|  4.89k|            timestamp: Timestamp::now(),
   54|  4.89k|        }
   55|  4.89k|    }
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time13normalize_day:
 1921|  4.89k|fn normalize_day(yr: i64, mo: i64, mut da: i64) -> Option<(i64, u8, u8)> {
 1922|  4.89k|    let (mut yr, mut mo) = normalize_month(yr, mo)?;
 1923|       |    loop {
 1924|  3.18M|        if da <= 0 {
 1925|      0|            let (yr2, mo2) = normalize_month(yr, i64::from(mo).checked_sub(1)?)?;
 1926|      0|            yr = yr2;
 1927|      0|            mo = mo2;
 1928|      0|            da = da.checked_add(days_in_month(Some(yr), mo).into())?;
 1929|  3.18M|        } else if da > days_in_month(Some(yr), mo).into() {
 1930|  3.18M|            da = da.checked_sub(days_in_month(Some(yr), mo).into())?;
 1931|  3.18M|            let (yr2, mo2) = normalize_month(yr, i64::from(mo).checked_add(1)?)?;
 1932|  3.18M|            yr = yr2;
 1933|  3.18M|            mo = mo2;
 1934|       |        } else {
 1935|  4.89k|            return Some((yr, mo, u8::try_from(da).ok()?));
 1936|       |        };
 1937|       |    }
 1938|  4.89k|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time15normalize_month:
 1902|  3.19M|fn normalize_month(yr: i64, mo: i64) -> Option<(i64, u8)> {
 1903|  3.19M|    if mo >= 0 {
 1904|  3.19M|        let yr = yr.checked_add(mo.checked_sub(1)?.checked_div(12)?)?;
 1905|  3.19M|        let mo = u8::try_from(mo.checked_sub(1)?.checked_rem(12)?.abs().checked_add(1)?).ok()?;
 1906|  3.19M|        Some((yr, mo))
 1907|       |    } else {
 1908|       |        // Needed to make it work with negative durations
 1909|      0|        let yr = yr.checked_add(mo.checked_sub(1)?.checked_div(12)?.checked_sub(1)?)?;
 1910|      0|        let mo = u8::try_from(
 1911|       |            12_i64
 1912|      0|                .checked_add(mo.checked_sub(1)?.checked_rem(12)?)?
 1913|      0|                .checked_add(1)?,
 1914|       |        )
 1915|      0|        .ok()?;
 1916|      0|        Some((yr, mo))
 1917|       |    }
 1918|  3.19M|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16time_on_timeline:
 2014|  4.89k|fn time_on_timeline(props: &DateTimeSevenPropertyModel) -> Option<Decimal> {
 2015|  4.89k|    let yr = props.year.map_or(1971, |y| y - 1);
 2016|  4.89k|    let mo = props.month.unwrap_or(12);
 2017|  4.89k|    let da = props
 2018|  4.89k|        .day
 2019|  4.89k|        .map_or_else(|| days_in_month(Some(yr + 1), mo) - 1, |d| d - 1);
 2020|  4.89k|    let hr = props.hour.unwrap_or(0);
 2021|  4.89k|    let mi = i128::from(props.minute.unwrap_or(0))
 2022|  4.89k|        - i128::from(props.timezone_offset.unwrap_or(TimezoneOffset::UTC).offset);
 2023|  4.89k|    let se = props.second.unwrap_or_default();
 2024|  4.89k|
 2025|  4.89k|    Decimal::try_from(
 2026|  4.89k|        31_536_000 * i128::from(yr)
 2027|  4.89k|            + 86400 * i128::from(yr.div_euclid(400) - yr.div_euclid(100) + yr.div_euclid(4))
 2028|  4.89k|            + 86400
 2029|  4.89k|                * (1..mo)
 2030|  4.89k|                    .map(|m| i128::from(days_in_month(Some(yr + 1), m)))
 2031|  4.89k|                    .sum::<i128>()
 2032|  4.89k|            + 86400 * i128::from(da)
 2033|  4.89k|            + 3600 * i128::from(hr)
 2034|  4.89k|            + 60 * mi,
 2035|  4.89k|    )
 2036|  4.89k|    .ok()?
 2037|  4.89k|    .checked_add(se)
 2038|  4.89k|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_duration:
 1985|  4.89k|fn date_time_plus_duration(
 1986|  4.89k|    du: Duration,
 1987|  4.89k|    dt: &DateTimeSevenPropertyModel,
 1988|  4.89k|) -> Option<DateTimeSevenPropertyModel> {
 1989|  4.89k|    let yr = dt.year.unwrap_or(1);
 1990|  4.89k|    let mo = dt.month.unwrap_or(1);
 1991|  4.89k|    let da = dt.day.unwrap_or(1);
 1992|  4.89k|    let hr = dt.hour.unwrap_or(0);
 1993|  4.89k|    let mi = dt.minute.unwrap_or(0);
 1994|  4.89k|    let se = dt.second.unwrap_or_default();
 1995|  4.89k|    let mo = i64::from(mo).checked_add(du.all_months())?;
 1996|  4.89k|    let (yr, mo) = normalize_month(yr, mo)?;
 1997|  4.89k|    let da = min(da, days_in_month(Some(yr), mo));
 1998|  4.89k|    let se = se.checked_add(du.all_seconds())?;
 1999|  4.89k|    let (yr, mo, da, hr, mi, se) =
 2000|  4.89k|        normalize_second(yr, mo.into(), da.into(), hr.into(), mi.into(), se)?;
 2001|       |
 2002|  4.89k|    Some(DateTimeSevenPropertyModel {
 2003|  4.89k|        year: dt.year.map(|_| yr),
 2004|  4.89k|        month: dt.month.map(|_| mo),
 2005|  4.89k|        day: dt.day.map(|_| da),
 2006|  4.89k|        hour: dt.hour.map(|_| hr),
 2007|  4.89k|        minute: dt.minute.map(|_| mi),
 2008|  4.89k|        second: dt.second.map(|_| se),
 2009|  4.89k|        timezone_offset: dt.timezone_offset,
 2010|  4.89k|    })
 2011|  4.89k|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16since_unix_epoch:
 1891|  4.89k|fn since_unix_epoch() -> Duration {
 1892|  4.89k|    use std::time::SystemTime;
 1893|  4.89k|
 1894|  4.89k|    SystemTime::now()
 1895|  4.89k|        .duration_since(SystemTime::UNIX_EPOCH)
 1896|  4.89k|        .expect("System time before UNIX epoch")
 1897|  4.89k|        .try_into()
 1898|  4.89k|        .expect("The current time seems way in the future, it's strange")
 1899|  4.89k|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time13days_in_month:
 1966|  6.39M|fn days_in_month(y: Option<i64>, m: u8) -> u8 {
 1967|  6.39M|    match m {
 1968|       |        2 => {
 1969|   542k|            if let Some(y) = y {
 1970|   542k|                if y % 4 != 0 || (y % 100 == 0 && y % 400 != 0) {
 1971|   400k|                    28
 1972|       |                } else {
 1973|   141k|                    29
 1974|       |                }
 1975|       |            } else {
 1976|      0|                28
 1977|       |            }
 1978|       |        }
 1979|  2.11M|        4 | 6 | 9 | 11 => 30,
 1980|  3.73M|        _ => 31,
 1981|       |    }
 1982|  6.39M|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16normalize_second:
 1951|  4.89k|fn normalize_second(
 1952|  4.89k|    yr: i64,
 1953|  4.89k|    mo: i64,
 1954|  4.89k|    da: i64,
 1955|  4.89k|    hr: i64,
 1956|  4.89k|    mi: i64,
 1957|  4.89k|    se: Decimal,
 1958|  4.89k|) -> Option<(i64, u8, u8, u8, u8, Decimal)> {
 1959|  4.89k|    let mi = mi.checked_add(i64::try_from(se.as_i128().checked_div(60)?).ok()?)?; // TODO: good idea?
 1960|  4.89k|    let se = se.checked_rem(60)?;
 1961|  4.89k|    let (yr, mo, da, hr, mi) = normalize_minute(yr, mo, da, hr, mi)?;
 1962|  4.89k|    Some((yr, mo, da, hr, mi, se))
 1963|  4.89k|}
_RNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16normalize_minute:
 1941|  4.89k|fn normalize_minute(yr: i64, mo: i64, da: i64, hr: i64, mi: i64) -> Option<(i64, u8, u8, u8, u8)> {
 1942|  4.89k|    let hr = hr.checked_add(mi.checked_div(60)?)?;
 1943|  4.89k|    let mi = mi.checked_rem(60)?;
 1944|  4.89k|    let da = da.checked_add(hr.checked_div(24)?)?;
 1945|  4.89k|    let hr = hr.checked_rem(24)?;
 1946|  4.89k|    let (yr, mo, da) = normalize_day(yr, mo, da)?;
 1947|  4.89k|    Some((yr, mo, da, u8::try_from(hr).ok()?, u8::try_from(mi).ok()?))
 1948|  4.89k|}
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_durations1_0B5_:
 2006|  4.89k|        hour: dt.hour.map(|_| hr),
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16time_on_timeline0B5_:
 2015|  4.89k|    let yr = props.year.map_or(1971, |y| y - 1);
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_durations_0B5_:
 2004|  4.89k|        month: dt.month.map(|_| mo),
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16time_on_timelines0_0B5_:
 2019|  4.89k|        .map_or_else(|| days_in_month(Some(yr + 1), mo) - 1, |d| d - 1);
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_durations3_0B5_:
 2008|  4.89k|        second: dt.second.map(|_| se),
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_durations2_0B5_:
 2007|  4.89k|        minute: dt.minute.map(|_| mi),
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_durations0_0B5_:
 2005|  4.89k|        day: dt.day.map(|_| da),
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time16time_on_timelines1_0B5_:
 2030|  14.6k|                    .map(|m| i128::from(days_in_month(Some(yr + 1), m)))
_RNCNvNtCsaP05r1vbY5r_12oxsdatatypes9date_time23date_time_plus_duration0B5_:
 2003|  4.89k|        year: dt.year.map(|_| yr),

_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal11to_be_bytesCs2ek33vt1YA5_8oxigraph:
   54|  4.80k|    pub fn to_be_bytes(self) -> [u8; 16] {
   55|  4.80k|        self.value.to_be_bytes()
   56|  4.80k|    }
_RNvXs2_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalINtNtCs9nhK3FOW46N_4core7convert4FromlE4fromCs2ek33vt1YA5_8oxigraph:
  298|      2|    fn from(value: i32) -> Self {
  299|      2|        Self {
  300|      2|            value: i128::from(value) * DECIMAL_PART_POW,
  301|      2|        }
  302|      2|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal11checked_negCs2ek33vt1YA5_8oxigraph:
  177|     30|    pub fn checked_neg(self) -> Option<Self> {
  178|     30|        Some(Self {
  179|     30|            value: self.value.checked_neg()?,
  180|       |        })
  181|     30|    }
_RNvXsn_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCs2ek33vt1YA5_8oxigraph:
   15|      8|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvXsp_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core3cmp10PartialOrd11partial_cmpCs2ek33vt1YA5_8oxigraph:
   15|      2|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvXsr_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   15|    323|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvXsu_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core7default7Default7defaultCs2ek33vt1YA5_8oxigraph:
   15|  4.89k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal17is_identical_withCs2ek33vt1YA5_8oxigraph:
  258|      8|    pub fn is_identical_with(self, other: Self) -> bool {
  259|      8|        self == other
  260|      8|    }
_RNvXs8_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7integer7IntegerE4fromCs2ek33vt1YA5_8oxigraph:
  352|    129|    fn from(value: Integer) -> Self {
  353|    129|        i64::from(value).into()
  354|    129|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal13from_be_bytesCs2ek33vt1YA5_8oxigraph:
   46|    669|    pub fn from_be_bytes(bytes: [u8; 16]) -> Self {
   47|    669|        Self {
   48|    669|            value: i128::from_be_bytes(bytes),
   49|    669|        }
   50|    669|    }
_RNvXs3_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalINtNtCs9nhK3FOW46N_4core7convert4FromxE4fromCs2ek33vt1YA5_8oxigraph:
  307|    129|    fn from(value: i64) -> Self {
  308|    129|        Self {
  309|    129|            value: i128::from(value) * DECIMAL_PART_POW,
  310|    129|        }
  311|    129|    }
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_subBF_ECs2ek33vt1YA5_8oxigraph:
   74|     22|    pub fn checked_sub(self, rhs: impl Into<Self>) -> Option<Self> {
   75|     22|        Some(Self {
   76|     22|            value: self.value.checked_sub(rhs.into().value)?,
   77|       |        })
   78|     22|    }
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_mulBF_ECs2ek33vt1YA5_8oxigraph:
   85|     12|    pub fn checked_mul(self, rhs: impl Into<Self>) -> Option<Self> {
   86|     12|        // Idea: we shift right as much as possible to keep as much precision as possible
   87|     12|        // Do the multiplication and do the required left shift
   88|     12|        let mut left = self.value;
   89|     12|        let mut shift_left = 0_u32;
   90|     12|        if left != 0 {
   91|      0|            while left % 10 == 0 {
   92|      0|                left /= 10;
   93|      0|                shift_left += 1;
   94|      0|            }
   95|     12|        }
   96|       |
   97|     12|        let mut right = rhs.into().value;
   98|     12|        let mut shift_right = 0_u32;
   99|     12|        if right != 0 {
  100|      0|            while right % 10 == 0 {
  101|      0|                right /= 10;
  102|      0|                shift_right += 1;
  103|      0|            }
  104|     12|        }
  105|       |
  106|       |        // We do multiplication + shift
  107|     12|        let shift = (shift_left + shift_right).checked_sub(DECIMAL_PART_DIGITS)?;
  108|       |        Some(Self {
  109|      0|            value: left
  110|      0|                .checked_mul(right)?
  111|      0|                .checked_mul(10_i128.checked_pow(shift)?)?,
  112|       |        })
  113|     12|    }
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_divNtNtB5_7integer7IntegerECs2ek33vt1YA5_8oxigraph:
  120|     62|    pub fn checked_div(self, rhs: impl Into<Self>) -> Option<Self> {
  121|     62|        // Idea: we shift the dividend left as much as possible to keep as much precision as possible
  122|     62|        // And we shift right the divisor as much as possible
  123|     62|        // Do the multiplication and do the required shift
  124|     62|        let mut left = self.value;
  125|     62|        let mut shift_left = 0_u32;
  126|     62|        if left != 0 {
  127|  1.30k|            while let Some(r) = left.checked_mul(10) {
  128|  1.24k|                left = r;
  129|  1.24k|                shift_left += 1;
  130|  1.24k|            }
  131|      0|        }
  132|     62|        let mut right = rhs.into().value;
  133|     62|        let mut shift_right = 0_u32;
  134|     62|        if right != 0 {
  135|  1.17k|            while right % 10 == 0 {
  136|  1.11k|                right /= 10;
  137|  1.11k|                shift_right += 1;
  138|  1.11k|            }
  139|      0|        }
  140|       |
  141|       |        // We do division + shift
  142|     62|        let shift = (shift_left + shift_right).checked_sub(DECIMAL_PART_DIGITS)?;
  143|       |        Some(Self {
  144|     62|            value: left
  145|     62|                .checked_div(right)?
  146|     62|                .checked_div(10_i128.checked_pow(shift)?)?,
  147|       |        })
  148|     62|    }
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_divBF_ECs2ek33vt1YA5_8oxigraph:
  120|      2|    pub fn checked_div(self, rhs: impl Into<Self>) -> Option<Self> {
  121|      2|        // Idea: we shift the dividend left as much as possible to keep as much precision as possible
  122|      2|        // And we shift right the divisor as much as possible
  123|      2|        // Do the multiplication and do the required shift
  124|      2|        let mut left = self.value;
  125|      2|        let mut shift_left = 0_u32;
  126|      2|        if left != 0 {
  127|      0|            while let Some(r) = left.checked_mul(10) {
  128|      0|                left = r;
  129|      0|                shift_left += 1;
  130|      0|            }
  131|      2|        }
  132|      2|        let mut right = rhs.into().value;
  133|      2|        let mut shift_right = 0_u32;
  134|      2|        if right != 0 {
  135|      0|            while right % 10 == 0 {
  136|      0|                right /= 10;
  137|      0|                shift_right += 1;
  138|      0|            }
  139|      2|        }
  140|       |
  141|       |        // We do division + shift
  142|      2|        let shift = (shift_left + shift_right).checked_sub(DECIMAL_PART_DIGITS)?;
  143|       |        Some(Self {
  144|      0|            value: left
  145|      0|                .checked_div(right)?
  146|      0|                .checked_div(10_i128.checked_pow(shift)?)?,
  147|       |        })
  148|      2|    }
_RINvXst_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB6_7DecimalNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECs2ek33vt1YA5_8oxigraph:
   15|     20|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_addBF_EB5_:
   63|  9.78k|    pub fn checked_add(self, rhs: impl Into<Self>) -> Option<Self> {
   64|  9.78k|        Some(Self {
   65|  9.78k|            value: self.value.checked_add(rhs.into().value)?,
   66|       |        })
   67|  9.78k|    }
_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB3_7Decimal11checked_remlEB5_:
  155|  4.89k|    pub fn checked_rem(self, rhs: impl Into<Self>) -> Option<Self> {
  156|  4.89k|        Some(Self {
  157|  4.89k|            value: self.value.checked_rem(rhs.into().value)?,
  158|       |        })
  159|  4.89k|    }
_RNCNvXsi_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB7_7DecimalNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt0B9_:
  567|  11.8k|            .find_map(|(i, v)| if v == b'0' { None } else { Some(i) })
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal3newB4_:
   28|  4.89k|    pub const fn new(i: i128, n: u32) -> Result<Self, TooLargeForDecimalError> {
   29|  4.89k|        let Some(shift) = DECIMAL_PART_DIGITS.checked_sub(n) else {
   30|      0|            return Err(TooLargeForDecimalError);
   31|       |        };
   32|  4.89k|        let Some(value) = i.checked_mul(10_i128.pow(shift)) else {
   33|      0|            return Err(TooLargeForDecimalError);
   34|       |        };
   35|  4.89k|        Ok(Self { value })
   36|  4.89k|    }
_RNvXs2_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalINtNtCs9nhK3FOW46N_4core7convert4FromlE4fromB7_:
  298|  4.89k|    fn from(value: i32) -> Self {
  299|  4.89k|        Self {
  300|  4.89k|            value: i128::from(value) * DECIMAL_PART_POW,
  301|  4.89k|        }
  302|  4.89k|    }
_RNvXsh_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtNtCs9nhK3FOW46N_4core3str6traits7FromStr8from_str:
  464|  1.85k|    fn from_str(input: &str) -> Result<Self, Self::Err> {
  465|  1.85k|        // (\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)
  466|  1.85k|        let input = input.as_bytes();
  467|  1.85k|        if input.is_empty() {
  468|      0|            return Err(PARSE_UNEXPECTED_END);
  469|  1.85k|        }
  470|       |
  471|  1.85k|        let (sign, mut input) = match input.first() {
  472|      0|            Some(b'+') => (1_i128, &input[1..]),
  473|      0|            Some(b'-') => (-1_i128, &input[1..]),
  474|  1.85k|            _ => (1, input),
  475|       |        };
  476|       |
  477|  1.85k|        let mut value = 0_i128;
  478|  1.85k|        let with_before_dot = input.first().map_or(false, u8::is_ascii_digit);
  479|  3.71k|        while let Some(c) = input.first() {
  480|  3.70k|            if c.is_ascii_digit() {
  481|  1.85k|                value = value
  482|  1.85k|                    .checked_mul(10)
  483|  1.85k|                    .ok_or(PARSE_OVERFLOW)?
  484|  1.85k|                    .checked_add(sign * i128::from(*c - b'0'))
  485|  1.85k|                    .ok_or(PARSE_OVERFLOW)?;
  486|  1.85k|                input = &input[1..];
  487|       |            } else {
  488|  1.85k|                break;
  489|       |            }
  490|       |        }
  491|       |
  492|  1.85k|        let mut exp = DECIMAL_PART_POW;
  493|  1.85k|        if let Some(c) = input.first() {
  494|  1.85k|            if *c != b'.' {
  495|      0|                return Err(PARSE_UNEXPECTED_CHAR);
  496|  1.85k|            }
  497|  1.85k|            input = &input[1..];
  498|  1.85k|            if input.is_empty() && !with_before_dot {
  499|       |                // We only have a dot
  500|      0|                return Err(PARSE_UNEXPECTED_END);
  501|  1.85k|            }
  502|  3.70k|            while input.last() == Some(&b'0') {
  503|  1.85k|                // Hack to avoid underflows
  504|  1.85k|                input = &input[..input.len() - 1];
  505|  1.85k|            }
  506|  1.85k|            while let Some(c) = input.first() {
  507|      0|                if c.is_ascii_digit() {
  508|      0|                    exp /= 10;
  509|      0|                    value = value
  510|      0|                        .checked_mul(10)
  511|      0|                        .ok_or(PARSE_OVERFLOW)?
  512|      0|                        .checked_add(sign * i128::from(*c - b'0'))
  513|      0|                        .ok_or(PARSE_OVERFLOW)?;
  514|      0|                    input = &input[1..];
  515|       |                } else {
  516|      0|                    return Err(PARSE_UNEXPECTED_CHAR);
  517|       |                }
  518|       |            }
  519|  1.85k|            if exp == 0 {
  520|       |                // Underflow
  521|      0|                return Err(PARSE_UNDERFLOW);
  522|  1.85k|            }
  523|      6|        } else if !with_before_dot {
  524|       |            // It's empty
  525|      0|            return Err(PARSE_UNEXPECTED_END);
  526|      6|        }
  527|       |
  528|       |        Ok(Self {
  529|  1.85k|            value: value.checked_mul(exp).ok_or(PARSE_OVERFLOW)?,
  530|       |        })
  531|  1.85k|    }
_RNvXsi_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  537|    660|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  538|    660|        if self.value == 0 {
  539|     38|            return if let Some(width) = f.width() {
  540|      0|                for _ in 0..width {
  541|      0|                    f.write_char('0')?;
  542|       |                }
  543|      0|                Ok(())
  544|       |            } else {
  545|     38|                f.write_char('0')
  546|       |            };
  547|    622|        }
  548|    622|
  549|    622|        let mut value = self.value;
  550|    622|        if self.value.is_negative() {
  551|      0|            f.write_char('-')?;
  552|    622|        }
  553|       |
  554|    622|        let mut digits = [b'0'; 40];
  555|    622|        let mut i = 0;
  556|  12.4k|        while value != 0 {
  557|  11.8k|            digits[i] = b'0' + ((value % 10).unsigned_abs() as u8);
  558|  11.8k|            value /= 10;
  559|  11.8k|            i += 1;
  560|  11.8k|        }
  561|       |
  562|    622|        let last_non_zero = i - 1;
  563|    622|        let first_non_zero = digits
  564|    622|            .iter()
  565|    622|            .copied()
  566|    622|            .enumerate()
  567|    622|            .find_map(|(i, v)| if v == b'0' { None } else { Some(i) })
  568|    622|            .unwrap_or(40);
  569|       |
  570|    622|        let decimal_part_digits = usize::try_from(DECIMAL_PART_DIGITS).map_err(|_| fmt::Error)?;
  571|    622|        if last_non_zero >= decimal_part_digits {
  572|    622|            let end = if let Some(mut width) = f.width() {
  573|      0|                if self.value.is_negative() {
  574|      0|                    width -= 1;
  575|      0|                }
  576|      0|                if last_non_zero - decimal_part_digits + 1 < width {
  577|      0|                    decimal_part_digits + width
  578|       |                } else {
  579|      0|                    last_non_zero + 1
  580|       |                }
  581|       |            } else {
  582|    622|                last_non_zero + 1
  583|       |            };
  584|    622|            for c in digits[decimal_part_digits..end].iter().rev() {
  585|    622|                f.write_char(char::from(*c))?;
  586|       |            }
  587|       |        } else {
  588|      0|            f.write_char('0')?
  589|       |        }
  590|    622|        if decimal_part_digits > first_non_zero {
  591|      0|            f.write_char('.')?;
  592|      0|            let start = if let Some(precision) = f.precision() {
  593|      0|                if decimal_part_digits - first_non_zero > precision {
  594|      0|                    decimal_part_digits - precision
  595|       |                } else {
  596|      0|                    first_non_zero
  597|       |                }
  598|       |            } else {
  599|      0|                first_non_zero
  600|       |            };
  601|      0|            for c in digits[start..decimal_part_digits].iter().rev() {
  602|      0|                f.write_char(char::from(*c))?;
  603|       |            }
  604|    622|        }
  605|       |
  606|    622|        Ok(())
  607|    660|    }
_RNvXsn_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB7_:
   15|      2|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB2_7Decimal7as_i128B4_:
  264|  4.89k|    pub(super) const fn as_i128(self) -> i128 {
  265|  4.89k|        self.value / DECIMAL_PART_POW
  266|  4.89k|    }
_RNvXs9_NtCsaP05r1vbY5r_12oxsdatatypes7decimalNtB5_7DecimalINtNtCs9nhK3FOW46N_4core7convert7TryFromnE8try_fromB7_:
  361|  4.89k|    fn try_from(value: i128) -> Result<Self, Self::Error> {
  362|  4.89k|        Ok(Self {
  363|  4.89k|            value: value
  364|  4.89k|                .checked_mul(DECIMAL_PART_POW)
  365|  4.89k|                .ok_or(TooLargeForDecimalError)?,
  366|       |        })
  367|  4.89k|    }

_RNvMNtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB2_6Double13from_be_bytesCs2ek33vt1YA5_8oxigraph:
   32|     66|    pub fn from_be_bytes(bytes: [u8; 8]) -> Self {
   33|     66|        Self {
   34|     66|            value: f64::from_be_bytes(bytes),
   35|     66|        }
   36|     66|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB2_6Double11to_be_bytesCs2ek33vt1YA5_8oxigraph:
   40|  1.18k|    pub fn to_be_bytes(self) -> [u8; 8] {
   41|  1.18k|        self.value.to_be_bytes()
   42|  1.18k|    }
_RNvXs0_NtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB5_6DoubleINtNtCs9nhK3FOW46N_4core7convert4FromdE4fromCs2ek33vt1YA5_8oxigraph:
  101|    962|    fn from(value: f64) -> Self {
  102|    962|        Self { value }
  103|    962|    }
_RNvXsb_NtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB5_6DoubleNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  195|     68|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  196|     68|        if self.value == f64::INFINITY {
  197|      0|            f.write_str("INF")
  198|     68|        } else if self.value == f64::NEG_INFINITY {
  199|      0|            f.write_str("-INF")
  200|       |        } else {
  201|     68|            self.value.fmt(f)
  202|       |        }
  203|     68|    }
_RNvXsa_NtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB5_6DoubleNtNtNtCs9nhK3FOW46N_4core3str6traits7FromStr8from_strCs2ek33vt1YA5_8oxigraph:
  188|    962|    fn from_str(input: &str) -> Result<Self, Self::Err> {
  189|    962|        Ok(f64::from_str(input)?.into())
  190|    962|    }
_RNvXsj_NtCsaP05r1vbY5r_12oxsdatatypes6doubleNtB5_6DoubleNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   13|    552|#[derive(Debug, Clone, Copy, Default, PartialEq)]

_RNvMNtCsaP05r1vbY5r_12oxsdatatypes8durationNtB2_8Duration11all_secondsB4_:
  112|  4.89k|    pub(crate) const fn all_seconds(self) -> Decimal {
  113|  4.89k|        self.day_time.as_seconds()
  114|  4.89k|    }
_RNvXsd_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB5_8DurationINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_15DayTimeDurationE4fromB7_:
  569|  4.89k|    fn from(value: DayTimeDuration) -> Self {
  570|  4.89k|        Self {
  571|  4.89k|            year_month: YearMonthDuration::default(),
  572|  4.89k|            day_time: value,
  573|  4.89k|        }
  574|  4.89k|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes8durationNtB2_8Duration10all_monthsB4_:
  106|  4.89k|    pub(crate) const fn all_months(self) -> i64 {
  107|  4.89k|        self.year_month.all_months()
  108|  4.89k|    }
_RNvMs3_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB5_17YearMonthDuration10all_monthsB7_:
  332|  4.89k|    pub(crate) const fn all_months(self) -> i64 {
  333|  4.89k|        self.months
  334|  4.89k|    }
_RNvXsM_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB5_17YearMonthDurationNtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
  296|  4.89k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy, Hash, Default)]
_RNvMsc_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB5_15DayTimeDuration10as_secondsB7_:
  519|  4.89k|    pub const fn as_seconds(self) -> Decimal {
  520|  4.89k|        self.seconds
  521|  4.89k|    }
_RNvXs_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB4_8DurationINtNtCs9nhK3FOW46N_4core7convert7TryFromNtNtB10_4time8DurationE8try_fromB6_:
  177|  4.89k|    fn try_from(value: StdDuration) -> Result<Self, Self::Error> {
  178|  4.89k|        Ok(DayTimeDuration::try_from(value)?.into())
  179|  4.89k|    }
_RNvXsf_NtCsaP05r1vbY5r_12oxsdatatypes8durationNtB5_15DayTimeDurationINtNtCs9nhK3FOW46N_4core7convert7TryFromNtNtB19_4time8DurationE8try_fromB7_:
  594|  4.89k|    fn try_from(value: StdDuration) -> Result<Self, Self::Error> {
  595|  4.89k|        Ok(Self {
  596|  4.89k|            seconds: Decimal::new(
  597|  4.89k|                i128::try_from(value.as_nanos()).map_err(|_| DurationOverflowError)?,
  598|       |                9,
  599|       |            )
  600|  4.89k|            .map_err(|_| DurationOverflowError)?,
  601|       |        })
  602|  4.89k|    }

_RINvMNtCsaP05r1vbY5r_12oxsdatatypes7integerNtB3_7Integer11checked_mulBF_ECs2ek33vt1YA5_8oxigraph:
   60|      2|    pub fn checked_mul(self, rhs: impl Into<Self>) -> Option<Self> {
   61|      2|        Some(Self {
   62|      2|            value: self.value.checked_mul(rhs.into().value)?,
   63|       |        })
   64|      2|    }
_RINvXsn_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB6_7IntegerNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECs2ek33vt1YA5_8oxigraph:
    9|     22|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs8_NtCsaP05r1vbY5r_12oxsdatatypes7integerxINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_7IntegerE4fromCs2ek33vt1YA5_8oxigraph:
  220|    129|    fn from(value: Integer) -> Self {
  221|    129|        value.value
  222|    129|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7integerNtB2_7Integer13from_be_bytesCs2ek33vt1YA5_8oxigraph:
   21|    260|    pub fn from_be_bytes(bytes: [u8; 8]) -> Self {
   22|    260|        Self {
   23|    260|            value: i64::from_be_bytes(bytes),
   24|    260|        }
   25|    260|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7integerNtB2_7Integer11to_be_bytesCs2ek33vt1YA5_8oxigraph:
   29|  2.32k|    pub fn to_be_bytes(self) -> [u8; 8] {
   30|  2.32k|        self.value.to_be_bytes()
   31|  2.32k|    }
_RNvXse_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
    9|    532|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs9_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerNtNtNtCs9nhK3FOW46N_4core3str6traits7FromStr8from_strCs2ek33vt1YA5_8oxigraph:
  229|  2.01k|    fn from_str(input: &str) -> Result<Self, Self::Err> {
  230|  2.01k|        Ok(i64::from_str(input)?.into())
  231|  2.01k|    }
_RNvXsa_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  236|    288|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  237|    288|        self.value.fmt(f)
  238|    288|    }
_RNvXsk_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqCs2ek33vt1YA5_8oxigraph:
    9|      6|#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
_RNvXs3_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerINtNtCs9nhK3FOW46N_4core7convert4FromxE4fromCs2ek33vt1YA5_8oxigraph:
  179|  2.01k|    fn from(value: i64) -> Self {
  180|  2.01k|        Self { value }
  181|  2.01k|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7integerNtB2_7Integer17is_identical_withCs2ek33vt1YA5_8oxigraph:
  136|      4|    pub fn is_identical_with(self, other: Self) -> bool {
  137|      4|        self == other
  138|      4|    }
_RNvMNtCsaP05r1vbY5r_12oxsdatatypes7integerNtB2_7Integer11checked_negCs2ek33vt1YA5_8oxigraph:
  104|    151|    pub fn checked_neg(self) -> Option<Self> {
  105|    151|        Some(Self {
  106|    151|            value: self.value.checked_neg()?,
  107|       |        })
  108|    151|    }
_RNvXs2_NtCsaP05r1vbY5r_12oxsdatatypes7integerNtB5_7IntegerINtNtCs9nhK3FOW46N_4core7convert4FromlE4fromCs2ek33vt1YA5_8oxigraph:
  170|      2|    fn from(value: i32) -> Self {
  171|      2|        Self {
  172|      2|            value: value.into(),
  173|      2|        }
  174|      2|    }

_RNvXs1o_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_11GraphTargetNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
 1354|  1.85k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1h_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12QueryDatasetNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
 1309|  1.75k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsu_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_22PropertyPathExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
    8|  6.07k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsB_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_10ExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  101|  10.3k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsI_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_8FunctionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  321|     29|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsP_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_12GraphPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  518|  26.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXsJ_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_8FunctionNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
  321|     33|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXsv_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_22PropertyPathExpressionNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
    8|  6.95k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsI_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_8FunctionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
  321|    118|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsu_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_22PropertyPathExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
    8|  18.2k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern25lookup_in_scope_variablesNCNvNtB8_6parser12build_select0EB8_:
  934|  3.05k|    fn lookup_in_scope_variables<'a>(&'a self, callback: &mut impl FnMut(&'a Variable)) {
  935|  3.05k|        #[allow(clippy::match_same_arms)]
  936|  3.05k|        match self {
  937|    707|            Self::Bgp { patterns } => {
  938|  2.95k|                for pattern in patterns {
  939|  2.24k|                    lookup_triple_pattern_variables(pattern, callback)
  940|       |                }
  941|       |            }
  942|       |            Self::Path {
  943|    820|                subject, object, ..
  944|       |            } => {
  945|    820|                if let TermPattern::Variable(s) = subject {
  946|    227|                    callback(s);
  947|    593|                }
  948|       |                #[cfg(feature = "rdf-star")]
  949|    820|                if let TermPattern::Triple(s) = subject {
  950|      0|                    lookup_triple_pattern_variables(s, callback)
  951|    820|                }
  952|    820|                if let TermPattern::Variable(o) = object {
  953|    132|                    callback(o);
  954|    688|                }
  955|       |                #[cfg(feature = "rdf-star")]
  956|    820|                if let TermPattern::Triple(o) = object {
  957|      0|                    lookup_triple_pattern_variables(o, callback)
  958|    820|                }
  959|       |            }
  960|    964|            Self::Join { left, right }
  961|     19|            | Self::LeftJoin { left, right, .. }
  962|    983|            | Self::Union { left, right } => {
  963|    983|                left.lookup_in_scope_variables(callback);
  964|    983|                right.lookup_in_scope_variables(callback);
  965|    983|            }
  966|       |            #[cfg(feature = "sep-0006")]
  967|     10|            Self::Lateral { left, right } => {
  968|     10|                left.lookup_in_scope_variables(callback);
  969|     10|                right.lookup_in_scope_variables(callback);
  970|     10|            }
  971|     12|            Self::Graph { name, inner } => {
  972|     12|                if let NamedNodePattern::Variable(g) = &name {
  973|     12|                    callback(g);
  974|     12|                }
  975|     12|                inner.lookup_in_scope_variables(callback);
  976|       |            }
  977|       |            Self::Extend {
  978|      0|                inner, variable, ..
  979|      0|            } => {
  980|      0|                callback(variable);
  981|      0|                inner.lookup_in_scope_variables(callback);
  982|      0|            }
  983|      0|            Self::Minus { left, .. } => left.lookup_in_scope_variables(callback),
  984|       |            Self::Group {
  985|     38|                variables,
  986|     38|                aggregates,
  987|       |                ..
  988|       |            } => {
  989|    148|                for v in variables {
  990|    110|                    callback(v);
  991|    110|                }
  992|     38|                for (v, _) in aggregates {
  993|      0|                    callback(v);
  994|      0|                }
  995|       |            }
  996|    345|            Self::Values { variables, .. } | Self::Project { variables, .. } => {
  997|  1.08k|                for v in variables {
  998|    698|                    callback(v);
  999|    698|                }
 1000|       |            }
 1001|      0|            Self::Service { inner, .. }
 1002|      5|            | Self::Filter { inner, .. }
 1003|      0|            | Self::OrderBy { inner, .. }
 1004|     39|            | Self::Distinct { inner }
 1005|     52|            | Self::Reduced { inner }
 1006|     96|            | Self::Slice { inner, .. } => inner.lookup_in_scope_variables(callback),
 1007|       |        }
 1008|  3.05k|    }
_RINvNtCshSv3hUzq9FP_9spargebra7algebra31lookup_triple_pattern_variablesNCNvNtB4_6parser12build_select0EB4_:
 1011|  2.24k|fn lookup_triple_pattern_variables<'a>(
 1012|  2.24k|    pattern: &'a TriplePattern,
 1013|  2.24k|    callback: &mut impl FnMut(&'a Variable),
 1014|  2.24k|) {
 1015|  2.24k|    if let TermPattern::Variable(s) = &pattern.subject {
 1016|    120|        callback(s);
 1017|  2.12k|    }
 1018|       |    #[cfg(feature = "rdf-star")]
 1019|  2.24k|    if let TermPattern::Triple(s) = &pattern.subject {
 1020|      0|        lookup_triple_pattern_variables(s, callback)
 1021|  2.24k|    }
 1022|  2.24k|    if let NamedNodePattern::Variable(p) = &pattern.predicate {
 1023|  1.41k|        callback(p);
 1024|  1.41k|    }
 1025|  2.24k|    if let TermPattern::Variable(o) = &pattern.object {
 1026|    537|        callback(o);
 1027|  1.70k|    }
 1028|       |    #[cfg(feature = "rdf-star")]
 1029|  2.24k|    if let TermPattern::Triple(o) = &pattern.object {
 1030|      0|        lookup_triple_pattern_variables(o, callback)
 1031|  2.24k|    }
 1032|  2.24k|}
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern20on_in_scope_variableNCNCNvNtNtB8_6parser6parser28___parse_GroupGraphPatternSub0s_0EB8_:
  930|      3|    pub fn on_in_scope_variable<'a>(&'a self, mut callback: impl FnMut(&'a Variable)) {
  931|      3|        self.lookup_in_scope_variables(&mut callback)
  932|      3|    }
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern20on_in_scope_variableNCNvNtB8_6parser12build_select0EB8_:
  930|    960|    pub fn on_in_scope_variable<'a>(&'a self, mut callback: impl FnMut(&'a Variable)) {
  931|    960|        self.lookup_in_scope_variables(&mut callback)
  932|    960|    }
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern20on_in_scope_variableNCNvNtB8_6parser12build_selects_0EB8_:
  930|    764|    pub fn on_in_scope_variable<'a>(&'a self, mut callback: impl FnMut(&'a Variable)) {
  931|    764|        self.lookup_in_scope_variables(&mut callback)
  932|    764|    }
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern25lookup_in_scope_variablesNCNCNvNtNtB8_6parser6parser28___parse_GroupGraphPatternSub00EB8_:
  934|    628|    fn lookup_in_scope_variables<'a>(&'a self, callback: &mut impl FnMut(&'a Variable)) {
  935|    628|        #[allow(clippy::match_same_arms)]
  936|    628|        match self {
  937|    304|            Self::Bgp { patterns } => {
  938|    498|                for pattern in patterns {
  939|    194|                    lookup_triple_pattern_variables(pattern, callback)
  940|       |                }
  941|       |            }
  942|       |            Self::Path {
  943|    151|                subject, object, ..
  944|       |            } => {
  945|    151|                if let TermPattern::Variable(s) = subject {
  946|     17|                    callback(s);
  947|    134|                }
  948|       |                #[cfg(feature = "rdf-star")]
  949|    151|                if let TermPattern::Triple(s) = subject {
  950|      0|                    lookup_triple_pattern_variables(s, callback)
  951|    151|                }
  952|    151|                if let TermPattern::Variable(o) = object {
  953|      5|                    callback(o);
  954|    146|                }
  955|       |                #[cfg(feature = "rdf-star")]
  956|    151|                if let TermPattern::Triple(o) = object {
  957|      0|                    lookup_triple_pattern_variables(o, callback)
  958|    151|                }
  959|       |            }
  960|    168|            Self::Join { left, right }
  961|      1|            | Self::LeftJoin { left, right, .. }
  962|    169|            | Self::Union { left, right } => {
  963|    169|                left.lookup_in_scope_variables(callback);
  964|    169|                right.lookup_in_scope_variables(callback);
  965|    169|            }
  966|       |            #[cfg(feature = "sep-0006")]
  967|      2|            Self::Lateral { left, right } => {
  968|      2|                left.lookup_in_scope_variables(callback);
  969|      2|                right.lookup_in_scope_variables(callback);
  970|      2|            }
  971|      0|            Self::Graph { name, inner } => {
  972|      0|                if let NamedNodePattern::Variable(g) = &name {
  973|      0|                    callback(g);
  974|      0|                }
  975|      0|                inner.lookup_in_scope_variables(callback);
  976|       |            }
  977|       |            Self::Extend {
  978|      0|                inner, variable, ..
  979|      0|            } => {
  980|      0|                callback(variable);
  981|      0|                inner.lookup_in_scope_variables(callback);
  982|      0|            }
  983|      0|            Self::Minus { left, .. } => left.lookup_in_scope_variables(callback),
  984|       |            Self::Group {
  985|      0|                variables,
  986|      0|                aggregates,
  987|       |                ..
  988|       |            } => {
  989|      0|                for v in variables {
  990|      0|                    callback(v);
  991|      0|                }
  992|      0|                for (v, _) in aggregates {
  993|      0|                    callback(v);
  994|      0|                }
  995|       |            }
  996|      2|            Self::Values { variables, .. } | Self::Project { variables, .. } => {
  997|     27|                for v in variables {
  998|     25|                    callback(v);
  999|     25|                }
 1000|       |            }
 1001|      0|            Self::Service { inner, .. }
 1002|      0|            | Self::Filter { inner, .. }
 1003|      0|            | Self::OrderBy { inner, .. }
 1004|      0|            | Self::Distinct { inner }
 1005|      0|            | Self::Reduced { inner }
 1006|      0|            | Self::Slice { inner, .. } => inner.lookup_in_scope_variables(callback),
 1007|       |        }
 1008|    628|    }
_RINvNtCshSv3hUzq9FP_9spargebra7algebra14write_arg_listRNtB2_10ExpressionRINtNtCsjOdcKtOMjJI_5alloc3vec3VecBR_EEB4_:
  304|    142|fn write_arg_list(
  305|    142|    params: impl IntoIterator<Item = impl fmt::Display>,
  306|    142|    f: &mut fmt::Formatter<'_>,
  307|    142|) -> fmt::Result {
  308|    142|    f.write_str("(")?;
  309|    142|    let mut cont = false;
  310|    220|    for p in params {
  311|     78|        if cont {
  312|      2|            f.write_str(", ")?;
  313|     76|        }
  314|     78|        p.fmt(f)?;
  315|     78|        cont = true;
  316|       |    }
  317|    142|    f.write_str(")")
  318|    142|}
_RINvNtCshSv3hUzq9FP_9spargebra7algebra31lookup_triple_pattern_variablesNCNCNvNtNtB4_6parser6parser28___parse_GroupGraphPatternSub00EB4_:
 1011|    194|fn lookup_triple_pattern_variables<'a>(
 1012|    194|    pattern: &'a TriplePattern,
 1013|    194|    callback: &mut impl FnMut(&'a Variable),
 1014|    194|) {
 1015|    194|    if let TermPattern::Variable(s) = &pattern.subject {
 1016|      0|        callback(s);
 1017|    194|    }
 1018|       |    #[cfg(feature = "rdf-star")]
 1019|    194|    if let TermPattern::Triple(s) = &pattern.subject {
 1020|      0|        lookup_triple_pattern_variables(s, callback)
 1021|    194|    }
 1022|    194|    if let NamedNodePattern::Variable(p) = &pattern.predicate {
 1023|    108|        callback(p);
 1024|    108|    }
 1025|    194|    if let TermPattern::Variable(o) = &pattern.object {
 1026|     63|        callback(o);
 1027|    131|    }
 1028|       |    #[cfg(feature = "rdf-star")]
 1029|    194|    if let TermPattern::Triple(o) = &pattern.object {
 1030|      0|        lookup_triple_pattern_variables(o, callback)
 1031|    194|    }
 1032|    194|}
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern20on_in_scope_variableNCNCNvNtNtB8_6parser6parser28___parse_GroupGraphPatternSub00EB8_:
  930|    286|    pub fn on_in_scope_variable<'a>(&'a self, mut callback: impl FnMut(&'a Variable)) {
  931|    286|        self.lookup_in_scope_variables(&mut callback)
  932|    286|    }
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern25lookup_in_scope_variablesNCNvNtB8_6parser12build_selects_0EB8_:
  934|  6.12k|    fn lookup_in_scope_variables<'a>(&'a self, callback: &mut impl FnMut(&'a Variable)) {
  935|  6.12k|        #[allow(clippy::match_same_arms)]
  936|  6.12k|        match self {
  937|    874|            Self::Bgp { patterns } => {
  938|  5.94k|                for pattern in patterns {
  939|  5.06k|                    lookup_triple_pattern_variables(pattern, callback)
  940|       |                }
  941|       |            }
  942|       |            Self::Path {
  943|  2.23k|                subject, object, ..
  944|       |            } => {
  945|  2.23k|                if let TermPattern::Variable(s) = subject {
  946|    451|                    callback(s);
  947|  1.78k|                }
  948|       |                #[cfg(feature = "rdf-star")]
  949|  2.23k|                if let TermPattern::Triple(s) = subject {
  950|      0|                    lookup_triple_pattern_variables(s, callback)
  951|  2.23k|                }
  952|  2.23k|                if let TermPattern::Variable(o) = object {
  953|    404|                    callback(o);
  954|  1.82k|                }
  955|       |                #[cfg(feature = "rdf-star")]
  956|  2.23k|                if let TermPattern::Triple(o) = object {
  957|      0|                    lookup_triple_pattern_variables(o, callback)
  958|  2.23k|                }
  959|       |            }
  960|  2.52k|            Self::Join { left, right }
  961|     52|            | Self::LeftJoin { left, right, .. }
  962|  2.58k|            | Self::Union { left, right } => {
  963|  2.58k|                left.lookup_in_scope_variables(callback);
  964|  2.58k|                right.lookup_in_scope_variables(callback);
  965|  2.58k|            }
  966|       |            #[cfg(feature = "sep-0006")]
  967|     24|            Self::Lateral { left, right } => {
  968|     24|                left.lookup_in_scope_variables(callback);
  969|     24|                right.lookup_in_scope_variables(callback);
  970|     24|            }
  971|     14|            Self::Graph { name, inner } => {
  972|     14|                if let NamedNodePattern::Variable(g) = &name {
  973|     13|                    callback(g);
  974|     13|                }
  975|     14|                inner.lookup_in_scope_variables(callback);
  976|       |            }
  977|       |            Self::Extend {
  978|      0|                inner, variable, ..
  979|      0|            } => {
  980|      0|                callback(variable);
  981|      0|                inner.lookup_in_scope_variables(callback);
  982|      0|            }
  983|      2|            Self::Minus { left, .. } => left.lookup_in_scope_variables(callback),
  984|       |            Self::Group {
  985|      0|                variables,
  986|      0|                aggregates,
  987|       |                ..
  988|       |            } => {
  989|      0|                for v in variables {
  990|      0|                    callback(v);
  991|      0|                }
  992|      0|                for (v, _) in aggregates {
  993|      0|                    callback(v);
  994|      0|                }
  995|       |            }
  996|    137|            Self::Values { variables, .. } | Self::Project { variables, .. } => {
  997|  2.84k|                for v in variables {
  998|  2.58k|                    callback(v);
  999|  2.58k|                }
 1000|       |            }
 1001|      0|            Self::Service { inner, .. }
 1002|     17|            | Self::Filter { inner, .. }
 1003|      0|            | Self::OrderBy { inner, .. }
 1004|     39|            | Self::Distinct { inner }
 1005|     84|            | Self::Reduced { inner }
 1006|    140|            | Self::Slice { inner, .. } => inner.lookup_in_scope_variables(callback),
 1007|       |        }
 1008|  6.12k|    }
_RINvNtCshSv3hUzq9FP_9spargebra7algebra31lookup_triple_pattern_variablesNCNvNtB4_6parser12build_selects_0EB4_:
 1011|  5.06k|fn lookup_triple_pattern_variables<'a>(
 1012|  5.06k|    pattern: &'a TriplePattern,
 1013|  5.06k|    callback: &mut impl FnMut(&'a Variable),
 1014|  5.06k|) {
 1015|  5.06k|    if let TermPattern::Variable(s) = &pattern.subject {
 1016|    224|        callback(s);
 1017|  4.84k|    }
 1018|       |    #[cfg(feature = "rdf-star")]
 1019|  5.06k|    if let TermPattern::Triple(s) = &pattern.subject {
 1020|      0|        lookup_triple_pattern_variables(s, callback)
 1021|  5.06k|    }
 1022|  5.06k|    if let NamedNodePattern::Variable(p) = &pattern.predicate {
 1023|  3.09k|        callback(p);
 1024|  3.09k|    }
 1025|  5.06k|    if let TermPattern::Variable(o) = &pattern.object {
 1026|  1.15k|        callback(o);
 1027|  3.91k|    }
 1028|       |    #[cfg(feature = "rdf-star")]
 1029|  5.06k|    if let TermPattern::Triple(o) = &pattern.object {
 1030|      0|        lookup_triple_pattern_variables(o, callback)
 1031|  5.06k|    }
 1032|  5.06k|}
_RINvMsb_NtCshSv3hUzq9FP_9spargebra7algebraNtB6_12GraphPattern25lookup_in_scope_variablesNCNCNvNtNtB8_6parser6parser28___parse_GroupGraphPatternSub0s_0EB8_:
  934|      9|    fn lookup_in_scope_variables<'a>(&'a self, callback: &mut impl FnMut(&'a Variable)) {
  935|      9|        #[allow(clippy::match_same_arms)]
  936|      9|        match self {
  937|      3|            Self::Bgp { patterns } => {
  938|      3|                for pattern in patterns {
  939|      0|                    lookup_triple_pattern_variables(pattern, callback)
  940|       |                }
  941|       |            }
  942|       |            Self::Path {
  943|      0|                subject, object, ..
  944|       |            } => {
  945|      0|                if let TermPattern::Variable(s) = subject {
  946|      0|                    callback(s);
  947|      0|                }
  948|       |                #[cfg(feature = "rdf-star")]
  949|      0|                if let TermPattern::Triple(s) = subject {
  950|      0|                    lookup_triple_pattern_variables(s, callback)
  951|      0|                }
  952|      0|                if let TermPattern::Variable(o) = object {
  953|      0|                    callback(o);
  954|      0|                }
  955|       |                #[cfg(feature = "rdf-star")]
  956|      0|                if let TermPattern::Triple(o) = object {
  957|      0|                    lookup_triple_pattern_variables(o, callback)
  958|      0|                }
  959|       |            }
  960|      0|            Self::Join { left, right }
  961|      0|            | Self::LeftJoin { left, right, .. }
  962|      0|            | Self::Union { left, right } => {
  963|      0|                left.lookup_in_scope_variables(callback);
  964|      0|                right.lookup_in_scope_variables(callback);
  965|      0|            }
  966|       |            #[cfg(feature = "sep-0006")]
  967|      2|            Self::Lateral { left, right } => {
  968|      2|                left.lookup_in_scope_variables(callback);
  969|      2|                right.lookup_in_scope_variables(callback);
  970|      2|            }
  971|      0|            Self::Graph { name, inner } => {
  972|      0|                if let NamedNodePattern::Variable(g) = &name {
  973|      0|                    callback(g);
  974|      0|                }
  975|      0|                inner.lookup_in_scope_variables(callback);
  976|       |            }
  977|       |            Self::Extend {
  978|      0|                inner, variable, ..
  979|      0|            } => {
  980|      0|                callback(variable);
  981|      0|                inner.lookup_in_scope_variables(callback);
  982|      0|            }
  983|      0|            Self::Minus { left, .. } => left.lookup_in_scope_variables(callback),
  984|       |            Self::Group {
  985|      0|                variables,
  986|      0|                aggregates,
  987|       |                ..
  988|       |            } => {
  989|      0|                for v in variables {
  990|      0|                    callback(v);
  991|      0|                }
  992|      0|                for (v, _) in aggregates {
  993|      0|                    callback(v);
  994|      0|                }
  995|       |            }
  996|      2|            Self::Values { variables, .. } | Self::Project { variables, .. } => {
  997|      8|                for v in variables {
  998|      6|                    callback(v);
  999|      6|                }
 1000|       |            }
 1001|      0|            Self::Service { inner, .. }
 1002|      0|            | Self::Filter { inner, .. }
 1003|      0|            | Self::OrderBy { inner, .. }
 1004|      2|            | Self::Distinct { inner }
 1005|      0|            | Self::Reduced { inner }
 1006|      2|            | Self::Slice { inner, .. } => inner.lookup_in_scope_variables(callback),
 1007|       |        }
 1008|      9|    }
_RNvXs5_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4from:
  290|  6.01k|    fn from(v: Variable) -> Self {
  291|  6.01k|        Self::Variable(v)
  292|  6.01k|    }
_RNvXso_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_11GraphTargetINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_4term9GraphNameE4from:
 1392|    424|    fn from(graph_name: GraphName) -> Self {
 1393|    424|        match graph_name {
 1394|    290|            GraphName::NamedNode(node) => Self::NamedNode(node),
 1395|    134|            GraphName::DefaultGraph => Self::DefaultGraph,
 1396|       |        }
 1397|    424|    }
_RNvXs0_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_22PropertyPathExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4from:
   95|  11.1k|    fn from(p: NamedNode) -> Self {
   96|  11.1k|        Self::NamedNode(p)
   97|  11.1k|    }
_RNvXs3_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4from:
  278|    730|    fn from(p: NamedNode) -> Self {
  279|    730|        Self::NamedNode(p)
  280|    730|    }
_RNvXs4_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE4from:
  284|  3.30k|    fn from(p: Literal) -> Self {
  285|  3.30k|        Self::Literal(p)
  286|  3.30k|    }
_RNvXsc_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_22SparqlGraphRootPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1040|    124|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1041|    124|        let mut distinct = false;
 1042|    124|        let mut reduced = false;
 1043|    124|        let mut order = None;
 1044|    124|        let mut start = 0;
 1045|    124|        let mut length = None;
 1046|    124|        let mut project: &[Variable] = &[];
 1047|    124|
 1048|    124|        let mut child = self.pattern;
 1049|       |        loop {
 1050|    140|            match child {
 1051|      0|                GraphPattern::OrderBy { inner, expression } => {
 1052|      0|                    order = Some(expression);
 1053|      0|                    child = inner;
 1054|      0|                }
 1055|    140|                GraphPattern::Project { inner, variables } if project.is_empty() => {
 1056|    126|                    project = variables;
 1057|    126|                    child = inner;
 1058|    126|                }
 1059|    102|                GraphPattern::Distinct { inner } => {
 1060|    102|                    distinct = true;
 1061|    102|                    child = inner;
 1062|    102|                }
 1063|      0|                GraphPattern::Reduced { inner } => {
 1064|      0|                    reduced = true;
 1065|      0|                    child = inner;
 1066|      0|                }
 1067|       |                GraphPattern::Slice {
 1068|      0|                    inner,
 1069|      0|                    start: s,
 1070|      0|                    length: l,
 1071|      0|                } => {
 1072|      0|                    start = *s;
 1073|      0|                    length = *l;
 1074|      0|                    child = inner;
 1075|      0|                }
 1076|    124|                p => {
 1077|    124|                    f.write_str("SELECT")?;
 1078|    124|                    if distinct {
 1079|     94|                        f.write_str(" DISTINCT")?;
 1080|     30|                    }
 1081|    124|                    if reduced {
 1082|      0|                        f.write_str(" REDUCED")?;
 1083|    124|                    }
 1084|    124|                    if project.is_empty() {
 1085|     22|                        f.write_str(" *")?;
 1086|       |                    } else {
 1087|    264|                        for v in project {
 1088|    162|                            write!(f, " {v}")?;
 1089|       |                        }
 1090|       |                    }
 1091|    124|                    if let Some(dataset) = self.dataset {
 1092|      0|                        write!(f, " {dataset}")?;
 1093|    124|                    }
 1094|    124|                    write!(f, " WHERE {{ {p} }}")?;
 1095|    124|                    if let Some(order) = order {
 1096|      0|                        f.write_str(" ORDER BY")?;
 1097|      0|                        for c in order {
 1098|      0|                            write!(f, " {c}")?;
 1099|       |                        }
 1100|    124|                    }
 1101|    124|                    if start > 0 {
 1102|      0|                        write!(f, " OFFSET {start}")?;
 1103|    124|                    }
 1104|    124|                    if let Some(length) = length {
 1105|      0|                        write!(f, " LIMIT {length}")?;
 1106|    124|                    }
 1107|    124|                    return Ok(());
 1108|       |                }
 1109|       |            }
 1110|       |        }
 1111|    124|    }
_RNvXs_NtCshSv3hUzq9FP_9spargebra7algebraNtB4_22PropertyPathExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
   71|  96.1k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   72|  96.1k|        match self {
   73|  24.0k|            Self::NamedNode(p) => p.fmt(f),
   74|  30.7k|            Self::Reverse(p) => write!(f, "^({p})"),
   75|  11.1k|            Self::Sequence(a, b) => write!(f, "({a} / {b})"),
   76|  4.90k|            Self::Alternative(a, b) => write!(f, "({a} | {b})"),
   77|  2.86k|            Self::ZeroOrMore(p) => write!(f, "({p})*"),
   78|  5.39k|            Self::OneOrMore(p) => write!(f, "({p})+"),
   79|  12.4k|            Self::ZeroOrOne(p) => write!(f, "({p})?"),
   80|  4.49k|            Self::NegatedPropertySet(p) => {
   81|  4.49k|                f.write_str("!(")?;
   82|  17.3k|                for (i, c) in p.iter().enumerate() {
   83|  17.3k|                    if i > 0 {
   84|  12.8k|                        f.write_str(" | ")?;
   85|  4.49k|                    }
   86|  17.3k|                    write!(f, "{c}")?;
   87|       |                }
   88|  4.49k|                f.write_str(")")
   89|       |            }
   90|       |        }
   91|  96.1k|    }
_RNvXs2_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_10ExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  218|  22.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  219|  22.5k|        match self {
  220|    600|            Self::NamedNode(node) => node.fmt(f),
  221|  4.15k|            Self::Literal(l) => l.fmt(f),
  222|  4.62k|            Self::Variable(var) => var.fmt(f),
  223|     36|            Self::Or(a, b) => write!(f, "({a} || {b})"),
  224|    284|            Self::And(a, b) => write!(f, "({a} && {b})"),
  225|    871|            Self::Equal(a, b) => {
  226|    871|                write!(f, "({a} = {b})")
  227|       |            }
  228|      3|            Self::SameTerm(a, b) => {
  229|      3|                write!(f, "sameTerm({a}, {b})")
  230|       |            }
  231|     36|            Self::Greater(a, b) => {
  232|     36|                write!(f, "({a} > {b})")
  233|       |            }
  234|    152|            Self::GreaterOrEqual(a, b) => write!(f, "({a} >= {b})"),
  235|     16|            Self::Less(a, b) => {
  236|     16|                write!(f, "({a} < {b})")
  237|       |            }
  238|     26|            Self::LessOrEqual(a, b) => write!(f, "({a} <= {b})"),
  239|      0|            Self::In(a, b) => {
  240|      0|                write!(f, "({a} IN ")?;
  241|      0|                write_arg_list(b, f)?;
  242|      0|                f.write_str(")")
  243|       |            }
  244|    268|            Self::Add(a, b) => {
  245|    268|                write!(f, "{a} + {b}")
  246|       |            }
  247|  1.72k|            Self::Subtract(a, b) => {
  248|  1.72k|                write!(f, "{a} - {b}")
  249|       |            }
  250|    590|            Self::Multiply(a, b) => {
  251|    590|                write!(f, "{a} * {b}")
  252|       |            }
  253|  3.26k|            Self::Divide(a, b) => {
  254|  3.26k|                write!(f, "{a} / {b}")
  255|       |            }
  256|    324|            Self::UnaryPlus(e) => write!(f, "+{e}"),
  257|  2.26k|            Self::UnaryMinus(e) => write!(f, "-{e}"),
  258|  2.24k|            Self::Not(e) => match e.as_ref() {
  259|     64|                Self::Exists(p) => write!(f, "NOT EXISTS {{ {p} }}"),
  260|  2.17k|                e => write!(f, "!{e}"),
  261|       |            },
  262|     60|            Self::FunctionCall(function, parameters) => {
  263|     60|                write!(f, "{function}")?;
  264|     60|                write_arg_list(parameters, f)
  265|       |            }
  266|    197|            Self::Bound(v) => write!(f, "BOUND({v})"),
  267|     62|            Self::Exists(p) => write!(f, "EXISTS {{ {p} }}"),
  268|    718|            Self::If(a, b, c) => write!(f, "IF({a}, {b}, {c})"),
  269|     82|            Self::Coalesce(parameters) => {
  270|     82|                f.write_str("COALESCE")?;
  271|     82|                write_arg_list(parameters, f)
  272|       |            }
  273|       |        }
  274|  22.5k|    }
_RNvXsu_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_22PropertyPathExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
    8|   231k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsa_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_12GraphPatternNtNtCs9nhK3FOW46N_4core7default7Default7default:
  719|  3.83k|    fn default() -> Self {
  720|  3.83k|        Self::Bgp {
  721|  3.83k|            patterns: Vec::default(),
  722|  3.83k|        }
  723|  3.83k|    }
_RNvXs8_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_8FunctionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  452|     60|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  453|     60|        match self {
  454|     10|            Self::Str => f.write_str("STR"),
  455|      6|            Self::Lang => f.write_str("LANG"),
  456|      0|            Self::LangMatches => f.write_str("LANGMATCHES"),
  457|      2|            Self::Datatype => f.write_str("DATATYPE"),
  458|      4|            Self::Iri => f.write_str("IRI"),
  459|      8|            Self::BNode => f.write_str("BNODE"),
  460|      0|            Self::Rand => f.write_str("RAND"),
  461|      0|            Self::Abs => f.write_str("ABS"),
  462|      0|            Self::Ceil => f.write_str("CEIL"),
  463|      0|            Self::Floor => f.write_str("FLOOR"),
  464|      0|            Self::Round => f.write_str("ROUND"),
  465|      0|            Self::Concat => f.write_str("CONCAT"),
  466|      0|            Self::SubStr => f.write_str("SUBSTR"),
  467|      0|            Self::StrLen => f.write_str("STRLEN"),
  468|      0|            Self::Replace => f.write_str("REPLACE"),
  469|      0|            Self::UCase => f.write_str("UCASE"),
  470|      0|            Self::LCase => f.write_str("LCASE"),
  471|      0|            Self::EncodeForUri => f.write_str("ENCODE_FOR_URI"),
  472|      0|            Self::Contains => f.write_str("CONTAINS"),
  473|      0|            Self::StrStarts => f.write_str("STRSTARTS"),
  474|      0|            Self::StrEnds => f.write_str("STRENDS"),
  475|      0|            Self::StrBefore => f.write_str("STRBEFORE"),
  476|      0|            Self::StrAfter => f.write_str("STRAFTER"),
  477|      0|            Self::Year => f.write_str("YEAR"),
  478|      0|            Self::Month => f.write_str("MONTH"),
  479|      0|            Self::Day => f.write_str("DAY"),
  480|      0|            Self::Hours => f.write_str("HOURS"),
  481|      0|            Self::Minutes => f.write_str("MINUTES"),
  482|      0|            Self::Seconds => f.write_str("SECONDS"),
  483|      0|            Self::Timezone => f.write_str("TIMEZONE"),
  484|      0|            Self::Tz => f.write_str("TZ"),
  485|      0|            Self::Now => f.write_str("NOW"),
  486|      0|            Self::Uuid => f.write_str("UUID"),
  487|      0|            Self::StrUuid => f.write_str("STRUUID"),
  488|      0|            Self::Md5 => f.write_str("MD5"),
  489|      0|            Self::Sha1 => f.write_str("SHA1"),
  490|      0|            Self::Sha256 => f.write_str("SHA256"),
  491|      0|            Self::Sha384 => f.write_str("SHA384"),
  492|      0|            Self::Sha512 => f.write_str("SHA512"),
  493|      0|            Self::StrLang => f.write_str("STRLANG"),
  494|      2|            Self::StrDt => f.write_str("STRDT"),
  495|      6|            Self::IsIri => f.write_str("isIRI"),
  496|     14|            Self::IsBlank => f.write_str("isBLANK"),
  497|      0|            Self::IsLiteral => f.write_str("isLITERAL"),
  498|      8|            Self::IsNumeric => f.write_str("isNUMERIC"),
  499|      0|            Self::Regex => f.write_str("REGEX"),
  500|       |            #[cfg(feature = "rdf-star")]
  501|      0|            Self::Triple => f.write_str("TRIPLE"),
  502|       |            #[cfg(feature = "rdf-star")]
  503|      0|            Self::Subject => f.write_str("SUBJECT"),
  504|       |            #[cfg(feature = "rdf-star")]
  505|      0|            Self::Predicate => f.write_str("PREDICATE"),
  506|       |            #[cfg(feature = "rdf-star")]
  507|      0|            Self::Object => f.write_str("OBJECT"),
  508|       |            #[cfg(feature = "rdf-star")]
  509|      0|            Self::IsTriple => f.write_str("isTRIPLE"),
  510|       |            #[cfg(feature = "sep-0002")]
  511|      0|            Self::Adjust => f.write_str("ADJUST"),
  512|      0|            Self::Custom(iri) => iri.fmt(f),
  513|       |        }
  514|     60|    }
_RNvXs9_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_12GraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  595|  1.79k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  596|  1.79k|        match self {
  597|    103|            Self::Bgp { patterns } => {
  598|    393|                for pattern in patterns {
  599|    290|                    write!(f, "{pattern} .")?
  600|       |                }
  601|    103|                Ok(())
  602|       |            }
  603|       |            Self::Path {
  604|    510|                subject,
  605|    510|                path,
  606|    510|                object,
  607|    510|            } => write!(f, "{subject} {path} {object} ."),
  608|    535|            Self::Join { left, right } => {
  609|    535|                #[allow(clippy::match_same_arms)]
  610|    535|                match right.as_ref() {
  611|       |                    Self::LeftJoin { .. }
  612|       |                    | Self::Minus { .. }
  613|       |                    | Self::Extend { .. }
  614|       |                    | Self::Filter { .. } => {
  615|       |                        // The second block might be considered as a modification of the first one.
  616|      0|                        write!(f, "{left} {{ {right} }}")
  617|       |                    }
  618|       |                    #[cfg(feature = "sep-0006")]
  619|       |                    Self::Lateral { .. } => {
  620|      0|                        write!(f, "{left} {{ {right} }}")
  621|       |                    }
  622|    535|                    _ => write!(f, "{left} {right}"),
  623|       |                }
  624|       |            }
  625|       |            Self::LeftJoin {
  626|     10|                left,
  627|     10|                right,
  628|     10|                expression,
  629|       |            } => {
  630|     10|                if let Some(expr) = expression {
  631|      0|                    write!(f, "{left} OPTIONAL {{ {right} FILTER({expr}) }}")
  632|       |                } else {
  633|     10|                    write!(f, "{left} OPTIONAL {{ {right} }}")
  634|       |                }
  635|       |            }
  636|       |            #[cfg(feature = "sep-0006")]
  637|      2|            Self::Lateral { left, right } => {
  638|      2|                write!(f, "{left} LATERAL {{ {right} }}")
  639|       |            }
  640|      0|            Self::Filter { expr, inner } => {
  641|      0|                write!(f, "{inner} FILTER({expr})")
  642|       |            }
  643|      0|            Self::Union { left, right } => write!(f, "{{ {left} }} UNION {{ {right} }}"),
  644|    418|            Self::Graph { name, inner } => {
  645|    418|                write!(f, "GRAPH {name} {{ {inner} }}")
  646|       |            }
  647|       |            Self::Extend {
  648|     32|                inner,
  649|     32|                variable,
  650|     32|                expression,
  651|     32|            } => write!(f, "{inner} BIND({expression} AS {variable})"),
  652|      0|            Self::Minus { left, right } => write!(f, "{left} MINUS {{ {right} }}"),
  653|       |            Self::Service {
  654|      0|                name,
  655|      0|                inner,
  656|      0|                silent,
  657|      0|            } => {
  658|      0|                if *silent {
  659|      0|                    write!(f, "SERVICE SILENT {name} {{ {inner} }}")
  660|       |                } else {
  661|      0|                    write!(f, "SERVICE {name} {{ {inner} }}")
  662|       |                }
  663|       |            }
  664|       |            Self::Values {
  665|     60|                variables,
  666|     60|                bindings,
  667|     60|            } => {
  668|     60|                f.write_str("VALUES ( ")?;
  669|    123|                for var in variables {
  670|     63|                    write!(f, "{var} ")?;
  671|       |                }
  672|     60|                f.write_str(") { ")?;
  673|    118|                for row in bindings {
  674|     58|                    f.write_str("( ")?;
  675|     68|                    for val in row {
  676|     10|                        match val {
  677|      4|                            Some(val) => write!(f, "{val} "),
  678|      6|                            None => f.write_str("UNDEF "),
  679|      0|                        }?;
  680|       |                    }
  681|     58|                    f.write_str(") ")?;
  682|       |                }
  683|     60|                f.write_str(" }")
  684|       |            }
  685|       |            Self::Group {
  686|      0|                inner,
  687|      0|                variables,
  688|      0|                aggregates,
  689|      0|            } => {
  690|      0|                f.write_str("{SELECT")?;
  691|      0|                for (a, v) in aggregates {
  692|      0|                    write!(f, " ({v} AS {a})")?;
  693|       |                }
  694|      0|                for b in variables {
  695|      0|                    write!(f, " {b}")?;
  696|       |                }
  697|      0|                write!(f, " WHERE {{ {inner} }}")?;
  698|      0|                if !variables.is_empty() {
  699|      0|                    f.write_str(" GROUP BY")?;
  700|      0|                    for v in variables {
  701|      0|                        write!(f, " {v}")?;
  702|       |                    }
  703|      0|                }
  704|      0|                f.write_str("}")
  705|       |            }
  706|    124|            p => write!(
  707|    124|                f,
  708|    124|                "{{ {} }}",
  709|    124|                SparqlGraphRootPattern {
  710|    124|                    pattern: p,
  711|    124|                    dataset: None
  712|    124|                }
  713|    124|            ),
  714|       |        }
  715|  1.79k|    }
_RNvXsn_NtCshSv3hUzq9FP_9spargebra7algebraNtB5_11GraphTargetINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4from:
 1386|    954|    fn from(node: NamedNode) -> Self {
 1387|    954|        Self::NamedNode(node)
 1388|    954|    }

_RNvXs0_NtCshSv3hUzq9FP_9spargebra6parserNtB5_22VariableOrPropertyPathINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4from:
   83|  9.46k|    fn from(var: Variable) -> Self {
   84|  9.46k|        Self::Variable(var)
   85|  9.46k|    }
_RNvNtCshSv3hUzq9FP_9spargebra6parser12parse_update:
   24|  2.71k|pub fn parse_update(update: &str, base_iri: Option<&str>) -> Result<Update, SparqlSyntaxError> {
   25|  2.71k|    let mut state = ParserState::from_base_iri(base_iri)?;
   26|  2.71k|    let operations = parser::UpdateInit(update, &mut state)
   27|  2.71k|        .map_err(|e| SparqlSyntaxError(ParseErrorKind::Syntax(e)))?;
   28|  2.49k|    Ok(Update {
   29|  2.49k|        operations,
   30|  2.49k|        base_iri: state.base_iri,
   31|  2.49k|    })
   32|  2.71k|}
_RNvXsk_NtCshSv3hUzq9FP_9spargebra6parserNtB5_22VariableOrPropertyPathNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
   76|  15.0k|#[derive(Clone, Debug)]
_RNvNtCshSv3hUzq9FP_9spargebra6parser8variable:
  774|     51|fn variable() -> Variable {
  775|     51|    Variable::new_unchecked(format!("{:x}", random::<u128>()))
  776|     51|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser12build_select:
  388|  1.76k|fn build_select(
  389|  1.76k|    select: Selection,
  390|  1.76k|    r#where: GraphPattern,
  391|  1.76k|    mut group: Option<(Vec<Variable>, Vec<(Expression, Variable)>)>,
  392|  1.76k|    having: Option<Expression>,
  393|  1.76k|    order_by: Option<Vec<OrderExpression>>,
  394|  1.76k|    offset_limit: Option<(usize, Option<usize>)>,
  395|  1.76k|    values: Option<GraphPattern>,
  396|  1.76k|    state: &mut ParserState,
  397|  1.76k|) -> Result<GraphPattern, &'static str> {
  398|  1.76k|    let mut p = r#where;
  399|  1.76k|    let mut with_aggregate = false;
  400|  1.76k|
  401|  1.76k|    // GROUP BY
  402|  1.76k|    let aggregates = state.aggregates.pop().unwrap_or_default();
  403|  1.76k|    if group.is_none() && !aggregates.is_empty() {
  404|      0|        group = Some((vec![], vec![]));
  405|  1.76k|    }
  406|       |
  407|  1.76k|    if let Some((clauses, binds)) = group {
  408|    131|        for (expression, variable) in binds {
  409|     51|            p = GraphPattern::Extend {
  410|     51|                inner: Box::new(p),
  411|     51|                variable,
  412|     51|                expression,
  413|     51|            };
  414|     51|        }
  415|     80|        p = GraphPattern::Group {
  416|     80|            inner: Box::new(p),
  417|     80|            variables: clauses,
  418|     80|            aggregates,
  419|     80|        };
  420|     80|        with_aggregate = true;
  421|  1.68k|    }
  422|       |
  423|       |    // HAVING
  424|  1.76k|    if let Some(expr) = having {
  425|     22|        p = GraphPattern::Filter {
  426|     22|            expr,
  427|     22|            inner: Box::new(p),
  428|     22|        };
  429|  1.74k|    }
  430|       |
  431|       |    // VALUES
  432|  1.76k|    if let Some(data) = values {
  433|     77|        p = new_join(p, data);
  434|  1.68k|    }
  435|       |
  436|       |    // SELECT
  437|  1.76k|    let mut pv = Vec::new();
  438|  1.76k|    let with_project = match select.variables {
  439|    960|        SelectionVariables::Explicit(sel_items) => {
  440|    960|            let mut visible = HashSet::default();
  441|    960|            p.on_in_scope_variable(|v| {
  442|       |                visible.insert(v.clone());
  443|    960|            });
  444|  1.68k|            for sel_item in sel_items {
  445|  1.11k|                let v = match sel_item {
  446|    392|                    SelectionMember::Variable(v) => {
  447|    392|                        if with_aggregate && !visible.contains(&v) {
  448|       |                            // We validate projection variables if there is an aggregate
  449|     16|                            return Err("The SELECT contains a variable that is unbound");
  450|    376|                        }
  451|    376|                        v
  452|       |                    }
  453|    725|                    SelectionMember::Expression(expression, variable) => {
  454|    725|                        if visible.contains(&variable) {
  455|       |                            // We disallow to override an existing variable with an expression
  456|    270|                            return Err(
  457|    270|                                "The SELECT overrides an existing variable using an expression",
  458|    270|                            );
  459|    455|                        }
  460|    455|                        if with_aggregate && !are_variables_bound(&expression, &visible) {
  461|       |                            // We validate projection variables if there is an aggregate
  462|      8|                            return Err(
  463|      8|                                "The SELECT contains an expression with a variable that is unbound",
  464|      8|                            );
  465|    447|                        }
  466|    447|                        p = GraphPattern::Extend {
  467|    447|                            inner: Box::new(p),
  468|    447|                            variable: variable.clone(),
  469|    447|                            expression,
  470|    447|                        };
  471|    447|                        variable
  472|       |                    }
  473|       |                };
  474|    823|                if pv.contains(&v) {
  475|     96|                    return Err("Duplicated variable name in SELECT");
  476|    727|                }
  477|    727|                pv.push(v)
  478|       |            }
  479|    570|            true
  480|       |        }
  481|       |        SelectionVariables::Star => {
  482|    806|            if with_aggregate {
  483|     42|                return Err("SELECT * is not authorized with GROUP BY");
  484|    764|            }
  485|    764|            // TODO: is it really useful to do a projection?
  486|    764|            p.on_in_scope_variable(|v| {
  487|       |                if !pv.contains(v) {
  488|       |                    pv.push(v.clone());
  489|       |                }
  490|    764|            });
  491|    764|            pv.sort();
  492|    764|            true
  493|       |        }
  494|      0|        SelectionVariables::Everything => false,
  495|       |    };
  496|       |
  497|  1.33k|    let mut m = p;
  498|       |
  499|       |    // ORDER BY
  500|  1.33k|    if let Some(expression) = order_by {
  501|      0|        m = GraphPattern::OrderBy {
  502|      0|            inner: Box::new(m),
  503|      0|            expression,
  504|      0|        };
  505|  1.33k|    }
  506|       |
  507|       |    // PROJECT
  508|  1.33k|    if with_project {
  509|  1.33k|        m = GraphPattern::Project {
  510|  1.33k|            inner: Box::new(m),
  511|  1.33k|            variables: pv,
  512|  1.33k|        };
  513|  1.33k|    }
  514|  1.33k|    match select.option {
  515|    289|        SelectionOption::Distinct => m = GraphPattern::Distinct { inner: Box::new(m) },
  516|    599|        SelectionOption::Reduced => m = GraphPattern::Reduced { inner: Box::new(m) },
  517|    446|        SelectionOption::Default => (),
  518|       |    }
  519|       |
  520|       |    // OFFSET LIMIT
  521|  1.33k|    if let Some((start, length)) = offset_limit {
  522|      0|        m = GraphPattern::Slice {
  523|      0|            inner: Box::new(m),
  524|      0|            start,
  525|      0|            length,
  526|      0|        }
  527|  1.33k|    }
  528|  1.33k|    Ok(m)
  529|  1.76k|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser9build_bgp:
  207|  1.64k|fn build_bgp(patterns: Vec<TripleOrPathPattern>) -> GraphPattern {
  208|  1.64k|    let mut bgp = Vec::new();
  209|  1.64k|    let mut elements = Vec::with_capacity(patterns.len());
  210|  28.4k|    for pattern in patterns {
  211|  26.8k|        match pattern {
  212|  19.6k|            TripleOrPathPattern::Triple(t) => bgp.push(t),
  213|       |            TripleOrPathPattern::Path {
  214|  7.17k|                subject,
  215|  7.17k|                path,
  216|  7.17k|                object,
  217|  7.17k|            } => {
  218|  7.17k|                if !bgp.is_empty() {
  219|  1.52k|                    elements.push(GraphPattern::Bgp {
  220|  1.52k|                        patterns: take(&mut bgp),
  221|  1.52k|                    });
  222|  5.64k|                }
  223|  7.17k|                elements.push(GraphPattern::Path {
  224|  7.17k|                    subject,
  225|  7.17k|                    path,
  226|  7.17k|                    object,
  227|  7.17k|                })
  228|       |            }
  229|       |        }
  230|       |    }
  231|  1.64k|    if !bgp.is_empty() {
  232|  1.12k|        elements.push(GraphPattern::Bgp { patterns: bgp });
  233|  1.12k|    }
  234|  1.64k|    elements.into_iter().reduce(new_join).unwrap_or_default()
  235|  1.64k|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser8new_join:
  316|  10.8k|fn new_join(l: GraphPattern, r: GraphPattern) -> GraphPattern {
  317|       |    // Avoid to output empty BGPs
  318|  10.8k|    if let GraphPattern::Bgp { patterns: pl } = &l {
  319|    992|        if pl.is_empty() {
  320|    348|            return r;
  321|    644|        }
  322|  9.84k|    }
  323|  10.4k|    if let GraphPattern::Bgp { patterns: pr } = &r {
  324|  1.93k|        if pr.is_empty() {
  325|      2|            return l;
  326|  1.93k|        }
  327|  8.54k|    }
  328|       |
  329|  10.4k|    match (l, r) {
  330|     13|        (GraphPattern::Bgp { patterns: mut pl }, GraphPattern::Bgp { patterns: pr }) => {
  331|     13|            pl.extend(pr);
  332|     13|            GraphPattern::Bgp { patterns: pl }
  333|       |        }
  334|      0|        (GraphPattern::Bgp { patterns }, other) | (other, GraphPattern::Bgp { patterns })
  335|  2.55k|            if patterns.is_empty() =>
  336|       |        {
  337|      0|            other
  338|       |        }
  339|  10.4k|        (l, r) => GraphPattern::Join {
  340|  10.4k|            left: Box::new(l),
  341|  10.4k|            right: Box::new(r),
  342|  10.4k|        },
  343|       |    }
  344|  10.8k|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser21add_defined_variables:
  572|  2.65k|fn add_defined_variables<'a>(pattern: &'a GraphPattern, set: &mut HashSet<&'a Variable>) {
  573|  2.65k|    match pattern {
  574|  1.37k|        GraphPattern::Bgp { .. } | GraphPattern::Path { .. } => {}
  575|  1.07k|        GraphPattern::Join { left, right }
  576|      8|        | GraphPattern::LeftJoin { left, right, .. }
  577|     12|        | GraphPattern::Lateral { left, right }
  578|      6|        | GraphPattern::Union { left, right }
  579|  1.09k|        | GraphPattern::Minus { left, right } => {
  580|  1.09k|            add_defined_variables(left, set);
  581|  1.09k|            add_defined_variables(right, set);
  582|  1.09k|        }
  583|      1|        GraphPattern::Graph { inner, .. } => {
  584|      1|            add_defined_variables(inner, set);
  585|      1|        }
  586|       |        GraphPattern::Extend {
  587|     19|            inner, variable, ..
  588|     19|        } => {
  589|     19|            set.insert(variable);
  590|     19|            add_defined_variables(inner, set);
  591|     19|        }
  592|       |        GraphPattern::Group {
  593|      0|            variables,
  594|      0|            aggregates,
  595|      0|            inner,
  596|       |        } => {
  597|      0|            for (v, _) in aggregates {
  598|      0|                set.insert(v);
  599|      0|            }
  600|      0|            let mut inner_variables = HashSet::new();
  601|      0|            add_defined_variables(inner, &mut inner_variables);
  602|      0|            for v in inner_variables {
  603|      0|                if variables.contains(v) {
  604|      0|                    set.insert(v);
  605|      0|                }
  606|       |            }
  607|       |        }
  608|      5|        GraphPattern::Values { variables, .. } => {
  609|     53|            for v in variables {
  610|     48|                set.insert(v);
  611|     48|            }
  612|       |        }
  613|     77|        GraphPattern::Project { variables, inner } => {
  614|     77|            let mut inner_variables = HashSet::new();
  615|     77|            add_defined_variables(inner, &mut inner_variables);
  616|     99|            for v in inner_variables {
  617|     22|                if variables.contains(v) {
  618|     19|                    set.insert(v);
  619|     19|                }
  620|       |            }
  621|       |        }
  622|      0|        GraphPattern::Service { inner, .. }
  623|      1|        | GraphPattern::Filter { inner, .. }
  624|      0|        | GraphPattern::OrderBy { inner, .. }
  625|     31|        | GraphPattern::Distinct { inner }
  626|     39|        | GraphPattern::Reduced { inner }
  627|     71|        | GraphPattern::Slice { inner, .. } => add_defined_variables(inner, set),
  628|       |    }
  629|  2.65k|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser19are_variables_bound:
  531|    352|fn are_variables_bound(expression: &Expression, variables: &HashSet<Variable>) -> bool {
  532|    352|    match expression {
  533|       |        Expression::NamedNode(_)
  534|       |        | Expression::Literal(_)
  535|       |        | Expression::Bound(_)
  536|       |        | Expression::Coalesce(_)
  537|     88|        | Expression::Exists(_) => true,
  538|     28|        Expression::Variable(var) => variables.contains(var),
  539|     67|        Expression::UnaryPlus(e) | Expression::UnaryMinus(e) | Expression::Not(e) => {
  540|    105|            are_variables_bound(e, variables)
  541|       |        }
  542|      0|        Expression::Or(a, b)
  543|     12|        | Expression::And(a, b)
  544|      4|        | Expression::Equal(a, b)
  545|      0|        | Expression::SameTerm(a, b)
  546|      0|        | Expression::Greater(a, b)
  547|     13|        | Expression::GreaterOrEqual(a, b)
  548|      0|        | Expression::Less(a, b)
  549|      0|        | Expression::LessOrEqual(a, b)
  550|      2|        | Expression::Add(a, b)
  551|     35|        | Expression::Subtract(a, b)
  552|      4|        | Expression::Multiply(a, b)
  553|     48|        | Expression::Divide(a, b) => {
  554|    118|            are_variables_bound(a, variables) && are_variables_bound(b, variables)
  555|       |        }
  556|      9|        Expression::In(a, b) => {
  557|      9|            are_variables_bound(a, variables) && b.iter().all(|b| are_variables_bound(b, variables))
  558|       |        }
  559|      4|        Expression::FunctionCall(_, parameters) => {
  560|      4|            parameters.iter().all(|p| are_variables_bound(p, variables))
  561|       |        }
  562|      0|        Expression::If(a, b, c) => {
  563|      0|            are_variables_bound(a, variables)
  564|      0|                && are_variables_bound(b, variables)
  565|      0|                && are_variables_bound(c, variables)
  566|       |        }
  567|       |    }
  568|    352|}
_RNvMs9_NtCshSv3hUzq9FP_9spargebra6parserNtB5_11ParserState13from_base_iri:
  672|  2.71k|    pub(crate) fn from_base_iri(base_iri: Option<&str>) -> Result<Self, SparqlSyntaxError> {
  673|       |        Ok(Self {
  674|  2.71k|            base_iri: if let Some(base_iri) = base_iri {
  675|       |                Some(
  676|      0|                    Iri::parse(base_iri.to_owned())
  677|      0|                        .map_err(|e| SparqlSyntaxError(ParseErrorKind::InvalidBaseIri(e)))?,
  678|       |                )
  679|       |            } else {
  680|  2.71k|                None
  681|       |            },
  682|  2.71k|            namespaces: HashMap::default(),
  683|  2.71k|            used_bnodes: HashSet::default(),
  684|  2.71k|            currently_used_bnodes: HashSet::default(),
  685|  2.71k|            aggregates: Vec::new(),
  686|       |        })
  687|  2.71k|    }
_RNvNtCshSv3hUzq9FP_9spargebra6parser22add_to_triple_patterns:
  103|  17.0k|fn add_to_triple_patterns(
  104|  17.0k|    subject: TermPattern,
  105|  17.0k|    predicate: NamedNodePattern,
  106|  17.0k|    object: AnnotatedTerm,
  107|  17.0k|    patterns: &mut Vec<TriplePattern>,
  108|  17.0k|) -> Result<(), &'static str> {
  109|  17.0k|    let triple = TriplePattern::new(subject, predicate, object.term);
  110|       |    #[cfg(feature = "rdf-star")]
  111|  17.0k|    for (p, os) in object.annotations {
  112|      0|        for o in os {
  113|      0|            add_to_triple_patterns(triple.clone().into(), p.clone(), o, patterns)?
  114|       |        }
  115|       |    }
  116|       |    #[cfg(not(feature = "rdf-star"))]
  117|       |    if !object.annotations.is_empty() {
  118|       |        return Err("Embedded triples are only available in SPARQL-star");
  119|       |    }
  120|  17.0k|    patterns.push(triple);
  121|  17.0k|    Ok(())
  122|  17.0k|}
_RNvMs9_NtCshSv3hUzq9FP_9spargebra6parserNtB5_11ParserState9parse_iri:
  689|  55.7k|    fn parse_iri(&self, iri: String) -> Result<Iri<String>, IriParseError> {
  690|  55.7k|        if let Some(base_iri) = &self.base_iri {
  691|      0|            base_iri.resolve(&iri)
  692|       |        } else {
  693|  55.7k|            Iri::parse(iri)
  694|       |        }
  695|  55.7k|    }
_RNvNtCshSv3hUzq9FP_9spargebra6parser15unescape_iriref:
  711|  55.7k|fn unescape_iriref(mut input: &str) -> Result<String, &'static str> {
  712|  55.7k|    let mut output = String::with_capacity(input.len());
  713|  55.7k|    while let Some((before, after)) = input.split_once('\\') {
  714|      0|        output.push_str(before);
  715|      0|        let mut after = after.chars();
  716|      0|        let (escape, after) = match after.next() {
  717|      0|            Some('u') => read_hex_char::<4>(after.as_str())?,
  718|      0|            Some('U') => read_hex_char::<8>(after.as_str())?,
  719|       |            Some(_) => {
  720|      0|                return Err(
  721|      0|                    "IRIs are only allowed to contain escape sequences \\uXXXX and \\UXXXXXXXX",
  722|      0|                )
  723|       |            }
  724|      0|            None => return Err("IRIs are not allowed to end with a '\'"),
  725|       |        };
  726|      0|        output.push(escape);
  727|      0|        input = after;
  728|       |    }
  729|  55.7k|    output.push_str(input);
  730|  55.7k|    Ok(output)
  731|  55.7k|}
_RNvNtCshSv3hUzq9FP_9spargebra6parser15unescape_string:
  733|  5.26k|fn unescape_string(mut input: &str) -> Result<String, &'static str> {
  734|  5.26k|    let mut output = String::with_capacity(input.len());
  735|  5.26k|    while let Some((before, after)) = input.split_once('\\') {
  736|      0|        output.push_str(before);
  737|      0|        let mut after = after.chars();
  738|      0|        let (escape, after) = match after.next() {
  739|      0|            Some('t') => ('\u{0009}', after.as_str()),
  740|      0|            Some('b') => ('\u{0008}', after.as_str()),
  741|      0|            Some('n') => ('\u{000A}', after.as_str()),
  742|      0|            Some('r') => ('\u{000D}', after.as_str()),
  743|      0|            Some('f') => ('\u{000C}', after.as_str()),
  744|      0|            Some('"') => ('\u{0022}', after.as_str()),
  745|      0|            Some('\'') => ('\u{0027}', after.as_str()),
  746|      0|            Some('\\') => ('\u{005C}', after.as_str()),
  747|      0|            Some('u') => read_hex_char::<4>(after.as_str())?,
  748|      0|            Some('U') => read_hex_char::<8>(after.as_str())?,
  749|      0|            Some(_) => return Err("The character that can be escaped in strings are tbnrf\"'\\"),
  750|      0|            None => return Err("strings are not allowed to end with a '\'"),
  751|       |        };
  752|      0|        output.push(escape);
  753|      0|        input = after;
  754|       |    }
  755|  5.26k|    output.push_str(input);
  756|  5.26k|    Ok(output)
  757|  5.26k|}
_RNvXs2_NtCshSv3hUzq9FP_9spargebra6parserNtB5_22VariableOrPropertyPathINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_7algebra22PropertyPathExpressionE4from:
   98|  24.7k|    fn from(path: PropertyPathExpression) -> Self {
   99|  24.7k|        Self::PropertyPath(path)
  100|  24.7k|    }
_RNvXs3_NtCshSv3hUzq9FP_9spargebra6parserNtB5_19TripleOrPathPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtB7_4term13TriplePatternE4from:
  248|  19.6k|    fn from(tp: TriplePattern) -> Self {
  249|  19.6k|        Self::Triple(tp)
  250|  19.6k|    }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_PropertyListPathNotEmpty0B7_:
 1442|  11.2k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  11.2k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  11.2k|                    focus: vec![(hp, ho.focus)],
 1445|  11.2k|                    patterns: ho.patterns
 1446|  11.2k|                }, |mut a, b| {
 1447|       |                    a.focus.push(b.focus);
 1448|       |                    a.patterns.extend(b.patterns);
 1449|       |                    a
 1450|  11.2k|                })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_Add0B7_:
  995|    265|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|    265|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|    265|            if from == to {
  998|    218|                Vec::new() // identity case
  999|       |            } else {
 1000|     47|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|     47|                vec![copy_graph(from, to)]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathOneInPropertySets_0B7_:
 1572|  3.40k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GraphRefAlls0_0B7_:
 1143|     46|            / i("NAMED") { GraphTarget::NamedGraphs }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_iri0B7_:
 1945|  55.7k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  55.7k|            NamedNode::from(i)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Create0B7_:
  991|    289|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|    289|            vec![GraphUpdateOperation::Create { silent, graph }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_RDFLiterals_0B7_:
 1918|  1.97k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsJ_0B7_:
 1839|      2|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Modify0B7_:
 1051|  1.93k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  1.93k|            let (delete, insert) = c;
 1053|  1.93k|            let mut delete = delete.unwrap_or_default();
 1054|  1.93k|            let mut insert = insert.unwrap_or_default();
 1055|  1.93k|            #[allow(clippy::shadow_same)]
 1056|  1.93k|            let mut pattern = pattern;
 1057|       |
 1058|  1.93k|            let mut using = if u.is_empty() {
 1059|  1.93k|                None
 1060|       |            } else {
 1061|      0|                let mut default = Vec::new();
 1062|      0|                let mut named = Vec::new();
 1063|      0|                for (d, n) in u {
 1064|      0|                    if let Some(d) = d {
 1065|      0|                        default.push(d)
 1066|      0|                    }
 1067|      0|                    if let Some(n) = n {
 1068|      0|                        named.push(n)
 1069|      0|                    }
 1070|       |                }
 1071|      0|                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|  1.93k|            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|  1.75k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|  1.75k|                }).collect();
 1086|  1.75k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|  1.75k|                }).collect();
 1096|  1.75k|                if using.is_none() {
 1097|  1.75k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  1.75k|                }
 1099|    171|            }
 1100|       |
 1101|  1.93k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  1.93k|                delete,
 1103|  1.93k|                insert,
 1104|  1.93k|                using,
 1105|  1.93k|                pattern: Box::new(pattern)
 1106|  1.93k|            }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_Modify_clear0B7_:
 1114|  4.86k|        rule Modify_clear() = {
 1115|  4.86k|            state.used_bnodes.clear();
 1116|  4.86k|            state.currently_used_bnodes.clear();
 1117|  4.86k|        }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PrimaryExpression0B7_:
 1768|  5.71k|            v:Var() { v.into() } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PropertyListNotEmpty00B9_:
 1371|  17.0k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  17.0k|                a.focus.push(b.focus);
 1373|  17.0k|                a.patterns.extend(b.patterns);
 1374|  17.0k|                a
 1375|  17.0k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_GroupGraphPatternSub0B7_:
  778|  5.23k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  5.23k|            let mut filter: Option<Expression> = None;
 1183|  5.23k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  5.23k|            for e in b.into_iter().flatten() {
 1185|  1.16k|                match e {
 1186|    243|                    PartialGraphPattern::Optional(p, f) => {
 1187|    243|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|    286|                    PartialGraphPattern::Lateral(p) => {
 1191|    286|                        let mut defined_variables = HashSet::default();
 1192|    286|                        add_defined_variables(&p, &mut defined_variables);
 1193|    286|                        let mut contains = false;
 1194|    286|                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|    286|                        });
 1199|    286|                        if contains {
 1200|      0|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|    286|                        }
 1202|    286|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|     20|                    PartialGraphPattern::Minus(p) => {
 1205|     20|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|      3|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|      3|                        let mut contains = false;
 1209|      3|                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|      3|                        });
 1214|      3|                        if contains {
 1215|      2|                            return Err("BIND is overriding an existing variable")
 1216|      1|                        }
 1217|      1|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|      3|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|      1|                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|      2|                        expr
 1223|       |                    }),
 1224|    611|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|  5.23k|            Ok(if let Some(expr) = filter {
 1229|      2|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|  5.23k|                g
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathOneInPropertySets0_0B7_:
 1573|  1.39k|            v:iri() { Either::Left(v) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsC_0B7_:
 1832|    167|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ExistsFunc0B7_:
 1883|     62|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_PathSequence0B7_:
  778|  25.5k|parser! {
  779|  25.5k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  25.5k|    grammar parser(state: &mut ParserState) for str {
  781|  25.5k|        pub rule QueryUnit() -> Query = Query()
  782|  25.5k|
  783|  25.5k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  25.5k|            q
  785|  25.5k|        }
  786|  25.5k|
  787|  25.5k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  25.5k|
  789|  25.5k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  25.5k|
  791|  25.5k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  25.5k|            state.base_iri = Some(i)
  793|  25.5k|        }
  794|  25.5k|
  795|  25.5k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  25.5k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  25.5k|        }
  798|  25.5k|
  799|  25.5k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  25.5k|            Ok(Query::Select {
  801|  25.5k|                dataset: d,
  802|  25.5k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  25.5k|                base_iri: state.base_iri.clone()
  804|  25.5k|            })
  805|  25.5k|        }
  806|  25.5k|
  807|  25.5k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  25.5k|            build_select(s, w, g, h, o, l, v, state)
  809|  25.5k|        }
  810|  25.5k|
  811|  25.5k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  25.5k|            Selection {
  813|  25.5k|                option: o,
  814|  25.5k|                variables: v
  815|  25.5k|            }
  816|  25.5k|        }
  817|  25.5k|        rule Selection_init() = {
  818|  25.5k|            state.aggregates.push(Vec::new())
  819|  25.5k|        }
  820|  25.5k|        rule SelectClause_option() -> SelectionOption =
  821|  25.5k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  25.5k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  25.5k|            { SelectionOption::Default }
  824|  25.5k|        rule SelectClause_variables() -> SelectionVariables =
  825|  25.5k|            "*" { SelectionVariables::Star } /
  826|  25.5k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  25.5k|        rule SelectClause_member() -> SelectionMember =
  828|  25.5k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  25.5k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  25.5k|
  831|  25.5k|        rule ConstructQuery() -> Query =
  832|  25.5k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  25.5k|                Ok(Query::Construct {
  834|  25.5k|                    template: c,
  835|  25.5k|                    dataset: d,
  836|  25.5k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  25.5k|                    base_iri: state.base_iri.clone()
  838|  25.5k|                })
  839|  25.5k|            } /
  840|  25.5k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  25.5k|                Ok(Query::Construct {
  842|  25.5k|                    template: c.clone(),
  843|  25.5k|                    dataset: d,
  844|  25.5k|                    pattern: build_select(
  845|  25.5k|                        Selection::no_op(),
  846|  25.5k|                        GraphPattern::Bgp { patterns: c },
  847|  25.5k|                        g, h, o, l, v, state
  848|  25.5k|                    )?,
  849|  25.5k|                    base_iri: state.base_iri.clone()
  850|  25.5k|                })
  851|  25.5k|            }
  852|  25.5k|
  853|  25.5k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  25.5k|
  855|  25.5k|        rule DescribeQuery() -> Query =
  856|  25.5k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  25.5k|                Ok(Query::Describe {
  858|  25.5k|                    dataset: d,
  859|  25.5k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  25.5k|                    base_iri: state.base_iri.clone()
  861|  25.5k|                })
  862|  25.5k|            } /
  863|  25.5k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  25.5k|                Ok(Query::Describe {
  865|  25.5k|                    dataset: d,
  866|  25.5k|                    pattern: build_select(Selection {
  867|  25.5k|                        option: SelectionOption::Default,
  868|  25.5k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  25.5k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  25.5k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  25.5k|                        }).collect())
  872|  25.5k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  25.5k|                    base_iri: state.base_iri.clone()
  874|  25.5k|                })
  875|  25.5k|            }
  876|  25.5k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  25.5k|
  878|  25.5k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  25.5k|            Ok(Query::Ask {
  880|  25.5k|                dataset: d,
  881|  25.5k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  25.5k|                base_iri: state.base_iri.clone()
  883|  25.5k|            })
  884|  25.5k|        }
  885|  25.5k|
  886|  25.5k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  25.5k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  25.5k|            if d.is_empty() {
  889|  25.5k|                return None;
  890|  25.5k|            }
  891|  25.5k|            let mut default = Vec::new();
  892|  25.5k|            let mut named = Vec::new();
  893|  25.5k|            for (d, n) in d {
  894|  25.5k|                if let Some(d) = d {
  895|  25.5k|                    default.push(d);
  896|  25.5k|                }
  897|  25.5k|                if let Some(n) = n {
  898|  25.5k|                    named.push(n);
  899|  25.5k|                }
  900|  25.5k|            }
  901|  25.5k|            Some(QueryDataset {
  902|  25.5k|                default, named: Some(named)
  903|  25.5k|            })
  904|  25.5k|        }
  905|  25.5k|
  906|  25.5k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  25.5k|            (Some(s), None)
  908|  25.5k|        }
  909|  25.5k|
  910|  25.5k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  25.5k|            (None, Some(s))
  912|  25.5k|        }
  913|  25.5k|
  914|  25.5k|        rule SourceSelector() -> NamedNode = iri()
  915|  25.5k|
  916|  25.5k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  25.5k|            p
  918|  25.5k|        }
  919|  25.5k|
  920|  25.5k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  25.5k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  25.5k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  25.5k|                if let Expression::Variable(v) = e {
  924|  25.5k|                    v
  925|  25.5k|                } else {
  926|  25.5k|                    let v = vo.unwrap_or_else(variable);
  927|  25.5k|                    projections.push((e, v.clone()));
  928|  25.5k|                    v
  929|  25.5k|                }
  930|  25.5k|            }).collect();
  931|  25.5k|            (clauses, projections)
  932|  25.5k|        }
  933|  25.5k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  25.5k|
  935|  25.5k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  25.5k|            e:BuiltInCall() { (e, None) } /
  937|  25.5k|            e:FunctionCall() { (e, None) } /
  938|  25.5k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  25.5k|            e:Var() { (e.into(), None) }
  940|  25.5k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  25.5k|
  942|  25.5k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  25.5k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  25.5k|        }
  945|  25.5k|
  946|  25.5k|        rule HavingCondition() -> Expression = Constraint()
  947|  25.5k|
  948|  25.5k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  25.5k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  25.5k|
  951|  25.5k|        rule OrderCondition() -> OrderExpression =
  952|  25.5k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  25.5k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  25.5k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  25.5k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  25.5k|
  957|  25.5k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  25.5k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  25.5k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  25.5k|
  961|  25.5k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  25.5k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  25.5k|        }
  964|  25.5k|
  965|  25.5k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  25.5k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  25.5k|        }
  968|  25.5k|
  969|  25.5k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  25.5k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  25.5k|            { None }
  972|  25.5k|
  973|  25.5k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  25.5k|
  975|  25.5k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  25.5k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  25.5k|
  978|  25.5k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  25.5k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  25.5k|        }
  981|  25.5k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  25.5k|
  983|  25.5k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  25.5k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  25.5k|        }
  986|  25.5k|
  987|  25.5k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  25.5k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  25.5k|        }
  990|  25.5k|
  991|  25.5k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  25.5k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  25.5k|        }
  994|  25.5k|
  995|  25.5k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  25.5k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  25.5k|            if from == to {
  998|  25.5k|                Vec::new() // identity case
  999|  25.5k|            } else {
 1000|  25.5k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  25.5k|                vec![copy_graph(from, to)]
 1002|  25.5k|            }
 1003|  25.5k|        }
 1004|  25.5k|
 1005|  25.5k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  25.5k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  25.5k|            if from == to {
 1008|  25.5k|                Vec::new() // identity case
 1009|  25.5k|            } else {
 1010|  25.5k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  25.5k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  25.5k|            }
 1013|  25.5k|        }
 1014|  25.5k|
 1015|  25.5k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  25.5k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  25.5k|            if from == to {
 1018|  25.5k|                Vec::new() // identity case
 1019|  25.5k|            } else {
 1020|  25.5k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  25.5k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  25.5k|            }
 1023|  25.5k|        }
 1024|  25.5k|
 1025|  25.5k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  25.5k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  25.5k|        }
 1028|  25.5k|
 1029|  25.5k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  25.5k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  25.5k|        }
 1032|  25.5k|
 1033|  25.5k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  25.5k|            let pattern = d.iter().map(|q| {
 1035|  25.5k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  25.5k|                match &q.graph_name {
 1037|  25.5k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  25.5k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  25.5k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  25.5k|                }
 1041|  25.5k|            }).reduce(new_join).unwrap_or_default();
 1042|  25.5k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  25.5k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  25.5k|                delete,
 1045|  25.5k|                insert: Vec::new(),
 1046|  25.5k|                using: None,
 1047|  25.5k|                pattern: Box::new(pattern)
 1048|  25.5k|            }])
 1049|  25.5k|        }
 1050|  25.5k|
 1051|  25.5k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  25.5k|            let (delete, insert) = c;
 1053|  25.5k|            let mut delete = delete.unwrap_or_default();
 1054|  25.5k|            let mut insert = insert.unwrap_or_default();
 1055|  25.5k|            #[allow(clippy::shadow_same)]
 1056|  25.5k|            let mut pattern = pattern;
 1057|  25.5k|
 1058|  25.5k|            let mut using = if u.is_empty() {
 1059|  25.5k|                None
 1060|  25.5k|            } else {
 1061|  25.5k|                let mut default = Vec::new();
 1062|  25.5k|                let mut named = Vec::new();
 1063|  25.5k|                for (d, n) in u {
 1064|  25.5k|                    if let Some(d) = d {
 1065|  25.5k|                        default.push(d)
 1066|  25.5k|                    }
 1067|  25.5k|                    if let Some(n) = n {
 1068|  25.5k|                        named.push(n)
 1069|  25.5k|                    }
 1070|  25.5k|                }
 1071|  25.5k|                Some(QueryDataset { default, named: Some(named) })
 1072|  25.5k|            };
 1073|  25.5k|
 1074|  25.5k|            if let Some(with) = with {
 1075|  25.5k|                // We inject WITH everywhere
 1076|  25.5k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  25.5k|                    GroundQuadPattern {
 1078|  25.5k|                        subject: q.subject,
 1079|  25.5k|                        predicate: q.predicate,
 1080|  25.5k|                        object: q.object,
 1081|  25.5k|                        graph_name: with.clone().into()
 1082|  25.5k|                    }
 1083|  25.5k|                } else {
 1084|  25.5k|                    q
 1085|  25.5k|                }).collect();
 1086|  25.5k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  25.5k|                    QuadPattern {
 1088|  25.5k|                        subject: q.subject,
 1089|  25.5k|                        predicate: q.predicate,
 1090|  25.5k|                        object: q.object,
 1091|  25.5k|                        graph_name: with.clone().into()
 1092|  25.5k|                    }
 1093|  25.5k|                } else {
 1094|  25.5k|                    q
 1095|  25.5k|                }).collect();
 1096|  25.5k|                if using.is_none() {
 1097|  25.5k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  25.5k|                }
 1099|  25.5k|            }
 1100|  25.5k|
 1101|  25.5k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  25.5k|                delete,
 1103|  25.5k|                insert,
 1104|  25.5k|                using,
 1105|  25.5k|                pattern: Box::new(pattern)
 1106|  25.5k|            }]
 1107|  25.5k|        }
 1108|  25.5k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  25.5k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  25.5k|            (Some(d), i)
 1111|  25.5k|        } / i:InsertClause() {
 1112|  25.5k|            (None, Some(i))
 1113|  25.5k|        }
 1114|  25.5k|        rule Modify_clear() = {
 1115|  25.5k|            state.used_bnodes.clear();
 1116|  25.5k|            state.currently_used_bnodes.clear();
 1117|  25.5k|        }
 1118|  25.5k|
 1119|  25.5k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  25.5k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  25.5k|        }
 1122|  25.5k|
 1123|  25.5k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  25.5k|
 1125|  25.5k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  25.5k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  25.5k|            (Some(i), None)
 1128|  25.5k|        }
 1129|  25.5k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  25.5k|            (None, Some(i))
 1131|  25.5k|        }
 1132|  25.5k|
 1133|  25.5k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  25.5k|            GraphName::DefaultGraph
 1135|  25.5k|        } / (i("GRAPH") _)? g:iri() {
 1136|  25.5k|            GraphName::NamedNode(g)
 1137|  25.5k|        }
 1138|  25.5k|
 1139|  25.5k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  25.5k|
 1141|  25.5k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  25.5k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  25.5k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  25.5k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  25.5k|
 1146|  25.5k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  25.5k|
 1148|  25.5k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  25.5k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  25.5k|        }
 1151|  25.5k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  25.5k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  25.5k|        }
 1154|  25.5k|
 1155|  25.5k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  25.5k|            q.into_iter().flatten().collect()
 1157|  25.5k|        }
 1158|  25.5k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  25.5k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  25.5k|        } //TODO: return iter?
 1161|  25.5k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  25.5k|
 1163|  25.5k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  25.5k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  25.5k|        }
 1166|  25.5k|
 1167|  25.5k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  25.5k|            ts.into_iter().flatten().collect()
 1169|  25.5k|        }
 1170|  25.5k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  25.5k|
 1172|  25.5k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  25.5k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  25.5k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  25.5k|        rule GroupGraphPattern_clear() = {
 1176|  25.5k|             // We deal with blank nodes aliases rule
 1177|  25.5k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  25.5k|            state.currently_used_bnodes.clear();
 1179|  25.5k|        }
 1180|  25.5k|
 1181|  25.5k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  25.5k|            let mut filter: Option<Expression> = None;
 1183|  25.5k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  25.5k|            for e in b.into_iter().flatten() {
 1185|  25.5k|                match e {
 1186|  25.5k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  25.5k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  25.5k|                    }
 1189|  25.5k|                    #[cfg(feature = "sep-0006")]
 1190|  25.5k|                    PartialGraphPattern::Lateral(p) => {
 1191|  25.5k|                        let mut defined_variables = HashSet::default();
 1192|  25.5k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  25.5k|                        let mut contains = false;
 1194|  25.5k|                        g.on_in_scope_variable(|v| {
 1195|  25.5k|                            if defined_variables.contains(v) {
 1196|  25.5k|                                contains = true;
 1197|  25.5k|                            }
 1198|  25.5k|                        });
 1199|  25.5k|                        if contains {
 1200|  25.5k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  25.5k|                        }
 1202|  25.5k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  25.5k|                    }
 1204|  25.5k|                    PartialGraphPattern::Minus(p) => {
 1205|  25.5k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  25.5k|                    }
 1207|  25.5k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  25.5k|                        let mut contains = false;
 1209|  25.5k|                        g.on_in_scope_variable(|v| {
 1210|  25.5k|                            if *v == variable {
 1211|  25.5k|                                contains = true;
 1212|  25.5k|                            }
 1213|  25.5k|                        });
 1214|  25.5k|                        if contains {
 1215|  25.5k|                            return Err("BIND is overriding an existing variable")
 1216|  25.5k|                        }
 1217|  25.5k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  25.5k|                    }
 1219|  25.5k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  25.5k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  25.5k|                    } else {
 1222|  25.5k|                        expr
 1223|  25.5k|                    }),
 1224|  25.5k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  25.5k|                }
 1226|  25.5k|            }
 1227|  25.5k|
 1228|  25.5k|            Ok(if let Some(expr) = filter {
 1229|  25.5k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  25.5k|            } else {
 1231|  25.5k|                g
 1232|  25.5k|            })
 1233|  25.5k|        }
 1234|  25.5k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  25.5k|            let mut result = vec![a];
 1236|  25.5k|            if let Some(v) = b {
 1237|  25.5k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  25.5k|            }
 1239|  25.5k|            result
 1240|  25.5k|        }
 1241|  25.5k|
 1242|  25.5k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  25.5k|            hs.into_iter().flatten().collect()
 1244|  25.5k|        }
 1245|  25.5k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  25.5k|
 1247|  25.5k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  25.5k|
 1249|  25.5k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  25.5k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  25.5k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  25.5k|            } else {
 1253|  25.5k|               PartialGraphPattern::Optional(p, None)
 1254|  25.5k|            }
 1255|  25.5k|        }
 1256|  25.5k|
 1257|  25.5k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  25.5k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  25.5k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  25.5k|        }
 1261|  25.5k|
 1262|  25.5k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  25.5k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  25.5k|        }
 1265|  25.5k|
 1266|  25.5k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  25.5k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  25.5k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  25.5k|
 1270|  25.5k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  25.5k|            PartialGraphPattern::Bind(e, v)
 1272|  25.5k|        }
 1273|  25.5k|
 1274|  25.5k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  25.5k|
 1276|  25.5k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  25.5k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  25.5k|        }
 1279|  25.5k|
 1280|  25.5k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  25.5k|            (vec![var], d)
 1282|  25.5k|        }
 1283|  25.5k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  25.5k|
 1285|  25.5k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  25.5k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  25.5k|                Ok((vars, vals))
 1288|  25.5k|            } else {
 1289|  25.5k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  25.5k|            }
 1291|  25.5k|        }
 1292|  25.5k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  25.5k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  25.5k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  25.5k|
 1296|  25.5k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  25.5k|            t:QuotedTripleData() {?
 1298|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  25.5k|            } /
 1301|  25.5k|            i:iri() { Some(i.into()) } /
 1302|  25.5k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  25.5k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  25.5k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  25.5k|            i("UNDEF") { None }
 1306|  25.5k|
 1307|  25.5k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  25.5k|            PartialGraphPattern::Minus(p)
 1309|  25.5k|        }
 1310|  25.5k|
 1311|  25.5k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  25.5k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  25.5k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  25.5k|            }).map(PartialGraphPattern::Other)
 1315|  25.5k|        }
 1316|  25.5k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  25.5k|
 1318|  25.5k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  25.5k|            PartialGraphPattern::Filter(c)
 1320|  25.5k|        }
 1321|  25.5k|
 1322|  25.5k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  25.5k|
 1324|  25.5k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  25.5k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  25.5k|        }
 1327|  25.5k|
 1328|  25.5k|        rule ArgList() -> Vec<Expression> =
 1329|  25.5k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  25.5k|            NIL() { Vec::new() }
 1331|  25.5k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  25.5k|
 1333|  25.5k|        rule ExpressionList() -> Vec<Expression> =
 1334|  25.5k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  25.5k|            NIL() { Vec::new() }
 1336|  25.5k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  25.5k|
 1338|  25.5k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  25.5k|
 1340|  25.5k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  25.5k|            p.into_iter().flatten().collect()
 1342|  25.5k|        }
 1343|  25.5k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  25.5k|
 1345|  25.5k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  25.5k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  25.5k|                let mut patterns = po.patterns;
 1348|  25.5k|                for (p, os) in po.focus {
 1349|  25.5k|                    for o in os {
 1350|  25.5k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  25.5k|                    }
 1352|  25.5k|                }
 1353|  25.5k|                Ok(patterns)
 1354|  25.5k|            } /
 1355|  25.5k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  25.5k|                let mut patterns = s.patterns;
 1357|  25.5k|                patterns.extend(po.patterns);
 1358|  25.5k|                for (p, os) in po.focus {
 1359|  25.5k|                    for o in os {
 1360|  25.5k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  25.5k|                    }
 1362|  25.5k|                }
 1363|  25.5k|                Ok(patterns)
 1364|  25.5k|            }
 1365|  25.5k|
 1366|  25.5k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  25.5k|            PropertyListNotEmpty() /
 1368|  25.5k|            { FocusedTriplePattern::default() }
 1369|  25.5k|
 1370|  25.5k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  25.5k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  25.5k|                a.focus.push(b.focus);
 1373|  25.5k|                a.patterns.extend(b.patterns);
 1374|  25.5k|                a
 1375|  25.5k|            })
 1376|  25.5k|        }
 1377|  25.5k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  25.5k|            FocusedTriplePattern {
 1379|  25.5k|                focus: (p, o.focus),
 1380|  25.5k|                patterns: o.patterns
 1381|  25.5k|            }
 1382|  25.5k|        }
 1383|  25.5k|
 1384|  25.5k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  25.5k|
 1386|  25.5k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  25.5k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  25.5k|                a.focus.push(b.focus);
 1389|  25.5k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  25.5k|                a
 1391|  25.5k|            })
 1392|  25.5k|        }
 1393|  25.5k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  25.5k|
 1395|  25.5k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  25.5k|            if let Some(a) = a {
 1397|  25.5k|                let mut patterns = g.patterns;
 1398|  25.5k|                patterns.extend(a.patterns);
 1399|  25.5k|                FocusedTriplePattern {
 1400|  25.5k|                    focus: AnnotatedTerm {
 1401|  25.5k|                        term: g.focus,
 1402|  25.5k|                        annotations: a.focus
 1403|  25.5k|                    },
 1404|  25.5k|                    patterns
 1405|  25.5k|                }
 1406|  25.5k|            } else {
 1407|  25.5k|                FocusedTriplePattern {
 1408|  25.5k|                    focus: AnnotatedTerm {
 1409|  25.5k|                        term: g.focus,
 1410|  25.5k|                        annotations: Vec::new()
 1411|  25.5k|                    },
 1412|  25.5k|                    patterns: g.patterns
 1413|  25.5k|                }
 1414|  25.5k|            }
 1415|  25.5k|        }
 1416|  25.5k|
 1417|  25.5k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  25.5k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  25.5k|                let mut patterns = po.patterns;
 1420|  25.5k|                for (p, os) in po.focus {
 1421|  25.5k|                    for o in os {
 1422|  25.5k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  25.5k|                    }
 1424|  25.5k|                }
 1425|  25.5k|                Ok(patterns)
 1426|  25.5k|            } /
 1427|  25.5k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  25.5k|                let mut patterns = s.patterns;
 1429|  25.5k|                patterns.extend(po.patterns);
 1430|  25.5k|                for (p, os) in po.focus {
 1431|  25.5k|                    for o in os {
 1432|  25.5k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  25.5k|                    }
 1434|  25.5k|                }
 1435|  25.5k|                Ok(patterns)
 1436|  25.5k|            }
 1437|  25.5k|
 1438|  25.5k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  25.5k|            PropertyListPathNotEmpty() /
 1440|  25.5k|            { FocusedTripleOrPathPattern::default() }
 1441|  25.5k|
 1442|  25.5k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  25.5k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  25.5k|                    focus: vec![(hp, ho.focus)],
 1445|  25.5k|                    patterns: ho.patterns
 1446|  25.5k|                }, |mut a, b| {
 1447|  25.5k|                    a.focus.push(b.focus);
 1448|  25.5k|                    a.patterns.extend(b.patterns);
 1449|  25.5k|                    a
 1450|  25.5k|                })
 1451|  25.5k|        }
 1452|  25.5k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  25.5k|            c
 1454|  25.5k|        }
 1455|  25.5k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  25.5k|            FocusedTripleOrPathPattern {
 1457|  25.5k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  25.5k|                patterns: o.patterns
 1459|  25.5k|            }
 1460|  25.5k|        }
 1461|  25.5k|
 1462|  25.5k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  25.5k|            p.into()
 1464|  25.5k|        }
 1465|  25.5k|
 1466|  25.5k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  25.5k|            v.into()
 1468|  25.5k|        }
 1469|  25.5k|
 1470|  25.5k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  25.5k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  25.5k|                a.focus.push(b.focus);
 1473|  25.5k|                a.patterns.extend(b.patterns);
 1474|  25.5k|                a
 1475|  25.5k|            })
 1476|  25.5k|        }
 1477|  25.5k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  25.5k|
 1479|  25.5k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  25.5k|             if let Some(a) = a {
 1481|  25.5k|                let mut patterns = g.patterns;
 1482|  25.5k|                patterns.extend(a.patterns);
 1483|  25.5k|                FocusedTripleOrPathPattern {
 1484|  25.5k|                    focus: AnnotatedTermPath {
 1485|  25.5k|                        term: g.focus,
 1486|  25.5k|                        annotations: a.focus
 1487|  25.5k|                    },
 1488|  25.5k|                    patterns
 1489|  25.5k|                }
 1490|  25.5k|            } else {
 1491|  25.5k|                FocusedTripleOrPathPattern {
 1492|  25.5k|                    focus: AnnotatedTermPath {
 1493|  25.5k|                        term: g.focus,
 1494|  25.5k|                        annotations: Vec::new()
 1495|  25.5k|                    },
 1496|  25.5k|                    patterns: g.patterns
 1497|  25.5k|                }
 1498|  25.5k|            }
 1499|  25.5k|        }
 1500|  25.5k|
 1501|  25.5k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  25.5k|
 1503|  25.5k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  25.5k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  25.5k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  25.5k|            })
 1507|  25.5k|        }
 1508|  25.5k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  25.5k|
 1510|  25.5k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  25.5k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|       |                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  25.5k|            })
 1514|  25.5k|        }
 1515|  25.5k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  25.5k|
 1517|  25.5k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  25.5k|            match o {
 1519|  25.5k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  25.5k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  25.5k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  25.5k|                Some(_) => unreachable!(),
 1523|  25.5k|                None => p
 1524|  25.5k|            }
 1525|  25.5k|        }
 1526|  25.5k|        rule PathElt_op() -> char =
 1527|  25.5k|            "*" { '*' } /
 1528|  25.5k|            "+" { '+' } /
 1529|  25.5k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  25.5k|
 1531|  25.5k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  25.5k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  25.5k|            PathElt()
 1534|  25.5k|
 1535|  25.5k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  25.5k|            v:iri() { v.into() } /
 1537|  25.5k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  25.5k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  25.5k|            "(" _ p:Path() _ ")" { p }
 1540|  25.5k|
 1541|  25.5k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  25.5k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  25.5k|                let mut direct = Vec::new();
 1544|  25.5k|                let mut inverse = Vec::new();
 1545|  25.5k|                for e in p {
 1546|  25.5k|                    match e {
 1547|  25.5k|                        Either::Left(a) => direct.push(a),
 1548|  25.5k|                        Either::Right(b) => inverse.push(b)
 1549|  25.5k|                    }
 1550|  25.5k|                }
 1551|  25.5k|                if inverse.is_empty() {
 1552|  25.5k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  25.5k|                } else if direct.is_empty() {
 1554|  25.5k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  25.5k|                } else {
 1556|  25.5k|                    PropertyPathExpression::Alternative(
 1557|  25.5k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  25.5k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  25.5k|                    )
 1560|  25.5k|                }
 1561|  25.5k|            } /
 1562|  25.5k|            p:PathOneInPropertySet() {
 1563|  25.5k|                match p {
 1564|  25.5k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  25.5k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  25.5k|                }
 1567|  25.5k|            }
 1568|  25.5k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  25.5k|
 1570|  25.5k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  25.5k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  25.5k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  25.5k|            v:iri() { Either::Left(v) } /
 1574|  25.5k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  25.5k|
 1576|  25.5k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  25.5k|
 1578|  25.5k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  25.5k|            let mut patterns = po.patterns;
 1580|  25.5k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  25.5k|            for (p, os) in po.focus {
 1582|  25.5k|                for o in os {
 1583|  25.5k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  25.5k|                }
 1585|  25.5k|            }
 1586|  25.5k|            Ok(FocusedTriplePattern {
 1587|  25.5k|                focus: bnode,
 1588|  25.5k|                patterns
 1589|  25.5k|            })
 1590|  25.5k|        }
 1591|  25.5k|
 1592|  25.5k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  25.5k|
 1594|  25.5k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  25.5k|            let mut patterns = po.patterns;
 1596|  25.5k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  25.5k|            for (p, os) in po.focus {
 1598|  25.5k|                for o in os {
 1599|  25.5k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  25.5k|                }
 1601|  25.5k|            }
 1602|  25.5k|            Ok(FocusedTripleOrPathPattern {
 1603|  25.5k|                focus: bnode,
 1604|  25.5k|                patterns
 1605|  25.5k|            })
 1606|  25.5k|        }
 1607|  25.5k|
 1608|  25.5k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  25.5k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  25.5k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  25.5k|            for objWithPatterns in o.into_iter().rev() {
 1612|  25.5k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  25.5k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  25.5k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  25.5k|                current_list_node = new_blank_node;
 1616|  25.5k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  25.5k|            }
 1618|  25.5k|            FocusedTriplePattern {
 1619|  25.5k|                focus: current_list_node,
 1620|  25.5k|                patterns
 1621|  25.5k|            }
 1622|  25.5k|        }
 1623|  25.5k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  25.5k|
 1625|  25.5k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  25.5k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  25.5k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  25.5k|            for objWithPatterns in o.into_iter().rev() {
 1629|  25.5k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  25.5k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  25.5k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  25.5k|                current_list_node = new_blank_node;
 1633|  25.5k|                patterns.extend(objWithPatterns.patterns);
 1634|  25.5k|            }
 1635|  25.5k|            FocusedTripleOrPathPattern {
 1636|  25.5k|                focus: current_list_node,
 1637|  25.5k|                patterns
 1638|  25.5k|            }
 1639|  25.5k|        }
 1640|  25.5k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  25.5k|
 1642|  25.5k|
 1643|  25.5k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  25.5k|
 1645|  25.5k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  25.5k|
 1647|  25.5k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  25.5k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  25.5k|            TriplesNode()
 1650|  25.5k|
 1651|  25.5k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  25.5k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  25.5k|            TriplesNodePath()
 1654|  25.5k|
 1655|  25.5k|        rule VarOrTerm() -> TermPattern =
 1656|  25.5k|            v:Var() { v.into() } /
 1657|  25.5k|            t:QuotedTriple() {?
 1658|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  25.5k|            } /
 1661|  25.5k|            t:GraphTerm() { t.into() }
 1662|  25.5k|
 1663|  25.5k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  25.5k|            Ok(TriplePattern {
 1665|  25.5k|                subject: s,
 1666|  25.5k|                predicate: p,
 1667|  25.5k|                object: o
 1668|  25.5k|            })
 1669|  25.5k|        }
 1670|  25.5k|
 1671|  25.5k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  25.5k|            Ok(GroundTriple {
 1673|  25.5k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  25.5k|                predicate: p,
 1675|  25.5k|                object: o
 1676|  25.5k|            })
 1677|  25.5k|        }
 1678|  25.5k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  25.5k|
 1680|  25.5k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  25.5k|            l:RDFLiteral() { l.into() } /
 1682|  25.5k|            l:NumericLiteral() { l.into() } /
 1683|  25.5k|            l:BooleanLiteral() { l.into() } /
 1684|  25.5k|            t:QuotedTripleData() {?
 1685|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  25.5k|            }
 1688|  25.5k|
 1689|  25.5k|        rule VarOrIri() -> NamedNodePattern =
 1690|  25.5k|            v:Var() { v.into() } /
 1691|  25.5k|            i:iri() { i.into() }
 1692|  25.5k|
 1693|  25.5k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  25.5k|
 1695|  25.5k|        rule GraphTerm() -> Term =
 1696|  25.5k|            i:iri() { i.into() } /
 1697|  25.5k|            l:RDFLiteral() { l.into() } /
 1698|  25.5k|            l:NumericLiteral() { l.into() } /
 1699|  25.5k|            l:BooleanLiteral() { l.into() } /
 1700|  25.5k|            b:BlankNode() { b.into() } /
 1701|  25.5k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  25.5k|
 1703|  25.5k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  25.5k|
 1705|  25.5k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  25.5k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  25.5k|        }
 1708|  25.5k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  25.5k|
 1710|  25.5k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  25.5k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  25.5k|        }
 1713|  25.5k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  25.5k|
 1715|  25.5k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  25.5k|
 1717|  25.5k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  25.5k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  25.5k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  25.5k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  25.5k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  25.5k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  25.5k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  25.5k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  25.5k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  25.5k|            Some(_) => unreachable!(),
 1727|  25.5k|            None => a
 1728|  25.5k|        } }
 1729|  25.5k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  25.5k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  25.5k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  25.5k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  25.5k|
 1734|  25.5k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  25.5k|
 1736|  25.5k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  25.5k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  25.5k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  25.5k|            Some(_) => unreachable!(),
 1740|  25.5k|            None => a,
 1741|  25.5k|        } }
 1742|  25.5k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  25.5k|            (s, e)
 1744|  25.5k|        }
 1745|  25.5k|
 1746|  25.5k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  25.5k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  25.5k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  25.5k|            Some(_) => unreachable!(),
 1750|  25.5k|            None => a
 1751|  25.5k|        } }
 1752|  25.5k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  25.5k|            (s, e)
 1754|  25.5k|        }
 1755|  25.5k|
 1756|  25.5k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  25.5k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  25.5k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  25.5k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  25.5k|            Some(_) => unreachable!(),
 1761|  25.5k|            None => e,
 1762|  25.5k|        } }
 1763|  25.5k|
 1764|  25.5k|        rule PrimaryExpression() -> Expression =
 1765|  25.5k|            BrackettedExpression()  /
 1766|  25.5k|            ExprQuotedTriple() /
 1767|  25.5k|            iriOrFunction() /
 1768|  25.5k|            v:Var() { v.into() } /
 1769|  25.5k|            l:RDFLiteral() { l.into() } /
 1770|  25.5k|            l:NumericLiteral() { l.into() } /
 1771|  25.5k|            l:BooleanLiteral() { l.into() } /
 1772|  25.5k|            BuiltInCall()
 1773|  25.5k|
 1774|  25.5k|        rule ExprVarOrTerm() -> Expression =
 1775|  25.5k|            ExprQuotedTriple() /
 1776|  25.5k|            i:iri() { i.into() } /
 1777|  25.5k|            l:RDFLiteral() { l.into() } /
 1778|  25.5k|            l:NumericLiteral() { l.into() } /
 1779|  25.5k|            l:BooleanLiteral() { l.into() } /
 1780|  25.5k|            v:Var() { v.into() }
 1781|  25.5k|
 1782|  25.5k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  25.5k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  25.5k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  25.5k|        }
 1786|  25.5k|
 1787|  25.5k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  25.5k|
 1789|  25.5k|        rule BuiltInCall() -> Expression =
 1790|  25.5k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  25.5k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  25.5k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  25.5k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  25.5k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  25.5k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  25.5k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  25.5k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  25.5k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  25.5k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  25.5k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  25.5k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  25.5k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  25.5k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  25.5k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  25.5k|            SubstringExpression() /
 1806|  25.5k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  25.5k|            StrReplaceExpression() /
 1808|  25.5k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  25.5k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  25.5k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  25.5k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  25.5k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  25.5k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  25.5k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  25.5k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  25.5k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  25.5k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  25.5k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  25.5k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  25.5k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  25.5k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  25.5k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  25.5k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  25.5k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  25.5k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  25.5k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  25.5k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  25.5k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  25.5k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  25.5k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  25.5k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  25.5k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  25.5k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  25.5k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  25.5k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  25.5k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  25.5k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  25.5k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  25.5k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  25.5k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  25.5k|            RegexExpression() /
 1842|  25.5k|            ExistsFunc() /
 1843|  25.5k|            NotExistsFunc() /
 1844|  25.5k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  25.5k|            } /
 1848|  25.5k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  25.5k|            } /
 1852|  25.5k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  25.5k|            } /
 1856|  25.5k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  25.5k|            } /
 1860|  25.5k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  25.5k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  25.5k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  25.5k|            } /
 1864|  25.5k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  25.5k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  25.5k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  25.5k|            }
 1868|  25.5k|
 1869|  25.5k|        rule RegexExpression() -> Expression =
 1870|  25.5k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  25.5k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  25.5k|
 1873|  25.5k|
 1874|  25.5k|        rule SubstringExpression() -> Expression =
 1875|  25.5k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  25.5k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  25.5k|
 1878|  25.5k|
 1879|  25.5k|        rule StrReplaceExpression() -> Expression =
 1880|  25.5k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  25.5k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  25.5k|
 1883|  25.5k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  25.5k|
 1885|  25.5k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  25.5k|
 1887|  25.5k|        rule Aggregate() -> AggregateExpression =
 1888|  25.5k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  25.5k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  25.5k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  25.5k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  25.5k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  25.5k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  25.5k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  25.5k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  25.5k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  25.5k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  25.5k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  25.5k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  25.5k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  25.5k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  25.5k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  25.5k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  25.5k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  25.5k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  25.5k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  25.5k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  25.5k|
 1909|  25.5k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  25.5k|            match a {
 1911|  25.5k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  25.5k|                None => i.into()
 1913|  25.5k|            }
 1914|  25.5k|        }
 1915|  25.5k|
 1916|  25.5k|        rule RDFLiteral() -> Literal =
 1917|  25.5k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  25.5k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  25.5k|            value:String() { Literal::new_simple_literal(value) }
 1920|  25.5k|
 1921|  25.5k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  25.5k|
 1923|  25.5k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  25.5k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  25.5k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  25.5k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  25.5k|
 1928|  25.5k|        rule NumericLiteralPositive() -> Literal =
 1929|  25.5k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  25.5k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  25.5k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  25.5k|
 1933|  25.5k|
 1934|  25.5k|        rule NumericLiteralNegative() -> Literal =
 1935|  25.5k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  25.5k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  25.5k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  25.5k|
 1939|  25.5k|        rule BooleanLiteral() -> Literal =
 1940|  25.5k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  25.5k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  25.5k|
 1943|  25.5k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  25.5k|
 1945|  25.5k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  25.5k|            NamedNode::from(i)
 1947|  25.5k|        }
 1948|  25.5k|
 1949|  25.5k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  25.5k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  25.5k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  25.5k|            } else {
 1953|  25.5k|                Err("Prefix not found")
 1954|  25.5k|            } }
 1955|  25.5k|
 1956|  25.5k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  25.5k|            let node = BlankNode::new_unchecked(id);
 1958|  25.5k|            if state.used_bnodes.contains(&node) {
 1959|  25.5k|                Err("Already used blank node id")
 1960|  25.5k|            } else {
 1961|  25.5k|                state.currently_used_bnodes.insert(node.clone());
 1962|  25.5k|                Ok(node)
 1963|  25.5k|            }
 1964|  25.5k|        } / ANON() { BlankNode::default() }
 1965|  25.5k|
 1966|  25.5k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  25.5k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  25.5k|        }
 1969|  25.5k|
 1970|  25.5k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  25.5k|            ns
 1972|  25.5k|        }
 1973|  25.5k|
 1974|  25.5k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  25.5k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  25.5k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  25.5k|                iri.push_str(base);
 1978|  25.5k|                for chunk in local.split('\\') { // We remove \
 1979|  25.5k|                    iri.push_str(chunk);
 1980|  25.5k|                }
 1981|  25.5k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  25.5k|            } else {
 1983|  25.5k|                Err("Prefix not found")
 1984|  25.5k|            }
 1985|  25.5k|        }
 1986|  25.5k|
 1987|  25.5k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  25.5k|            b
 1989|  25.5k|        }
 1990|  25.5k|
 1991|  25.5k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  25.5k|
 1993|  25.5k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  25.5k|
 1995|  25.5k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  25.5k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  25.5k|        }
 1998|  25.5k|
 1999|  25.5k|        rule INTEGER() = ['0'..='9']+
 2000|  25.5k|
 2001|  25.5k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  25.5k|
 2003|  25.5k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  25.5k|
 2005|  25.5k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  25.5k|
 2007|  25.5k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  25.5k|
 2009|  25.5k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  25.5k|
 2011|  25.5k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  25.5k|
 2013|  25.5k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  25.5k|
 2015|  25.5k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  25.5k|
 2017|  25.5k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  25.5k|
 2019|  25.5k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  25.5k|             unescape_string(l)
 2021|  25.5k|        }
 2022|  25.5k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  25.5k|
 2024|  25.5k|
 2025|  25.5k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  25.5k|             unescape_string(l)
 2027|  25.5k|        }
 2028|  25.5k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  25.5k|
 2030|  25.5k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  25.5k|             unescape_string(l)
 2032|  25.5k|        }
 2033|  25.5k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  25.5k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  25.5k|
 2036|  25.5k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  25.5k|             unescape_string(l)
 2038|  25.5k|        }
 2039|  25.5k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  25.5k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  25.5k|
 2042|  25.5k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  25.5k|
 2044|  25.5k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  25.5k|
 2046|  25.5k|        rule NIL() = "(" WS()* ")"
 2047|  25.5k|
 2048|  25.5k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  25.5k|
 2050|  25.5k|        rule ANON() = "[" WS()* "]"
 2051|  25.5k|
 2052|  25.5k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  25.5k|
 2054|  25.5k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  25.5k|
 2056|  25.5k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  25.5k|
 2058|  25.5k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  25.5k|
 2060|  25.5k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  25.5k|
 2062|  25.5k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  25.5k|
 2064|  25.5k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  25.5k|
 2066|  25.5k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  25.5k|
 2068|  25.5k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  25.5k|
 2070|  25.5k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  25.5k|
 2072|  25.5k|        //space
 2073|  25.5k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  25.5k|
 2075|  25.5k|        //comment
 2076|  25.5k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  25.5k|
 2078|  25.5k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  25.5k|            if input.eq_ignore_ascii_case(literal) {
 2080|  25.5k|                Ok(())
 2081|  25.5k|            } else {
 2082|  25.5k|                Err(literal)
 2083|  25.5k|            }
 2084|  25.5k|        }
 2085|  25.5k|    }
 2086|  25.5k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_VAR10B7_:
 1991|  46.5k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_DeleteWhere00B9_:
 1034|  2.32k|            let pattern = d.iter().map(|q| {
 1035|  2.32k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  2.32k|                match &q.graph_name {
 1037|  1.42k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|    287|                    GraphNamePattern::DefaultGraph => bgp,
 1039|    611|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|  2.32k|            }).reduce(new_join).unwrap_or_default();
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ObjectListPath00B9_:
 1471|  15.0k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  15.0k|                a.focus.push(b.focus);
 1473|  15.0k|                a.patterns.extend(b.patterns);
 1474|  15.0k|                a
 1475|  15.0k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_PropertyListPath0B7_:
 1440|    600|            { FocusedTripleOrPathPattern::default() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_ConditionalAndExpression_item0B7_:
 1713|  2.89k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_TriplesSameSubjectPaths_0B7_:
  778|    626|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|       |                let mut patterns = po.patterns;
 1348|       |                for (p, os) in po.focus {
 1349|       |                    for o in os {
 1350|       |                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|       |                Ok(patterns)
 1354|       |            } /
 1355|       |            s:TriplesNode() _ po:PropertyList() {?
 1356|       |                let mut patterns = s.patterns;
 1357|       |                patterns.extend(po.patterns);
 1358|       |                for (p, os) in po.focus {
 1359|       |                    for o in os {
 1360|       |                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|       |                    }
 1362|       |                }
 1363|       |                Ok(patterns)
 1364|       |            }
 1365|       |
 1366|       |        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|       |            PropertyListNotEmpty() /
 1368|       |            { FocusedTriplePattern::default() }
 1369|       |
 1370|       |        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|       |            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|       |            })
 1376|       |        }
 1377|       |        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|       |            FocusedTriplePattern {
 1379|       |                focus: (p, o.focus),
 1380|       |                patterns: o.patterns
 1381|       |            }
 1382|       |        }
 1383|       |
 1384|       |        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|       |
 1386|       |        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|       |            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|       |            })
 1392|       |        }
 1393|       |        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|       |
 1395|       |        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|       |            if let Some(a) = a {
 1397|       |                let mut patterns = g.patterns;
 1398|       |                patterns.extend(a.patterns);
 1399|       |                FocusedTriplePattern {
 1400|       |                    focus: AnnotatedTerm {
 1401|       |                        term: g.focus,
 1402|       |                        annotations: a.focus
 1403|       |                    },
 1404|       |                    patterns
 1405|       |                }
 1406|       |            } else {
 1407|       |                FocusedTriplePattern {
 1408|       |                    focus: AnnotatedTerm {
 1409|       |                        term: g.focus,
 1410|       |                        annotations: Vec::new()
 1411|       |                    },
 1412|       |                    patterns: g.patterns
 1413|       |                }
 1414|       |            }
 1415|       |        }
 1416|       |
 1417|       |        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|       |            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|       |                let mut patterns = po.patterns;
 1420|       |                for (p, os) in po.focus {
 1421|       |                    for o in os {
 1422|       |                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|       |                    }
 1424|       |                }
 1425|       |                Ok(patterns)
 1426|       |            } /
 1427|       |            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|    626|                let mut patterns = s.patterns;
 1429|    626|                patterns.extend(po.patterns);
 1430|    654|                for (p, os) in po.focus {
 1431|     75|                    for o in os {
 1432|     47|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|       |                    }
 1434|       |                }
 1435|    626|                Ok(patterns)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_VarOrTerm0B7_:
 1656|  19.7k|            v:Var() { v.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_VarOrIris_0B7_:
 1691|  16.5k|            i:iri() { i.into() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_UnaryExpression0B7_:
 1756|  11.4k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  5.53k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  3.96k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  3.53k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|      0|            Some(_) => unreachable!(),
 1761|  5.95k|            None => e,
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_member0B7_:
  828|    616|            v:Var() _ { SelectionMember::Variable(v) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_CollectionPath0B7_:
 1625|  1.41k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  1.41k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  1.41k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  3.04k|            for objWithPatterns in o.into_iter().rev() {
 1629|  3.04k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  3.04k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  3.04k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  3.04k|                current_list_node = new_blank_node;
 1633|  3.04k|                patterns.extend(objWithPatterns.patterns);
 1634|  3.04k|            }
 1635|  1.41k|            FocusedTripleOrPathPattern {
 1636|  1.41k|                focus: current_list_node,
 1637|  1.41k|                patterns
 1638|  1.41k|            }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ObjectList00B9_:
 1387|  17.0k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  17.0k|                a.focus.push(b.focus);
 1389|  17.0k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  17.0k|                a
 1391|  17.0k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PathSequence_item0B7_:
 1515|  34.5k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser36___parse_ConditionalOrExpression_item0B7_:
 1708|  2.49k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_ObjectListPath_item0B7_:
 1477|  15.0k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_PathNegatedPropertySet0B7_:
 1542|  1.30k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  1.30k|                let mut direct = Vec::new();
 1544|  1.30k|                let mut inverse = Vec::new();
 1545|  8.99k|                for e in p {
 1546|  7.69k|                    match e {
 1547|  1.57k|                        Either::Left(a) => direct.push(a),
 1548|  6.11k|                        Either::Right(b) => inverse.push(b)
 1549|       |                    }
 1550|       |                }
 1551|  1.30k|                if inverse.is_empty() {
 1552|    106|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  1.19k|                } else if direct.is_empty() {
 1554|    724|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|       |                } else {
 1556|    470|                    PropertyPathExpression::Alternative(
 1557|    470|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|    470|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|    470|                    )
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_HavingClause0B7_:
  778|     22|parser! {
  779|     22|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|     22|    grammar parser(state: &mut ParserState) for str {
  781|     22|        pub rule QueryUnit() -> Query = Query()
  782|     22|
  783|     22|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|     22|            q
  785|     22|        }
  786|     22|
  787|     22|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|     22|
  789|     22|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|     22|
  791|     22|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|     22|            state.base_iri = Some(i)
  793|     22|        }
  794|     22|
  795|     22|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|     22|            state.namespaces.insert(ns.into(), i.into_inner());
  797|     22|        }
  798|     22|
  799|     22|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|     22|            Ok(Query::Select {
  801|     22|                dataset: d,
  802|     22|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|     22|                base_iri: state.base_iri.clone()
  804|     22|            })
  805|     22|        }
  806|     22|
  807|     22|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|     22|            build_select(s, w, g, h, o, l, v, state)
  809|     22|        }
  810|     22|
  811|     22|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|     22|            Selection {
  813|     22|                option: o,
  814|     22|                variables: v
  815|     22|            }
  816|     22|        }
  817|     22|        rule Selection_init() = {
  818|     22|            state.aggregates.push(Vec::new())
  819|     22|        }
  820|     22|        rule SelectClause_option() -> SelectionOption =
  821|     22|            i("DISTINCT") { SelectionOption::Distinct } /
  822|     22|            i("REDUCED") { SelectionOption::Reduced } /
  823|     22|            { SelectionOption::Default }
  824|     22|        rule SelectClause_variables() -> SelectionVariables =
  825|     22|            "*" { SelectionVariables::Star } /
  826|     22|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|     22|        rule SelectClause_member() -> SelectionMember =
  828|     22|            v:Var() _ { SelectionMember::Variable(v) } /
  829|     22|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|     22|
  831|     22|        rule ConstructQuery() -> Query =
  832|     22|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|     22|                Ok(Query::Construct {
  834|     22|                    template: c,
  835|     22|                    dataset: d,
  836|     22|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|     22|                    base_iri: state.base_iri.clone()
  838|     22|                })
  839|     22|            } /
  840|     22|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|     22|                Ok(Query::Construct {
  842|     22|                    template: c.clone(),
  843|     22|                    dataset: d,
  844|     22|                    pattern: build_select(
  845|     22|                        Selection::no_op(),
  846|     22|                        GraphPattern::Bgp { patterns: c },
  847|     22|                        g, h, o, l, v, state
  848|     22|                    )?,
  849|     22|                    base_iri: state.base_iri.clone()
  850|     22|                })
  851|     22|            }
  852|     22|
  853|     22|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|     22|
  855|     22|        rule DescribeQuery() -> Query =
  856|     22|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|     22|                Ok(Query::Describe {
  858|     22|                    dataset: d,
  859|     22|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|     22|                    base_iri: state.base_iri.clone()
  861|     22|                })
  862|     22|            } /
  863|     22|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|     22|                Ok(Query::Describe {
  865|     22|                    dataset: d,
  866|     22|                    pattern: build_select(Selection {
  867|     22|                        option: SelectionOption::Default,
  868|     22|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|     22|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|     22|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|     22|                        }).collect())
  872|     22|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|     22|                    base_iri: state.base_iri.clone()
  874|     22|                })
  875|     22|            }
  876|     22|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|     22|
  878|     22|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|     22|            Ok(Query::Ask {
  880|     22|                dataset: d,
  881|     22|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|     22|                base_iri: state.base_iri.clone()
  883|     22|            })
  884|     22|        }
  885|     22|
  886|     22|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|     22|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|     22|            if d.is_empty() {
  889|     22|                return None;
  890|     22|            }
  891|     22|            let mut default = Vec::new();
  892|     22|            let mut named = Vec::new();
  893|     22|            for (d, n) in d {
  894|     22|                if let Some(d) = d {
  895|     22|                    default.push(d);
  896|     22|                }
  897|     22|                if let Some(n) = n {
  898|     22|                    named.push(n);
  899|     22|                }
  900|     22|            }
  901|     22|            Some(QueryDataset {
  902|     22|                default, named: Some(named)
  903|     22|            })
  904|     22|        }
  905|     22|
  906|     22|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|     22|            (Some(s), None)
  908|     22|        }
  909|     22|
  910|     22|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|     22|            (None, Some(s))
  912|     22|        }
  913|     22|
  914|     22|        rule SourceSelector() -> NamedNode = iri()
  915|     22|
  916|     22|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|     22|            p
  918|     22|        }
  919|     22|
  920|     22|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|     22|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|     22|            let clauses = c.into_iter().map(|(e, vo)| {
  923|     22|                if let Expression::Variable(v) = e {
  924|     22|                    v
  925|     22|                } else {
  926|     22|                    let v = vo.unwrap_or_else(variable);
  927|     22|                    projections.push((e, v.clone()));
  928|     22|                    v
  929|     22|                }
  930|     22|            }).collect();
  931|     22|            (clauses, projections)
  932|     22|        }
  933|     22|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|     22|
  935|     22|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|     22|            e:BuiltInCall() { (e, None) } /
  937|     22|            e:FunctionCall() { (e, None) } /
  938|     22|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|     22|            e:Var() { (e.into(), None) }
  940|     22|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|     22|
  942|     22|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|     22|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|     22|        }
  945|     22|
  946|     22|        rule HavingCondition() -> Expression = Constraint()
  947|     22|
  948|     22|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|     22|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|     22|
  951|     22|        rule OrderCondition() -> OrderExpression =
  952|     22|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|     22|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|     22|            e: Constraint() { OrderExpression::Asc(e) } /
  955|     22|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|     22|
  957|     22|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|     22|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|     22|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|     22|
  961|     22|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|     22|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|     22|        }
  964|     22|
  965|     22|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|     22|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|     22|        }
  968|     22|
  969|     22|        rule ValuesClause() -> Option<GraphPattern> =
  970|     22|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|     22|            { None }
  972|     22|
  973|     22|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|     22|
  975|     22|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|     22|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|     22|
  978|     22|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|     22|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|     22|        }
  981|     22|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|     22|
  983|     22|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|     22|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|     22|        }
  986|     22|
  987|     22|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|     22|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|     22|        }
  990|     22|
  991|     22|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|     22|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|     22|        }
  994|     22|
  995|     22|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|     22|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|     22|            if from == to {
  998|     22|                Vec::new() // identity case
  999|     22|            } else {
 1000|     22|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|     22|                vec![copy_graph(from, to)]
 1002|     22|            }
 1003|     22|        }
 1004|     22|
 1005|     22|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|     22|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|     22|            if from == to {
 1008|     22|                Vec::new() // identity case
 1009|     22|            } else {
 1010|     22|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|     22|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|     22|            }
 1013|     22|        }
 1014|     22|
 1015|     22|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|     22|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|     22|            if from == to {
 1018|     22|                Vec::new() // identity case
 1019|     22|            } else {
 1020|     22|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|     22|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|     22|            }
 1023|     22|        }
 1024|     22|
 1025|     22|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|     22|            vec![GraphUpdateOperation::InsertData { data }]
 1027|     22|        }
 1028|     22|
 1029|     22|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|     22|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|     22|        }
 1032|     22|
 1033|     22|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|     22|            let pattern = d.iter().map(|q| {
 1035|     22|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|     22|                match &q.graph_name {
 1037|     22|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|     22|                    GraphNamePattern::DefaultGraph => bgp,
 1039|     22|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|     22|                }
 1041|     22|            }).reduce(new_join).unwrap_or_default();
 1042|     22|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|     22|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|     22|                delete,
 1045|     22|                insert: Vec::new(),
 1046|     22|                using: None,
 1047|     22|                pattern: Box::new(pattern)
 1048|     22|            }])
 1049|     22|        }
 1050|     22|
 1051|     22|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|     22|            let (delete, insert) = c;
 1053|     22|            let mut delete = delete.unwrap_or_default();
 1054|     22|            let mut insert = insert.unwrap_or_default();
 1055|     22|            #[allow(clippy::shadow_same)]
 1056|     22|            let mut pattern = pattern;
 1057|     22|
 1058|     22|            let mut using = if u.is_empty() {
 1059|     22|                None
 1060|     22|            } else {
 1061|     22|                let mut default = Vec::new();
 1062|     22|                let mut named = Vec::new();
 1063|     22|                for (d, n) in u {
 1064|     22|                    if let Some(d) = d {
 1065|     22|                        default.push(d)
 1066|     22|                    }
 1067|     22|                    if let Some(n) = n {
 1068|     22|                        named.push(n)
 1069|     22|                    }
 1070|     22|                }
 1071|     22|                Some(QueryDataset { default, named: Some(named) })
 1072|     22|            };
 1073|     22|
 1074|     22|            if let Some(with) = with {
 1075|     22|                // We inject WITH everywhere
 1076|     22|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|     22|                    GroundQuadPattern {
 1078|     22|                        subject: q.subject,
 1079|     22|                        predicate: q.predicate,
 1080|     22|                        object: q.object,
 1081|     22|                        graph_name: with.clone().into()
 1082|     22|                    }
 1083|     22|                } else {
 1084|     22|                    q
 1085|     22|                }).collect();
 1086|     22|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|     22|                    QuadPattern {
 1088|     22|                        subject: q.subject,
 1089|     22|                        predicate: q.predicate,
 1090|     22|                        object: q.object,
 1091|     22|                        graph_name: with.clone().into()
 1092|     22|                    }
 1093|     22|                } else {
 1094|     22|                    q
 1095|     22|                }).collect();
 1096|     22|                if using.is_none() {
 1097|     22|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|     22|                }
 1099|     22|            }
 1100|     22|
 1101|     22|            vec![GraphUpdateOperation::DeleteInsert {
 1102|     22|                delete,
 1103|     22|                insert,
 1104|     22|                using,
 1105|     22|                pattern: Box::new(pattern)
 1106|     22|            }]
 1107|     22|        }
 1108|     22|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|     22|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|     22|            (Some(d), i)
 1111|     22|        } / i:InsertClause() {
 1112|     22|            (None, Some(i))
 1113|     22|        }
 1114|     22|        rule Modify_clear() = {
 1115|     22|            state.used_bnodes.clear();
 1116|     22|            state.currently_used_bnodes.clear();
 1117|     22|        }
 1118|     22|
 1119|     22|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|     22|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|     22|        }
 1122|     22|
 1123|     22|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|     22|
 1125|     22|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|     22|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|     22|            (Some(i), None)
 1128|     22|        }
 1129|     22|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|     22|            (None, Some(i))
 1131|     22|        }
 1132|     22|
 1133|     22|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|     22|            GraphName::DefaultGraph
 1135|     22|        } / (i("GRAPH") _)? g:iri() {
 1136|     22|            GraphName::NamedNode(g)
 1137|     22|        }
 1138|     22|
 1139|     22|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|     22|
 1141|     22|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|     22|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|     22|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|     22|            / i("ALL") { GraphTarget::AllGraphs }
 1145|     22|
 1146|     22|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|     22|
 1148|     22|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|     22|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|     22|        }
 1151|     22|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|     22|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|     22|        }
 1154|     22|
 1155|     22|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|     22|            q.into_iter().flatten().collect()
 1157|     22|        }
 1158|     22|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|     22|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|     22|        } //TODO: return iter?
 1161|     22|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|     22|
 1163|     22|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|     22|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|     22|        }
 1166|     22|
 1167|     22|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|     22|            ts.into_iter().flatten().collect()
 1169|     22|        }
 1170|     22|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|     22|
 1172|     22|        rule GroupGraphPattern() -> GraphPattern =
 1173|     22|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|     22|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|     22|        rule GroupGraphPattern_clear() = {
 1176|     22|             // We deal with blank nodes aliases rule
 1177|     22|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|     22|            state.currently_used_bnodes.clear();
 1179|     22|        }
 1180|     22|
 1181|     22|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|     22|            let mut filter: Option<Expression> = None;
 1183|     22|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|     22|            for e in b.into_iter().flatten() {
 1185|     22|                match e {
 1186|     22|                    PartialGraphPattern::Optional(p, f) => {
 1187|     22|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|     22|                    }
 1189|     22|                    #[cfg(feature = "sep-0006")]
 1190|     22|                    PartialGraphPattern::Lateral(p) => {
 1191|     22|                        let mut defined_variables = HashSet::default();
 1192|     22|                        add_defined_variables(&p, &mut defined_variables);
 1193|     22|                        let mut contains = false;
 1194|     22|                        g.on_in_scope_variable(|v| {
 1195|     22|                            if defined_variables.contains(v) {
 1196|     22|                                contains = true;
 1197|     22|                            }
 1198|     22|                        });
 1199|     22|                        if contains {
 1200|     22|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|     22|                        }
 1202|     22|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|     22|                    }
 1204|     22|                    PartialGraphPattern::Minus(p) => {
 1205|     22|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|     22|                    }
 1207|     22|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|     22|                        let mut contains = false;
 1209|     22|                        g.on_in_scope_variable(|v| {
 1210|     22|                            if *v == variable {
 1211|     22|                                contains = true;
 1212|     22|                            }
 1213|     22|                        });
 1214|     22|                        if contains {
 1215|     22|                            return Err("BIND is overriding an existing variable")
 1216|     22|                        }
 1217|     22|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|     22|                    }
 1219|     22|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|     22|                        Expression::And(Box::new(f), Box::new(expr))
 1221|     22|                    } else {
 1222|     22|                        expr
 1223|     22|                    }),
 1224|     22|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|     22|                }
 1226|     22|            }
 1227|     22|
 1228|     22|            Ok(if let Some(expr) = filter {
 1229|     22|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|     22|            } else {
 1231|     22|                g
 1232|     22|            })
 1233|     22|        }
 1234|     22|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|     22|            let mut result = vec![a];
 1236|     22|            if let Some(v) = b {
 1237|     22|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|     22|            }
 1239|     22|            result
 1240|     22|        }
 1241|     22|
 1242|     22|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|     22|            hs.into_iter().flatten().collect()
 1244|     22|        }
 1245|     22|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|     22|
 1247|     22|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|     22|
 1249|     22|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|     22|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|     22|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|     22|            } else {
 1253|     22|               PartialGraphPattern::Optional(p, None)
 1254|     22|            }
 1255|     22|        }
 1256|     22|
 1257|     22|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|     22|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|     22|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|     22|        }
 1261|     22|
 1262|     22|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|     22|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|     22|        }
 1265|     22|
 1266|     22|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|     22|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|     22|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|     22|
 1270|     22|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|     22|            PartialGraphPattern::Bind(e, v)
 1272|     22|        }
 1273|     22|
 1274|     22|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|     22|
 1276|     22|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|     22|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|     22|        }
 1279|     22|
 1280|     22|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|     22|            (vec![var], d)
 1282|     22|        }
 1283|     22|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|     22|
 1285|     22|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|     22|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|     22|                Ok((vars, vals))
 1288|     22|            } else {
 1289|     22|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|     22|            }
 1291|     22|        }
 1292|     22|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|     22|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|     22|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|     22|
 1296|     22|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|     22|            t:QuotedTripleData() {?
 1298|     22|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|     22|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|     22|            } /
 1301|     22|            i:iri() { Some(i.into()) } /
 1302|     22|            l:RDFLiteral() { Some(l.into()) } /
 1303|     22|            l:NumericLiteral() { Some(l.into()) } /
 1304|     22|            l:BooleanLiteral() { Some(l.into()) } /
 1305|     22|            i("UNDEF") { None }
 1306|     22|
 1307|     22|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|     22|            PartialGraphPattern::Minus(p)
 1309|     22|        }
 1310|     22|
 1311|     22|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|     22|            not_empty_fold(p.into_iter(), |a, b| {
 1313|     22|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|     22|            }).map(PartialGraphPattern::Other)
 1315|     22|        }
 1316|     22|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|     22|
 1318|     22|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|     22|            PartialGraphPattern::Filter(c)
 1320|     22|        }
 1321|     22|
 1322|     22|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|     22|
 1324|     22|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|     22|            Expression::FunctionCall(Function::Custom(f), a)
 1326|     22|        }
 1327|     22|
 1328|     22|        rule ArgList() -> Vec<Expression> =
 1329|     22|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|     22|            NIL() { Vec::new() }
 1331|     22|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|     22|
 1333|     22|        rule ExpressionList() -> Vec<Expression> =
 1334|     22|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|     22|            NIL() { Vec::new() }
 1336|     22|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|     22|
 1338|     22|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|     22|
 1340|     22|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|     22|            p.into_iter().flatten().collect()
 1342|     22|        }
 1343|     22|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|     22|
 1345|     22|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|     22|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|     22|                let mut patterns = po.patterns;
 1348|     22|                for (p, os) in po.focus {
 1349|     22|                    for o in os {
 1350|     22|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|     22|                    }
 1352|     22|                }
 1353|     22|                Ok(patterns)
 1354|     22|            } /
 1355|     22|            s:TriplesNode() _ po:PropertyList() {?
 1356|     22|                let mut patterns = s.patterns;
 1357|     22|                patterns.extend(po.patterns);
 1358|     22|                for (p, os) in po.focus {
 1359|     22|                    for o in os {
 1360|     22|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|     22|                    }
 1362|     22|                }
 1363|     22|                Ok(patterns)
 1364|     22|            }
 1365|     22|
 1366|     22|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|     22|            PropertyListNotEmpty() /
 1368|     22|            { FocusedTriplePattern::default() }
 1369|     22|
 1370|     22|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|     22|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|     22|                a.focus.push(b.focus);
 1373|     22|                a.patterns.extend(b.patterns);
 1374|     22|                a
 1375|     22|            })
 1376|     22|        }
 1377|     22|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|     22|            FocusedTriplePattern {
 1379|     22|                focus: (p, o.focus),
 1380|     22|                patterns: o.patterns
 1381|     22|            }
 1382|     22|        }
 1383|     22|
 1384|     22|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|     22|
 1386|     22|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|     22|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|     22|                a.focus.push(b.focus);
 1389|     22|                a.patterns.extend_from_slice(&b.patterns);
 1390|     22|                a
 1391|     22|            })
 1392|     22|        }
 1393|     22|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|     22|
 1395|     22|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|     22|            if let Some(a) = a {
 1397|     22|                let mut patterns = g.patterns;
 1398|     22|                patterns.extend(a.patterns);
 1399|     22|                FocusedTriplePattern {
 1400|     22|                    focus: AnnotatedTerm {
 1401|     22|                        term: g.focus,
 1402|     22|                        annotations: a.focus
 1403|     22|                    },
 1404|     22|                    patterns
 1405|     22|                }
 1406|     22|            } else {
 1407|     22|                FocusedTriplePattern {
 1408|     22|                    focus: AnnotatedTerm {
 1409|     22|                        term: g.focus,
 1410|     22|                        annotations: Vec::new()
 1411|     22|                    },
 1412|     22|                    patterns: g.patterns
 1413|     22|                }
 1414|     22|            }
 1415|     22|        }
 1416|     22|
 1417|     22|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|     22|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|     22|                let mut patterns = po.patterns;
 1420|     22|                for (p, os) in po.focus {
 1421|     22|                    for o in os {
 1422|     22|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|     22|                    }
 1424|     22|                }
 1425|     22|                Ok(patterns)
 1426|     22|            } /
 1427|     22|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|     22|                let mut patterns = s.patterns;
 1429|     22|                patterns.extend(po.patterns);
 1430|     22|                for (p, os) in po.focus {
 1431|     22|                    for o in os {
 1432|     22|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|     22|                    }
 1434|     22|                }
 1435|     22|                Ok(patterns)
 1436|     22|            }
 1437|     22|
 1438|     22|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|     22|            PropertyListPathNotEmpty() /
 1440|     22|            { FocusedTripleOrPathPattern::default() }
 1441|     22|
 1442|     22|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|     22|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|     22|                    focus: vec![(hp, ho.focus)],
 1445|     22|                    patterns: ho.patterns
 1446|     22|                }, |mut a, b| {
 1447|     22|                    a.focus.push(b.focus);
 1448|     22|                    a.patterns.extend(b.patterns);
 1449|     22|                    a
 1450|     22|                })
 1451|     22|        }
 1452|     22|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|     22|            c
 1454|     22|        }
 1455|     22|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|     22|            FocusedTripleOrPathPattern {
 1457|     22|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|     22|                patterns: o.patterns
 1459|     22|            }
 1460|     22|        }
 1461|     22|
 1462|     22|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|     22|            p.into()
 1464|     22|        }
 1465|     22|
 1466|     22|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|     22|            v.into()
 1468|     22|        }
 1469|     22|
 1470|     22|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|     22|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|     22|                a.focus.push(b.focus);
 1473|     22|                a.patterns.extend(b.patterns);
 1474|     22|                a
 1475|     22|            })
 1476|     22|        }
 1477|     22|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|     22|
 1479|     22|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|     22|             if let Some(a) = a {
 1481|     22|                let mut patterns = g.patterns;
 1482|     22|                patterns.extend(a.patterns);
 1483|     22|                FocusedTripleOrPathPattern {
 1484|     22|                    focus: AnnotatedTermPath {
 1485|     22|                        term: g.focus,
 1486|     22|                        annotations: a.focus
 1487|     22|                    },
 1488|     22|                    patterns
 1489|     22|                }
 1490|     22|            } else {
 1491|     22|                FocusedTripleOrPathPattern {
 1492|     22|                    focus: AnnotatedTermPath {
 1493|     22|                        term: g.focus,
 1494|     22|                        annotations: Vec::new()
 1495|     22|                    },
 1496|     22|                    patterns: g.patterns
 1497|     22|                }
 1498|     22|            }
 1499|     22|        }
 1500|     22|
 1501|     22|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|     22|
 1503|     22|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|     22|            not_empty_fold(p.into_iter(), |a, b| {
 1505|     22|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|     22|            })
 1507|     22|        }
 1508|     22|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|     22|
 1510|     22|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|     22|            not_empty_fold(p.into_iter(), |a, b| {
 1512|     22|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|     22|            })
 1514|     22|        }
 1515|     22|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|     22|
 1517|     22|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|     22|            match o {
 1519|     22|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|     22|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|     22|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|     22|                Some(_) => unreachable!(),
 1523|     22|                None => p
 1524|     22|            }
 1525|     22|        }
 1526|     22|        rule PathElt_op() -> char =
 1527|     22|            "*" { '*' } /
 1528|     22|            "+" { '+' } /
 1529|     22|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|     22|
 1531|     22|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|     22|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|     22|            PathElt()
 1534|     22|
 1535|     22|        rule PathPrimary() -> PropertyPathExpression =
 1536|     22|            v:iri() { v.into() } /
 1537|     22|            "a" { rdf::TYPE.into_owned().into() } /
 1538|     22|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|     22|            "(" _ p:Path() _ ")" { p }
 1540|     22|
 1541|     22|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|     22|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|     22|                let mut direct = Vec::new();
 1544|     22|                let mut inverse = Vec::new();
 1545|     22|                for e in p {
 1546|     22|                    match e {
 1547|     22|                        Either::Left(a) => direct.push(a),
 1548|     22|                        Either::Right(b) => inverse.push(b)
 1549|     22|                    }
 1550|     22|                }
 1551|     22|                if inverse.is_empty() {
 1552|     22|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|     22|                } else if direct.is_empty() {
 1554|     22|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|     22|                } else {
 1556|     22|                    PropertyPathExpression::Alternative(
 1557|     22|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|     22|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|     22|                    )
 1560|     22|                }
 1561|     22|            } /
 1562|     22|            p:PathOneInPropertySet() {
 1563|     22|                match p {
 1564|     22|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|     22|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|     22|                }
 1567|     22|            }
 1568|     22|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|     22|
 1570|     22|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|     22|            "^" _ v:iri() { Either::Right(v) } /
 1572|     22|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|     22|            v:iri() { Either::Left(v) } /
 1574|     22|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|     22|
 1576|     22|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|     22|
 1578|     22|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|     22|            let mut patterns = po.patterns;
 1580|     22|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|     22|            for (p, os) in po.focus {
 1582|     22|                for o in os {
 1583|     22|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|     22|                }
 1585|     22|            }
 1586|     22|            Ok(FocusedTriplePattern {
 1587|     22|                focus: bnode,
 1588|     22|                patterns
 1589|     22|            })
 1590|     22|        }
 1591|     22|
 1592|     22|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|     22|
 1594|     22|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|     22|            let mut patterns = po.patterns;
 1596|     22|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|     22|            for (p, os) in po.focus {
 1598|     22|                for o in os {
 1599|     22|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|     22|                }
 1601|     22|            }
 1602|     22|            Ok(FocusedTripleOrPathPattern {
 1603|     22|                focus: bnode,
 1604|     22|                patterns
 1605|     22|            })
 1606|     22|        }
 1607|     22|
 1608|     22|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|     22|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|     22|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|     22|            for objWithPatterns in o.into_iter().rev() {
 1612|     22|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|     22|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|     22|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|     22|                current_list_node = new_blank_node;
 1616|     22|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|     22|            }
 1618|     22|            FocusedTriplePattern {
 1619|     22|                focus: current_list_node,
 1620|     22|                patterns
 1621|     22|            }
 1622|     22|        }
 1623|     22|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|     22|
 1625|     22|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|     22|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|     22|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|     22|            for objWithPatterns in o.into_iter().rev() {
 1629|     22|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|     22|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|     22|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|     22|                current_list_node = new_blank_node;
 1633|     22|                patterns.extend(objWithPatterns.patterns);
 1634|     22|            }
 1635|     22|            FocusedTripleOrPathPattern {
 1636|     22|                focus: current_list_node,
 1637|     22|                patterns
 1638|     22|            }
 1639|     22|        }
 1640|     22|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|     22|
 1642|     22|
 1643|     22|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|     22|
 1645|     22|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|     22|
 1647|     22|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|     22|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|     22|            TriplesNode()
 1650|     22|
 1651|     22|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|     22|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|     22|            TriplesNodePath()
 1654|     22|
 1655|     22|        rule VarOrTerm() -> TermPattern =
 1656|     22|            v:Var() { v.into() } /
 1657|     22|            t:QuotedTriple() {?
 1658|     22|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|     22|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|     22|            } /
 1661|     22|            t:GraphTerm() { t.into() }
 1662|     22|
 1663|     22|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|     22|            Ok(TriplePattern {
 1665|     22|                subject: s,
 1666|     22|                predicate: p,
 1667|     22|                object: o
 1668|     22|            })
 1669|     22|        }
 1670|     22|
 1671|     22|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|     22|            Ok(GroundTriple {
 1673|     22|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|     22|                predicate: p,
 1675|     22|                object: o
 1676|     22|            })
 1677|     22|        }
 1678|     22|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|     22|
 1680|     22|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|     22|            l:RDFLiteral() { l.into() } /
 1682|     22|            l:NumericLiteral() { l.into() } /
 1683|     22|            l:BooleanLiteral() { l.into() } /
 1684|     22|            t:QuotedTripleData() {?
 1685|     22|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|     22|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|     22|            }
 1688|     22|
 1689|     22|        rule VarOrIri() -> NamedNodePattern =
 1690|     22|            v:Var() { v.into() } /
 1691|     22|            i:iri() { i.into() }
 1692|     22|
 1693|     22|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|     22|
 1695|     22|        rule GraphTerm() -> Term =
 1696|     22|            i:iri() { i.into() } /
 1697|     22|            l:RDFLiteral() { l.into() } /
 1698|     22|            l:NumericLiteral() { l.into() } /
 1699|     22|            l:BooleanLiteral() { l.into() } /
 1700|     22|            b:BlankNode() { b.into() } /
 1701|     22|            NIL() { rdf::NIL.into_owned().into() }
 1702|     22|
 1703|     22|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|     22|
 1705|     22|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|     22|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|     22|        }
 1708|     22|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|     22|
 1710|     22|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|     22|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|     22|        }
 1713|     22|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|     22|
 1715|     22|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|     22|
 1717|     22|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|     22|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|     22|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|     22|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|     22|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|     22|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|     22|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|     22|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|     22|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|     22|            Some(_) => unreachable!(),
 1727|     22|            None => a
 1728|     22|        } }
 1729|     22|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|     22|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|     22|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|     22|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|     22|
 1734|     22|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|     22|
 1736|     22|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|     22|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|     22|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|     22|            Some(_) => unreachable!(),
 1740|     22|            None => a,
 1741|     22|        } }
 1742|     22|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|     22|            (s, e)
 1744|     22|        }
 1745|     22|
 1746|     22|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|     22|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|     22|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|     22|            Some(_) => unreachable!(),
 1750|     22|            None => a
 1751|     22|        } }
 1752|     22|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|     22|            (s, e)
 1754|     22|        }
 1755|     22|
 1756|     22|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|     22|            Some("!") => Expression::Not(Box::new(e)),
 1758|     22|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|     22|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|     22|            Some(_) => unreachable!(),
 1761|     22|            None => e,
 1762|     22|        } }
 1763|     22|
 1764|     22|        rule PrimaryExpression() -> Expression =
 1765|     22|            BrackettedExpression()  /
 1766|     22|            ExprQuotedTriple() /
 1767|     22|            iriOrFunction() /
 1768|     22|            v:Var() { v.into() } /
 1769|     22|            l:RDFLiteral() { l.into() } /
 1770|     22|            l:NumericLiteral() { l.into() } /
 1771|     22|            l:BooleanLiteral() { l.into() } /
 1772|     22|            BuiltInCall()
 1773|     22|
 1774|     22|        rule ExprVarOrTerm() -> Expression =
 1775|     22|            ExprQuotedTriple() /
 1776|     22|            i:iri() { i.into() } /
 1777|     22|            l:RDFLiteral() { l.into() } /
 1778|     22|            l:NumericLiteral() { l.into() } /
 1779|     22|            l:BooleanLiteral() { l.into() } /
 1780|     22|            v:Var() { v.into() }
 1781|     22|
 1782|     22|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|     22|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|     22|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|     22|        }
 1786|     22|
 1787|     22|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|     22|
 1789|     22|        rule BuiltInCall() -> Expression =
 1790|     22|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|     22|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|     22|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|     22|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|     22|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|     22|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|     22|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|     22|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|     22|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|     22|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|     22|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|     22|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|     22|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|     22|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|     22|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|     22|            SubstringExpression() /
 1806|     22|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|     22|            StrReplaceExpression() /
 1808|     22|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|     22|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|     22|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|     22|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|     22|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|     22|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|     22|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|     22|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|     22|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|     22|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|     22|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|     22|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|     22|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|     22|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|     22|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|     22|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|     22|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|     22|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|     22|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|     22|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|     22|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|     22|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|     22|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|     22|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|     22|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|     22|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|     22|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|     22|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|     22|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|     22|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|     22|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|     22|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|     22|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|     22|            RegexExpression() /
 1842|     22|            ExistsFunc() /
 1843|     22|            NotExistsFunc() /
 1844|     22|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|     22|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|     22|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|     22|            } /
 1848|     22|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|     22|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|     22|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|     22|            } /
 1852|     22|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|     22|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|     22|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|     22|            } /
 1856|     22|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|     22|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|     22|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|     22|            } /
 1860|     22|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|     22|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|     22|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|     22|            } /
 1864|     22|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|     22|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|     22|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|     22|            }
 1868|     22|
 1869|     22|        rule RegexExpression() -> Expression =
 1870|     22|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|     22|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|     22|
 1873|     22|
 1874|     22|        rule SubstringExpression() -> Expression =
 1875|     22|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|     22|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|     22|
 1878|     22|
 1879|     22|        rule StrReplaceExpression() -> Expression =
 1880|     22|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|     22|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|     22|
 1883|     22|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|     22|
 1885|     22|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|     22|
 1887|     22|        rule Aggregate() -> AggregateExpression =
 1888|     22|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|     22|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|     22|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|     22|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|     22|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|     22|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|     22|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|     22|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|     22|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|     22|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|     22|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|     22|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|     22|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|     22|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|     22|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|     22|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|     22|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|     22|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|     22|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|     22|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|     22|
 1909|     22|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|     22|            match a {
 1911|     22|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|     22|                None => i.into()
 1913|     22|            }
 1914|     22|        }
 1915|     22|
 1916|     22|        rule RDFLiteral() -> Literal =
 1917|     22|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|     22|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|     22|            value:String() { Literal::new_simple_literal(value) }
 1920|     22|
 1921|     22|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|     22|
 1923|     22|        rule NumericLiteralUnsigned() -> Literal =
 1924|     22|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|     22|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|     22|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|     22|
 1928|     22|        rule NumericLiteralPositive() -> Literal =
 1929|     22|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|     22|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|     22|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|     22|
 1933|     22|
 1934|     22|        rule NumericLiteralNegative() -> Literal =
 1935|     22|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|     22|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|     22|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|     22|
 1939|     22|        rule BooleanLiteral() -> Literal =
 1940|     22|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|     22|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|     22|
 1943|     22|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|     22|
 1945|     22|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|     22|            NamedNode::from(i)
 1947|     22|        }
 1948|     22|
 1949|     22|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|     22|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|     22|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|     22|            } else {
 1953|     22|                Err("Prefix not found")
 1954|     22|            } }
 1955|     22|
 1956|     22|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|     22|            let node = BlankNode::new_unchecked(id);
 1958|     22|            if state.used_bnodes.contains(&node) {
 1959|     22|                Err("Already used blank node id")
 1960|     22|            } else {
 1961|     22|                state.currently_used_bnodes.insert(node.clone());
 1962|     22|                Ok(node)
 1963|     22|            }
 1964|     22|        } / ANON() { BlankNode::default() }
 1965|     22|
 1966|     22|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|     22|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|     22|        }
 1969|     22|
 1970|     22|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|     22|            ns
 1972|     22|        }
 1973|     22|
 1974|     22|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|     22|            if let Some(base) = state.namespaces.get(ns) {
 1976|     22|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|     22|                iri.push_str(base);
 1978|     22|                for chunk in local.split('\\') { // We remove \
 1979|     22|                    iri.push_str(chunk);
 1980|     22|                }
 1981|     22|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|     22|            } else {
 1983|     22|                Err("Prefix not found")
 1984|     22|            }
 1985|     22|        }
 1986|     22|
 1987|     22|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|     22|            b
 1989|     22|        }
 1990|     22|
 1991|     22|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|     22|
 1993|     22|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|     22|
 1995|     22|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|     22|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|     22|        }
 1998|     22|
 1999|     22|        rule INTEGER() = ['0'..='9']+
 2000|     22|
 2001|     22|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|     22|
 2003|     22|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|     22|
 2005|     22|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|     22|
 2007|     22|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|     22|
 2009|     22|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|     22|
 2011|     22|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|     22|
 2013|     22|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|     22|
 2015|     22|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|     22|
 2017|     22|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|     22|
 2019|     22|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|     22|             unescape_string(l)
 2021|     22|        }
 2022|     22|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|     22|
 2024|     22|
 2025|     22|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|     22|             unescape_string(l)
 2027|     22|        }
 2028|     22|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|     22|
 2030|     22|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|     22|             unescape_string(l)
 2032|     22|        }
 2033|     22|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|     22|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|     22|
 2036|     22|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|     22|             unescape_string(l)
 2038|     22|        }
 2039|     22|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|     22|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|     22|
 2042|     22|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|     22|
 2044|     22|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|     22|
 2046|     22|        rule NIL() = "(" WS()* ")"
 2047|     22|
 2048|     22|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|     22|
 2050|     22|        rule ANON() = "[" WS()* "]"
 2051|     22|
 2052|     22|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|     22|
 2054|     22|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|     22|
 2056|     22|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|     22|
 2058|     22|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|     22|
 2060|     22|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|     22|
 2062|     22|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|     22|
 2064|     22|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|     22|
 2066|     22|        rule PERCENT() = ['%'] HEX() HEX()
 2067|     22|
 2068|     22|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|     22|
 2070|     22|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|     22|
 2072|     22|        //space
 2073|     22|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|     22|
 2075|     22|        //comment
 2076|     22|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|     22|
 2078|     22|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|     22|            if input.eq_ignore_ascii_case(literal) {
 2080|     22|                Ok(())
 2081|     22|            } else {
 2082|     22|                Err(literal)
 2083|     22|            }
 2084|     22|        }
 2085|     22|    }
 2086|     22|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Update1_silent0B7_:
  976|  2.29k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PathElt_ops_0B7_:
 1528|  2.50k|            "+" { '+' } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls5_0B7_:
 1797|     16|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_Expression0B7_:
 1703|  2.42k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_GroupOrUnionGraphPattern00B9_:
 1312|     19|            not_empty_fold(p.into_iter(), |a, b| {
 1313|     19|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|     19|            }).map(PartialGraphPattern::Other)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GraphRefAlls1_0B7_:
 1144|    293|            / i("ALL") { GraphTarget::AllGraphs }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValues0_0B7_:
 1302|    148|            l:RDFLiteral() { Some(l.into()) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValues1_0B7_:
 1303|    255|            l:NumericLiteral() { Some(l.into()) } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_PathSequence00B9_:
 1511|  9.08k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  9.08k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  9.08k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_iriOrFunction0B7_:
 1909|    730|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|    730|            match a {
 1911|      0|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|    730|                None => i.into()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Bind0B7_:
 1270|      3|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|      3|            PartialGraphPattern::Bind(e, v)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_option0B7_:
  821|    329|            i("DISTINCT") { SelectionOption::Distinct } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_PathAlternative00B9_:
 1504|  1.58k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  1.58k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  1.58k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_GraphNodePath0B7_:
 1652|  7.17k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_ConditionalAndExpression00B9_:
 1711|    400|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_DataBlock0B7_:
 1276|    248|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|    248|            GraphPattern::Values { variables: l.0, bindings: l.1 }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Selection_init0B7_:
  817|  1.94k|        rule Selection_init() = {
  818|  1.94k|            state.aggregates.push(Vec::new())
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GroupClause0B7_:
  920|     80|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|     80|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|     80|            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|     80|            }).collect();
  931|     80|            (clauses, projections)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Update1_silents_0B7_:
  976|    541|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroupConditions1_0B7_:
  939|    295|            e:Var() { (e.into(), None) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_DeleteClause0B7_:
  778|  2.36k|parser! {
  779|  2.36k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  2.36k|    grammar parser(state: &mut ParserState) for str {
  781|  2.36k|        pub rule QueryUnit() -> Query = Query()
  782|  2.36k|
  783|  2.36k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  2.36k|            q
  785|  2.36k|        }
  786|  2.36k|
  787|  2.36k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  2.36k|
  789|  2.36k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  2.36k|
  791|  2.36k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  2.36k|            state.base_iri = Some(i)
  793|  2.36k|        }
  794|  2.36k|
  795|  2.36k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  2.36k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  2.36k|        }
  798|  2.36k|
  799|  2.36k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  2.36k|            Ok(Query::Select {
  801|  2.36k|                dataset: d,
  802|  2.36k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  2.36k|                base_iri: state.base_iri.clone()
  804|  2.36k|            })
  805|  2.36k|        }
  806|  2.36k|
  807|  2.36k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  2.36k|            build_select(s, w, g, h, o, l, v, state)
  809|  2.36k|        }
  810|  2.36k|
  811|  2.36k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  2.36k|            Selection {
  813|  2.36k|                option: o,
  814|  2.36k|                variables: v
  815|  2.36k|            }
  816|  2.36k|        }
  817|  2.36k|        rule Selection_init() = {
  818|  2.36k|            state.aggregates.push(Vec::new())
  819|  2.36k|        }
  820|  2.36k|        rule SelectClause_option() -> SelectionOption =
  821|  2.36k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  2.36k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  2.36k|            { SelectionOption::Default }
  824|  2.36k|        rule SelectClause_variables() -> SelectionVariables =
  825|  2.36k|            "*" { SelectionVariables::Star } /
  826|  2.36k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  2.36k|        rule SelectClause_member() -> SelectionMember =
  828|  2.36k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  2.36k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  2.36k|
  831|  2.36k|        rule ConstructQuery() -> Query =
  832|  2.36k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  2.36k|                Ok(Query::Construct {
  834|  2.36k|                    template: c,
  835|  2.36k|                    dataset: d,
  836|  2.36k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  2.36k|                    base_iri: state.base_iri.clone()
  838|  2.36k|                })
  839|  2.36k|            } /
  840|  2.36k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  2.36k|                Ok(Query::Construct {
  842|  2.36k|                    template: c.clone(),
  843|  2.36k|                    dataset: d,
  844|  2.36k|                    pattern: build_select(
  845|  2.36k|                        Selection::no_op(),
  846|  2.36k|                        GraphPattern::Bgp { patterns: c },
  847|  2.36k|                        g, h, o, l, v, state
  848|  2.36k|                    )?,
  849|  2.36k|                    base_iri: state.base_iri.clone()
  850|  2.36k|                })
  851|  2.36k|            }
  852|  2.36k|
  853|  2.36k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  2.36k|
  855|  2.36k|        rule DescribeQuery() -> Query =
  856|  2.36k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  2.36k|                Ok(Query::Describe {
  858|  2.36k|                    dataset: d,
  859|  2.36k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  2.36k|                    base_iri: state.base_iri.clone()
  861|  2.36k|                })
  862|  2.36k|            } /
  863|  2.36k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  2.36k|                Ok(Query::Describe {
  865|  2.36k|                    dataset: d,
  866|  2.36k|                    pattern: build_select(Selection {
  867|  2.36k|                        option: SelectionOption::Default,
  868|  2.36k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  2.36k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  2.36k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  2.36k|                        }).collect())
  872|  2.36k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  2.36k|                    base_iri: state.base_iri.clone()
  874|  2.36k|                })
  875|  2.36k|            }
  876|  2.36k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  2.36k|
  878|  2.36k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  2.36k|            Ok(Query::Ask {
  880|  2.36k|                dataset: d,
  881|  2.36k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  2.36k|                base_iri: state.base_iri.clone()
  883|  2.36k|            })
  884|  2.36k|        }
  885|  2.36k|
  886|  2.36k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  2.36k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  2.36k|            if d.is_empty() {
  889|  2.36k|                return None;
  890|  2.36k|            }
  891|  2.36k|            let mut default = Vec::new();
  892|  2.36k|            let mut named = Vec::new();
  893|  2.36k|            for (d, n) in d {
  894|  2.36k|                if let Some(d) = d {
  895|  2.36k|                    default.push(d);
  896|  2.36k|                }
  897|  2.36k|                if let Some(n) = n {
  898|  2.36k|                    named.push(n);
  899|  2.36k|                }
  900|  2.36k|            }
  901|  2.36k|            Some(QueryDataset {
  902|  2.36k|                default, named: Some(named)
  903|  2.36k|            })
  904|  2.36k|        }
  905|  2.36k|
  906|  2.36k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  2.36k|            (Some(s), None)
  908|  2.36k|        }
  909|  2.36k|
  910|  2.36k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  2.36k|            (None, Some(s))
  912|  2.36k|        }
  913|  2.36k|
  914|  2.36k|        rule SourceSelector() -> NamedNode = iri()
  915|  2.36k|
  916|  2.36k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  2.36k|            p
  918|  2.36k|        }
  919|  2.36k|
  920|  2.36k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  2.36k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  2.36k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  2.36k|                if let Expression::Variable(v) = e {
  924|  2.36k|                    v
  925|  2.36k|                } else {
  926|  2.36k|                    let v = vo.unwrap_or_else(variable);
  927|  2.36k|                    projections.push((e, v.clone()));
  928|  2.36k|                    v
  929|  2.36k|                }
  930|  2.36k|            }).collect();
  931|  2.36k|            (clauses, projections)
  932|  2.36k|        }
  933|  2.36k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  2.36k|
  935|  2.36k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  2.36k|            e:BuiltInCall() { (e, None) } /
  937|  2.36k|            e:FunctionCall() { (e, None) } /
  938|  2.36k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  2.36k|            e:Var() { (e.into(), None) }
  940|  2.36k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  2.36k|
  942|  2.36k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  2.36k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  2.36k|        }
  945|  2.36k|
  946|  2.36k|        rule HavingCondition() -> Expression = Constraint()
  947|  2.36k|
  948|  2.36k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  2.36k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  2.36k|
  951|  2.36k|        rule OrderCondition() -> OrderExpression =
  952|  2.36k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  2.36k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  2.36k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  2.36k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  2.36k|
  957|  2.36k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  2.36k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  2.36k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  2.36k|
  961|  2.36k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  2.36k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  2.36k|        }
  964|  2.36k|
  965|  2.36k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  2.36k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  2.36k|        }
  968|  2.36k|
  969|  2.36k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  2.36k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  2.36k|            { None }
  972|  2.36k|
  973|  2.36k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  2.36k|
  975|  2.36k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  2.36k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  2.36k|
  978|  2.36k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  2.36k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  2.36k|        }
  981|  2.36k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  2.36k|
  983|  2.36k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  2.36k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  2.36k|        }
  986|  2.36k|
  987|  2.36k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  2.36k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  2.36k|        }
  990|  2.36k|
  991|  2.36k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  2.36k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  2.36k|        }
  994|  2.36k|
  995|  2.36k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  2.36k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  2.36k|            if from == to {
  998|  2.36k|                Vec::new() // identity case
  999|  2.36k|            } else {
 1000|  2.36k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  2.36k|                vec![copy_graph(from, to)]
 1002|  2.36k|            }
 1003|  2.36k|        }
 1004|  2.36k|
 1005|  2.36k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  2.36k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  2.36k|            if from == to {
 1008|  2.36k|                Vec::new() // identity case
 1009|  2.36k|            } else {
 1010|  2.36k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  2.36k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  2.36k|            }
 1013|  2.36k|        }
 1014|  2.36k|
 1015|  2.36k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  2.36k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  2.36k|            if from == to {
 1018|  2.36k|                Vec::new() // identity case
 1019|  2.36k|            } else {
 1020|  2.36k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  2.36k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  2.36k|            }
 1023|  2.36k|        }
 1024|  2.36k|
 1025|  2.36k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  2.36k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  2.36k|        }
 1028|  2.36k|
 1029|  2.36k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  2.36k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  2.36k|        }
 1032|  2.36k|
 1033|  2.36k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  2.36k|            let pattern = d.iter().map(|q| {
 1035|  2.36k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  2.36k|                match &q.graph_name {
 1037|  2.36k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  2.36k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  2.36k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  2.36k|                }
 1041|  2.36k|            }).reduce(new_join).unwrap_or_default();
 1042|  2.36k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  2.36k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  2.36k|                delete,
 1045|  2.36k|                insert: Vec::new(),
 1046|  2.36k|                using: None,
 1047|  2.36k|                pattern: Box::new(pattern)
 1048|  2.36k|            }])
 1049|  2.36k|        }
 1050|  2.36k|
 1051|  2.36k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  2.36k|            let (delete, insert) = c;
 1053|  2.36k|            let mut delete = delete.unwrap_or_default();
 1054|  2.36k|            let mut insert = insert.unwrap_or_default();
 1055|  2.36k|            #[allow(clippy::shadow_same)]
 1056|  2.36k|            let mut pattern = pattern;
 1057|  2.36k|
 1058|  2.36k|            let mut using = if u.is_empty() {
 1059|  2.36k|                None
 1060|  2.36k|            } else {
 1061|  2.36k|                let mut default = Vec::new();
 1062|  2.36k|                let mut named = Vec::new();
 1063|  2.36k|                for (d, n) in u {
 1064|  2.36k|                    if let Some(d) = d {
 1065|  2.36k|                        default.push(d)
 1066|  2.36k|                    }
 1067|  2.36k|                    if let Some(n) = n {
 1068|  2.36k|                        named.push(n)
 1069|  2.36k|                    }
 1070|  2.36k|                }
 1071|  2.36k|                Some(QueryDataset { default, named: Some(named) })
 1072|  2.36k|            };
 1073|  2.36k|
 1074|  2.36k|            if let Some(with) = with {
 1075|  2.36k|                // We inject WITH everywhere
 1076|  2.36k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  2.36k|                    GroundQuadPattern {
 1078|  2.36k|                        subject: q.subject,
 1079|  2.36k|                        predicate: q.predicate,
 1080|  2.36k|                        object: q.object,
 1081|  2.36k|                        graph_name: with.clone().into()
 1082|  2.36k|                    }
 1083|  2.36k|                } else {
 1084|  2.36k|                    q
 1085|  2.36k|                }).collect();
 1086|  2.36k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  2.36k|                    QuadPattern {
 1088|  2.36k|                        subject: q.subject,
 1089|  2.36k|                        predicate: q.predicate,
 1090|  2.36k|                        object: q.object,
 1091|  2.36k|                        graph_name: with.clone().into()
 1092|  2.36k|                    }
 1093|  2.36k|                } else {
 1094|  2.36k|                    q
 1095|  2.36k|                }).collect();
 1096|  2.36k|                if using.is_none() {
 1097|  2.36k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  2.36k|                }
 1099|  2.36k|            }
 1100|  2.36k|
 1101|  2.36k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  2.36k|                delete,
 1103|  2.36k|                insert,
 1104|  2.36k|                using,
 1105|  2.36k|                pattern: Box::new(pattern)
 1106|  2.36k|            }]
 1107|  2.36k|        }
 1108|  2.36k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  2.36k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  2.36k|            (Some(d), i)
 1111|  2.36k|        } / i:InsertClause() {
 1112|  2.36k|            (None, Some(i))
 1113|  2.36k|        }
 1114|  2.36k|        rule Modify_clear() = {
 1115|  2.36k|            state.used_bnodes.clear();
 1116|  2.36k|            state.currently_used_bnodes.clear();
 1117|  2.36k|        }
 1118|  2.36k|
 1119|  2.36k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  2.36k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  2.36k|        }
 1122|  2.36k|
 1123|  2.36k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  2.36k|
 1125|  2.36k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  2.36k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  2.36k|            (Some(i), None)
 1128|  2.36k|        }
 1129|  2.36k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  2.36k|            (None, Some(i))
 1131|  2.36k|        }
 1132|  2.36k|
 1133|  2.36k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  2.36k|            GraphName::DefaultGraph
 1135|  2.36k|        } / (i("GRAPH") _)? g:iri() {
 1136|  2.36k|            GraphName::NamedNode(g)
 1137|  2.36k|        }
 1138|  2.36k|
 1139|  2.36k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  2.36k|
 1141|  2.36k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  2.36k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  2.36k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  2.36k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  2.36k|
 1146|  2.36k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  2.36k|
 1148|  2.36k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  2.36k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  2.36k|        }
 1151|  2.36k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  2.36k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  2.36k|        }
 1154|  2.36k|
 1155|  2.36k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  2.36k|            q.into_iter().flatten().collect()
 1157|  2.36k|        }
 1158|  2.36k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  2.36k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  2.36k|        } //TODO: return iter?
 1161|  2.36k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  2.36k|
 1163|  2.36k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  2.36k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  2.36k|        }
 1166|  2.36k|
 1167|  2.36k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  2.36k|            ts.into_iter().flatten().collect()
 1169|  2.36k|        }
 1170|  2.36k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  2.36k|
 1172|  2.36k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  2.36k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  2.36k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  2.36k|        rule GroupGraphPattern_clear() = {
 1176|  2.36k|             // We deal with blank nodes aliases rule
 1177|  2.36k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  2.36k|            state.currently_used_bnodes.clear();
 1179|  2.36k|        }
 1180|  2.36k|
 1181|  2.36k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  2.36k|            let mut filter: Option<Expression> = None;
 1183|  2.36k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  2.36k|            for e in b.into_iter().flatten() {
 1185|  2.36k|                match e {
 1186|  2.36k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  2.36k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  2.36k|                    }
 1189|  2.36k|                    #[cfg(feature = "sep-0006")]
 1190|  2.36k|                    PartialGraphPattern::Lateral(p) => {
 1191|  2.36k|                        let mut defined_variables = HashSet::default();
 1192|  2.36k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  2.36k|                        let mut contains = false;
 1194|  2.36k|                        g.on_in_scope_variable(|v| {
 1195|  2.36k|                            if defined_variables.contains(v) {
 1196|  2.36k|                                contains = true;
 1197|  2.36k|                            }
 1198|  2.36k|                        });
 1199|  2.36k|                        if contains {
 1200|  2.36k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  2.36k|                        }
 1202|  2.36k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  2.36k|                    }
 1204|  2.36k|                    PartialGraphPattern::Minus(p) => {
 1205|  2.36k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  2.36k|                    }
 1207|  2.36k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  2.36k|                        let mut contains = false;
 1209|  2.36k|                        g.on_in_scope_variable(|v| {
 1210|  2.36k|                            if *v == variable {
 1211|  2.36k|                                contains = true;
 1212|  2.36k|                            }
 1213|  2.36k|                        });
 1214|  2.36k|                        if contains {
 1215|  2.36k|                            return Err("BIND is overriding an existing variable")
 1216|  2.36k|                        }
 1217|  2.36k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  2.36k|                    }
 1219|  2.36k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  2.36k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  2.36k|                    } else {
 1222|  2.36k|                        expr
 1223|  2.36k|                    }),
 1224|  2.36k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  2.36k|                }
 1226|  2.36k|            }
 1227|  2.36k|
 1228|  2.36k|            Ok(if let Some(expr) = filter {
 1229|  2.36k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  2.36k|            } else {
 1231|  2.36k|                g
 1232|  2.36k|            })
 1233|  2.36k|        }
 1234|  2.36k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  2.36k|            let mut result = vec![a];
 1236|  2.36k|            if let Some(v) = b {
 1237|  2.36k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  2.36k|            }
 1239|  2.36k|            result
 1240|  2.36k|        }
 1241|  2.36k|
 1242|  2.36k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  2.36k|            hs.into_iter().flatten().collect()
 1244|  2.36k|        }
 1245|  2.36k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  2.36k|
 1247|  2.36k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  2.36k|
 1249|  2.36k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  2.36k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  2.36k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  2.36k|            } else {
 1253|  2.36k|               PartialGraphPattern::Optional(p, None)
 1254|  2.36k|            }
 1255|  2.36k|        }
 1256|  2.36k|
 1257|  2.36k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  2.36k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  2.36k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  2.36k|        }
 1261|  2.36k|
 1262|  2.36k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  2.36k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  2.36k|        }
 1265|  2.36k|
 1266|  2.36k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  2.36k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  2.36k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  2.36k|
 1270|  2.36k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  2.36k|            PartialGraphPattern::Bind(e, v)
 1272|  2.36k|        }
 1273|  2.36k|
 1274|  2.36k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  2.36k|
 1276|  2.36k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  2.36k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  2.36k|        }
 1279|  2.36k|
 1280|  2.36k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  2.36k|            (vec![var], d)
 1282|  2.36k|        }
 1283|  2.36k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  2.36k|
 1285|  2.36k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  2.36k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  2.36k|                Ok((vars, vals))
 1288|  2.36k|            } else {
 1289|  2.36k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  2.36k|            }
 1291|  2.36k|        }
 1292|  2.36k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  2.36k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  2.36k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  2.36k|
 1296|  2.36k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  2.36k|            t:QuotedTripleData() {?
 1298|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  2.36k|            } /
 1301|  2.36k|            i:iri() { Some(i.into()) } /
 1302|  2.36k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  2.36k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  2.36k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  2.36k|            i("UNDEF") { None }
 1306|  2.36k|
 1307|  2.36k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  2.36k|            PartialGraphPattern::Minus(p)
 1309|  2.36k|        }
 1310|  2.36k|
 1311|  2.36k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  2.36k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  2.36k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  2.36k|            }).map(PartialGraphPattern::Other)
 1315|  2.36k|        }
 1316|  2.36k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  2.36k|
 1318|  2.36k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  2.36k|            PartialGraphPattern::Filter(c)
 1320|  2.36k|        }
 1321|  2.36k|
 1322|  2.36k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  2.36k|
 1324|  2.36k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  2.36k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  2.36k|        }
 1327|  2.36k|
 1328|  2.36k|        rule ArgList() -> Vec<Expression> =
 1329|  2.36k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  2.36k|            NIL() { Vec::new() }
 1331|  2.36k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  2.36k|
 1333|  2.36k|        rule ExpressionList() -> Vec<Expression> =
 1334|  2.36k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  2.36k|            NIL() { Vec::new() }
 1336|  2.36k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  2.36k|
 1338|  2.36k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  2.36k|
 1340|  2.36k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  2.36k|            p.into_iter().flatten().collect()
 1342|  2.36k|        }
 1343|  2.36k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  2.36k|
 1345|  2.36k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  2.36k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  2.36k|                let mut patterns = po.patterns;
 1348|  2.36k|                for (p, os) in po.focus {
 1349|  2.36k|                    for o in os {
 1350|  2.36k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  2.36k|                    }
 1352|  2.36k|                }
 1353|  2.36k|                Ok(patterns)
 1354|  2.36k|            } /
 1355|  2.36k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  2.36k|                let mut patterns = s.patterns;
 1357|  2.36k|                patterns.extend(po.patterns);
 1358|  2.36k|                for (p, os) in po.focus {
 1359|  2.36k|                    for o in os {
 1360|  2.36k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  2.36k|                    }
 1362|  2.36k|                }
 1363|  2.36k|                Ok(patterns)
 1364|  2.36k|            }
 1365|  2.36k|
 1366|  2.36k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  2.36k|            PropertyListNotEmpty() /
 1368|  2.36k|            { FocusedTriplePattern::default() }
 1369|  2.36k|
 1370|  2.36k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  2.36k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  2.36k|                a.focus.push(b.focus);
 1373|  2.36k|                a.patterns.extend(b.patterns);
 1374|  2.36k|                a
 1375|  2.36k|            })
 1376|  2.36k|        }
 1377|  2.36k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  2.36k|            FocusedTriplePattern {
 1379|  2.36k|                focus: (p, o.focus),
 1380|  2.36k|                patterns: o.patterns
 1381|  2.36k|            }
 1382|  2.36k|        }
 1383|  2.36k|
 1384|  2.36k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  2.36k|
 1386|  2.36k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  2.36k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  2.36k|                a.focus.push(b.focus);
 1389|  2.36k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  2.36k|                a
 1391|  2.36k|            })
 1392|  2.36k|        }
 1393|  2.36k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  2.36k|
 1395|  2.36k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  2.36k|            if let Some(a) = a {
 1397|  2.36k|                let mut patterns = g.patterns;
 1398|  2.36k|                patterns.extend(a.patterns);
 1399|  2.36k|                FocusedTriplePattern {
 1400|  2.36k|                    focus: AnnotatedTerm {
 1401|  2.36k|                        term: g.focus,
 1402|  2.36k|                        annotations: a.focus
 1403|  2.36k|                    },
 1404|  2.36k|                    patterns
 1405|  2.36k|                }
 1406|  2.36k|            } else {
 1407|  2.36k|                FocusedTriplePattern {
 1408|  2.36k|                    focus: AnnotatedTerm {
 1409|  2.36k|                        term: g.focus,
 1410|  2.36k|                        annotations: Vec::new()
 1411|  2.36k|                    },
 1412|  2.36k|                    patterns: g.patterns
 1413|  2.36k|                }
 1414|  2.36k|            }
 1415|  2.36k|        }
 1416|  2.36k|
 1417|  2.36k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  2.36k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  2.36k|                let mut patterns = po.patterns;
 1420|  2.36k|                for (p, os) in po.focus {
 1421|  2.36k|                    for o in os {
 1422|  2.36k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  2.36k|                    }
 1424|  2.36k|                }
 1425|  2.36k|                Ok(patterns)
 1426|  2.36k|            } /
 1427|  2.36k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  2.36k|                let mut patterns = s.patterns;
 1429|  2.36k|                patterns.extend(po.patterns);
 1430|  2.36k|                for (p, os) in po.focus {
 1431|  2.36k|                    for o in os {
 1432|  2.36k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  2.36k|                    }
 1434|  2.36k|                }
 1435|  2.36k|                Ok(patterns)
 1436|  2.36k|            }
 1437|  2.36k|
 1438|  2.36k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  2.36k|            PropertyListPathNotEmpty() /
 1440|  2.36k|            { FocusedTripleOrPathPattern::default() }
 1441|  2.36k|
 1442|  2.36k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  2.36k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  2.36k|                    focus: vec![(hp, ho.focus)],
 1445|  2.36k|                    patterns: ho.patterns
 1446|  2.36k|                }, |mut a, b| {
 1447|  2.36k|                    a.focus.push(b.focus);
 1448|  2.36k|                    a.patterns.extend(b.patterns);
 1449|  2.36k|                    a
 1450|  2.36k|                })
 1451|  2.36k|        }
 1452|  2.36k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  2.36k|            c
 1454|  2.36k|        }
 1455|  2.36k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  2.36k|            FocusedTripleOrPathPattern {
 1457|  2.36k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  2.36k|                patterns: o.patterns
 1459|  2.36k|            }
 1460|  2.36k|        }
 1461|  2.36k|
 1462|  2.36k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  2.36k|            p.into()
 1464|  2.36k|        }
 1465|  2.36k|
 1466|  2.36k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  2.36k|            v.into()
 1468|  2.36k|        }
 1469|  2.36k|
 1470|  2.36k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  2.36k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  2.36k|                a.focus.push(b.focus);
 1473|  2.36k|                a.patterns.extend(b.patterns);
 1474|  2.36k|                a
 1475|  2.36k|            })
 1476|  2.36k|        }
 1477|  2.36k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  2.36k|
 1479|  2.36k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  2.36k|             if let Some(a) = a {
 1481|  2.36k|                let mut patterns = g.patterns;
 1482|  2.36k|                patterns.extend(a.patterns);
 1483|  2.36k|                FocusedTripleOrPathPattern {
 1484|  2.36k|                    focus: AnnotatedTermPath {
 1485|  2.36k|                        term: g.focus,
 1486|  2.36k|                        annotations: a.focus
 1487|  2.36k|                    },
 1488|  2.36k|                    patterns
 1489|  2.36k|                }
 1490|  2.36k|            } else {
 1491|  2.36k|                FocusedTripleOrPathPattern {
 1492|  2.36k|                    focus: AnnotatedTermPath {
 1493|  2.36k|                        term: g.focus,
 1494|  2.36k|                        annotations: Vec::new()
 1495|  2.36k|                    },
 1496|  2.36k|                    patterns: g.patterns
 1497|  2.36k|                }
 1498|  2.36k|            }
 1499|  2.36k|        }
 1500|  2.36k|
 1501|  2.36k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  2.36k|
 1503|  2.36k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  2.36k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  2.36k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  2.36k|            })
 1507|  2.36k|        }
 1508|  2.36k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  2.36k|
 1510|  2.36k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  2.36k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  2.36k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  2.36k|            })
 1514|  2.36k|        }
 1515|  2.36k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  2.36k|
 1517|  2.36k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  2.36k|            match o {
 1519|  2.36k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  2.36k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  2.36k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  2.36k|                Some(_) => unreachable!(),
 1523|  2.36k|                None => p
 1524|  2.36k|            }
 1525|  2.36k|        }
 1526|  2.36k|        rule PathElt_op() -> char =
 1527|  2.36k|            "*" { '*' } /
 1528|  2.36k|            "+" { '+' } /
 1529|  2.36k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  2.36k|
 1531|  2.36k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  2.36k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  2.36k|            PathElt()
 1534|  2.36k|
 1535|  2.36k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  2.36k|            v:iri() { v.into() } /
 1537|  2.36k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  2.36k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  2.36k|            "(" _ p:Path() _ ")" { p }
 1540|  2.36k|
 1541|  2.36k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  2.36k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  2.36k|                let mut direct = Vec::new();
 1544|  2.36k|                let mut inverse = Vec::new();
 1545|  2.36k|                for e in p {
 1546|  2.36k|                    match e {
 1547|  2.36k|                        Either::Left(a) => direct.push(a),
 1548|  2.36k|                        Either::Right(b) => inverse.push(b)
 1549|  2.36k|                    }
 1550|  2.36k|                }
 1551|  2.36k|                if inverse.is_empty() {
 1552|  2.36k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  2.36k|                } else if direct.is_empty() {
 1554|  2.36k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  2.36k|                } else {
 1556|  2.36k|                    PropertyPathExpression::Alternative(
 1557|  2.36k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  2.36k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  2.36k|                    )
 1560|  2.36k|                }
 1561|  2.36k|            } /
 1562|  2.36k|            p:PathOneInPropertySet() {
 1563|  2.36k|                match p {
 1564|  2.36k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  2.36k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  2.36k|                }
 1567|  2.36k|            }
 1568|  2.36k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  2.36k|
 1570|  2.36k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  2.36k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  2.36k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  2.36k|            v:iri() { Either::Left(v) } /
 1574|  2.36k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  2.36k|
 1576|  2.36k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  2.36k|
 1578|  2.36k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  2.36k|            let mut patterns = po.patterns;
 1580|  2.36k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  2.36k|            for (p, os) in po.focus {
 1582|  2.36k|                for o in os {
 1583|  2.36k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  2.36k|                }
 1585|  2.36k|            }
 1586|  2.36k|            Ok(FocusedTriplePattern {
 1587|  2.36k|                focus: bnode,
 1588|  2.36k|                patterns
 1589|  2.36k|            })
 1590|  2.36k|        }
 1591|  2.36k|
 1592|  2.36k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  2.36k|
 1594|  2.36k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  2.36k|            let mut patterns = po.patterns;
 1596|  2.36k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  2.36k|            for (p, os) in po.focus {
 1598|  2.36k|                for o in os {
 1599|  2.36k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  2.36k|                }
 1601|  2.36k|            }
 1602|  2.36k|            Ok(FocusedTripleOrPathPattern {
 1603|  2.36k|                focus: bnode,
 1604|  2.36k|                patterns
 1605|  2.36k|            })
 1606|  2.36k|        }
 1607|  2.36k|
 1608|  2.36k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  2.36k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  2.36k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  2.36k|            for objWithPatterns in o.into_iter().rev() {
 1612|  2.36k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  2.36k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  2.36k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  2.36k|                current_list_node = new_blank_node;
 1616|  2.36k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  2.36k|            }
 1618|  2.36k|            FocusedTriplePattern {
 1619|  2.36k|                focus: current_list_node,
 1620|  2.36k|                patterns
 1621|  2.36k|            }
 1622|  2.36k|        }
 1623|  2.36k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  2.36k|
 1625|  2.36k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  2.36k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  2.36k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  2.36k|            for objWithPatterns in o.into_iter().rev() {
 1629|  2.36k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  2.36k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  2.36k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  2.36k|                current_list_node = new_blank_node;
 1633|  2.36k|                patterns.extend(objWithPatterns.patterns);
 1634|  2.36k|            }
 1635|  2.36k|            FocusedTripleOrPathPattern {
 1636|  2.36k|                focus: current_list_node,
 1637|  2.36k|                patterns
 1638|  2.36k|            }
 1639|  2.36k|        }
 1640|  2.36k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  2.36k|
 1642|  2.36k|
 1643|  2.36k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  2.36k|
 1645|  2.36k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  2.36k|
 1647|  2.36k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  2.36k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  2.36k|            TriplesNode()
 1650|  2.36k|
 1651|  2.36k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  2.36k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  2.36k|            TriplesNodePath()
 1654|  2.36k|
 1655|  2.36k|        rule VarOrTerm() -> TermPattern =
 1656|  2.36k|            v:Var() { v.into() } /
 1657|  2.36k|            t:QuotedTriple() {?
 1658|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  2.36k|            } /
 1661|  2.36k|            t:GraphTerm() { t.into() }
 1662|  2.36k|
 1663|  2.36k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  2.36k|            Ok(TriplePattern {
 1665|  2.36k|                subject: s,
 1666|  2.36k|                predicate: p,
 1667|  2.36k|                object: o
 1668|  2.36k|            })
 1669|  2.36k|        }
 1670|  2.36k|
 1671|  2.36k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  2.36k|            Ok(GroundTriple {
 1673|  2.36k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  2.36k|                predicate: p,
 1675|  2.36k|                object: o
 1676|  2.36k|            })
 1677|  2.36k|        }
 1678|  2.36k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  2.36k|
 1680|  2.36k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  2.36k|            l:RDFLiteral() { l.into() } /
 1682|  2.36k|            l:NumericLiteral() { l.into() } /
 1683|  2.36k|            l:BooleanLiteral() { l.into() } /
 1684|  2.36k|            t:QuotedTripleData() {?
 1685|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  2.36k|            }
 1688|  2.36k|
 1689|  2.36k|        rule VarOrIri() -> NamedNodePattern =
 1690|  2.36k|            v:Var() { v.into() } /
 1691|  2.36k|            i:iri() { i.into() }
 1692|  2.36k|
 1693|  2.36k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  2.36k|
 1695|  2.36k|        rule GraphTerm() -> Term =
 1696|  2.36k|            i:iri() { i.into() } /
 1697|  2.36k|            l:RDFLiteral() { l.into() } /
 1698|  2.36k|            l:NumericLiteral() { l.into() } /
 1699|  2.36k|            l:BooleanLiteral() { l.into() } /
 1700|  2.36k|            b:BlankNode() { b.into() } /
 1701|  2.36k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  2.36k|
 1703|  2.36k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  2.36k|
 1705|  2.36k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  2.36k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  2.36k|        }
 1708|  2.36k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  2.36k|
 1710|  2.36k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  2.36k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  2.36k|        }
 1713|  2.36k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  2.36k|
 1715|  2.36k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  2.36k|
 1717|  2.36k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  2.36k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  2.36k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  2.36k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  2.36k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  2.36k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  2.36k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  2.36k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  2.36k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  2.36k|            Some(_) => unreachable!(),
 1727|  2.36k|            None => a
 1728|  2.36k|        } }
 1729|  2.36k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  2.36k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  2.36k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  2.36k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  2.36k|
 1734|  2.36k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  2.36k|
 1736|  2.36k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  2.36k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  2.36k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  2.36k|            Some(_) => unreachable!(),
 1740|  2.36k|            None => a,
 1741|  2.36k|        } }
 1742|  2.36k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  2.36k|            (s, e)
 1744|  2.36k|        }
 1745|  2.36k|
 1746|  2.36k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  2.36k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  2.36k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  2.36k|            Some(_) => unreachable!(),
 1750|  2.36k|            None => a
 1751|  2.36k|        } }
 1752|  2.36k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  2.36k|            (s, e)
 1754|  2.36k|        }
 1755|  2.36k|
 1756|  2.36k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  2.36k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  2.36k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  2.36k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  2.36k|            Some(_) => unreachable!(),
 1761|  2.36k|            None => e,
 1762|  2.36k|        } }
 1763|  2.36k|
 1764|  2.36k|        rule PrimaryExpression() -> Expression =
 1765|  2.36k|            BrackettedExpression()  /
 1766|  2.36k|            ExprQuotedTriple() /
 1767|  2.36k|            iriOrFunction() /
 1768|  2.36k|            v:Var() { v.into() } /
 1769|  2.36k|            l:RDFLiteral() { l.into() } /
 1770|  2.36k|            l:NumericLiteral() { l.into() } /
 1771|  2.36k|            l:BooleanLiteral() { l.into() } /
 1772|  2.36k|            BuiltInCall()
 1773|  2.36k|
 1774|  2.36k|        rule ExprVarOrTerm() -> Expression =
 1775|  2.36k|            ExprQuotedTriple() /
 1776|  2.36k|            i:iri() { i.into() } /
 1777|  2.36k|            l:RDFLiteral() { l.into() } /
 1778|  2.36k|            l:NumericLiteral() { l.into() } /
 1779|  2.36k|            l:BooleanLiteral() { l.into() } /
 1780|  2.36k|            v:Var() { v.into() }
 1781|  2.36k|
 1782|  2.36k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  2.36k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  2.36k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  2.36k|        }
 1786|  2.36k|
 1787|  2.36k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  2.36k|
 1789|  2.36k|        rule BuiltInCall() -> Expression =
 1790|  2.36k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  2.36k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  2.36k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  2.36k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  2.36k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  2.36k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  2.36k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  2.36k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  2.36k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  2.36k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  2.36k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  2.36k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  2.36k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  2.36k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  2.36k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  2.36k|            SubstringExpression() /
 1806|  2.36k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  2.36k|            StrReplaceExpression() /
 1808|  2.36k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  2.36k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  2.36k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  2.36k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  2.36k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  2.36k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  2.36k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  2.36k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  2.36k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  2.36k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  2.36k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  2.36k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  2.36k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  2.36k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  2.36k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  2.36k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  2.36k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  2.36k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  2.36k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  2.36k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  2.36k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  2.36k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  2.36k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  2.36k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  2.36k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  2.36k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  2.36k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  2.36k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  2.36k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  2.36k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  2.36k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  2.36k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  2.36k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  2.36k|            RegexExpression() /
 1842|  2.36k|            ExistsFunc() /
 1843|  2.36k|            NotExistsFunc() /
 1844|  2.36k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  2.36k|            } /
 1848|  2.36k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  2.36k|            } /
 1852|  2.36k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  2.36k|            } /
 1856|  2.36k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  2.36k|            } /
 1860|  2.36k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  2.36k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  2.36k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  2.36k|            } /
 1864|  2.36k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  2.36k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  2.36k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  2.36k|            }
 1868|  2.36k|
 1869|  2.36k|        rule RegexExpression() -> Expression =
 1870|  2.36k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  2.36k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  2.36k|
 1873|  2.36k|
 1874|  2.36k|        rule SubstringExpression() -> Expression =
 1875|  2.36k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  2.36k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  2.36k|
 1878|  2.36k|
 1879|  2.36k|        rule StrReplaceExpression() -> Expression =
 1880|  2.36k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  2.36k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  2.36k|
 1883|  2.36k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  2.36k|
 1885|  2.36k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  2.36k|
 1887|  2.36k|        rule Aggregate() -> AggregateExpression =
 1888|  2.36k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  2.36k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  2.36k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  2.36k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  2.36k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  2.36k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  2.36k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  2.36k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  2.36k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  2.36k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  2.36k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  2.36k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  2.36k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  2.36k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  2.36k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  2.36k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  2.36k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  2.36k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  2.36k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  2.36k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  2.36k|
 1909|  2.36k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  2.36k|            match a {
 1911|  2.36k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  2.36k|                None => i.into()
 1913|  2.36k|            }
 1914|  2.36k|        }
 1915|  2.36k|
 1916|  2.36k|        rule RDFLiteral() -> Literal =
 1917|  2.36k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  2.36k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  2.36k|            value:String() { Literal::new_simple_literal(value) }
 1920|  2.36k|
 1921|  2.36k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  2.36k|
 1923|  2.36k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  2.36k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  2.36k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  2.36k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  2.36k|
 1928|  2.36k|        rule NumericLiteralPositive() -> Literal =
 1929|  2.36k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  2.36k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  2.36k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  2.36k|
 1933|  2.36k|
 1934|  2.36k|        rule NumericLiteralNegative() -> Literal =
 1935|  2.36k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  2.36k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  2.36k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  2.36k|
 1939|  2.36k|        rule BooleanLiteral() -> Literal =
 1940|  2.36k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  2.36k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  2.36k|
 1943|  2.36k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  2.36k|
 1945|  2.36k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  2.36k|            NamedNode::from(i)
 1947|  2.36k|        }
 1948|  2.36k|
 1949|  2.36k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  2.36k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  2.36k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  2.36k|            } else {
 1953|  2.36k|                Err("Prefix not found")
 1954|  2.36k|            } }
 1955|  2.36k|
 1956|  2.36k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  2.36k|            let node = BlankNode::new_unchecked(id);
 1958|  2.36k|            if state.used_bnodes.contains(&node) {
 1959|  2.36k|                Err("Already used blank node id")
 1960|  2.36k|            } else {
 1961|  2.36k|                state.currently_used_bnodes.insert(node.clone());
 1962|  2.36k|                Ok(node)
 1963|  2.36k|            }
 1964|  2.36k|        } / ANON() { BlankNode::default() }
 1965|  2.36k|
 1966|  2.36k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  2.36k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  2.36k|        }
 1969|  2.36k|
 1970|  2.36k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  2.36k|            ns
 1972|  2.36k|        }
 1973|  2.36k|
 1974|  2.36k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  2.36k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  2.36k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  2.36k|                iri.push_str(base);
 1978|  2.36k|                for chunk in local.split('\\') { // We remove \
 1979|  2.36k|                    iri.push_str(chunk);
 1980|  2.36k|                }
 1981|  2.36k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  2.36k|            } else {
 1983|  2.36k|                Err("Prefix not found")
 1984|  2.36k|            }
 1985|  2.36k|        }
 1986|  2.36k|
 1987|  2.36k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  2.36k|            b
 1989|  2.36k|        }
 1990|  2.36k|
 1991|  2.36k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  2.36k|
 1993|  2.36k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  2.36k|
 1995|  2.36k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  2.36k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  2.36k|        }
 1998|  2.36k|
 1999|  2.36k|        rule INTEGER() = ['0'..='9']+
 2000|  2.36k|
 2001|  2.36k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  2.36k|
 2003|  2.36k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  2.36k|
 2005|  2.36k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  2.36k|
 2007|  2.36k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  2.36k|
 2009|  2.36k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  2.36k|
 2011|  2.36k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  2.36k|
 2013|  2.36k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  2.36k|
 2015|  2.36k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  2.36k|
 2017|  2.36k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  2.36k|
 2019|  2.36k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  2.36k|             unescape_string(l)
 2021|  2.36k|        }
 2022|  2.36k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  2.36k|
 2024|  2.36k|
 2025|  2.36k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  2.36k|             unescape_string(l)
 2027|  2.36k|        }
 2028|  2.36k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  2.36k|
 2030|  2.36k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  2.36k|             unescape_string(l)
 2032|  2.36k|        }
 2033|  2.36k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  2.36k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  2.36k|
 2036|  2.36k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  2.36k|             unescape_string(l)
 2038|  2.36k|        }
 2039|  2.36k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  2.36k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  2.36k|
 2042|  2.36k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  2.36k|
 2044|  2.36k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  2.36k|
 2046|  2.36k|        rule NIL() = "(" WS()* ")"
 2047|  2.36k|
 2048|  2.36k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  2.36k|
 2050|  2.36k|        rule ANON() = "[" WS()* "]"
 2051|  2.36k|
 2052|  2.36k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  2.36k|
 2054|  2.36k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  2.36k|
 2056|  2.36k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  2.36k|
 2058|  2.36k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  2.36k|
 2060|  2.36k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  2.36k|
 2062|  2.36k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  2.36k|
 2064|  2.36k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  2.36k|
 2066|  2.36k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  2.36k|
 2068|  2.36k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  2.36k|
 2070|  2.36k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  2.36k|
 2072|  2.36k|        //space
 2073|  2.36k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  2.36k|
 2075|  2.36k|        //comment
 2076|  2.36k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  2.36k|
 2078|  2.36k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  2.36k|            if input.eq_ignore_ascii_case(literal) {
 2080|  2.36k|                Ok(())
 2081|  2.36k|            } else {
 2082|  2.36k|                Err(literal)
 2083|  2.36k|            }
 2084|  2.36k|        }
 2085|  2.36k|    }
 2086|  2.36k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Move0B7_:
 1005|    748|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|    748|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|    748|            if from == to {
 1008|    536|                Vec::new() // identity case
 1009|       |            } else {
 1010|    212|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|    212|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_GroupCondition_item0B7_:
  933|    346|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_TriplesSameSubject0B7_:
  778|  17.0k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  17.0k|                let mut patterns = po.patterns;
 1348|  34.1k|                for (p, os) in po.focus {
 1349|  34.1k|                    for o in os {
 1350|  17.0k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|  17.0k|                Ok(patterns)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_TriplesTemplate_inner0B7_:
 1170|  17.0k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerm0B7_:
 1696|  17.6k|            i:iri() { i.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_RDFLiteral0B7_:
 1917|    194|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_Prologue0B7_:
  789|  2.93k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Verb0B7_:
 1384|  9.80k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_PropertyListNotEmpty_item0B7_:
 1377|  17.0k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  17.0k|            FocusedTriplePattern {
 1379|  17.0k|                focus: (p, o.focus),
 1380|  17.0k|                patterns: o.patterns
 1381|  17.0k|            }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralUnsigned0B7_:
 1924|    625|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser45___parse_PropertyListPathNotEmpty_item_content0B7_:
 1455|    367|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|    367|            FocusedTripleOrPathPattern {
 1457|    367|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|    367|                patterns: o.patterns
 1459|    367|            }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser34___parse_RelationalExpression_inners0_0B7_:
 1732|  1.43k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsF_0B7_:
 1835|      5|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_QuadPattern0B7_:
 1146|  5.09k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathAlternative_item0B7_:
 1508|  25.5k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerms_0B7_:
 1697|  1.30k|            l:RDFLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PrimaryExpressions_0B7_:
 1769|  1.08k|            l:RDFLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_CollectionPath_item0B7_:
 1640|  3.04k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_IRIREF0B7_:
  778|  55.7k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|       |                let mut patterns = po.patterns;
 1348|       |                for (p, os) in po.focus {
 1349|       |                    for o in os {
 1350|       |                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|       |                Ok(patterns)
 1354|       |            } /
 1355|       |            s:TriplesNode() _ po:PropertyList() {?
 1356|       |                let mut patterns = s.patterns;
 1357|       |                patterns.extend(po.patterns);
 1358|       |                for (p, os) in po.focus {
 1359|       |                    for o in os {
 1360|       |                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|       |                    }
 1362|       |                }
 1363|       |                Ok(patterns)
 1364|       |            }
 1365|       |
 1366|       |        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|       |            PropertyListNotEmpty() /
 1368|       |            { FocusedTriplePattern::default() }
 1369|       |
 1370|       |        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|       |            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|       |            })
 1376|       |        }
 1377|       |        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|       |            FocusedTriplePattern {
 1379|       |                focus: (p, o.focus),
 1380|       |                patterns: o.patterns
 1381|       |            }
 1382|       |        }
 1383|       |
 1384|       |        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|       |
 1386|       |        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|       |            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|       |            })
 1392|       |        }
 1393|       |        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|       |
 1395|       |        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|       |            if let Some(a) = a {
 1397|       |                let mut patterns = g.patterns;
 1398|       |                patterns.extend(a.patterns);
 1399|       |                FocusedTriplePattern {
 1400|       |                    focus: AnnotatedTerm {
 1401|       |                        term: g.focus,
 1402|       |                        annotations: a.focus
 1403|       |                    },
 1404|       |                    patterns
 1405|       |                }
 1406|       |            } else {
 1407|       |                FocusedTriplePattern {
 1408|       |                    focus: AnnotatedTerm {
 1409|       |                        term: g.focus,
 1410|       |                        annotations: Vec::new()
 1411|       |                    },
 1412|       |                    patterns: g.patterns
 1413|       |                }
 1414|       |            }
 1415|       |        }
 1416|       |
 1417|       |        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|       |            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|       |                let mut patterns = po.patterns;
 1420|       |                for (p, os) in po.focus {
 1421|       |                    for o in os {
 1422|       |                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|       |                    }
 1424|       |                }
 1425|       |                Ok(patterns)
 1426|       |            } /
 1427|       |            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|       |                let mut patterns = s.patterns;
 1429|       |                patterns.extend(po.patterns);
 1430|       |                for (p, os) in po.focus {
 1431|       |                    for o in os {
 1432|       |                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|       |                    }
 1434|       |                }
 1435|       |                Ok(patterns)
 1436|       |            }
 1437|       |
 1438|       |        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|       |            PropertyListPathNotEmpty() /
 1440|       |            { FocusedTripleOrPathPattern::default() }
 1441|       |
 1442|       |        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|       |                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|       |                    focus: vec![(hp, ho.focus)],
 1445|       |                    patterns: ho.patterns
 1446|       |                }, |mut a, b| {
 1447|       |                    a.focus.push(b.focus);
 1448|       |                    a.patterns.extend(b.patterns);
 1449|       |                    a
 1450|       |                })
 1451|       |        }
 1452|       |        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|       |            c
 1454|       |        }
 1455|       |        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|       |            FocusedTripleOrPathPattern {
 1457|       |                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|       |                patterns: o.patterns
 1459|       |            }
 1460|       |        }
 1461|       |
 1462|       |        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|       |            p.into()
 1464|       |        }
 1465|       |
 1466|       |        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|       |            v.into()
 1468|       |        }
 1469|       |
 1470|       |        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|       |            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|       |                a.focus.push(b.focus);
 1473|       |                a.patterns.extend(b.patterns);
 1474|       |                a
 1475|       |            })
 1476|       |        }
 1477|       |        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|       |
 1479|       |        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|       |             if let Some(a) = a {
 1481|       |                let mut patterns = g.patterns;
 1482|       |                patterns.extend(a.patterns);
 1483|       |                FocusedTripleOrPathPattern {
 1484|       |                    focus: AnnotatedTermPath {
 1485|       |                        term: g.focus,
 1486|       |                        annotations: a.focus
 1487|       |                    },
 1488|       |                    patterns
 1489|       |                }
 1490|       |            } else {
 1491|       |                FocusedTripleOrPathPattern {
 1492|       |                    focus: AnnotatedTermPath {
 1493|       |                        term: g.focus,
 1494|       |                        annotations: Vec::new()
 1495|       |                    },
 1496|       |                    patterns: g.patterns
 1497|       |                }
 1498|       |            }
 1499|       |        }
 1500|       |
 1501|       |        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|       |
 1503|       |        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|       |            not_empty_fold(p.into_iter(), |a, b| {
 1505|       |                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|       |            })
 1507|       |        }
 1508|       |        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|       |
 1510|       |        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|       |            not_empty_fold(p.into_iter(), |a, b| {
 1512|       |                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|       |            })
 1514|       |        }
 1515|       |        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|       |
 1517|       |        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|       |            match o {
 1519|       |                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|       |                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|       |                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|       |                Some(_) => unreachable!(),
 1523|       |                None => p
 1524|       |            }
 1525|       |        }
 1526|       |        rule PathElt_op() -> char =
 1527|       |            "*" { '*' } /
 1528|       |            "+" { '+' } /
 1529|       |            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|       |
 1531|       |        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|       |            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|       |            PathElt()
 1534|       |
 1535|       |        rule PathPrimary() -> PropertyPathExpression =
 1536|       |            v:iri() { v.into() } /
 1537|       |            "a" { rdf::TYPE.into_owned().into() } /
 1538|       |            "!" _ p:PathNegatedPropertySet() { p } /
 1539|       |            "(" _ p:Path() _ ")" { p }
 1540|       |
 1541|       |        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|       |            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|       |                let mut direct = Vec::new();
 1544|       |                let mut inverse = Vec::new();
 1545|       |                for e in p {
 1546|       |                    match e {
 1547|       |                        Either::Left(a) => direct.push(a),
 1548|       |                        Either::Right(b) => inverse.push(b)
 1549|       |                    }
 1550|       |                }
 1551|       |                if inverse.is_empty() {
 1552|       |                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|       |                } else if direct.is_empty() {
 1554|       |                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|       |                } else {
 1556|       |                    PropertyPathExpression::Alternative(
 1557|       |                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|       |                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|       |                    )
 1560|       |                }
 1561|       |            } /
 1562|       |            p:PathOneInPropertySet() {
 1563|       |                match p {
 1564|       |                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|       |                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|       |                }
 1567|       |            }
 1568|       |        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|       |
 1570|       |        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|       |            "^" _ v:iri() { Either::Right(v) } /
 1572|       |            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|       |            v:iri() { Either::Left(v) } /
 1574|       |            "a" { Either::Left(rdf::TYPE.into()) }
 1575|       |
 1576|       |        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|       |
 1578|       |        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|       |            let mut patterns = po.patterns;
 1580|       |            let mut bnode = TermPattern::from(BlankNode::default());
 1581|       |            for (p, os) in po.focus {
 1582|       |                for o in os {
 1583|       |                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|       |                }
 1585|       |            }
 1586|       |            Ok(FocusedTriplePattern {
 1587|       |                focus: bnode,
 1588|       |                patterns
 1589|       |            })
 1590|       |        }
 1591|       |
 1592|       |        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|       |
 1594|       |        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|       |            let mut patterns = po.patterns;
 1596|       |            let mut bnode = TermPattern::from(BlankNode::default());
 1597|       |            for (p, os) in po.focus {
 1598|       |                for o in os {
 1599|       |                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|       |                }
 1601|       |            }
 1602|       |            Ok(FocusedTripleOrPathPattern {
 1603|       |                focus: bnode,
 1604|       |                patterns
 1605|       |            })
 1606|       |        }
 1607|       |
 1608|       |        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|       |            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|       |            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|       |            for objWithPatterns in o.into_iter().rev() {
 1612|       |                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|       |                current_list_node = new_blank_node;
 1616|       |                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|       |            }
 1618|       |            FocusedTriplePattern {
 1619|       |                focus: current_list_node,
 1620|       |                patterns
 1621|       |            }
 1622|       |        }
 1623|       |        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|       |
 1625|       |        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|       |            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|       |            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|       |            for objWithPatterns in o.into_iter().rev() {
 1629|       |                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|       |                current_list_node = new_blank_node;
 1633|       |                patterns.extend(objWithPatterns.patterns);
 1634|       |            }
 1635|       |            FocusedTripleOrPathPattern {
 1636|       |                focus: current_list_node,
 1637|       |                patterns
 1638|       |            }
 1639|       |        }
 1640|       |        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|       |
 1642|       |
 1643|       |        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|       |
 1645|       |        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|       |
 1647|       |        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|       |            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|       |            TriplesNode()
 1650|       |
 1651|       |        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|       |            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|       |            TriplesNodePath()
 1654|       |
 1655|       |        rule VarOrTerm() -> TermPattern =
 1656|       |            v:Var() { v.into() } /
 1657|       |            t:QuotedTriple() {?
 1658|       |                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|       |            } /
 1661|       |            t:GraphTerm() { t.into() }
 1662|       |
 1663|       |        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|       |            Ok(TriplePattern {
 1665|       |                subject: s,
 1666|       |                predicate: p,
 1667|       |                object: o
 1668|       |            })
 1669|       |        }
 1670|       |
 1671|       |        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|       |            Ok(GroundTriple {
 1673|       |                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|       |                predicate: p,
 1675|       |                object: o
 1676|       |            })
 1677|       |        }
 1678|       |        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|       |
 1680|       |        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|       |            l:RDFLiteral() { l.into() } /
 1682|       |            l:NumericLiteral() { l.into() } /
 1683|       |            l:BooleanLiteral() { l.into() } /
 1684|       |            t:QuotedTripleData() {?
 1685|       |                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|       |            }
 1688|       |
 1689|       |        rule VarOrIri() -> NamedNodePattern =
 1690|       |            v:Var() { v.into() } /
 1691|       |            i:iri() { i.into() }
 1692|       |
 1693|       |        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|       |
 1695|       |        rule GraphTerm() -> Term =
 1696|       |            i:iri() { i.into() } /
 1697|       |            l:RDFLiteral() { l.into() } /
 1698|       |            l:NumericLiteral() { l.into() } /
 1699|       |            l:BooleanLiteral() { l.into() } /
 1700|       |            b:BlankNode() { b.into() } /
 1701|       |            NIL() { rdf::NIL.into_owned().into() }
 1702|       |
 1703|       |        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|       |
 1705|       |        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|       |            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|       |        }
 1708|       |        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|       |
 1710|       |        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|       |        }
 1713|       |        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|       |
 1715|       |        rule ValueLogical() -> Expression = RelationalExpression()
 1716|       |
 1717|       |        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|       |            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|       |            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|       |            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|       |            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|       |            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|       |            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|       |            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|       |            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|       |            Some(_) => unreachable!(),
 1727|       |            None => a
 1728|       |        } }
 1729|       |        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|       |            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|       |            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|       |            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|       |
 1734|       |        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|       |
 1736|       |        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|       |            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|       |            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|       |            Some(_) => unreachable!(),
 1740|       |            None => a,
 1741|       |        } }
 1742|       |        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|       |            (s, e)
 1744|       |        }
 1745|       |
 1746|       |        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|       |            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|       |            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|       |            Some(_) => unreachable!(),
 1750|       |            None => a
 1751|       |        } }
 1752|       |        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|       |            (s, e)
 1754|       |        }
 1755|       |
 1756|       |        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|       |            Some("!") => Expression::Not(Box::new(e)),
 1758|       |            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|       |            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|       |            Some(_) => unreachable!(),
 1761|       |            None => e,
 1762|       |        } }
 1763|       |
 1764|       |        rule PrimaryExpression() -> Expression =
 1765|       |            BrackettedExpression()  /
 1766|       |            ExprQuotedTriple() /
 1767|       |            iriOrFunction() /
 1768|       |            v:Var() { v.into() } /
 1769|       |            l:RDFLiteral() { l.into() } /
 1770|       |            l:NumericLiteral() { l.into() } /
 1771|       |            l:BooleanLiteral() { l.into() } /
 1772|       |            BuiltInCall()
 1773|       |
 1774|       |        rule ExprVarOrTerm() -> Expression =
 1775|       |            ExprQuotedTriple() /
 1776|       |            i:iri() { i.into() } /
 1777|       |            l:RDFLiteral() { l.into() } /
 1778|       |            l:NumericLiteral() { l.into() } /
 1779|       |            l:BooleanLiteral() { l.into() } /
 1780|       |            v:Var() { v.into() }
 1781|       |
 1782|       |        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|       |            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|       |            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|       |        }
 1786|       |
 1787|       |        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|       |
 1789|       |        rule BuiltInCall() -> Expression =
 1790|       |            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|       |            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|       |            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|       |            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|       |            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|       |            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|       |            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|       |            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|       |            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|       |            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|       |            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|       |            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|       |            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|       |            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|       |            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|       |            SubstringExpression() /
 1806|       |            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|       |            StrReplaceExpression() /
 1808|       |            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|       |            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|       |            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|       |            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|       |            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|       |            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|       |            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|       |            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|       |            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|       |            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|       |            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|       |            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|       |            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|       |            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|       |            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|       |            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|       |            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|       |            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|       |            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|       |            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|       |            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|       |            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|       |            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|       |            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|       |            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|       |            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|       |            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|       |            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|       |            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|       |            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|       |            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|       |            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|       |            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|       |            RegexExpression() /
 1842|       |            ExistsFunc() /
 1843|       |            NotExistsFunc() /
 1844|       |            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|       |                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|       |            } /
 1848|       |            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|       |                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|       |            } /
 1852|       |            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|       |                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|       |            } /
 1856|       |            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|       |                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|       |            } /
 1860|       |            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|       |                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|       |            } /
 1864|       |            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|       |                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|       |                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|       |            }
 1868|       |
 1869|       |        rule RegexExpression() -> Expression =
 1870|       |            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|       |            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|       |
 1873|       |
 1874|       |        rule SubstringExpression() -> Expression =
 1875|       |            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|       |            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|       |
 1878|       |
 1879|       |        rule StrReplaceExpression() -> Expression =
 1880|       |            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|       |            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|       |
 1883|       |        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|       |
 1885|       |        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|       |
 1887|       |        rule Aggregate() -> AggregateExpression =
 1888|       |            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|       |            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|       |            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|       |            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|       |            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|       |            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|       |            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|       |            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|       |            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|       |            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|       |            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|       |            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|       |            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|       |            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|       |            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|       |            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|       |            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|       |            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|       |            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|       |            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|       |
 1909|       |        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|       |            match a {
 1911|       |                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|       |                None => i.into()
 1913|       |            }
 1914|       |        }
 1915|       |
 1916|       |        rule RDFLiteral() -> Literal =
 1917|       |            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|       |            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|       |            value:String() { Literal::new_simple_literal(value) }
 1920|       |
 1921|       |        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|       |
 1923|       |        rule NumericLiteralUnsigned() -> Literal =
 1924|       |            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|       |            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|       |            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|       |
 1928|       |        rule NumericLiteralPositive() -> Literal =
 1929|       |            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|       |            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|       |            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|       |
 1933|       |
 1934|       |        rule NumericLiteralNegative() -> Literal =
 1935|       |            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|       |            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|       |            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|       |
 1939|       |        rule BooleanLiteral() -> Literal =
 1940|       |            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|       |            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|       |
 1943|       |        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|       |
 1945|       |        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|       |            NamedNode::from(i)
 1947|       |        }
 1948|       |
 1949|       |        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|       |            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|       |                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|       |            } else {
 1953|       |                Err("Prefix not found")
 1954|       |            } }
 1955|       |
 1956|       |        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|       |            let node = BlankNode::new_unchecked(id);
 1958|       |            if state.used_bnodes.contains(&node) {
 1959|       |                Err("Already used blank node id")
 1960|       |            } else {
 1961|       |                state.currently_used_bnodes.insert(node.clone());
 1962|       |                Ok(node)
 1963|       |            }
 1964|       |        } / ANON() { BlankNode::default() }
 1965|       |
 1966|       |        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  55.7k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerms1_0B7_:
 1699|    564|            l:BooleanLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_InlineDataOneVar_value0B7_:
 1283|    364|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_PathPrimarys0_0B7_:
 1538|  1.60k|            "!" _ p:PathNegatedPropertySet() { p } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_Clear0B7_:
  983|  1.31k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  1.31k|            vec![GraphUpdateOperation::Clear { silent, graph }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_QuadData0B7_:
  778|    239|parser! {
  779|    239|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|    239|    grammar parser(state: &mut ParserState) for str {
  781|    239|        pub rule QueryUnit() -> Query = Query()
  782|    239|
  783|    239|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|    239|            q
  785|    239|        }
  786|    239|
  787|    239|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|    239|
  789|    239|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|    239|
  791|    239|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|    239|            state.base_iri = Some(i)
  793|    239|        }
  794|    239|
  795|    239|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|    239|            state.namespaces.insert(ns.into(), i.into_inner());
  797|    239|        }
  798|    239|
  799|    239|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|    239|            Ok(Query::Select {
  801|    239|                dataset: d,
  802|    239|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|    239|                base_iri: state.base_iri.clone()
  804|    239|            })
  805|    239|        }
  806|    239|
  807|    239|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|    239|            build_select(s, w, g, h, o, l, v, state)
  809|    239|        }
  810|    239|
  811|    239|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|    239|            Selection {
  813|    239|                option: o,
  814|    239|                variables: v
  815|    239|            }
  816|    239|        }
  817|    239|        rule Selection_init() = {
  818|    239|            state.aggregates.push(Vec::new())
  819|    239|        }
  820|    239|        rule SelectClause_option() -> SelectionOption =
  821|    239|            i("DISTINCT") { SelectionOption::Distinct } /
  822|    239|            i("REDUCED") { SelectionOption::Reduced } /
  823|    239|            { SelectionOption::Default }
  824|    239|        rule SelectClause_variables() -> SelectionVariables =
  825|    239|            "*" { SelectionVariables::Star } /
  826|    239|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|    239|        rule SelectClause_member() -> SelectionMember =
  828|    239|            v:Var() _ { SelectionMember::Variable(v) } /
  829|    239|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|    239|
  831|    239|        rule ConstructQuery() -> Query =
  832|    239|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|    239|                Ok(Query::Construct {
  834|    239|                    template: c,
  835|    239|                    dataset: d,
  836|    239|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|    239|                    base_iri: state.base_iri.clone()
  838|    239|                })
  839|    239|            } /
  840|    239|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|    239|                Ok(Query::Construct {
  842|    239|                    template: c.clone(),
  843|    239|                    dataset: d,
  844|    239|                    pattern: build_select(
  845|    239|                        Selection::no_op(),
  846|    239|                        GraphPattern::Bgp { patterns: c },
  847|    239|                        g, h, o, l, v, state
  848|    239|                    )?,
  849|    239|                    base_iri: state.base_iri.clone()
  850|    239|                })
  851|    239|            }
  852|    239|
  853|    239|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|    239|
  855|    239|        rule DescribeQuery() -> Query =
  856|    239|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|    239|                Ok(Query::Describe {
  858|    239|                    dataset: d,
  859|    239|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|    239|                    base_iri: state.base_iri.clone()
  861|    239|                })
  862|    239|            } /
  863|    239|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|    239|                Ok(Query::Describe {
  865|    239|                    dataset: d,
  866|    239|                    pattern: build_select(Selection {
  867|    239|                        option: SelectionOption::Default,
  868|    239|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|    239|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|    239|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|    239|                        }).collect())
  872|    239|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|    239|                    base_iri: state.base_iri.clone()
  874|    239|                })
  875|    239|            }
  876|    239|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|    239|
  878|    239|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|    239|            Ok(Query::Ask {
  880|    239|                dataset: d,
  881|    239|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|    239|                base_iri: state.base_iri.clone()
  883|    239|            })
  884|    239|        }
  885|    239|
  886|    239|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|    239|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|    239|            if d.is_empty() {
  889|    239|                return None;
  890|    239|            }
  891|    239|            let mut default = Vec::new();
  892|    239|            let mut named = Vec::new();
  893|    239|            for (d, n) in d {
  894|    239|                if let Some(d) = d {
  895|    239|                    default.push(d);
  896|    239|                }
  897|    239|                if let Some(n) = n {
  898|    239|                    named.push(n);
  899|    239|                }
  900|    239|            }
  901|    239|            Some(QueryDataset {
  902|    239|                default, named: Some(named)
  903|    239|            })
  904|    239|        }
  905|    239|
  906|    239|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|    239|            (Some(s), None)
  908|    239|        }
  909|    239|
  910|    239|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|    239|            (None, Some(s))
  912|    239|        }
  913|    239|
  914|    239|        rule SourceSelector() -> NamedNode = iri()
  915|    239|
  916|    239|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|    239|            p
  918|    239|        }
  919|    239|
  920|    239|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|    239|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|    239|            let clauses = c.into_iter().map(|(e, vo)| {
  923|    239|                if let Expression::Variable(v) = e {
  924|    239|                    v
  925|    239|                } else {
  926|    239|                    let v = vo.unwrap_or_else(variable);
  927|    239|                    projections.push((e, v.clone()));
  928|    239|                    v
  929|    239|                }
  930|    239|            }).collect();
  931|    239|            (clauses, projections)
  932|    239|        }
  933|    239|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|    239|
  935|    239|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|    239|            e:BuiltInCall() { (e, None) } /
  937|    239|            e:FunctionCall() { (e, None) } /
  938|    239|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|    239|            e:Var() { (e.into(), None) }
  940|    239|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|    239|
  942|    239|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|    239|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|    239|        }
  945|    239|
  946|    239|        rule HavingCondition() -> Expression = Constraint()
  947|    239|
  948|    239|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|    239|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|    239|
  951|    239|        rule OrderCondition() -> OrderExpression =
  952|    239|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|    239|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|    239|            e: Constraint() { OrderExpression::Asc(e) } /
  955|    239|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|    239|
  957|    239|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|    239|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|    239|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|    239|
  961|    239|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|    239|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|    239|        }
  964|    239|
  965|    239|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|    239|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|    239|        }
  968|    239|
  969|    239|        rule ValuesClause() -> Option<GraphPattern> =
  970|    239|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|    239|            { None }
  972|    239|
  973|    239|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|    239|
  975|    239|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|    239|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|    239|
  978|    239|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|    239|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|    239|        }
  981|    239|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|    239|
  983|    239|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|    239|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|    239|        }
  986|    239|
  987|    239|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|    239|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|    239|        }
  990|    239|
  991|    239|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|    239|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|    239|        }
  994|    239|
  995|    239|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|    239|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|    239|            if from == to {
  998|    239|                Vec::new() // identity case
  999|    239|            } else {
 1000|    239|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|    239|                vec![copy_graph(from, to)]
 1002|    239|            }
 1003|    239|        }
 1004|    239|
 1005|    239|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|    239|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|    239|            if from == to {
 1008|    239|                Vec::new() // identity case
 1009|    239|            } else {
 1010|    239|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|    239|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|    239|            }
 1013|    239|        }
 1014|    239|
 1015|    239|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|    239|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|    239|            if from == to {
 1018|    239|                Vec::new() // identity case
 1019|    239|            } else {
 1020|    239|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|    239|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|    239|            }
 1023|    239|        }
 1024|    239|
 1025|    239|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|    239|            vec![GraphUpdateOperation::InsertData { data }]
 1027|    239|        }
 1028|    239|
 1029|    239|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|    239|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|    239|        }
 1032|    239|
 1033|    239|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|    239|            let pattern = d.iter().map(|q| {
 1035|    239|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|    239|                match &q.graph_name {
 1037|    239|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|    239|                    GraphNamePattern::DefaultGraph => bgp,
 1039|    239|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|    239|                }
 1041|    239|            }).reduce(new_join).unwrap_or_default();
 1042|    239|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|    239|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|    239|                delete,
 1045|    239|                insert: Vec::new(),
 1046|    239|                using: None,
 1047|    239|                pattern: Box::new(pattern)
 1048|    239|            }])
 1049|    239|        }
 1050|    239|
 1051|    239|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|    239|            let (delete, insert) = c;
 1053|    239|            let mut delete = delete.unwrap_or_default();
 1054|    239|            let mut insert = insert.unwrap_or_default();
 1055|    239|            #[allow(clippy::shadow_same)]
 1056|    239|            let mut pattern = pattern;
 1057|    239|
 1058|    239|            let mut using = if u.is_empty() {
 1059|    239|                None
 1060|    239|            } else {
 1061|    239|                let mut default = Vec::new();
 1062|    239|                let mut named = Vec::new();
 1063|    239|                for (d, n) in u {
 1064|    239|                    if let Some(d) = d {
 1065|    239|                        default.push(d)
 1066|    239|                    }
 1067|    239|                    if let Some(n) = n {
 1068|    239|                        named.push(n)
 1069|    239|                    }
 1070|    239|                }
 1071|    239|                Some(QueryDataset { default, named: Some(named) })
 1072|    239|            };
 1073|    239|
 1074|    239|            if let Some(with) = with {
 1075|    239|                // We inject WITH everywhere
 1076|    239|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|    239|                    GroundQuadPattern {
 1078|    239|                        subject: q.subject,
 1079|    239|                        predicate: q.predicate,
 1080|    239|                        object: q.object,
 1081|    239|                        graph_name: with.clone().into()
 1082|    239|                    }
 1083|    239|                } else {
 1084|    239|                    q
 1085|    239|                }).collect();
 1086|    239|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|    239|                    QuadPattern {
 1088|    239|                        subject: q.subject,
 1089|    239|                        predicate: q.predicate,
 1090|    239|                        object: q.object,
 1091|    239|                        graph_name: with.clone().into()
 1092|    239|                    }
 1093|    239|                } else {
 1094|    239|                    q
 1095|    239|                }).collect();
 1096|    239|                if using.is_none() {
 1097|    239|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|    239|                }
 1099|    239|            }
 1100|    239|
 1101|    239|            vec![GraphUpdateOperation::DeleteInsert {
 1102|    239|                delete,
 1103|    239|                insert,
 1104|    239|                using,
 1105|    239|                pattern: Box::new(pattern)
 1106|    239|            }]
 1107|    239|        }
 1108|    239|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|    239|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|    239|            (Some(d), i)
 1111|    239|        } / i:InsertClause() {
 1112|    239|            (None, Some(i))
 1113|    239|        }
 1114|    239|        rule Modify_clear() = {
 1115|    239|            state.used_bnodes.clear();
 1116|    239|            state.currently_used_bnodes.clear();
 1117|    239|        }
 1118|    239|
 1119|    239|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|    239|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|    239|        }
 1122|    239|
 1123|    239|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|    239|
 1125|    239|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|    239|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|    239|            (Some(i), None)
 1128|    239|        }
 1129|    239|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|    239|            (None, Some(i))
 1131|    239|        }
 1132|    239|
 1133|    239|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|    239|            GraphName::DefaultGraph
 1135|    239|        } / (i("GRAPH") _)? g:iri() {
 1136|    239|            GraphName::NamedNode(g)
 1137|    239|        }
 1138|    239|
 1139|    239|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|    239|
 1141|    239|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|    239|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|    239|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|    239|            / i("ALL") { GraphTarget::AllGraphs }
 1145|    239|
 1146|    239|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|    239|
 1148|    239|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|    239|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|    239|        }
 1151|    239|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|    239|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|    239|        }
 1154|    239|
 1155|    239|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|    239|            q.into_iter().flatten().collect()
 1157|    239|        }
 1158|    239|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|    239|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|    239|        } //TODO: return iter?
 1161|    239|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|    239|
 1163|    239|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|    239|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|    239|        }
 1166|    239|
 1167|    239|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|    239|            ts.into_iter().flatten().collect()
 1169|    239|        }
 1170|    239|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|    239|
 1172|    239|        rule GroupGraphPattern() -> GraphPattern =
 1173|    239|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|    239|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|    239|        rule GroupGraphPattern_clear() = {
 1176|    239|             // We deal with blank nodes aliases rule
 1177|    239|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|    239|            state.currently_used_bnodes.clear();
 1179|    239|        }
 1180|    239|
 1181|    239|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|    239|            let mut filter: Option<Expression> = None;
 1183|    239|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|    239|            for e in b.into_iter().flatten() {
 1185|    239|                match e {
 1186|    239|                    PartialGraphPattern::Optional(p, f) => {
 1187|    239|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|    239|                    }
 1189|    239|                    #[cfg(feature = "sep-0006")]
 1190|    239|                    PartialGraphPattern::Lateral(p) => {
 1191|    239|                        let mut defined_variables = HashSet::default();
 1192|    239|                        add_defined_variables(&p, &mut defined_variables);
 1193|    239|                        let mut contains = false;
 1194|    239|                        g.on_in_scope_variable(|v| {
 1195|    239|                            if defined_variables.contains(v) {
 1196|    239|                                contains = true;
 1197|    239|                            }
 1198|    239|                        });
 1199|    239|                        if contains {
 1200|    239|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|    239|                        }
 1202|    239|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|    239|                    }
 1204|    239|                    PartialGraphPattern::Minus(p) => {
 1205|    239|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|    239|                    }
 1207|    239|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|    239|                        let mut contains = false;
 1209|    239|                        g.on_in_scope_variable(|v| {
 1210|    239|                            if *v == variable {
 1211|    239|                                contains = true;
 1212|    239|                            }
 1213|    239|                        });
 1214|    239|                        if contains {
 1215|    239|                            return Err("BIND is overriding an existing variable")
 1216|    239|                        }
 1217|    239|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|    239|                    }
 1219|    239|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|    239|                        Expression::And(Box::new(f), Box::new(expr))
 1221|    239|                    } else {
 1222|    239|                        expr
 1223|    239|                    }),
 1224|    239|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|    239|                }
 1226|    239|            }
 1227|    239|
 1228|    239|            Ok(if let Some(expr) = filter {
 1229|    239|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|    239|            } else {
 1231|    239|                g
 1232|    239|            })
 1233|    239|        }
 1234|    239|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|    239|            let mut result = vec![a];
 1236|    239|            if let Some(v) = b {
 1237|    239|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|    239|            }
 1239|    239|            result
 1240|    239|        }
 1241|    239|
 1242|    239|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|    239|            hs.into_iter().flatten().collect()
 1244|    239|        }
 1245|    239|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|    239|
 1247|    239|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|    239|
 1249|    239|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|    239|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|    239|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|    239|            } else {
 1253|    239|               PartialGraphPattern::Optional(p, None)
 1254|    239|            }
 1255|    239|        }
 1256|    239|
 1257|    239|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|    239|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|    239|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|    239|        }
 1261|    239|
 1262|    239|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|    239|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|    239|        }
 1265|    239|
 1266|    239|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|    239|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|    239|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|    239|
 1270|    239|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|    239|            PartialGraphPattern::Bind(e, v)
 1272|    239|        }
 1273|    239|
 1274|    239|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|    239|
 1276|    239|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|    239|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|    239|        }
 1279|    239|
 1280|    239|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|    239|            (vec![var], d)
 1282|    239|        }
 1283|    239|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|    239|
 1285|    239|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|    239|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|    239|                Ok((vars, vals))
 1288|    239|            } else {
 1289|    239|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|    239|            }
 1291|    239|        }
 1292|    239|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|    239|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|    239|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|    239|
 1296|    239|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|    239|            t:QuotedTripleData() {?
 1298|    239|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|    239|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|    239|            } /
 1301|    239|            i:iri() { Some(i.into()) } /
 1302|    239|            l:RDFLiteral() { Some(l.into()) } /
 1303|    239|            l:NumericLiteral() { Some(l.into()) } /
 1304|    239|            l:BooleanLiteral() { Some(l.into()) } /
 1305|    239|            i("UNDEF") { None }
 1306|    239|
 1307|    239|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|    239|            PartialGraphPattern::Minus(p)
 1309|    239|        }
 1310|    239|
 1311|    239|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|    239|            not_empty_fold(p.into_iter(), |a, b| {
 1313|    239|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|    239|            }).map(PartialGraphPattern::Other)
 1315|    239|        }
 1316|    239|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|    239|
 1318|    239|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|    239|            PartialGraphPattern::Filter(c)
 1320|    239|        }
 1321|    239|
 1322|    239|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|    239|
 1324|    239|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|    239|            Expression::FunctionCall(Function::Custom(f), a)
 1326|    239|        }
 1327|    239|
 1328|    239|        rule ArgList() -> Vec<Expression> =
 1329|    239|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|    239|            NIL() { Vec::new() }
 1331|    239|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|    239|
 1333|    239|        rule ExpressionList() -> Vec<Expression> =
 1334|    239|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|    239|            NIL() { Vec::new() }
 1336|    239|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|    239|
 1338|    239|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|    239|
 1340|    239|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|    239|            p.into_iter().flatten().collect()
 1342|    239|        }
 1343|    239|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|    239|
 1345|    239|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|    239|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|    239|                let mut patterns = po.patterns;
 1348|    239|                for (p, os) in po.focus {
 1349|    239|                    for o in os {
 1350|    239|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|    239|                    }
 1352|    239|                }
 1353|    239|                Ok(patterns)
 1354|    239|            } /
 1355|    239|            s:TriplesNode() _ po:PropertyList() {?
 1356|    239|                let mut patterns = s.patterns;
 1357|    239|                patterns.extend(po.patterns);
 1358|    239|                for (p, os) in po.focus {
 1359|    239|                    for o in os {
 1360|    239|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|    239|                    }
 1362|    239|                }
 1363|    239|                Ok(patterns)
 1364|    239|            }
 1365|    239|
 1366|    239|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|    239|            PropertyListNotEmpty() /
 1368|    239|            { FocusedTriplePattern::default() }
 1369|    239|
 1370|    239|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|    239|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|    239|                a.focus.push(b.focus);
 1373|    239|                a.patterns.extend(b.patterns);
 1374|    239|                a
 1375|    239|            })
 1376|    239|        }
 1377|    239|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|    239|            FocusedTriplePattern {
 1379|    239|                focus: (p, o.focus),
 1380|    239|                patterns: o.patterns
 1381|    239|            }
 1382|    239|        }
 1383|    239|
 1384|    239|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|    239|
 1386|    239|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|    239|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|    239|                a.focus.push(b.focus);
 1389|    239|                a.patterns.extend_from_slice(&b.patterns);
 1390|    239|                a
 1391|    239|            })
 1392|    239|        }
 1393|    239|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|    239|
 1395|    239|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|    239|            if let Some(a) = a {
 1397|    239|                let mut patterns = g.patterns;
 1398|    239|                patterns.extend(a.patterns);
 1399|    239|                FocusedTriplePattern {
 1400|    239|                    focus: AnnotatedTerm {
 1401|    239|                        term: g.focus,
 1402|    239|                        annotations: a.focus
 1403|    239|                    },
 1404|    239|                    patterns
 1405|    239|                }
 1406|    239|            } else {
 1407|    239|                FocusedTriplePattern {
 1408|    239|                    focus: AnnotatedTerm {
 1409|    239|                        term: g.focus,
 1410|    239|                        annotations: Vec::new()
 1411|    239|                    },
 1412|    239|                    patterns: g.patterns
 1413|    239|                }
 1414|    239|            }
 1415|    239|        }
 1416|    239|
 1417|    239|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|    239|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|    239|                let mut patterns = po.patterns;
 1420|    239|                for (p, os) in po.focus {
 1421|    239|                    for o in os {
 1422|    239|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|    239|                    }
 1424|    239|                }
 1425|    239|                Ok(patterns)
 1426|    239|            } /
 1427|    239|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|    239|                let mut patterns = s.patterns;
 1429|    239|                patterns.extend(po.patterns);
 1430|    239|                for (p, os) in po.focus {
 1431|    239|                    for o in os {
 1432|    239|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|    239|                    }
 1434|    239|                }
 1435|    239|                Ok(patterns)
 1436|    239|            }
 1437|    239|
 1438|    239|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|    239|            PropertyListPathNotEmpty() /
 1440|    239|            { FocusedTripleOrPathPattern::default() }
 1441|    239|
 1442|    239|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|    239|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|    239|                    focus: vec![(hp, ho.focus)],
 1445|    239|                    patterns: ho.patterns
 1446|    239|                }, |mut a, b| {
 1447|    239|                    a.focus.push(b.focus);
 1448|    239|                    a.patterns.extend(b.patterns);
 1449|    239|                    a
 1450|    239|                })
 1451|    239|        }
 1452|    239|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|    239|            c
 1454|    239|        }
 1455|    239|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|    239|            FocusedTripleOrPathPattern {
 1457|    239|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|    239|                patterns: o.patterns
 1459|    239|            }
 1460|    239|        }
 1461|    239|
 1462|    239|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|    239|            p.into()
 1464|    239|        }
 1465|    239|
 1466|    239|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|    239|            v.into()
 1468|    239|        }
 1469|    239|
 1470|    239|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|    239|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|    239|                a.focus.push(b.focus);
 1473|    239|                a.patterns.extend(b.patterns);
 1474|    239|                a
 1475|    239|            })
 1476|    239|        }
 1477|    239|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|    239|
 1479|    239|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|    239|             if let Some(a) = a {
 1481|    239|                let mut patterns = g.patterns;
 1482|    239|                patterns.extend(a.patterns);
 1483|    239|                FocusedTripleOrPathPattern {
 1484|    239|                    focus: AnnotatedTermPath {
 1485|    239|                        term: g.focus,
 1486|    239|                        annotations: a.focus
 1487|    239|                    },
 1488|    239|                    patterns
 1489|    239|                }
 1490|    239|            } else {
 1491|    239|                FocusedTripleOrPathPattern {
 1492|    239|                    focus: AnnotatedTermPath {
 1493|    239|                        term: g.focus,
 1494|    239|                        annotations: Vec::new()
 1495|    239|                    },
 1496|    239|                    patterns: g.patterns
 1497|    239|                }
 1498|    239|            }
 1499|    239|        }
 1500|    239|
 1501|    239|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|    239|
 1503|    239|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|    239|            not_empty_fold(p.into_iter(), |a, b| {
 1505|    239|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|    239|            })
 1507|    239|        }
 1508|    239|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|    239|
 1510|    239|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|    239|            not_empty_fold(p.into_iter(), |a, b| {
 1512|    239|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|    239|            })
 1514|    239|        }
 1515|    239|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|    239|
 1517|    239|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|    239|            match o {
 1519|    239|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|    239|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|    239|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|    239|                Some(_) => unreachable!(),
 1523|    239|                None => p
 1524|    239|            }
 1525|    239|        }
 1526|    239|        rule PathElt_op() -> char =
 1527|    239|            "*" { '*' } /
 1528|    239|            "+" { '+' } /
 1529|    239|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|    239|
 1531|    239|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|    239|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|    239|            PathElt()
 1534|    239|
 1535|    239|        rule PathPrimary() -> PropertyPathExpression =
 1536|    239|            v:iri() { v.into() } /
 1537|    239|            "a" { rdf::TYPE.into_owned().into() } /
 1538|    239|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|    239|            "(" _ p:Path() _ ")" { p }
 1540|    239|
 1541|    239|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|    239|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|    239|                let mut direct = Vec::new();
 1544|    239|                let mut inverse = Vec::new();
 1545|    239|                for e in p {
 1546|    239|                    match e {
 1547|    239|                        Either::Left(a) => direct.push(a),
 1548|    239|                        Either::Right(b) => inverse.push(b)
 1549|    239|                    }
 1550|    239|                }
 1551|    239|                if inverse.is_empty() {
 1552|    239|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|    239|                } else if direct.is_empty() {
 1554|    239|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|    239|                } else {
 1556|    239|                    PropertyPathExpression::Alternative(
 1557|    239|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|    239|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|    239|                    )
 1560|    239|                }
 1561|    239|            } /
 1562|    239|            p:PathOneInPropertySet() {
 1563|    239|                match p {
 1564|    239|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|    239|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|    239|                }
 1567|    239|            }
 1568|    239|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|    239|
 1570|    239|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|    239|            "^" _ v:iri() { Either::Right(v) } /
 1572|    239|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|    239|            v:iri() { Either::Left(v) } /
 1574|    239|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|    239|
 1576|    239|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|    239|
 1578|    239|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|    239|            let mut patterns = po.patterns;
 1580|    239|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|    239|            for (p, os) in po.focus {
 1582|    239|                for o in os {
 1583|    239|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|    239|                }
 1585|    239|            }
 1586|    239|            Ok(FocusedTriplePattern {
 1587|    239|                focus: bnode,
 1588|    239|                patterns
 1589|    239|            })
 1590|    239|        }
 1591|    239|
 1592|    239|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|    239|
 1594|    239|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|    239|            let mut patterns = po.patterns;
 1596|    239|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|    239|            for (p, os) in po.focus {
 1598|    239|                for o in os {
 1599|    239|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|    239|                }
 1601|    239|            }
 1602|    239|            Ok(FocusedTripleOrPathPattern {
 1603|    239|                focus: bnode,
 1604|    239|                patterns
 1605|    239|            })
 1606|    239|        }
 1607|    239|
 1608|    239|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|    239|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|    239|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|    239|            for objWithPatterns in o.into_iter().rev() {
 1612|    239|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|    239|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|    239|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|    239|                current_list_node = new_blank_node;
 1616|    239|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|    239|            }
 1618|    239|            FocusedTriplePattern {
 1619|    239|                focus: current_list_node,
 1620|    239|                patterns
 1621|    239|            }
 1622|    239|        }
 1623|    239|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|    239|
 1625|    239|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|    239|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|    239|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|    239|            for objWithPatterns in o.into_iter().rev() {
 1629|    239|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|    239|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|    239|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|    239|                current_list_node = new_blank_node;
 1633|    239|                patterns.extend(objWithPatterns.patterns);
 1634|    239|            }
 1635|    239|            FocusedTripleOrPathPattern {
 1636|    239|                focus: current_list_node,
 1637|    239|                patterns
 1638|    239|            }
 1639|    239|        }
 1640|    239|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|    239|
 1642|    239|
 1643|    239|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|    239|
 1645|    239|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|    239|
 1647|    239|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|    239|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|    239|            TriplesNode()
 1650|    239|
 1651|    239|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|    239|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|    239|            TriplesNodePath()
 1654|    239|
 1655|    239|        rule VarOrTerm() -> TermPattern =
 1656|    239|            v:Var() { v.into() } /
 1657|    239|            t:QuotedTriple() {?
 1658|    239|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|    239|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|    239|            } /
 1661|    239|            t:GraphTerm() { t.into() }
 1662|    239|
 1663|    239|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|    239|            Ok(TriplePattern {
 1665|    239|                subject: s,
 1666|    239|                predicate: p,
 1667|    239|                object: o
 1668|    239|            })
 1669|    239|        }
 1670|    239|
 1671|    239|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|    239|            Ok(GroundTriple {
 1673|    239|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|    239|                predicate: p,
 1675|    239|                object: o
 1676|    239|            })
 1677|    239|        }
 1678|    239|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|    239|
 1680|    239|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|    239|            l:RDFLiteral() { l.into() } /
 1682|    239|            l:NumericLiteral() { l.into() } /
 1683|    239|            l:BooleanLiteral() { l.into() } /
 1684|    239|            t:QuotedTripleData() {?
 1685|    239|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|    239|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|    239|            }
 1688|    239|
 1689|    239|        rule VarOrIri() -> NamedNodePattern =
 1690|    239|            v:Var() { v.into() } /
 1691|    239|            i:iri() { i.into() }
 1692|    239|
 1693|    239|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|    239|
 1695|    239|        rule GraphTerm() -> Term =
 1696|    239|            i:iri() { i.into() } /
 1697|    239|            l:RDFLiteral() { l.into() } /
 1698|    239|            l:NumericLiteral() { l.into() } /
 1699|    239|            l:BooleanLiteral() { l.into() } /
 1700|    239|            b:BlankNode() { b.into() } /
 1701|    239|            NIL() { rdf::NIL.into_owned().into() }
 1702|    239|
 1703|    239|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|    239|
 1705|    239|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|    239|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|    239|        }
 1708|    239|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|    239|
 1710|    239|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|    239|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|    239|        }
 1713|    239|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|    239|
 1715|    239|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|    239|
 1717|    239|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|    239|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|    239|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|    239|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|    239|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|    239|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|    239|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|    239|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|    239|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|    239|            Some(_) => unreachable!(),
 1727|    239|            None => a
 1728|    239|        } }
 1729|    239|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|    239|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|    239|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|    239|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|    239|
 1734|    239|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|    239|
 1736|    239|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|    239|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|    239|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|    239|            Some(_) => unreachable!(),
 1740|    239|            None => a,
 1741|    239|        } }
 1742|    239|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|    239|            (s, e)
 1744|    239|        }
 1745|    239|
 1746|    239|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|    239|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|    239|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|    239|            Some(_) => unreachable!(),
 1750|    239|            None => a
 1751|    239|        } }
 1752|    239|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|    239|            (s, e)
 1754|    239|        }
 1755|    239|
 1756|    239|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|    239|            Some("!") => Expression::Not(Box::new(e)),
 1758|    239|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|    239|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|    239|            Some(_) => unreachable!(),
 1761|    239|            None => e,
 1762|    239|        } }
 1763|    239|
 1764|    239|        rule PrimaryExpression() -> Expression =
 1765|    239|            BrackettedExpression()  /
 1766|    239|            ExprQuotedTriple() /
 1767|    239|            iriOrFunction() /
 1768|    239|            v:Var() { v.into() } /
 1769|    239|            l:RDFLiteral() { l.into() } /
 1770|    239|            l:NumericLiteral() { l.into() } /
 1771|    239|            l:BooleanLiteral() { l.into() } /
 1772|    239|            BuiltInCall()
 1773|    239|
 1774|    239|        rule ExprVarOrTerm() -> Expression =
 1775|    239|            ExprQuotedTriple() /
 1776|    239|            i:iri() { i.into() } /
 1777|    239|            l:RDFLiteral() { l.into() } /
 1778|    239|            l:NumericLiteral() { l.into() } /
 1779|    239|            l:BooleanLiteral() { l.into() } /
 1780|    239|            v:Var() { v.into() }
 1781|    239|
 1782|    239|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|    239|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|    239|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|    239|        }
 1786|    239|
 1787|    239|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|    239|
 1789|    239|        rule BuiltInCall() -> Expression =
 1790|    239|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|    239|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|    239|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|    239|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|    239|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|    239|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|    239|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|    239|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|    239|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|    239|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|    239|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|    239|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|    239|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|    239|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|    239|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|    239|            SubstringExpression() /
 1806|    239|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|    239|            StrReplaceExpression() /
 1808|    239|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|    239|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|    239|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|    239|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|    239|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|    239|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|    239|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|    239|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|    239|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|    239|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|    239|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|    239|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|    239|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|    239|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|    239|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|    239|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|    239|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|    239|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|    239|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|    239|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|    239|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|    239|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|    239|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|    239|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|    239|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|    239|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|    239|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|    239|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|    239|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|    239|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|    239|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|    239|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|    239|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|    239|            RegexExpression() /
 1842|    239|            ExistsFunc() /
 1843|    239|            NotExistsFunc() /
 1844|    239|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|    239|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|    239|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|    239|            } /
 1848|    239|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|    239|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|    239|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|    239|            } /
 1852|    239|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|    239|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|    239|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|    239|            } /
 1856|    239|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|    239|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|    239|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|    239|            } /
 1860|    239|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|    239|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|    239|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|    239|            } /
 1864|    239|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|    239|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|    239|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|    239|            }
 1868|    239|
 1869|    239|        rule RegexExpression() -> Expression =
 1870|    239|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|    239|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|    239|
 1873|    239|
 1874|    239|        rule SubstringExpression() -> Expression =
 1875|    239|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|    239|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|    239|
 1878|    239|
 1879|    239|        rule StrReplaceExpression() -> Expression =
 1880|    239|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|    239|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|    239|
 1883|    239|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|    239|
 1885|    239|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|    239|
 1887|    239|        rule Aggregate() -> AggregateExpression =
 1888|    239|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|    239|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|    239|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|    239|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|    239|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|    239|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|    239|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|    239|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|    239|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|    239|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|    239|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|    239|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|    239|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|    239|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|    239|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|    239|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|    239|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|    239|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|    239|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|    239|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|    239|
 1909|    239|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|    239|            match a {
 1911|    239|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|    239|                None => i.into()
 1913|    239|            }
 1914|    239|        }
 1915|    239|
 1916|    239|        rule RDFLiteral() -> Literal =
 1917|    239|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|    239|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|    239|            value:String() { Literal::new_simple_literal(value) }
 1920|    239|
 1921|    239|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|    239|
 1923|    239|        rule NumericLiteralUnsigned() -> Literal =
 1924|    239|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|    239|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|    239|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|    239|
 1928|    239|        rule NumericLiteralPositive() -> Literal =
 1929|    239|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|    239|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|    239|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|    239|
 1933|    239|
 1934|    239|        rule NumericLiteralNegative() -> Literal =
 1935|    239|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|    239|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|    239|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|    239|
 1939|    239|        rule BooleanLiteral() -> Literal =
 1940|    239|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|    239|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|    239|
 1943|    239|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|    239|
 1945|    239|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|    239|            NamedNode::from(i)
 1947|    239|        }
 1948|    239|
 1949|    239|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|    239|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|    239|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|    239|            } else {
 1953|    239|                Err("Prefix not found")
 1954|    239|            } }
 1955|    239|
 1956|    239|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|    239|            let node = BlankNode::new_unchecked(id);
 1958|    239|            if state.used_bnodes.contains(&node) {
 1959|    239|                Err("Already used blank node id")
 1960|    239|            } else {
 1961|    239|                state.currently_used_bnodes.insert(node.clone());
 1962|    239|                Ok(node)
 1963|    239|            }
 1964|    239|        } / ANON() { BlankNode::default() }
 1965|    239|
 1966|    239|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|    239|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|    239|        }
 1969|    239|
 1970|    239|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|    239|            ns
 1972|    239|        }
 1973|    239|
 1974|    239|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|    239|            if let Some(base) = state.namespaces.get(ns) {
 1976|    239|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|    239|                iri.push_str(base);
 1978|    239|                for chunk in local.split('\\') { // We remove \
 1979|    239|                    iri.push_str(chunk);
 1980|    239|                }
 1981|    239|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|    239|            } else {
 1983|    239|                Err("Prefix not found")
 1984|    239|            }
 1985|    239|        }
 1986|    239|
 1987|    239|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|    239|            b
 1989|    239|        }
 1990|    239|
 1991|    239|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|    239|
 1993|    239|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|    239|
 1995|    239|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|    239|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|    239|        }
 1998|    239|
 1999|    239|        rule INTEGER() = ['0'..='9']+
 2000|    239|
 2001|    239|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|    239|
 2003|    239|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|    239|
 2005|    239|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|    239|
 2007|    239|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|    239|
 2009|    239|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|    239|
 2011|    239|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|    239|
 2013|    239|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|    239|
 2015|    239|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|    239|
 2017|    239|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|    239|
 2019|    239|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|    239|             unescape_string(l)
 2021|    239|        }
 2022|    239|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|    239|
 2024|    239|
 2025|    239|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|    239|             unescape_string(l)
 2027|    239|        }
 2028|    239|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|    239|
 2030|    239|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|    239|             unescape_string(l)
 2032|    239|        }
 2033|    239|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|    239|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|    239|
 2036|    239|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|    239|             unescape_string(l)
 2038|    239|        }
 2039|    239|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|    239|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|    239|
 2042|    239|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|    239|
 2044|    239|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|    239|
 2046|    239|        rule NIL() = "(" WS()* ")"
 2047|    239|
 2048|    239|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|    239|
 2050|    239|        rule ANON() = "[" WS()* "]"
 2051|    239|
 2052|    239|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|    239|
 2054|    239|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|    239|
 2056|    239|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|    239|
 2058|    239|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|    239|
 2060|    239|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|    239|
 2062|    239|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|    239|
 2064|    239|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|    239|
 2066|    239|        rule PERCENT() = ['%'] HEX() HEX()
 2067|    239|
 2068|    239|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|    239|
 2070|    239|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|    239|
 2072|    239|        //space
 2073|    239|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|    239|
 2075|    239|        //comment
 2076|    239|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|    239|
 2078|    239|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|    239|            if input.eq_ignore_ascii_case(literal) {
 2080|    239|                Ok(())
 2081|    239|            } else {
 2082|    239|                Err(literal)
 2083|    239|            }
 2084|    239|        }
 2085|    239|    }
 2086|    239|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_options_0B7_:
  822|    869|            i("REDUCED") { SelectionOption::Reduced } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls4_0B7_:
 1796|      6|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_Modify_with0B7_:
 1108|  2.13k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Update0B7_:
  973|  2.93k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsH_0B7_:
 1837|      7|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValues3_0B7_:
 1305|  1.53k|            i("UNDEF") { None }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_InlineDataFull_var0B7_:
 1292|  3.42k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PropertyListNotEmpty0B7_:
 1370|  17.0k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  17.0k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|  17.0k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_AdditiveExpression0B7_:
 1736|  6.33k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  2.69k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  2.36k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|      0|            Some(_) => unreachable!(),
 1740|  3.63k|            None => a,
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_MultiplicativeExpression0B7_:
 1746|  11.4k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  5.15k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  4.47k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|      0|            Some(_) => unreachable!(),
 1750|  6.33k|            None => a
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroundQuadData0B7_:
  778|     75|parser! {
  779|     75|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|     75|    grammar parser(state: &mut ParserState) for str {
  781|     75|        pub rule QueryUnit() -> Query = Query()
  782|     75|
  783|     75|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|     75|            q
  785|     75|        }
  786|     75|
  787|     75|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|     75|
  789|     75|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|     75|
  791|     75|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|     75|            state.base_iri = Some(i)
  793|     75|        }
  794|     75|
  795|     75|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|     75|            state.namespaces.insert(ns.into(), i.into_inner());
  797|     75|        }
  798|     75|
  799|     75|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|     75|            Ok(Query::Select {
  801|     75|                dataset: d,
  802|     75|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|     75|                base_iri: state.base_iri.clone()
  804|     75|            })
  805|     75|        }
  806|     75|
  807|     75|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|     75|            build_select(s, w, g, h, o, l, v, state)
  809|     75|        }
  810|     75|
  811|     75|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|     75|            Selection {
  813|     75|                option: o,
  814|     75|                variables: v
  815|     75|            }
  816|     75|        }
  817|     75|        rule Selection_init() = {
  818|     75|            state.aggregates.push(Vec::new())
  819|     75|        }
  820|     75|        rule SelectClause_option() -> SelectionOption =
  821|     75|            i("DISTINCT") { SelectionOption::Distinct } /
  822|     75|            i("REDUCED") { SelectionOption::Reduced } /
  823|     75|            { SelectionOption::Default }
  824|     75|        rule SelectClause_variables() -> SelectionVariables =
  825|     75|            "*" { SelectionVariables::Star } /
  826|     75|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|     75|        rule SelectClause_member() -> SelectionMember =
  828|     75|            v:Var() _ { SelectionMember::Variable(v) } /
  829|     75|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|     75|
  831|     75|        rule ConstructQuery() -> Query =
  832|     75|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|     75|                Ok(Query::Construct {
  834|     75|                    template: c,
  835|     75|                    dataset: d,
  836|     75|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|     75|                    base_iri: state.base_iri.clone()
  838|     75|                })
  839|     75|            } /
  840|     75|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|     75|                Ok(Query::Construct {
  842|     75|                    template: c.clone(),
  843|     75|                    dataset: d,
  844|     75|                    pattern: build_select(
  845|     75|                        Selection::no_op(),
  846|     75|                        GraphPattern::Bgp { patterns: c },
  847|     75|                        g, h, o, l, v, state
  848|     75|                    )?,
  849|     75|                    base_iri: state.base_iri.clone()
  850|     75|                })
  851|     75|            }
  852|     75|
  853|     75|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|     75|
  855|     75|        rule DescribeQuery() -> Query =
  856|     75|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|     75|                Ok(Query::Describe {
  858|     75|                    dataset: d,
  859|     75|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|     75|                    base_iri: state.base_iri.clone()
  861|     75|                })
  862|     75|            } /
  863|     75|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|     75|                Ok(Query::Describe {
  865|     75|                    dataset: d,
  866|     75|                    pattern: build_select(Selection {
  867|     75|                        option: SelectionOption::Default,
  868|     75|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|     75|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|     75|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|     75|                        }).collect())
  872|     75|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|     75|                    base_iri: state.base_iri.clone()
  874|     75|                })
  875|     75|            }
  876|     75|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|     75|
  878|     75|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|     75|            Ok(Query::Ask {
  880|     75|                dataset: d,
  881|     75|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|     75|                base_iri: state.base_iri.clone()
  883|     75|            })
  884|     75|        }
  885|     75|
  886|     75|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|     75|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|     75|            if d.is_empty() {
  889|     75|                return None;
  890|     75|            }
  891|     75|            let mut default = Vec::new();
  892|     75|            let mut named = Vec::new();
  893|     75|            for (d, n) in d {
  894|     75|                if let Some(d) = d {
  895|     75|                    default.push(d);
  896|     75|                }
  897|     75|                if let Some(n) = n {
  898|     75|                    named.push(n);
  899|     75|                }
  900|     75|            }
  901|     75|            Some(QueryDataset {
  902|     75|                default, named: Some(named)
  903|     75|            })
  904|     75|        }
  905|     75|
  906|     75|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|     75|            (Some(s), None)
  908|     75|        }
  909|     75|
  910|     75|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|     75|            (None, Some(s))
  912|     75|        }
  913|     75|
  914|     75|        rule SourceSelector() -> NamedNode = iri()
  915|     75|
  916|     75|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|     75|            p
  918|     75|        }
  919|     75|
  920|     75|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|     75|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|     75|            let clauses = c.into_iter().map(|(e, vo)| {
  923|     75|                if let Expression::Variable(v) = e {
  924|     75|                    v
  925|     75|                } else {
  926|     75|                    let v = vo.unwrap_or_else(variable);
  927|     75|                    projections.push((e, v.clone()));
  928|     75|                    v
  929|     75|                }
  930|     75|            }).collect();
  931|     75|            (clauses, projections)
  932|     75|        }
  933|     75|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|     75|
  935|     75|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|     75|            e:BuiltInCall() { (e, None) } /
  937|     75|            e:FunctionCall() { (e, None) } /
  938|     75|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|     75|            e:Var() { (e.into(), None) }
  940|     75|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|     75|
  942|     75|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|     75|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|     75|        }
  945|     75|
  946|     75|        rule HavingCondition() -> Expression = Constraint()
  947|     75|
  948|     75|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|     75|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|     75|
  951|     75|        rule OrderCondition() -> OrderExpression =
  952|     75|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|     75|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|     75|            e: Constraint() { OrderExpression::Asc(e) } /
  955|     75|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|     75|
  957|     75|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|     75|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|     75|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|     75|
  961|     75|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|     75|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|     75|        }
  964|     75|
  965|     75|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|     75|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|     75|        }
  968|     75|
  969|     75|        rule ValuesClause() -> Option<GraphPattern> =
  970|     75|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|     75|            { None }
  972|     75|
  973|     75|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|     75|
  975|     75|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|     75|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|     75|
  978|     75|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|     75|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|     75|        }
  981|     75|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|     75|
  983|     75|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|     75|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|     75|        }
  986|     75|
  987|     75|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|     75|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|     75|        }
  990|     75|
  991|     75|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|     75|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|     75|        }
  994|     75|
  995|     75|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|     75|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|     75|            if from == to {
  998|     75|                Vec::new() // identity case
  999|     75|            } else {
 1000|     75|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|     75|                vec![copy_graph(from, to)]
 1002|     75|            }
 1003|     75|        }
 1004|     75|
 1005|     75|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|     75|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|     75|            if from == to {
 1008|     75|                Vec::new() // identity case
 1009|     75|            } else {
 1010|     75|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|     75|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|     75|            }
 1013|     75|        }
 1014|     75|
 1015|     75|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|     75|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|     75|            if from == to {
 1018|     75|                Vec::new() // identity case
 1019|     75|            } else {
 1020|     75|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|     75|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|     75|            }
 1023|     75|        }
 1024|     75|
 1025|     75|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|     75|            vec![GraphUpdateOperation::InsertData { data }]
 1027|     75|        }
 1028|     75|
 1029|     75|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|     75|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|     75|        }
 1032|     75|
 1033|     75|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|     75|            let pattern = d.iter().map(|q| {
 1035|     75|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|     75|                match &q.graph_name {
 1037|     75|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|     75|                    GraphNamePattern::DefaultGraph => bgp,
 1039|     75|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|     75|                }
 1041|     75|            }).reduce(new_join).unwrap_or_default();
 1042|     75|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|     75|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|     75|                delete,
 1045|     75|                insert: Vec::new(),
 1046|     75|                using: None,
 1047|     75|                pattern: Box::new(pattern)
 1048|     75|            }])
 1049|     75|        }
 1050|     75|
 1051|     75|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|     75|            let (delete, insert) = c;
 1053|     75|            let mut delete = delete.unwrap_or_default();
 1054|     75|            let mut insert = insert.unwrap_or_default();
 1055|     75|            #[allow(clippy::shadow_same)]
 1056|     75|            let mut pattern = pattern;
 1057|     75|
 1058|     75|            let mut using = if u.is_empty() {
 1059|     75|                None
 1060|     75|            } else {
 1061|     75|                let mut default = Vec::new();
 1062|     75|                let mut named = Vec::new();
 1063|     75|                for (d, n) in u {
 1064|     75|                    if let Some(d) = d {
 1065|     75|                        default.push(d)
 1066|     75|                    }
 1067|     75|                    if let Some(n) = n {
 1068|     75|                        named.push(n)
 1069|     75|                    }
 1070|     75|                }
 1071|     75|                Some(QueryDataset { default, named: Some(named) })
 1072|     75|            };
 1073|     75|
 1074|     75|            if let Some(with) = with {
 1075|     75|                // We inject WITH everywhere
 1076|     75|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|     75|                    GroundQuadPattern {
 1078|     75|                        subject: q.subject,
 1079|     75|                        predicate: q.predicate,
 1080|     75|                        object: q.object,
 1081|     75|                        graph_name: with.clone().into()
 1082|     75|                    }
 1083|     75|                } else {
 1084|     75|                    q
 1085|     75|                }).collect();
 1086|     75|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|     75|                    QuadPattern {
 1088|     75|                        subject: q.subject,
 1089|     75|                        predicate: q.predicate,
 1090|     75|                        object: q.object,
 1091|     75|                        graph_name: with.clone().into()
 1092|     75|                    }
 1093|     75|                } else {
 1094|     75|                    q
 1095|     75|                }).collect();
 1096|     75|                if using.is_none() {
 1097|     75|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|     75|                }
 1099|     75|            }
 1100|     75|
 1101|     75|            vec![GraphUpdateOperation::DeleteInsert {
 1102|     75|                delete,
 1103|     75|                insert,
 1104|     75|                using,
 1105|     75|                pattern: Box::new(pattern)
 1106|     75|            }]
 1107|     75|        }
 1108|     75|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|     75|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|     75|            (Some(d), i)
 1111|     75|        } / i:InsertClause() {
 1112|     75|            (None, Some(i))
 1113|     75|        }
 1114|     75|        rule Modify_clear() = {
 1115|     75|            state.used_bnodes.clear();
 1116|     75|            state.currently_used_bnodes.clear();
 1117|     75|        }
 1118|     75|
 1119|     75|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|     75|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|     75|        }
 1122|     75|
 1123|     75|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|     75|
 1125|     75|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|     75|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|     75|            (Some(i), None)
 1128|     75|        }
 1129|     75|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|     75|            (None, Some(i))
 1131|     75|        }
 1132|     75|
 1133|     75|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|     75|            GraphName::DefaultGraph
 1135|     75|        } / (i("GRAPH") _)? g:iri() {
 1136|     75|            GraphName::NamedNode(g)
 1137|     75|        }
 1138|     75|
 1139|     75|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|     75|
 1141|     75|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|     75|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|     75|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|     75|            / i("ALL") { GraphTarget::AllGraphs }
 1145|     75|
 1146|     75|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|     75|
 1148|     75|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|     75|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|     75|        }
 1151|     75|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|     75|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|     75|        }
 1154|     75|
 1155|     75|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|     75|            q.into_iter().flatten().collect()
 1157|     75|        }
 1158|     75|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|     75|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|     75|        } //TODO: return iter?
 1161|     75|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|     75|
 1163|     75|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|     75|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|     75|        }
 1166|     75|
 1167|     75|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|     75|            ts.into_iter().flatten().collect()
 1169|     75|        }
 1170|     75|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|     75|
 1172|     75|        rule GroupGraphPattern() -> GraphPattern =
 1173|     75|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|     75|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|     75|        rule GroupGraphPattern_clear() = {
 1176|     75|             // We deal with blank nodes aliases rule
 1177|     75|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|     75|            state.currently_used_bnodes.clear();
 1179|     75|        }
 1180|     75|
 1181|     75|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|     75|            let mut filter: Option<Expression> = None;
 1183|     75|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|     75|            for e in b.into_iter().flatten() {
 1185|     75|                match e {
 1186|     75|                    PartialGraphPattern::Optional(p, f) => {
 1187|     75|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|     75|                    }
 1189|     75|                    #[cfg(feature = "sep-0006")]
 1190|     75|                    PartialGraphPattern::Lateral(p) => {
 1191|     75|                        let mut defined_variables = HashSet::default();
 1192|     75|                        add_defined_variables(&p, &mut defined_variables);
 1193|     75|                        let mut contains = false;
 1194|     75|                        g.on_in_scope_variable(|v| {
 1195|     75|                            if defined_variables.contains(v) {
 1196|     75|                                contains = true;
 1197|     75|                            }
 1198|     75|                        });
 1199|     75|                        if contains {
 1200|     75|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|     75|                        }
 1202|     75|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|     75|                    }
 1204|     75|                    PartialGraphPattern::Minus(p) => {
 1205|     75|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|     75|                    }
 1207|     75|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|     75|                        let mut contains = false;
 1209|     75|                        g.on_in_scope_variable(|v| {
 1210|     75|                            if *v == variable {
 1211|     75|                                contains = true;
 1212|     75|                            }
 1213|     75|                        });
 1214|     75|                        if contains {
 1215|     75|                            return Err("BIND is overriding an existing variable")
 1216|     75|                        }
 1217|     75|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|     75|                    }
 1219|     75|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|     75|                        Expression::And(Box::new(f), Box::new(expr))
 1221|     75|                    } else {
 1222|     75|                        expr
 1223|     75|                    }),
 1224|     75|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|     75|                }
 1226|     75|            }
 1227|     75|
 1228|     75|            Ok(if let Some(expr) = filter {
 1229|     75|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|     75|            } else {
 1231|     75|                g
 1232|     75|            })
 1233|     75|        }
 1234|     75|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|     75|            let mut result = vec![a];
 1236|     75|            if let Some(v) = b {
 1237|     75|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|     75|            }
 1239|     75|            result
 1240|     75|        }
 1241|     75|
 1242|     75|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|     75|            hs.into_iter().flatten().collect()
 1244|     75|        }
 1245|     75|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|     75|
 1247|     75|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|     75|
 1249|     75|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|     75|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|     75|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|     75|            } else {
 1253|     75|               PartialGraphPattern::Optional(p, None)
 1254|     75|            }
 1255|     75|        }
 1256|     75|
 1257|     75|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|     75|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|     75|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|     75|        }
 1261|     75|
 1262|     75|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|     75|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|     75|        }
 1265|     75|
 1266|     75|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|     75|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|     75|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|     75|
 1270|     75|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|     75|            PartialGraphPattern::Bind(e, v)
 1272|     75|        }
 1273|     75|
 1274|     75|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|     75|
 1276|     75|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|     75|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|     75|        }
 1279|     75|
 1280|     75|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|     75|            (vec![var], d)
 1282|     75|        }
 1283|     75|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|     75|
 1285|     75|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|     75|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|     75|                Ok((vars, vals))
 1288|     75|            } else {
 1289|     75|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|     75|            }
 1291|     75|        }
 1292|     75|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|     75|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|     75|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|     75|
 1296|     75|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|     75|            t:QuotedTripleData() {?
 1298|     75|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|     75|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|     75|            } /
 1301|     75|            i:iri() { Some(i.into()) } /
 1302|     75|            l:RDFLiteral() { Some(l.into()) } /
 1303|     75|            l:NumericLiteral() { Some(l.into()) } /
 1304|     75|            l:BooleanLiteral() { Some(l.into()) } /
 1305|     75|            i("UNDEF") { None }
 1306|     75|
 1307|     75|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|     75|            PartialGraphPattern::Minus(p)
 1309|     75|        }
 1310|     75|
 1311|     75|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|     75|            not_empty_fold(p.into_iter(), |a, b| {
 1313|     75|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|     75|            }).map(PartialGraphPattern::Other)
 1315|     75|        }
 1316|     75|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|     75|
 1318|     75|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|     75|            PartialGraphPattern::Filter(c)
 1320|     75|        }
 1321|     75|
 1322|     75|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|     75|
 1324|     75|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|     75|            Expression::FunctionCall(Function::Custom(f), a)
 1326|     75|        }
 1327|     75|
 1328|     75|        rule ArgList() -> Vec<Expression> =
 1329|     75|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|     75|            NIL() { Vec::new() }
 1331|     75|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|     75|
 1333|     75|        rule ExpressionList() -> Vec<Expression> =
 1334|     75|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|     75|            NIL() { Vec::new() }
 1336|     75|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|     75|
 1338|     75|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|     75|
 1340|     75|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|     75|            p.into_iter().flatten().collect()
 1342|     75|        }
 1343|     75|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|     75|
 1345|     75|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|     75|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|     75|                let mut patterns = po.patterns;
 1348|     75|                for (p, os) in po.focus {
 1349|     75|                    for o in os {
 1350|     75|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|     75|                    }
 1352|     75|                }
 1353|     75|                Ok(patterns)
 1354|     75|            } /
 1355|     75|            s:TriplesNode() _ po:PropertyList() {?
 1356|     75|                let mut patterns = s.patterns;
 1357|     75|                patterns.extend(po.patterns);
 1358|     75|                for (p, os) in po.focus {
 1359|     75|                    for o in os {
 1360|     75|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|     75|                    }
 1362|     75|                }
 1363|     75|                Ok(patterns)
 1364|     75|            }
 1365|     75|
 1366|     75|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|     75|            PropertyListNotEmpty() /
 1368|     75|            { FocusedTriplePattern::default() }
 1369|     75|
 1370|     75|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|     75|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|     75|                a.focus.push(b.focus);
 1373|     75|                a.patterns.extend(b.patterns);
 1374|     75|                a
 1375|     75|            })
 1376|     75|        }
 1377|     75|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|     75|            FocusedTriplePattern {
 1379|     75|                focus: (p, o.focus),
 1380|     75|                patterns: o.patterns
 1381|     75|            }
 1382|     75|        }
 1383|     75|
 1384|     75|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|     75|
 1386|     75|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|     75|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|     75|                a.focus.push(b.focus);
 1389|     75|                a.patterns.extend_from_slice(&b.patterns);
 1390|     75|                a
 1391|     75|            })
 1392|     75|        }
 1393|     75|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|     75|
 1395|     75|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|     75|            if let Some(a) = a {
 1397|     75|                let mut patterns = g.patterns;
 1398|     75|                patterns.extend(a.patterns);
 1399|     75|                FocusedTriplePattern {
 1400|     75|                    focus: AnnotatedTerm {
 1401|     75|                        term: g.focus,
 1402|     75|                        annotations: a.focus
 1403|     75|                    },
 1404|     75|                    patterns
 1405|     75|                }
 1406|     75|            } else {
 1407|     75|                FocusedTriplePattern {
 1408|     75|                    focus: AnnotatedTerm {
 1409|     75|                        term: g.focus,
 1410|     75|                        annotations: Vec::new()
 1411|     75|                    },
 1412|     75|                    patterns: g.patterns
 1413|     75|                }
 1414|     75|            }
 1415|     75|        }
 1416|     75|
 1417|     75|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|     75|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|     75|                let mut patterns = po.patterns;
 1420|     75|                for (p, os) in po.focus {
 1421|     75|                    for o in os {
 1422|     75|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|     75|                    }
 1424|     75|                }
 1425|     75|                Ok(patterns)
 1426|     75|            } /
 1427|     75|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|     75|                let mut patterns = s.patterns;
 1429|     75|                patterns.extend(po.patterns);
 1430|     75|                for (p, os) in po.focus {
 1431|     75|                    for o in os {
 1432|     75|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|     75|                    }
 1434|     75|                }
 1435|     75|                Ok(patterns)
 1436|     75|            }
 1437|     75|
 1438|     75|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|     75|            PropertyListPathNotEmpty() /
 1440|     75|            { FocusedTripleOrPathPattern::default() }
 1441|     75|
 1442|     75|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|     75|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|     75|                    focus: vec![(hp, ho.focus)],
 1445|     75|                    patterns: ho.patterns
 1446|     75|                }, |mut a, b| {
 1447|     75|                    a.focus.push(b.focus);
 1448|     75|                    a.patterns.extend(b.patterns);
 1449|     75|                    a
 1450|     75|                })
 1451|     75|        }
 1452|     75|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|     75|            c
 1454|     75|        }
 1455|     75|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|     75|            FocusedTripleOrPathPattern {
 1457|     75|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|     75|                patterns: o.patterns
 1459|     75|            }
 1460|     75|        }
 1461|     75|
 1462|     75|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|     75|            p.into()
 1464|     75|        }
 1465|     75|
 1466|     75|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|     75|            v.into()
 1468|     75|        }
 1469|     75|
 1470|     75|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|     75|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|     75|                a.focus.push(b.focus);
 1473|     75|                a.patterns.extend(b.patterns);
 1474|     75|                a
 1475|     75|            })
 1476|     75|        }
 1477|     75|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|     75|
 1479|     75|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|     75|             if let Some(a) = a {
 1481|     75|                let mut patterns = g.patterns;
 1482|     75|                patterns.extend(a.patterns);
 1483|     75|                FocusedTripleOrPathPattern {
 1484|     75|                    focus: AnnotatedTermPath {
 1485|     75|                        term: g.focus,
 1486|     75|                        annotations: a.focus
 1487|     75|                    },
 1488|     75|                    patterns
 1489|     75|                }
 1490|     75|            } else {
 1491|     75|                FocusedTripleOrPathPattern {
 1492|     75|                    focus: AnnotatedTermPath {
 1493|     75|                        term: g.focus,
 1494|     75|                        annotations: Vec::new()
 1495|     75|                    },
 1496|     75|                    patterns: g.patterns
 1497|     75|                }
 1498|     75|            }
 1499|     75|        }
 1500|     75|
 1501|     75|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|     75|
 1503|     75|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|     75|            not_empty_fold(p.into_iter(), |a, b| {
 1505|     75|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|     75|            })
 1507|     75|        }
 1508|     75|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|     75|
 1510|     75|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|     75|            not_empty_fold(p.into_iter(), |a, b| {
 1512|     75|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|     75|            })
 1514|     75|        }
 1515|     75|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|     75|
 1517|     75|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|     75|            match o {
 1519|     75|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|     75|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|     75|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|     75|                Some(_) => unreachable!(),
 1523|     75|                None => p
 1524|     75|            }
 1525|     75|        }
 1526|     75|        rule PathElt_op() -> char =
 1527|     75|            "*" { '*' } /
 1528|     75|            "+" { '+' } /
 1529|     75|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|     75|
 1531|     75|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|     75|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|     75|            PathElt()
 1534|     75|
 1535|     75|        rule PathPrimary() -> PropertyPathExpression =
 1536|     75|            v:iri() { v.into() } /
 1537|     75|            "a" { rdf::TYPE.into_owned().into() } /
 1538|     75|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|     75|            "(" _ p:Path() _ ")" { p }
 1540|     75|
 1541|     75|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|     75|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|     75|                let mut direct = Vec::new();
 1544|     75|                let mut inverse = Vec::new();
 1545|     75|                for e in p {
 1546|     75|                    match e {
 1547|     75|                        Either::Left(a) => direct.push(a),
 1548|     75|                        Either::Right(b) => inverse.push(b)
 1549|     75|                    }
 1550|     75|                }
 1551|     75|                if inverse.is_empty() {
 1552|     75|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|     75|                } else if direct.is_empty() {
 1554|     75|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|     75|                } else {
 1556|     75|                    PropertyPathExpression::Alternative(
 1557|     75|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|     75|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|     75|                    )
 1560|     75|                }
 1561|     75|            } /
 1562|     75|            p:PathOneInPropertySet() {
 1563|     75|                match p {
 1564|     75|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|     75|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|     75|                }
 1567|     75|            }
 1568|     75|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|     75|
 1570|     75|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|     75|            "^" _ v:iri() { Either::Right(v) } /
 1572|     75|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|     75|            v:iri() { Either::Left(v) } /
 1574|     75|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|     75|
 1576|     75|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|     75|
 1578|     75|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|     75|            let mut patterns = po.patterns;
 1580|     75|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|     75|            for (p, os) in po.focus {
 1582|     75|                for o in os {
 1583|     75|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|     75|                }
 1585|     75|            }
 1586|     75|            Ok(FocusedTriplePattern {
 1587|     75|                focus: bnode,
 1588|     75|                patterns
 1589|     75|            })
 1590|     75|        }
 1591|     75|
 1592|     75|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|     75|
 1594|     75|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|     75|            let mut patterns = po.patterns;
 1596|     75|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|     75|            for (p, os) in po.focus {
 1598|     75|                for o in os {
 1599|     75|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|     75|                }
 1601|     75|            }
 1602|     75|            Ok(FocusedTripleOrPathPattern {
 1603|     75|                focus: bnode,
 1604|     75|                patterns
 1605|     75|            })
 1606|     75|        }
 1607|     75|
 1608|     75|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|     75|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|     75|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|     75|            for objWithPatterns in o.into_iter().rev() {
 1612|     75|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|     75|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|     75|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|     75|                current_list_node = new_blank_node;
 1616|     75|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|     75|            }
 1618|     75|            FocusedTriplePattern {
 1619|     75|                focus: current_list_node,
 1620|     75|                patterns
 1621|     75|            }
 1622|     75|        }
 1623|     75|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|     75|
 1625|     75|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|     75|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|     75|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|     75|            for objWithPatterns in o.into_iter().rev() {
 1629|     75|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|     75|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|     75|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|     75|                current_list_node = new_blank_node;
 1633|     75|                patterns.extend(objWithPatterns.patterns);
 1634|     75|            }
 1635|     75|            FocusedTripleOrPathPattern {
 1636|     75|                focus: current_list_node,
 1637|     75|                patterns
 1638|     75|            }
 1639|     75|        }
 1640|     75|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|     75|
 1642|     75|
 1643|     75|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|     75|
 1645|     75|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|     75|
 1647|     75|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|     75|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|     75|            TriplesNode()
 1650|     75|
 1651|     75|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|     75|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|     75|            TriplesNodePath()
 1654|     75|
 1655|     75|        rule VarOrTerm() -> TermPattern =
 1656|     75|            v:Var() { v.into() } /
 1657|     75|            t:QuotedTriple() {?
 1658|     75|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|     75|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|     75|            } /
 1661|     75|            t:GraphTerm() { t.into() }
 1662|     75|
 1663|     75|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|     75|            Ok(TriplePattern {
 1665|     75|                subject: s,
 1666|     75|                predicate: p,
 1667|     75|                object: o
 1668|     75|            })
 1669|     75|        }
 1670|     75|
 1671|     75|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|     75|            Ok(GroundTriple {
 1673|     75|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|     75|                predicate: p,
 1675|     75|                object: o
 1676|     75|            })
 1677|     75|        }
 1678|     75|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|     75|
 1680|     75|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|     75|            l:RDFLiteral() { l.into() } /
 1682|     75|            l:NumericLiteral() { l.into() } /
 1683|     75|            l:BooleanLiteral() { l.into() } /
 1684|     75|            t:QuotedTripleData() {?
 1685|     75|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|     75|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|     75|            }
 1688|     75|
 1689|     75|        rule VarOrIri() -> NamedNodePattern =
 1690|     75|            v:Var() { v.into() } /
 1691|     75|            i:iri() { i.into() }
 1692|     75|
 1693|     75|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|     75|
 1695|     75|        rule GraphTerm() -> Term =
 1696|     75|            i:iri() { i.into() } /
 1697|     75|            l:RDFLiteral() { l.into() } /
 1698|     75|            l:NumericLiteral() { l.into() } /
 1699|     75|            l:BooleanLiteral() { l.into() } /
 1700|     75|            b:BlankNode() { b.into() } /
 1701|     75|            NIL() { rdf::NIL.into_owned().into() }
 1702|     75|
 1703|     75|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|     75|
 1705|     75|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|     75|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|     75|        }
 1708|     75|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|     75|
 1710|     75|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|     75|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|     75|        }
 1713|     75|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|     75|
 1715|     75|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|     75|
 1717|     75|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|     75|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|     75|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|     75|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|     75|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|     75|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|     75|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|     75|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|     75|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|     75|            Some(_) => unreachable!(),
 1727|     75|            None => a
 1728|     75|        } }
 1729|     75|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|     75|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|     75|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|     75|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|     75|
 1734|     75|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|     75|
 1736|     75|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|     75|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|     75|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|     75|            Some(_) => unreachable!(),
 1740|     75|            None => a,
 1741|     75|        } }
 1742|     75|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|     75|            (s, e)
 1744|     75|        }
 1745|     75|
 1746|     75|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|     75|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|     75|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|     75|            Some(_) => unreachable!(),
 1750|     75|            None => a
 1751|     75|        } }
 1752|     75|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|     75|            (s, e)
 1754|     75|        }
 1755|     75|
 1756|     75|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|     75|            Some("!") => Expression::Not(Box::new(e)),
 1758|     75|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|     75|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|     75|            Some(_) => unreachable!(),
 1761|     75|            None => e,
 1762|     75|        } }
 1763|     75|
 1764|     75|        rule PrimaryExpression() -> Expression =
 1765|     75|            BrackettedExpression()  /
 1766|     75|            ExprQuotedTriple() /
 1767|     75|            iriOrFunction() /
 1768|     75|            v:Var() { v.into() } /
 1769|     75|            l:RDFLiteral() { l.into() } /
 1770|     75|            l:NumericLiteral() { l.into() } /
 1771|     75|            l:BooleanLiteral() { l.into() } /
 1772|     75|            BuiltInCall()
 1773|     75|
 1774|     75|        rule ExprVarOrTerm() -> Expression =
 1775|     75|            ExprQuotedTriple() /
 1776|     75|            i:iri() { i.into() } /
 1777|     75|            l:RDFLiteral() { l.into() } /
 1778|     75|            l:NumericLiteral() { l.into() } /
 1779|     75|            l:BooleanLiteral() { l.into() } /
 1780|     75|            v:Var() { v.into() }
 1781|     75|
 1782|     75|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|     75|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|     75|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|     75|        }
 1786|     75|
 1787|     75|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|     75|
 1789|     75|        rule BuiltInCall() -> Expression =
 1790|     75|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|     75|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|     75|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|     75|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|     75|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|     75|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|     75|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|     75|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|     75|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|     75|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|     75|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|     75|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|     75|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|     75|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|     75|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|     75|            SubstringExpression() /
 1806|     75|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|     75|            StrReplaceExpression() /
 1808|     75|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|     75|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|     75|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|     75|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|     75|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|     75|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|     75|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|     75|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|     75|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|     75|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|     75|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|     75|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|     75|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|     75|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|     75|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|     75|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|     75|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|     75|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|     75|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|     75|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|     75|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|     75|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|     75|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|     75|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|     75|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|     75|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|     75|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|     75|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|     75|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|     75|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|     75|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|     75|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|     75|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|     75|            RegexExpression() /
 1842|     75|            ExistsFunc() /
 1843|     75|            NotExistsFunc() /
 1844|     75|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|     75|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|     75|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|     75|            } /
 1848|     75|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|     75|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|     75|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|     75|            } /
 1852|     75|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|     75|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|     75|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|     75|            } /
 1856|     75|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|     75|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|     75|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|     75|            } /
 1860|     75|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|     75|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|     75|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|     75|            } /
 1864|     75|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|     75|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|     75|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|     75|            }
 1868|     75|
 1869|     75|        rule RegexExpression() -> Expression =
 1870|     75|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|     75|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|     75|
 1873|     75|
 1874|     75|        rule SubstringExpression() -> Expression =
 1875|     75|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|     75|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|     75|
 1878|     75|
 1879|     75|        rule StrReplaceExpression() -> Expression =
 1880|     75|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|     75|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|     75|
 1883|     75|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|     75|
 1885|     75|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|     75|
 1887|     75|        rule Aggregate() -> AggregateExpression =
 1888|     75|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|     75|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|     75|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|     75|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|     75|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|     75|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|     75|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|     75|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|     75|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|     75|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|     75|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|     75|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|     75|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|     75|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|     75|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|     75|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|     75|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|     75|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|     75|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|     75|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|     75|
 1909|     75|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|     75|            match a {
 1911|     75|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|     75|                None => i.into()
 1913|     75|            }
 1914|     75|        }
 1915|     75|
 1916|     75|        rule RDFLiteral() -> Literal =
 1917|     75|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|     75|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|     75|            value:String() { Literal::new_simple_literal(value) }
 1920|     75|
 1921|     75|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|     75|
 1923|     75|        rule NumericLiteralUnsigned() -> Literal =
 1924|     75|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|     75|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|     75|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|     75|
 1928|     75|        rule NumericLiteralPositive() -> Literal =
 1929|     75|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|     75|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|     75|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|     75|
 1933|     75|
 1934|     75|        rule NumericLiteralNegative() -> Literal =
 1935|     75|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|     75|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|     75|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|     75|
 1939|     75|        rule BooleanLiteral() -> Literal =
 1940|     75|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|     75|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|     75|
 1943|     75|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|     75|
 1945|     75|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|     75|            NamedNode::from(i)
 1947|     75|        }
 1948|     75|
 1949|     75|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|     75|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|     75|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|     75|            } else {
 1953|     75|                Err("Prefix not found")
 1954|     75|            } }
 1955|     75|
 1956|     75|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|     75|            let node = BlankNode::new_unchecked(id);
 1958|     75|            if state.used_bnodes.contains(&node) {
 1959|     75|                Err("Already used blank node id")
 1960|     75|            } else {
 1961|     75|                state.currently_used_bnodes.insert(node.clone());
 1962|     75|                Ok(node)
 1963|     75|            }
 1964|     75|        } / ANON() { BlankNode::default() }
 1965|     75|
 1966|     75|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|     75|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|     75|        }
 1969|     75|
 1970|     75|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|     75|            ns
 1972|     75|        }
 1973|     75|
 1974|     75|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|     75|            if let Some(base) = state.namespaces.get(ns) {
 1976|     75|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|     75|                iri.push_str(base);
 1978|     75|                for chunk in local.split('\\') { // We remove \
 1979|     75|                    iri.push_str(chunk);
 1980|     75|                }
 1981|     75|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|     75|            } else {
 1983|     75|                Err("Prefix not found")
 1984|     75|            }
 1985|     75|        }
 1986|     75|
 1987|     75|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|     75|            b
 1989|     75|        }
 1990|     75|
 1991|     75|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|     75|
 1993|     75|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|     75|
 1995|     75|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|     75|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|     75|        }
 1998|     75|
 1999|     75|        rule INTEGER() = ['0'..='9']+
 2000|     75|
 2001|     75|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|     75|
 2003|     75|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|     75|
 2005|     75|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|     75|
 2007|     75|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|     75|
 2009|     75|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|     75|
 2011|     75|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|     75|
 2013|     75|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|     75|
 2015|     75|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|     75|
 2017|     75|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|     75|
 2019|     75|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|     75|             unescape_string(l)
 2021|     75|        }
 2022|     75|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|     75|
 2024|     75|
 2025|     75|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|     75|             unescape_string(l)
 2027|     75|        }
 2028|     75|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|     75|
 2030|     75|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|     75|             unescape_string(l)
 2032|     75|        }
 2033|     75|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|     75|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|     75|
 2036|     75|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|     75|             unescape_string(l)
 2038|     75|        }
 2039|     75|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|     75|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|     75|
 2042|     75|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|     75|
 2044|     75|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|     75|
 2046|     75|        rule NIL() = "(" WS()* ")"
 2047|     75|
 2048|     75|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|     75|
 2050|     75|        rule ANON() = "[" WS()* "]"
 2051|     75|
 2052|     75|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|     75|
 2054|     75|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|     75|
 2056|     75|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|     75|
 2058|     75|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|     75|
 2060|     75|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|     75|
 2062|     75|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|     75|
 2064|     75|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|     75|
 2066|     75|        rule PERCENT() = ['%'] HEX() HEX()
 2067|     75|
 2068|     75|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|     75|
 2070|     75|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|     75|
 2072|     75|        //space
 2073|     75|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|     75|
 2075|     75|        //comment
 2076|     75|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|     75|
 2078|     75|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|     75|            if input.eq_ignore_ascii_case(literal) {
 2080|     75|                Ok(())
 2081|     75|            } else {
 2082|     75|                Err(literal)
 2083|     75|            }
 2084|     75|        }
 2085|     75|    }
 2086|     75|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_SelectClause_variables0B7_:
  825|    834|            "*" { SelectionVariables::Star } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroundQuadData00B9_:
 1152|  1.18k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Object0B7_:
 1395|  17.0k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  17.0k|            if let Some(a) = a {
 1397|      0|                let mut patterns = g.patterns;
 1398|      0|                patterns.extend(a.patterns);
 1399|      0|                FocusedTriplePattern {
 1400|      0|                    focus: AnnotatedTerm {
 1401|      0|                        term: g.focus,
 1402|      0|                        annotations: a.focus
 1403|      0|                    },
 1404|      0|                    patterns
 1405|      0|                }
 1406|       |            } else {
 1407|  17.0k|                FocusedTriplePattern {
 1408|  17.0k|                    focus: AnnotatedTerm {
 1409|  17.0k|                        term: g.focus,
 1410|  17.0k|                        annotations: Vec::new()
 1411|  17.0k|                    },
 1412|  17.0k|                    patterns: g.patterns
 1413|  17.0k|                }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_PropertyListPathNotEmpty00B9_:
 1446|    367|                }, |mut a, b| {
 1447|    367|                    a.focus.push(b.focus);
 1448|    367|                    a.patterns.extend(b.patterns);
 1449|    367|                    a
 1450|    367|                })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_GroupGraphPatternSub_item0B7_:
 1234|    938|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|    938|            let mut result = vec![a];
 1236|    938|            if let Some(v) = b {
 1237|    228|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|    710|            }
 1239|    938|            result
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_VerbSimple0B7_:
 1466|  9.46k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  9.46k|            v.into()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphNode0B7_:
 1648|  17.0k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser34___parse_RelationalExpression_inner0B7_:
 1730|    748|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GroupClause00B9_:
  922|    346|            let clauses = c.into_iter().map(|(e, vo)| {
  923|    346|                if let Expression::Variable(v) = e {
  924|    295|                    v
  925|       |                } else {
  926|     51|                    let v = vo.unwrap_or_else(variable);
  927|     51|                    projections.push((e, v.clone()));
  928|     51|                    v
  929|       |                }
  930|    346|            }).collect();
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_InlineDataFull_value0B7_:
 1294|  4.79k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_PropertyListPathNotEmpty_item0B7_:
 1452|    592|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|    592|            c
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_RelationalExpression0B7_:
 1717|  2.89k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  2.31k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  2.13k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  2.10k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  2.03k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  1.64k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  1.61k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  1.56k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  1.43k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|      0|            Some(_) => unreachable!(),
 1727|    573|            None => a
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_AdditiveExpression_inner0B7_:
 1742|  2.69k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  2.69k|            (s, e)
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_GroupGraphPatternSub00B9_:
 1194|    218|                        g.on_in_scope_variable(|v| {
 1195|    218|                            if defined_variables.contains(v) {
 1196|      0|                                contains = true;
 1197|    218|                            }
 1198|    218|                        });
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_RDFLiterals0_0B7_:
 1919|    373|            value:String() { Literal::new_simple_literal(value) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser9___parse_i0B7_:
  778|   310k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|       |                let mut patterns = po.patterns;
 1348|       |                for (p, os) in po.focus {
 1349|       |                    for o in os {
 1350|       |                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|       |                Ok(patterns)
 1354|       |            } /
 1355|       |            s:TriplesNode() _ po:PropertyList() {?
 1356|       |                let mut patterns = s.patterns;
 1357|       |                patterns.extend(po.patterns);
 1358|       |                for (p, os) in po.focus {
 1359|       |                    for o in os {
 1360|       |                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|       |                    }
 1362|       |                }
 1363|       |                Ok(patterns)
 1364|       |            }
 1365|       |
 1366|       |        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|       |            PropertyListNotEmpty() /
 1368|       |            { FocusedTriplePattern::default() }
 1369|       |
 1370|       |        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|       |            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|       |            })
 1376|       |        }
 1377|       |        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|       |            FocusedTriplePattern {
 1379|       |                focus: (p, o.focus),
 1380|       |                patterns: o.patterns
 1381|       |            }
 1382|       |        }
 1383|       |
 1384|       |        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|       |
 1386|       |        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|       |            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|       |            })
 1392|       |        }
 1393|       |        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|       |
 1395|       |        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|       |            if let Some(a) = a {
 1397|       |                let mut patterns = g.patterns;
 1398|       |                patterns.extend(a.patterns);
 1399|       |                FocusedTriplePattern {
 1400|       |                    focus: AnnotatedTerm {
 1401|       |                        term: g.focus,
 1402|       |                        annotations: a.focus
 1403|       |                    },
 1404|       |                    patterns
 1405|       |                }
 1406|       |            } else {
 1407|       |                FocusedTriplePattern {
 1408|       |                    focus: AnnotatedTerm {
 1409|       |                        term: g.focus,
 1410|       |                        annotations: Vec::new()
 1411|       |                    },
 1412|       |                    patterns: g.patterns
 1413|       |                }
 1414|       |            }
 1415|       |        }
 1416|       |
 1417|       |        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|       |            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|       |                let mut patterns = po.patterns;
 1420|       |                for (p, os) in po.focus {
 1421|       |                    for o in os {
 1422|       |                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|       |                    }
 1424|       |                }
 1425|       |                Ok(patterns)
 1426|       |            } /
 1427|       |            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|       |                let mut patterns = s.patterns;
 1429|       |                patterns.extend(po.patterns);
 1430|       |                for (p, os) in po.focus {
 1431|       |                    for o in os {
 1432|       |                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|       |                    }
 1434|       |                }
 1435|       |                Ok(patterns)
 1436|       |            }
 1437|       |
 1438|       |        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|       |            PropertyListPathNotEmpty() /
 1440|       |            { FocusedTripleOrPathPattern::default() }
 1441|       |
 1442|       |        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|       |                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|       |                    focus: vec![(hp, ho.focus)],
 1445|       |                    patterns: ho.patterns
 1446|       |                }, |mut a, b| {
 1447|       |                    a.focus.push(b.focus);
 1448|       |                    a.patterns.extend(b.patterns);
 1449|       |                    a
 1450|       |                })
 1451|       |        }
 1452|       |        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|       |            c
 1454|       |        }
 1455|       |        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|       |            FocusedTripleOrPathPattern {
 1457|       |                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|       |                patterns: o.patterns
 1459|       |            }
 1460|       |        }
 1461|       |
 1462|       |        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|       |            p.into()
 1464|       |        }
 1465|       |
 1466|       |        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|       |            v.into()
 1468|       |        }
 1469|       |
 1470|       |        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|       |            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|       |                a.focus.push(b.focus);
 1473|       |                a.patterns.extend(b.patterns);
 1474|       |                a
 1475|       |            })
 1476|       |        }
 1477|       |        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|       |
 1479|       |        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|       |             if let Some(a) = a {
 1481|       |                let mut patterns = g.patterns;
 1482|       |                patterns.extend(a.patterns);
 1483|       |                FocusedTripleOrPathPattern {
 1484|       |                    focus: AnnotatedTermPath {
 1485|       |                        term: g.focus,
 1486|       |                        annotations: a.focus
 1487|       |                    },
 1488|       |                    patterns
 1489|       |                }
 1490|       |            } else {
 1491|       |                FocusedTripleOrPathPattern {
 1492|       |                    focus: AnnotatedTermPath {
 1493|       |                        term: g.focus,
 1494|       |                        annotations: Vec::new()
 1495|       |                    },
 1496|       |                    patterns: g.patterns
 1497|       |                }
 1498|       |            }
 1499|       |        }
 1500|       |
 1501|       |        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|       |
 1503|       |        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|       |            not_empty_fold(p.into_iter(), |a, b| {
 1505|       |                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|       |            })
 1507|       |        }
 1508|       |        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|       |
 1510|       |        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|       |            not_empty_fold(p.into_iter(), |a, b| {
 1512|       |                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|       |            })
 1514|       |        }
 1515|       |        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|       |
 1517|       |        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|       |            match o {
 1519|       |                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|       |                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|       |                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|       |                Some(_) => unreachable!(),
 1523|       |                None => p
 1524|       |            }
 1525|       |        }
 1526|       |        rule PathElt_op() -> char =
 1527|       |            "*" { '*' } /
 1528|       |            "+" { '+' } /
 1529|       |            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|       |
 1531|       |        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|       |            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|       |            PathElt()
 1534|       |
 1535|       |        rule PathPrimary() -> PropertyPathExpression =
 1536|       |            v:iri() { v.into() } /
 1537|       |            "a" { rdf::TYPE.into_owned().into() } /
 1538|       |            "!" _ p:PathNegatedPropertySet() { p } /
 1539|       |            "(" _ p:Path() _ ")" { p }
 1540|       |
 1541|       |        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|       |            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|       |                let mut direct = Vec::new();
 1544|       |                let mut inverse = Vec::new();
 1545|       |                for e in p {
 1546|       |                    match e {
 1547|       |                        Either::Left(a) => direct.push(a),
 1548|       |                        Either::Right(b) => inverse.push(b)
 1549|       |                    }
 1550|       |                }
 1551|       |                if inverse.is_empty() {
 1552|       |                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|       |                } else if direct.is_empty() {
 1554|       |                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|       |                } else {
 1556|       |                    PropertyPathExpression::Alternative(
 1557|       |                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|       |                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|       |                    )
 1560|       |                }
 1561|       |            } /
 1562|       |            p:PathOneInPropertySet() {
 1563|       |                match p {
 1564|       |                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|       |                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|       |                }
 1567|       |            }
 1568|       |        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|       |
 1570|       |        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|       |            "^" _ v:iri() { Either::Right(v) } /
 1572|       |            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|       |            v:iri() { Either::Left(v) } /
 1574|       |            "a" { Either::Left(rdf::TYPE.into()) }
 1575|       |
 1576|       |        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|       |
 1578|       |        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|       |            let mut patterns = po.patterns;
 1580|       |            let mut bnode = TermPattern::from(BlankNode::default());
 1581|       |            for (p, os) in po.focus {
 1582|       |                for o in os {
 1583|       |                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|       |                }
 1585|       |            }
 1586|       |            Ok(FocusedTriplePattern {
 1587|       |                focus: bnode,
 1588|       |                patterns
 1589|       |            })
 1590|       |        }
 1591|       |
 1592|       |        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|       |
 1594|       |        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|       |            let mut patterns = po.patterns;
 1596|       |            let mut bnode = TermPattern::from(BlankNode::default());
 1597|       |            for (p, os) in po.focus {
 1598|       |                for o in os {
 1599|       |                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|       |                }
 1601|       |            }
 1602|       |            Ok(FocusedTripleOrPathPattern {
 1603|       |                focus: bnode,
 1604|       |                patterns
 1605|       |            })
 1606|       |        }
 1607|       |
 1608|       |        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|       |            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|       |            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|       |            for objWithPatterns in o.into_iter().rev() {
 1612|       |                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|       |                current_list_node = new_blank_node;
 1616|       |                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|       |            }
 1618|       |            FocusedTriplePattern {
 1619|       |                focus: current_list_node,
 1620|       |                patterns
 1621|       |            }
 1622|       |        }
 1623|       |        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|       |
 1625|       |        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|       |            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|       |            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|       |            for objWithPatterns in o.into_iter().rev() {
 1629|       |                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|       |                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|       |                current_list_node = new_blank_node;
 1633|       |                patterns.extend(objWithPatterns.patterns);
 1634|       |            }
 1635|       |            FocusedTripleOrPathPattern {
 1636|       |                focus: current_list_node,
 1637|       |                patterns
 1638|       |            }
 1639|       |        }
 1640|       |        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|       |
 1642|       |
 1643|       |        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|       |
 1645|       |        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|       |
 1647|       |        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|       |            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|       |            TriplesNode()
 1650|       |
 1651|       |        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|       |            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|       |            TriplesNodePath()
 1654|       |
 1655|       |        rule VarOrTerm() -> TermPattern =
 1656|       |            v:Var() { v.into() } /
 1657|       |            t:QuotedTriple() {?
 1658|       |                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|       |            } /
 1661|       |            t:GraphTerm() { t.into() }
 1662|       |
 1663|       |        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|       |            Ok(TriplePattern {
 1665|       |                subject: s,
 1666|       |                predicate: p,
 1667|       |                object: o
 1668|       |            })
 1669|       |        }
 1670|       |
 1671|       |        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|       |            Ok(GroundTriple {
 1673|       |                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|       |                predicate: p,
 1675|       |                object: o
 1676|       |            })
 1677|       |        }
 1678|       |        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|       |
 1680|       |        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|       |            l:RDFLiteral() { l.into() } /
 1682|       |            l:NumericLiteral() { l.into() } /
 1683|       |            l:BooleanLiteral() { l.into() } /
 1684|       |            t:QuotedTripleData() {?
 1685|       |                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|       |            }
 1688|       |
 1689|       |        rule VarOrIri() -> NamedNodePattern =
 1690|       |            v:Var() { v.into() } /
 1691|       |            i:iri() { i.into() }
 1692|       |
 1693|       |        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|       |
 1695|       |        rule GraphTerm() -> Term =
 1696|       |            i:iri() { i.into() } /
 1697|       |            l:RDFLiteral() { l.into() } /
 1698|       |            l:NumericLiteral() { l.into() } /
 1699|       |            l:BooleanLiteral() { l.into() } /
 1700|       |            b:BlankNode() { b.into() } /
 1701|       |            NIL() { rdf::NIL.into_owned().into() }
 1702|       |
 1703|       |        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|       |
 1705|       |        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|       |            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|       |        }
 1708|       |        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|       |
 1710|       |        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|       |        }
 1713|       |        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|       |
 1715|       |        rule ValueLogical() -> Expression = RelationalExpression()
 1716|       |
 1717|       |        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|       |            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|       |            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|       |            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|       |            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|       |            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|       |            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|       |            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|       |            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|       |            Some(_) => unreachable!(),
 1727|       |            None => a
 1728|       |        } }
 1729|       |        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|       |            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|       |            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|       |            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|       |
 1734|       |        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|       |
 1736|       |        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|       |            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|       |            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|       |            Some(_) => unreachable!(),
 1740|       |            None => a,
 1741|       |        } }
 1742|       |        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|       |            (s, e)
 1744|       |        }
 1745|       |
 1746|       |        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|       |            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|       |            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|       |            Some(_) => unreachable!(),
 1750|       |            None => a
 1751|       |        } }
 1752|       |        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|       |            (s, e)
 1754|       |        }
 1755|       |
 1756|       |        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|       |            Some("!") => Expression::Not(Box::new(e)),
 1758|       |            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|       |            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|       |            Some(_) => unreachable!(),
 1761|       |            None => e,
 1762|       |        } }
 1763|       |
 1764|       |        rule PrimaryExpression() -> Expression =
 1765|       |            BrackettedExpression()  /
 1766|       |            ExprQuotedTriple() /
 1767|       |            iriOrFunction() /
 1768|       |            v:Var() { v.into() } /
 1769|       |            l:RDFLiteral() { l.into() } /
 1770|       |            l:NumericLiteral() { l.into() } /
 1771|       |            l:BooleanLiteral() { l.into() } /
 1772|       |            BuiltInCall()
 1773|       |
 1774|       |        rule ExprVarOrTerm() -> Expression =
 1775|       |            ExprQuotedTriple() /
 1776|       |            i:iri() { i.into() } /
 1777|       |            l:RDFLiteral() { l.into() } /
 1778|       |            l:NumericLiteral() { l.into() } /
 1779|       |            l:BooleanLiteral() { l.into() } /
 1780|       |            v:Var() { v.into() }
 1781|       |
 1782|       |        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|       |            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|       |            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|       |        }
 1786|       |
 1787|       |        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|       |
 1789|       |        rule BuiltInCall() -> Expression =
 1790|       |            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|       |            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|       |            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|       |            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|       |            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|       |            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|       |            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|       |            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|       |            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|       |            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|       |            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|       |            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|       |            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|       |            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|       |            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|       |            SubstringExpression() /
 1806|       |            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|       |            StrReplaceExpression() /
 1808|       |            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|       |            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|       |            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|       |            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|       |            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|       |            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|       |            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|       |            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|       |            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|       |            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|       |            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|       |            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|       |            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|       |            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|       |            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|       |            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|       |            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|       |            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|       |            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|       |            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|       |            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|       |            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|       |            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|       |            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|       |            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|       |            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|       |            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|       |            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|       |            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|       |            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|       |            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|       |            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|       |            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|       |            RegexExpression() /
 1842|       |            ExistsFunc() /
 1843|       |            NotExistsFunc() /
 1844|       |            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|       |                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|       |            } /
 1848|       |            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|       |                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|       |            } /
 1852|       |            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|       |                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|       |            } /
 1856|       |            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|       |                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|       |            } /
 1860|       |            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|       |                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|       |                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|       |            } /
 1864|       |            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|       |                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|       |                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|       |            }
 1868|       |
 1869|       |        rule RegexExpression() -> Expression =
 1870|       |            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|       |            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|       |
 1873|       |
 1874|       |        rule SubstringExpression() -> Expression =
 1875|       |            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|       |            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|       |
 1878|       |
 1879|       |        rule StrReplaceExpression() -> Expression =
 1880|       |            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|       |            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|       |
 1883|       |        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|       |
 1885|       |        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|       |
 1887|       |        rule Aggregate() -> AggregateExpression =
 1888|       |            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|       |            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|       |            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|       |            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|       |            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|       |            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|       |            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|       |            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|       |            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|       |            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|       |            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|       |            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|       |            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|       |            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|       |            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|       |            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|       |            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|       |            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|       |            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|       |            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|       |
 1909|       |        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|       |            match a {
 1911|       |                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|       |                None => i.into()
 1913|       |            }
 1914|       |        }
 1915|       |
 1916|       |        rule RDFLiteral() -> Literal =
 1917|       |            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|       |            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|       |            value:String() { Literal::new_simple_literal(value) }
 1920|       |
 1921|       |        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|       |
 1923|       |        rule NumericLiteralUnsigned() -> Literal =
 1924|       |            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|       |            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|       |            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|       |
 1928|       |        rule NumericLiteralPositive() -> Literal =
 1929|       |            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|       |            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|       |            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|       |
 1933|       |
 1934|       |        rule NumericLiteralNegative() -> Literal =
 1935|       |            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|       |            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|       |            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|       |
 1939|       |        rule BooleanLiteral() -> Literal =
 1940|       |            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|       |            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|       |
 1943|       |        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|       |
 1945|       |        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|       |            NamedNode::from(i)
 1947|       |        }
 1948|       |
 1949|       |        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|       |            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|       |                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|       |            } else {
 1953|       |                Err("Prefix not found")
 1954|       |            } }
 1955|       |
 1956|       |        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|       |            let node = BlankNode::new_unchecked(id);
 1958|       |            if state.used_bnodes.contains(&node) {
 1959|       |                Err("Already used blank node id")
 1960|       |            } else {
 1961|       |                state.currently_used_bnodes.insert(node.clone());
 1962|       |                Ok(node)
 1963|       |            }
 1964|       |        } / ANON() { BlankNode::default() }
 1965|       |
 1966|       |        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|       |            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|       |        }
 1969|       |
 1970|       |        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|       |            ns
 1972|       |        }
 1973|       |
 1974|       |        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|       |            if let Some(base) = state.namespaces.get(ns) {
 1976|       |                let mut iri = String::with_capacity(base.len() + local.len());
 1977|       |                iri.push_str(base);
 1978|       |                for chunk in local.split('\\') { // We remove \
 1979|       |                    iri.push_str(chunk);
 1980|       |                }
 1981|       |                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|       |            } else {
 1983|       |                Err("Prefix not found")
 1984|       |            }
 1985|       |        }
 1986|       |
 1987|       |        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|       |            b
 1989|       |        }
 1990|       |
 1991|       |        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|       |
 1993|       |        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|       |
 1995|       |        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|       |            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|       |        }
 1998|       |
 1999|       |        rule INTEGER() = ['0'..='9']+
 2000|       |
 2001|       |        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|       |
 2003|       |        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|       |
 2005|       |        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|       |
 2007|       |        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|       |
 2009|       |        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|       |
 2011|       |        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|       |
 2013|       |        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|       |
 2015|       |        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|       |
 2017|       |        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|       |
 2019|       |        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|       |             unescape_string(l)
 2021|       |        }
 2022|       |        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|       |
 2024|       |
 2025|       |        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|       |             unescape_string(l)
 2027|       |        }
 2028|       |        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|       |
 2030|       |        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|       |             unescape_string(l)
 2032|       |        }
 2033|       |        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|       |        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|       |
 2036|       |        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|       |             unescape_string(l)
 2038|       |        }
 2039|       |        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|       |        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|       |
 2042|       |        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|       |
 2044|       |        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|       |
 2046|       |        rule NIL() = "(" WS()* ")"
 2047|       |
 2048|       |        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|       |
 2050|       |        rule ANON() = "[" WS()* "]"
 2051|       |
 2052|       |        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|       |
 2054|       |        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|       |
 2056|       |        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|       |
 2058|       |        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|       |
 2060|       |        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|       |
 2062|       |        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|       |
 2064|       |        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|       |
 2066|       |        rule PERCENT() = ['%'] HEX() HEX()
 2067|       |
 2068|       |        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|       |
 2070|       |        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|       |
 2072|       |        //space
 2073|       |        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|       |
 2075|       |        //comment
 2076|       |        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|       |
 2078|       |        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|   310k|            if input.eq_ignore_ascii_case(literal) {
 2080|  47.3k|                Ok(())
 2081|       |            } else {
 2082|   263k|                Err(literal)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_PathPrimarys_0B7_:
 1537|  2.32k|            "a" { rdf::TYPE.into_owned().into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_NotExistsFunc0B7_:
 1885|     46|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_InlineDataOneVar0B7_:
 1280|     49|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|     49|            (vec![var], d)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_TriplesBlock_inner0B7_:
 1245|  1.69k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_ValuesClauses_0B7_:
  971|  1.68k|            { None }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_TriplesBlock0B7_:
 1242|  1.64k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  1.64k|            hs.into_iter().flatten().collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_GraphRef0B7_:
 1139|  1.24k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValues_0B7_:
 1301|  3.19k|            i:iri() { Some(i.into()) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_SelectClause_variabless_0B7_:
  826|  1.10k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_MinusGraphPattern0B7_:
 1307|     20|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|     20|            PartialGraphPattern::Minus(p)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsK_0B7_:
 1840|      3|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GraphRefAlls_0B7_:
 1142|    244|            / i("DEFAULT") { GraphTarget::DefaultGraph }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_QuadsNotTriples00B9_:
 1164|  14.8k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_InsertClause0B7_:
 1123|  2.36k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_Quads_TriplesTemplate0B7_:
 1158|  2.15k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  2.15k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_TriplesTemplate0B7_:
 1167|  16.9k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  16.9k|            ts.into_iter().flatten().collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Modify_clauses0B7_:
 1109|  2.36k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  2.36k|            (Some(d), i)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser35___parse_PathNegatedPropertySet_item0B7_:
 1568|  7.69k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsI_0B7_:
 1838|     27|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_LANGTAG0B7_:
  778|  1.97k|parser! {
  779|  1.97k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  1.97k|    grammar parser(state: &mut ParserState) for str {
  781|  1.97k|        pub rule QueryUnit() -> Query = Query()
  782|  1.97k|
  783|  1.97k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  1.97k|            q
  785|  1.97k|        }
  786|  1.97k|
  787|  1.97k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  1.97k|
  789|  1.97k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  1.97k|
  791|  1.97k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  1.97k|            state.base_iri = Some(i)
  793|  1.97k|        }
  794|  1.97k|
  795|  1.97k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  1.97k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  1.97k|        }
  798|  1.97k|
  799|  1.97k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  1.97k|            Ok(Query::Select {
  801|  1.97k|                dataset: d,
  802|  1.97k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  1.97k|                base_iri: state.base_iri.clone()
  804|  1.97k|            })
  805|  1.97k|        }
  806|  1.97k|
  807|  1.97k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  1.97k|            build_select(s, w, g, h, o, l, v, state)
  809|  1.97k|        }
  810|  1.97k|
  811|  1.97k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  1.97k|            Selection {
  813|  1.97k|                option: o,
  814|  1.97k|                variables: v
  815|  1.97k|            }
  816|  1.97k|        }
  817|  1.97k|        rule Selection_init() = {
  818|  1.97k|            state.aggregates.push(Vec::new())
  819|  1.97k|        }
  820|  1.97k|        rule SelectClause_option() -> SelectionOption =
  821|  1.97k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  1.97k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  1.97k|            { SelectionOption::Default }
  824|  1.97k|        rule SelectClause_variables() -> SelectionVariables =
  825|  1.97k|            "*" { SelectionVariables::Star } /
  826|  1.97k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  1.97k|        rule SelectClause_member() -> SelectionMember =
  828|  1.97k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  1.97k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  1.97k|
  831|  1.97k|        rule ConstructQuery() -> Query =
  832|  1.97k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  1.97k|                Ok(Query::Construct {
  834|  1.97k|                    template: c,
  835|  1.97k|                    dataset: d,
  836|  1.97k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  1.97k|                    base_iri: state.base_iri.clone()
  838|  1.97k|                })
  839|  1.97k|            } /
  840|  1.97k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  1.97k|                Ok(Query::Construct {
  842|  1.97k|                    template: c.clone(),
  843|  1.97k|                    dataset: d,
  844|  1.97k|                    pattern: build_select(
  845|  1.97k|                        Selection::no_op(),
  846|  1.97k|                        GraphPattern::Bgp { patterns: c },
  847|  1.97k|                        g, h, o, l, v, state
  848|  1.97k|                    )?,
  849|  1.97k|                    base_iri: state.base_iri.clone()
  850|  1.97k|                })
  851|  1.97k|            }
  852|  1.97k|
  853|  1.97k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  1.97k|
  855|  1.97k|        rule DescribeQuery() -> Query =
  856|  1.97k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  1.97k|                Ok(Query::Describe {
  858|  1.97k|                    dataset: d,
  859|  1.97k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  1.97k|                    base_iri: state.base_iri.clone()
  861|  1.97k|                })
  862|  1.97k|            } /
  863|  1.97k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  1.97k|                Ok(Query::Describe {
  865|  1.97k|                    dataset: d,
  866|  1.97k|                    pattern: build_select(Selection {
  867|  1.97k|                        option: SelectionOption::Default,
  868|  1.97k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  1.97k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  1.97k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  1.97k|                        }).collect())
  872|  1.97k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  1.97k|                    base_iri: state.base_iri.clone()
  874|  1.97k|                })
  875|  1.97k|            }
  876|  1.97k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  1.97k|
  878|  1.97k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  1.97k|            Ok(Query::Ask {
  880|  1.97k|                dataset: d,
  881|  1.97k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  1.97k|                base_iri: state.base_iri.clone()
  883|  1.97k|            })
  884|  1.97k|        }
  885|  1.97k|
  886|  1.97k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  1.97k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  1.97k|            if d.is_empty() {
  889|  1.97k|                return None;
  890|  1.97k|            }
  891|  1.97k|            let mut default = Vec::new();
  892|  1.97k|            let mut named = Vec::new();
  893|  1.97k|            for (d, n) in d {
  894|  1.97k|                if let Some(d) = d {
  895|  1.97k|                    default.push(d);
  896|  1.97k|                }
  897|  1.97k|                if let Some(n) = n {
  898|  1.97k|                    named.push(n);
  899|  1.97k|                }
  900|  1.97k|            }
  901|  1.97k|            Some(QueryDataset {
  902|  1.97k|                default, named: Some(named)
  903|  1.97k|            })
  904|  1.97k|        }
  905|  1.97k|
  906|  1.97k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  1.97k|            (Some(s), None)
  908|  1.97k|        }
  909|  1.97k|
  910|  1.97k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  1.97k|            (None, Some(s))
  912|  1.97k|        }
  913|  1.97k|
  914|  1.97k|        rule SourceSelector() -> NamedNode = iri()
  915|  1.97k|
  916|  1.97k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  1.97k|            p
  918|  1.97k|        }
  919|  1.97k|
  920|  1.97k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  1.97k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  1.97k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  1.97k|                if let Expression::Variable(v) = e {
  924|  1.97k|                    v
  925|  1.97k|                } else {
  926|  1.97k|                    let v = vo.unwrap_or_else(variable);
  927|  1.97k|                    projections.push((e, v.clone()));
  928|  1.97k|                    v
  929|  1.97k|                }
  930|  1.97k|            }).collect();
  931|  1.97k|            (clauses, projections)
  932|  1.97k|        }
  933|  1.97k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  1.97k|
  935|  1.97k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  1.97k|            e:BuiltInCall() { (e, None) } /
  937|  1.97k|            e:FunctionCall() { (e, None) } /
  938|  1.97k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  1.97k|            e:Var() { (e.into(), None) }
  940|  1.97k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  1.97k|
  942|  1.97k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  1.97k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  1.97k|        }
  945|  1.97k|
  946|  1.97k|        rule HavingCondition() -> Expression = Constraint()
  947|  1.97k|
  948|  1.97k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  1.97k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  1.97k|
  951|  1.97k|        rule OrderCondition() -> OrderExpression =
  952|  1.97k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  1.97k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  1.97k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  1.97k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  1.97k|
  957|  1.97k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  1.97k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  1.97k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  1.97k|
  961|  1.97k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  1.97k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  1.97k|        }
  964|  1.97k|
  965|  1.97k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  1.97k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  1.97k|        }
  968|  1.97k|
  969|  1.97k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  1.97k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  1.97k|            { None }
  972|  1.97k|
  973|  1.97k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  1.97k|
  975|  1.97k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  1.97k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  1.97k|
  978|  1.97k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  1.97k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  1.97k|        }
  981|  1.97k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  1.97k|
  983|  1.97k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  1.97k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  1.97k|        }
  986|  1.97k|
  987|  1.97k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  1.97k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  1.97k|        }
  990|  1.97k|
  991|  1.97k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  1.97k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  1.97k|        }
  994|  1.97k|
  995|  1.97k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  1.97k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  1.97k|            if from == to {
  998|  1.97k|                Vec::new() // identity case
  999|  1.97k|            } else {
 1000|  1.97k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  1.97k|                vec![copy_graph(from, to)]
 1002|  1.97k|            }
 1003|  1.97k|        }
 1004|  1.97k|
 1005|  1.97k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  1.97k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  1.97k|            if from == to {
 1008|  1.97k|                Vec::new() // identity case
 1009|  1.97k|            } else {
 1010|  1.97k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  1.97k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  1.97k|            }
 1013|  1.97k|        }
 1014|  1.97k|
 1015|  1.97k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  1.97k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  1.97k|            if from == to {
 1018|  1.97k|                Vec::new() // identity case
 1019|  1.97k|            } else {
 1020|  1.97k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  1.97k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  1.97k|            }
 1023|  1.97k|        }
 1024|  1.97k|
 1025|  1.97k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  1.97k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  1.97k|        }
 1028|  1.97k|
 1029|  1.97k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  1.97k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  1.97k|        }
 1032|  1.97k|
 1033|  1.97k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  1.97k|            let pattern = d.iter().map(|q| {
 1035|  1.97k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  1.97k|                match &q.graph_name {
 1037|  1.97k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  1.97k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  1.97k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  1.97k|                }
 1041|  1.97k|            }).reduce(new_join).unwrap_or_default();
 1042|  1.97k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  1.97k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  1.97k|                delete,
 1045|  1.97k|                insert: Vec::new(),
 1046|  1.97k|                using: None,
 1047|  1.97k|                pattern: Box::new(pattern)
 1048|  1.97k|            }])
 1049|  1.97k|        }
 1050|  1.97k|
 1051|  1.97k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  1.97k|            let (delete, insert) = c;
 1053|  1.97k|            let mut delete = delete.unwrap_or_default();
 1054|  1.97k|            let mut insert = insert.unwrap_or_default();
 1055|  1.97k|            #[allow(clippy::shadow_same)]
 1056|  1.97k|            let mut pattern = pattern;
 1057|  1.97k|
 1058|  1.97k|            let mut using = if u.is_empty() {
 1059|  1.97k|                None
 1060|  1.97k|            } else {
 1061|  1.97k|                let mut default = Vec::new();
 1062|  1.97k|                let mut named = Vec::new();
 1063|  1.97k|                for (d, n) in u {
 1064|  1.97k|                    if let Some(d) = d {
 1065|  1.97k|                        default.push(d)
 1066|  1.97k|                    }
 1067|  1.97k|                    if let Some(n) = n {
 1068|  1.97k|                        named.push(n)
 1069|  1.97k|                    }
 1070|  1.97k|                }
 1071|  1.97k|                Some(QueryDataset { default, named: Some(named) })
 1072|  1.97k|            };
 1073|  1.97k|
 1074|  1.97k|            if let Some(with) = with {
 1075|  1.97k|                // We inject WITH everywhere
 1076|  1.97k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  1.97k|                    GroundQuadPattern {
 1078|  1.97k|                        subject: q.subject,
 1079|  1.97k|                        predicate: q.predicate,
 1080|  1.97k|                        object: q.object,
 1081|  1.97k|                        graph_name: with.clone().into()
 1082|  1.97k|                    }
 1083|  1.97k|                } else {
 1084|  1.97k|                    q
 1085|  1.97k|                }).collect();
 1086|  1.97k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  1.97k|                    QuadPattern {
 1088|  1.97k|                        subject: q.subject,
 1089|  1.97k|                        predicate: q.predicate,
 1090|  1.97k|                        object: q.object,
 1091|  1.97k|                        graph_name: with.clone().into()
 1092|  1.97k|                    }
 1093|  1.97k|                } else {
 1094|  1.97k|                    q
 1095|  1.97k|                }).collect();
 1096|  1.97k|                if using.is_none() {
 1097|  1.97k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  1.97k|                }
 1099|  1.97k|            }
 1100|  1.97k|
 1101|  1.97k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  1.97k|                delete,
 1103|  1.97k|                insert,
 1104|  1.97k|                using,
 1105|  1.97k|                pattern: Box::new(pattern)
 1106|  1.97k|            }]
 1107|  1.97k|        }
 1108|  1.97k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  1.97k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  1.97k|            (Some(d), i)
 1111|  1.97k|        } / i:InsertClause() {
 1112|  1.97k|            (None, Some(i))
 1113|  1.97k|        }
 1114|  1.97k|        rule Modify_clear() = {
 1115|  1.97k|            state.used_bnodes.clear();
 1116|  1.97k|            state.currently_used_bnodes.clear();
 1117|  1.97k|        }
 1118|  1.97k|
 1119|  1.97k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  1.97k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  1.97k|        }
 1122|  1.97k|
 1123|  1.97k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  1.97k|
 1125|  1.97k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  1.97k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  1.97k|            (Some(i), None)
 1128|  1.97k|        }
 1129|  1.97k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  1.97k|            (None, Some(i))
 1131|  1.97k|        }
 1132|  1.97k|
 1133|  1.97k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  1.97k|            GraphName::DefaultGraph
 1135|  1.97k|        } / (i("GRAPH") _)? g:iri() {
 1136|  1.97k|            GraphName::NamedNode(g)
 1137|  1.97k|        }
 1138|  1.97k|
 1139|  1.97k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  1.97k|
 1141|  1.97k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  1.97k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  1.97k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  1.97k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  1.97k|
 1146|  1.97k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  1.97k|
 1148|  1.97k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  1.97k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  1.97k|        }
 1151|  1.97k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  1.97k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  1.97k|        }
 1154|  1.97k|
 1155|  1.97k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  1.97k|            q.into_iter().flatten().collect()
 1157|  1.97k|        }
 1158|  1.97k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  1.97k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  1.97k|        } //TODO: return iter?
 1161|  1.97k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  1.97k|
 1163|  1.97k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  1.97k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  1.97k|        }
 1166|  1.97k|
 1167|  1.97k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  1.97k|            ts.into_iter().flatten().collect()
 1169|  1.97k|        }
 1170|  1.97k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  1.97k|
 1172|  1.97k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  1.97k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  1.97k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  1.97k|        rule GroupGraphPattern_clear() = {
 1176|  1.97k|             // We deal with blank nodes aliases rule
 1177|  1.97k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  1.97k|            state.currently_used_bnodes.clear();
 1179|  1.97k|        }
 1180|  1.97k|
 1181|  1.97k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  1.97k|            let mut filter: Option<Expression> = None;
 1183|  1.97k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  1.97k|            for e in b.into_iter().flatten() {
 1185|  1.97k|                match e {
 1186|  1.97k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  1.97k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  1.97k|                    }
 1189|  1.97k|                    #[cfg(feature = "sep-0006")]
 1190|  1.97k|                    PartialGraphPattern::Lateral(p) => {
 1191|  1.97k|                        let mut defined_variables = HashSet::default();
 1192|  1.97k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  1.97k|                        let mut contains = false;
 1194|  1.97k|                        g.on_in_scope_variable(|v| {
 1195|  1.97k|                            if defined_variables.contains(v) {
 1196|  1.97k|                                contains = true;
 1197|  1.97k|                            }
 1198|  1.97k|                        });
 1199|  1.97k|                        if contains {
 1200|  1.97k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  1.97k|                        }
 1202|  1.97k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  1.97k|                    }
 1204|  1.97k|                    PartialGraphPattern::Minus(p) => {
 1205|  1.97k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  1.97k|                    }
 1207|  1.97k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  1.97k|                        let mut contains = false;
 1209|  1.97k|                        g.on_in_scope_variable(|v| {
 1210|  1.97k|                            if *v == variable {
 1211|  1.97k|                                contains = true;
 1212|  1.97k|                            }
 1213|  1.97k|                        });
 1214|  1.97k|                        if contains {
 1215|  1.97k|                            return Err("BIND is overriding an existing variable")
 1216|  1.97k|                        }
 1217|  1.97k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  1.97k|                    }
 1219|  1.97k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  1.97k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  1.97k|                    } else {
 1222|  1.97k|                        expr
 1223|  1.97k|                    }),
 1224|  1.97k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  1.97k|                }
 1226|  1.97k|            }
 1227|  1.97k|
 1228|  1.97k|            Ok(if let Some(expr) = filter {
 1229|  1.97k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  1.97k|            } else {
 1231|  1.97k|                g
 1232|  1.97k|            })
 1233|  1.97k|        }
 1234|  1.97k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  1.97k|            let mut result = vec![a];
 1236|  1.97k|            if let Some(v) = b {
 1237|  1.97k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  1.97k|            }
 1239|  1.97k|            result
 1240|  1.97k|        }
 1241|  1.97k|
 1242|  1.97k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  1.97k|            hs.into_iter().flatten().collect()
 1244|  1.97k|        }
 1245|  1.97k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  1.97k|
 1247|  1.97k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  1.97k|
 1249|  1.97k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  1.97k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  1.97k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  1.97k|            } else {
 1253|  1.97k|               PartialGraphPattern::Optional(p, None)
 1254|  1.97k|            }
 1255|  1.97k|        }
 1256|  1.97k|
 1257|  1.97k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  1.97k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  1.97k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  1.97k|        }
 1261|  1.97k|
 1262|  1.97k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  1.97k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  1.97k|        }
 1265|  1.97k|
 1266|  1.97k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  1.97k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  1.97k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  1.97k|
 1270|  1.97k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  1.97k|            PartialGraphPattern::Bind(e, v)
 1272|  1.97k|        }
 1273|  1.97k|
 1274|  1.97k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  1.97k|
 1276|  1.97k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  1.97k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  1.97k|        }
 1279|  1.97k|
 1280|  1.97k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  1.97k|            (vec![var], d)
 1282|  1.97k|        }
 1283|  1.97k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  1.97k|
 1285|  1.97k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  1.97k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  1.97k|                Ok((vars, vals))
 1288|  1.97k|            } else {
 1289|  1.97k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  1.97k|            }
 1291|  1.97k|        }
 1292|  1.97k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  1.97k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  1.97k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  1.97k|
 1296|  1.97k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  1.97k|            t:QuotedTripleData() {?
 1298|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  1.97k|            } /
 1301|  1.97k|            i:iri() { Some(i.into()) } /
 1302|  1.97k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  1.97k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  1.97k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  1.97k|            i("UNDEF") { None }
 1306|  1.97k|
 1307|  1.97k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  1.97k|            PartialGraphPattern::Minus(p)
 1309|  1.97k|        }
 1310|  1.97k|
 1311|  1.97k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  1.97k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  1.97k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  1.97k|            }).map(PartialGraphPattern::Other)
 1315|  1.97k|        }
 1316|  1.97k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  1.97k|
 1318|  1.97k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  1.97k|            PartialGraphPattern::Filter(c)
 1320|  1.97k|        }
 1321|  1.97k|
 1322|  1.97k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  1.97k|
 1324|  1.97k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  1.97k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  1.97k|        }
 1327|  1.97k|
 1328|  1.97k|        rule ArgList() -> Vec<Expression> =
 1329|  1.97k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  1.97k|            NIL() { Vec::new() }
 1331|  1.97k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  1.97k|
 1333|  1.97k|        rule ExpressionList() -> Vec<Expression> =
 1334|  1.97k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  1.97k|            NIL() { Vec::new() }
 1336|  1.97k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  1.97k|
 1338|  1.97k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  1.97k|
 1340|  1.97k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  1.97k|            p.into_iter().flatten().collect()
 1342|  1.97k|        }
 1343|  1.97k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  1.97k|
 1345|  1.97k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  1.97k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  1.97k|                let mut patterns = po.patterns;
 1348|  1.97k|                for (p, os) in po.focus {
 1349|  1.97k|                    for o in os {
 1350|  1.97k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  1.97k|                    }
 1352|  1.97k|                }
 1353|  1.97k|                Ok(patterns)
 1354|  1.97k|            } /
 1355|  1.97k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  1.97k|                let mut patterns = s.patterns;
 1357|  1.97k|                patterns.extend(po.patterns);
 1358|  1.97k|                for (p, os) in po.focus {
 1359|  1.97k|                    for o in os {
 1360|  1.97k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  1.97k|                    }
 1362|  1.97k|                }
 1363|  1.97k|                Ok(patterns)
 1364|  1.97k|            }
 1365|  1.97k|
 1366|  1.97k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  1.97k|            PropertyListNotEmpty() /
 1368|  1.97k|            { FocusedTriplePattern::default() }
 1369|  1.97k|
 1370|  1.97k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  1.97k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  1.97k|                a.focus.push(b.focus);
 1373|  1.97k|                a.patterns.extend(b.patterns);
 1374|  1.97k|                a
 1375|  1.97k|            })
 1376|  1.97k|        }
 1377|  1.97k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  1.97k|            FocusedTriplePattern {
 1379|  1.97k|                focus: (p, o.focus),
 1380|  1.97k|                patterns: o.patterns
 1381|  1.97k|            }
 1382|  1.97k|        }
 1383|  1.97k|
 1384|  1.97k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  1.97k|
 1386|  1.97k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  1.97k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  1.97k|                a.focus.push(b.focus);
 1389|  1.97k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  1.97k|                a
 1391|  1.97k|            })
 1392|  1.97k|        }
 1393|  1.97k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  1.97k|
 1395|  1.97k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  1.97k|            if let Some(a) = a {
 1397|  1.97k|                let mut patterns = g.patterns;
 1398|  1.97k|                patterns.extend(a.patterns);
 1399|  1.97k|                FocusedTriplePattern {
 1400|  1.97k|                    focus: AnnotatedTerm {
 1401|  1.97k|                        term: g.focus,
 1402|  1.97k|                        annotations: a.focus
 1403|  1.97k|                    },
 1404|  1.97k|                    patterns
 1405|  1.97k|                }
 1406|  1.97k|            } else {
 1407|  1.97k|                FocusedTriplePattern {
 1408|  1.97k|                    focus: AnnotatedTerm {
 1409|  1.97k|                        term: g.focus,
 1410|  1.97k|                        annotations: Vec::new()
 1411|  1.97k|                    },
 1412|  1.97k|                    patterns: g.patterns
 1413|  1.97k|                }
 1414|  1.97k|            }
 1415|  1.97k|        }
 1416|  1.97k|
 1417|  1.97k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  1.97k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  1.97k|                let mut patterns = po.patterns;
 1420|  1.97k|                for (p, os) in po.focus {
 1421|  1.97k|                    for o in os {
 1422|  1.97k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  1.97k|                    }
 1424|  1.97k|                }
 1425|  1.97k|                Ok(patterns)
 1426|  1.97k|            } /
 1427|  1.97k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  1.97k|                let mut patterns = s.patterns;
 1429|  1.97k|                patterns.extend(po.patterns);
 1430|  1.97k|                for (p, os) in po.focus {
 1431|  1.97k|                    for o in os {
 1432|  1.97k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  1.97k|                    }
 1434|  1.97k|                }
 1435|  1.97k|                Ok(patterns)
 1436|  1.97k|            }
 1437|  1.97k|
 1438|  1.97k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  1.97k|            PropertyListPathNotEmpty() /
 1440|  1.97k|            { FocusedTripleOrPathPattern::default() }
 1441|  1.97k|
 1442|  1.97k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  1.97k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  1.97k|                    focus: vec![(hp, ho.focus)],
 1445|  1.97k|                    patterns: ho.patterns
 1446|  1.97k|                }, |mut a, b| {
 1447|  1.97k|                    a.focus.push(b.focus);
 1448|  1.97k|                    a.patterns.extend(b.patterns);
 1449|  1.97k|                    a
 1450|  1.97k|                })
 1451|  1.97k|        }
 1452|  1.97k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  1.97k|            c
 1454|  1.97k|        }
 1455|  1.97k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  1.97k|            FocusedTripleOrPathPattern {
 1457|  1.97k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  1.97k|                patterns: o.patterns
 1459|  1.97k|            }
 1460|  1.97k|        }
 1461|  1.97k|
 1462|  1.97k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  1.97k|            p.into()
 1464|  1.97k|        }
 1465|  1.97k|
 1466|  1.97k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  1.97k|            v.into()
 1468|  1.97k|        }
 1469|  1.97k|
 1470|  1.97k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  1.97k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  1.97k|                a.focus.push(b.focus);
 1473|  1.97k|                a.patterns.extend(b.patterns);
 1474|  1.97k|                a
 1475|  1.97k|            })
 1476|  1.97k|        }
 1477|  1.97k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  1.97k|
 1479|  1.97k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  1.97k|             if let Some(a) = a {
 1481|  1.97k|                let mut patterns = g.patterns;
 1482|  1.97k|                patterns.extend(a.patterns);
 1483|  1.97k|                FocusedTripleOrPathPattern {
 1484|  1.97k|                    focus: AnnotatedTermPath {
 1485|  1.97k|                        term: g.focus,
 1486|  1.97k|                        annotations: a.focus
 1487|  1.97k|                    },
 1488|  1.97k|                    patterns
 1489|  1.97k|                }
 1490|  1.97k|            } else {
 1491|  1.97k|                FocusedTripleOrPathPattern {
 1492|  1.97k|                    focus: AnnotatedTermPath {
 1493|  1.97k|                        term: g.focus,
 1494|  1.97k|                        annotations: Vec::new()
 1495|  1.97k|                    },
 1496|  1.97k|                    patterns: g.patterns
 1497|  1.97k|                }
 1498|  1.97k|            }
 1499|  1.97k|        }
 1500|  1.97k|
 1501|  1.97k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  1.97k|
 1503|  1.97k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  1.97k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  1.97k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  1.97k|            })
 1507|  1.97k|        }
 1508|  1.97k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  1.97k|
 1510|  1.97k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  1.97k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  1.97k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  1.97k|            })
 1514|  1.97k|        }
 1515|  1.97k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  1.97k|
 1517|  1.97k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  1.97k|            match o {
 1519|  1.97k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  1.97k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  1.97k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  1.97k|                Some(_) => unreachable!(),
 1523|  1.97k|                None => p
 1524|  1.97k|            }
 1525|  1.97k|        }
 1526|  1.97k|        rule PathElt_op() -> char =
 1527|  1.97k|            "*" { '*' } /
 1528|  1.97k|            "+" { '+' } /
 1529|  1.97k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  1.97k|
 1531|  1.97k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  1.97k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  1.97k|            PathElt()
 1534|  1.97k|
 1535|  1.97k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  1.97k|            v:iri() { v.into() } /
 1537|  1.97k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  1.97k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  1.97k|            "(" _ p:Path() _ ")" { p }
 1540|  1.97k|
 1541|  1.97k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  1.97k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  1.97k|                let mut direct = Vec::new();
 1544|  1.97k|                let mut inverse = Vec::new();
 1545|  1.97k|                for e in p {
 1546|  1.97k|                    match e {
 1547|  1.97k|                        Either::Left(a) => direct.push(a),
 1548|  1.97k|                        Either::Right(b) => inverse.push(b)
 1549|  1.97k|                    }
 1550|  1.97k|                }
 1551|  1.97k|                if inverse.is_empty() {
 1552|  1.97k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  1.97k|                } else if direct.is_empty() {
 1554|  1.97k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  1.97k|                } else {
 1556|  1.97k|                    PropertyPathExpression::Alternative(
 1557|  1.97k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  1.97k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  1.97k|                    )
 1560|  1.97k|                }
 1561|  1.97k|            } /
 1562|  1.97k|            p:PathOneInPropertySet() {
 1563|  1.97k|                match p {
 1564|  1.97k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  1.97k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  1.97k|                }
 1567|  1.97k|            }
 1568|  1.97k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  1.97k|
 1570|  1.97k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  1.97k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  1.97k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  1.97k|            v:iri() { Either::Left(v) } /
 1574|  1.97k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  1.97k|
 1576|  1.97k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  1.97k|
 1578|  1.97k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  1.97k|            let mut patterns = po.patterns;
 1580|  1.97k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  1.97k|            for (p, os) in po.focus {
 1582|  1.97k|                for o in os {
 1583|  1.97k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  1.97k|                }
 1585|  1.97k|            }
 1586|  1.97k|            Ok(FocusedTriplePattern {
 1587|  1.97k|                focus: bnode,
 1588|  1.97k|                patterns
 1589|  1.97k|            })
 1590|  1.97k|        }
 1591|  1.97k|
 1592|  1.97k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  1.97k|
 1594|  1.97k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  1.97k|            let mut patterns = po.patterns;
 1596|  1.97k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  1.97k|            for (p, os) in po.focus {
 1598|  1.97k|                for o in os {
 1599|  1.97k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  1.97k|                }
 1601|  1.97k|            }
 1602|  1.97k|            Ok(FocusedTripleOrPathPattern {
 1603|  1.97k|                focus: bnode,
 1604|  1.97k|                patterns
 1605|  1.97k|            })
 1606|  1.97k|        }
 1607|  1.97k|
 1608|  1.97k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  1.97k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  1.97k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  1.97k|            for objWithPatterns in o.into_iter().rev() {
 1612|  1.97k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  1.97k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  1.97k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  1.97k|                current_list_node = new_blank_node;
 1616|  1.97k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  1.97k|            }
 1618|  1.97k|            FocusedTriplePattern {
 1619|  1.97k|                focus: current_list_node,
 1620|  1.97k|                patterns
 1621|  1.97k|            }
 1622|  1.97k|        }
 1623|  1.97k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  1.97k|
 1625|  1.97k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  1.97k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  1.97k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  1.97k|            for objWithPatterns in o.into_iter().rev() {
 1629|  1.97k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  1.97k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  1.97k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  1.97k|                current_list_node = new_blank_node;
 1633|  1.97k|                patterns.extend(objWithPatterns.patterns);
 1634|  1.97k|            }
 1635|  1.97k|            FocusedTripleOrPathPattern {
 1636|  1.97k|                focus: current_list_node,
 1637|  1.97k|                patterns
 1638|  1.97k|            }
 1639|  1.97k|        }
 1640|  1.97k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  1.97k|
 1642|  1.97k|
 1643|  1.97k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  1.97k|
 1645|  1.97k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  1.97k|
 1647|  1.97k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  1.97k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  1.97k|            TriplesNode()
 1650|  1.97k|
 1651|  1.97k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  1.97k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  1.97k|            TriplesNodePath()
 1654|  1.97k|
 1655|  1.97k|        rule VarOrTerm() -> TermPattern =
 1656|  1.97k|            v:Var() { v.into() } /
 1657|  1.97k|            t:QuotedTriple() {?
 1658|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  1.97k|            } /
 1661|  1.97k|            t:GraphTerm() { t.into() }
 1662|  1.97k|
 1663|  1.97k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  1.97k|            Ok(TriplePattern {
 1665|  1.97k|                subject: s,
 1666|  1.97k|                predicate: p,
 1667|  1.97k|                object: o
 1668|  1.97k|            })
 1669|  1.97k|        }
 1670|  1.97k|
 1671|  1.97k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  1.97k|            Ok(GroundTriple {
 1673|  1.97k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  1.97k|                predicate: p,
 1675|  1.97k|                object: o
 1676|  1.97k|            })
 1677|  1.97k|        }
 1678|  1.97k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  1.97k|
 1680|  1.97k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  1.97k|            l:RDFLiteral() { l.into() } /
 1682|  1.97k|            l:NumericLiteral() { l.into() } /
 1683|  1.97k|            l:BooleanLiteral() { l.into() } /
 1684|  1.97k|            t:QuotedTripleData() {?
 1685|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  1.97k|            }
 1688|  1.97k|
 1689|  1.97k|        rule VarOrIri() -> NamedNodePattern =
 1690|  1.97k|            v:Var() { v.into() } /
 1691|  1.97k|            i:iri() { i.into() }
 1692|  1.97k|
 1693|  1.97k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  1.97k|
 1695|  1.97k|        rule GraphTerm() -> Term =
 1696|  1.97k|            i:iri() { i.into() } /
 1697|  1.97k|            l:RDFLiteral() { l.into() } /
 1698|  1.97k|            l:NumericLiteral() { l.into() } /
 1699|  1.97k|            l:BooleanLiteral() { l.into() } /
 1700|  1.97k|            b:BlankNode() { b.into() } /
 1701|  1.97k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  1.97k|
 1703|  1.97k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  1.97k|
 1705|  1.97k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  1.97k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  1.97k|        }
 1708|  1.97k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  1.97k|
 1710|  1.97k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  1.97k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  1.97k|        }
 1713|  1.97k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  1.97k|
 1715|  1.97k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  1.97k|
 1717|  1.97k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  1.97k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  1.97k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  1.97k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  1.97k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  1.97k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  1.97k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  1.97k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  1.97k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  1.97k|            Some(_) => unreachable!(),
 1727|  1.97k|            None => a
 1728|  1.97k|        } }
 1729|  1.97k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  1.97k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  1.97k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  1.97k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  1.97k|
 1734|  1.97k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  1.97k|
 1736|  1.97k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  1.97k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  1.97k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  1.97k|            Some(_) => unreachable!(),
 1740|  1.97k|            None => a,
 1741|  1.97k|        } }
 1742|  1.97k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  1.97k|            (s, e)
 1744|  1.97k|        }
 1745|  1.97k|
 1746|  1.97k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  1.97k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  1.97k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  1.97k|            Some(_) => unreachable!(),
 1750|  1.97k|            None => a
 1751|  1.97k|        } }
 1752|  1.97k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  1.97k|            (s, e)
 1754|  1.97k|        }
 1755|  1.97k|
 1756|  1.97k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  1.97k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  1.97k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  1.97k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  1.97k|            Some(_) => unreachable!(),
 1761|  1.97k|            None => e,
 1762|  1.97k|        } }
 1763|  1.97k|
 1764|  1.97k|        rule PrimaryExpression() -> Expression =
 1765|  1.97k|            BrackettedExpression()  /
 1766|  1.97k|            ExprQuotedTriple() /
 1767|  1.97k|            iriOrFunction() /
 1768|  1.97k|            v:Var() { v.into() } /
 1769|  1.97k|            l:RDFLiteral() { l.into() } /
 1770|  1.97k|            l:NumericLiteral() { l.into() } /
 1771|  1.97k|            l:BooleanLiteral() { l.into() } /
 1772|  1.97k|            BuiltInCall()
 1773|  1.97k|
 1774|  1.97k|        rule ExprVarOrTerm() -> Expression =
 1775|  1.97k|            ExprQuotedTriple() /
 1776|  1.97k|            i:iri() { i.into() } /
 1777|  1.97k|            l:RDFLiteral() { l.into() } /
 1778|  1.97k|            l:NumericLiteral() { l.into() } /
 1779|  1.97k|            l:BooleanLiteral() { l.into() } /
 1780|  1.97k|            v:Var() { v.into() }
 1781|  1.97k|
 1782|  1.97k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  1.97k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  1.97k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  1.97k|        }
 1786|  1.97k|
 1787|  1.97k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  1.97k|
 1789|  1.97k|        rule BuiltInCall() -> Expression =
 1790|  1.97k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  1.97k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  1.97k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  1.97k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  1.97k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  1.97k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  1.97k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  1.97k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  1.97k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  1.97k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  1.97k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  1.97k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  1.97k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  1.97k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  1.97k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  1.97k|            SubstringExpression() /
 1806|  1.97k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  1.97k|            StrReplaceExpression() /
 1808|  1.97k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  1.97k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  1.97k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  1.97k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  1.97k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  1.97k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  1.97k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  1.97k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  1.97k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  1.97k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  1.97k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  1.97k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  1.97k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  1.97k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  1.97k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  1.97k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  1.97k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  1.97k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  1.97k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  1.97k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  1.97k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  1.97k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  1.97k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  1.97k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  1.97k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  1.97k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  1.97k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  1.97k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  1.97k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  1.97k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  1.97k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  1.97k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  1.97k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  1.97k|            RegexExpression() /
 1842|  1.97k|            ExistsFunc() /
 1843|  1.97k|            NotExistsFunc() /
 1844|  1.97k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  1.97k|            } /
 1848|  1.97k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  1.97k|            } /
 1852|  1.97k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  1.97k|            } /
 1856|  1.97k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  1.97k|            } /
 1860|  1.97k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  1.97k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  1.97k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  1.97k|            } /
 1864|  1.97k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  1.97k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  1.97k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  1.97k|            }
 1868|  1.97k|
 1869|  1.97k|        rule RegexExpression() -> Expression =
 1870|  1.97k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  1.97k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  1.97k|
 1873|  1.97k|
 1874|  1.97k|        rule SubstringExpression() -> Expression =
 1875|  1.97k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  1.97k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  1.97k|
 1878|  1.97k|
 1879|  1.97k|        rule StrReplaceExpression() -> Expression =
 1880|  1.97k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  1.97k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  1.97k|
 1883|  1.97k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  1.97k|
 1885|  1.97k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  1.97k|
 1887|  1.97k|        rule Aggregate() -> AggregateExpression =
 1888|  1.97k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  1.97k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  1.97k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  1.97k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  1.97k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  1.97k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  1.97k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  1.97k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  1.97k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  1.97k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  1.97k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  1.97k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  1.97k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  1.97k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  1.97k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  1.97k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  1.97k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  1.97k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  1.97k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  1.97k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  1.97k|
 1909|  1.97k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  1.97k|            match a {
 1911|  1.97k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  1.97k|                None => i.into()
 1913|  1.97k|            }
 1914|  1.97k|        }
 1915|  1.97k|
 1916|  1.97k|        rule RDFLiteral() -> Literal =
 1917|  1.97k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  1.97k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  1.97k|            value:String() { Literal::new_simple_literal(value) }
 1920|  1.97k|
 1921|  1.97k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  1.97k|
 1923|  1.97k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  1.97k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  1.97k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  1.97k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  1.97k|
 1928|  1.97k|        rule NumericLiteralPositive() -> Literal =
 1929|  1.97k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  1.97k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  1.97k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  1.97k|
 1933|  1.97k|
 1934|  1.97k|        rule NumericLiteralNegative() -> Literal =
 1935|  1.97k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  1.97k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  1.97k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  1.97k|
 1939|  1.97k|        rule BooleanLiteral() -> Literal =
 1940|  1.97k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  1.97k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  1.97k|
 1943|  1.97k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  1.97k|
 1945|  1.97k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  1.97k|            NamedNode::from(i)
 1947|  1.97k|        }
 1948|  1.97k|
 1949|  1.97k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  1.97k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  1.97k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  1.97k|            } else {
 1953|  1.97k|                Err("Prefix not found")
 1954|  1.97k|            } }
 1955|  1.97k|
 1956|  1.97k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  1.97k|            let node = BlankNode::new_unchecked(id);
 1958|  1.97k|            if state.used_bnodes.contains(&node) {
 1959|  1.97k|                Err("Already used blank node id")
 1960|  1.97k|            } else {
 1961|  1.97k|                state.currently_used_bnodes.insert(node.clone());
 1962|  1.97k|                Ok(node)
 1963|  1.97k|            }
 1964|  1.97k|        } / ANON() { BlankNode::default() }
 1965|  1.97k|
 1966|  1.97k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  1.97k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  1.97k|        }
 1969|  1.97k|
 1970|  1.97k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  1.97k|            ns
 1972|  1.97k|        }
 1973|  1.97k|
 1974|  1.97k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  1.97k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  1.97k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  1.97k|                iri.push_str(base);
 1978|  1.97k|                for chunk in local.split('\\') { // We remove \
 1979|  1.97k|                    iri.push_str(chunk);
 1980|  1.97k|                }
 1981|  1.97k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  1.97k|            } else {
 1983|  1.97k|                Err("Prefix not found")
 1984|  1.97k|            }
 1985|  1.97k|        }
 1986|  1.97k|
 1987|  1.97k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  1.97k|            b
 1989|  1.97k|        }
 1990|  1.97k|
 1991|  1.97k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  1.97k|
 1993|  1.97k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  1.97k|
 1995|  1.97k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  1.97k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  1.97k|        }
 1998|  1.97k|
 1999|  1.97k|        rule INTEGER() = ['0'..='9']+
 2000|  1.97k|
 2001|  1.97k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  1.97k|
 2003|  1.97k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  1.97k|
 2005|  1.97k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  1.97k|
 2007|  1.97k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  1.97k|
 2009|  1.97k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  1.97k|
 2011|  1.97k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  1.97k|
 2013|  1.97k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  1.97k|
 2015|  1.97k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  1.97k|
 2017|  1.97k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  1.97k|
 2019|  1.97k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  1.97k|             unescape_string(l)
 2021|  1.97k|        }
 2022|  1.97k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  1.97k|
 2024|  1.97k|
 2025|  1.97k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  1.97k|             unescape_string(l)
 2027|  1.97k|        }
 2028|  1.97k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  1.97k|
 2030|  1.97k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  1.97k|             unescape_string(l)
 2032|  1.97k|        }
 2033|  1.97k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  1.97k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  1.97k|
 2036|  1.97k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  1.97k|             unescape_string(l)
 2038|  1.97k|        }
 2039|  1.97k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  1.97k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  1.97k|
 2042|  1.97k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  1.97k|
 2044|  1.97k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  1.97k|
 2046|  1.97k|        rule NIL() = "(" WS()* ")"
 2047|  1.97k|
 2048|  1.97k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  1.97k|
 2050|  1.97k|        rule ANON() = "[" WS()* "]"
 2051|  1.97k|
 2052|  1.97k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  1.97k|
 2054|  1.97k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  1.97k|
 2056|  1.97k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  1.97k|
 2058|  1.97k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  1.97k|
 2060|  1.97k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  1.97k|
 2062|  1.97k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  1.97k|
 2064|  1.97k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  1.97k|
 2066|  1.97k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  1.97k|
 2068|  1.97k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  1.97k|
 2070|  1.97k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  1.97k|
 2072|  1.97k|        //space
 2073|  1.97k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  1.97k|
 2075|  1.97k|        //comment
 2076|  1.97k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  1.97k|
 2078|  1.97k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  1.97k|            if input.eq_ignore_ascii_case(literal) {
 2080|  1.97k|                Ok(())
 2081|  1.97k|            } else {
 2082|  1.97k|                Err(literal)
 2083|  1.97k|            }
 2084|  1.97k|        }
 2085|  1.97k|    }
 2086|  1.97k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_ValuesClause0B7_:
  970|     77|            i("VALUES") _ p:DataBlock() { Some(p) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_QuadsNotTriples0B7_:
 1163|  14.8k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  14.8k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_InlineDataFull0B7_:
  778|    199|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|    199|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|    199|                Ok((vars, vals))
 1288|       |            } else {
 1289|      0|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GroupGraphPattern0B7_:
 1173|  3.25k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_InlineData0B7_:
 1274|    171|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_TriplesSameSubjectPath0B7_:
  778|  1.06k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|       |                let mut patterns = po.patterns;
 1348|       |                for (p, os) in po.focus {
 1349|       |                    for o in os {
 1350|       |                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|       |                Ok(patterns)
 1354|       |            } /
 1355|       |            s:TriplesNode() _ po:PropertyList() {?
 1356|       |                let mut patterns = s.patterns;
 1357|       |                patterns.extend(po.patterns);
 1358|       |                for (p, os) in po.focus {
 1359|       |                    for o in os {
 1360|       |                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|       |                    }
 1362|       |                }
 1363|       |                Ok(patterns)
 1364|       |            }
 1365|       |
 1366|       |        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|       |            PropertyListNotEmpty() /
 1368|       |            { FocusedTriplePattern::default() }
 1369|       |
 1370|       |        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|       |            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|       |            })
 1376|       |        }
 1377|       |        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|       |            FocusedTriplePattern {
 1379|       |                focus: (p, o.focus),
 1380|       |                patterns: o.patterns
 1381|       |            }
 1382|       |        }
 1383|       |
 1384|       |        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|       |
 1386|       |        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|       |            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|       |            })
 1392|       |        }
 1393|       |        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|       |
 1395|       |        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|       |            if let Some(a) = a {
 1397|       |                let mut patterns = g.patterns;
 1398|       |                patterns.extend(a.patterns);
 1399|       |                FocusedTriplePattern {
 1400|       |                    focus: AnnotatedTerm {
 1401|       |                        term: g.focus,
 1402|       |                        annotations: a.focus
 1403|       |                    },
 1404|       |                    patterns
 1405|       |                }
 1406|       |            } else {
 1407|       |                FocusedTriplePattern {
 1408|       |                    focus: AnnotatedTerm {
 1409|       |                        term: g.focus,
 1410|       |                        annotations: Vec::new()
 1411|       |                    },
 1412|       |                    patterns: g.patterns
 1413|       |                }
 1414|       |            }
 1415|       |        }
 1416|       |
 1417|       |        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|       |            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  1.06k|                let mut patterns = po.patterns;
 1420|  2.20k|                for (p, os) in po.focus {
 1421|  3.05k|                    for o in os {
 1422|  1.91k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|       |                    }
 1424|       |                }
 1425|  1.06k|                Ok(patterns)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValues2_0B7_:
 1304|     33|            l:BooleanLiteral() { Some(l.into()) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PathElt_ops0_0B7_:
 1529|  4.89k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_PathAlternative0B7_:
  778|  23.9k|parser! {
  779|  23.9k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  23.9k|    grammar parser(state: &mut ParserState) for str {
  781|  23.9k|        pub rule QueryUnit() -> Query = Query()
  782|  23.9k|
  783|  23.9k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  23.9k|            q
  785|  23.9k|        }
  786|  23.9k|
  787|  23.9k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  23.9k|
  789|  23.9k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  23.9k|
  791|  23.9k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  23.9k|            state.base_iri = Some(i)
  793|  23.9k|        }
  794|  23.9k|
  795|  23.9k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  23.9k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  23.9k|        }
  798|  23.9k|
  799|  23.9k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  23.9k|            Ok(Query::Select {
  801|  23.9k|                dataset: d,
  802|  23.9k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  23.9k|                base_iri: state.base_iri.clone()
  804|  23.9k|            })
  805|  23.9k|        }
  806|  23.9k|
  807|  23.9k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  23.9k|            build_select(s, w, g, h, o, l, v, state)
  809|  23.9k|        }
  810|  23.9k|
  811|  23.9k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  23.9k|            Selection {
  813|  23.9k|                option: o,
  814|  23.9k|                variables: v
  815|  23.9k|            }
  816|  23.9k|        }
  817|  23.9k|        rule Selection_init() = {
  818|  23.9k|            state.aggregates.push(Vec::new())
  819|  23.9k|        }
  820|  23.9k|        rule SelectClause_option() -> SelectionOption =
  821|  23.9k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  23.9k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  23.9k|            { SelectionOption::Default }
  824|  23.9k|        rule SelectClause_variables() -> SelectionVariables =
  825|  23.9k|            "*" { SelectionVariables::Star } /
  826|  23.9k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  23.9k|        rule SelectClause_member() -> SelectionMember =
  828|  23.9k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  23.9k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  23.9k|
  831|  23.9k|        rule ConstructQuery() -> Query =
  832|  23.9k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  23.9k|                Ok(Query::Construct {
  834|  23.9k|                    template: c,
  835|  23.9k|                    dataset: d,
  836|  23.9k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  23.9k|                    base_iri: state.base_iri.clone()
  838|  23.9k|                })
  839|  23.9k|            } /
  840|  23.9k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  23.9k|                Ok(Query::Construct {
  842|  23.9k|                    template: c.clone(),
  843|  23.9k|                    dataset: d,
  844|  23.9k|                    pattern: build_select(
  845|  23.9k|                        Selection::no_op(),
  846|  23.9k|                        GraphPattern::Bgp { patterns: c },
  847|  23.9k|                        g, h, o, l, v, state
  848|  23.9k|                    )?,
  849|  23.9k|                    base_iri: state.base_iri.clone()
  850|  23.9k|                })
  851|  23.9k|            }
  852|  23.9k|
  853|  23.9k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  23.9k|
  855|  23.9k|        rule DescribeQuery() -> Query =
  856|  23.9k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  23.9k|                Ok(Query::Describe {
  858|  23.9k|                    dataset: d,
  859|  23.9k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  23.9k|                    base_iri: state.base_iri.clone()
  861|  23.9k|                })
  862|  23.9k|            } /
  863|  23.9k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  23.9k|                Ok(Query::Describe {
  865|  23.9k|                    dataset: d,
  866|  23.9k|                    pattern: build_select(Selection {
  867|  23.9k|                        option: SelectionOption::Default,
  868|  23.9k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  23.9k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  23.9k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  23.9k|                        }).collect())
  872|  23.9k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  23.9k|                    base_iri: state.base_iri.clone()
  874|  23.9k|                })
  875|  23.9k|            }
  876|  23.9k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  23.9k|
  878|  23.9k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  23.9k|            Ok(Query::Ask {
  880|  23.9k|                dataset: d,
  881|  23.9k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  23.9k|                base_iri: state.base_iri.clone()
  883|  23.9k|            })
  884|  23.9k|        }
  885|  23.9k|
  886|  23.9k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  23.9k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  23.9k|            if d.is_empty() {
  889|  23.9k|                return None;
  890|  23.9k|            }
  891|  23.9k|            let mut default = Vec::new();
  892|  23.9k|            let mut named = Vec::new();
  893|  23.9k|            for (d, n) in d {
  894|  23.9k|                if let Some(d) = d {
  895|  23.9k|                    default.push(d);
  896|  23.9k|                }
  897|  23.9k|                if let Some(n) = n {
  898|  23.9k|                    named.push(n);
  899|  23.9k|                }
  900|  23.9k|            }
  901|  23.9k|            Some(QueryDataset {
  902|  23.9k|                default, named: Some(named)
  903|  23.9k|            })
  904|  23.9k|        }
  905|  23.9k|
  906|  23.9k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  23.9k|            (Some(s), None)
  908|  23.9k|        }
  909|  23.9k|
  910|  23.9k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  23.9k|            (None, Some(s))
  912|  23.9k|        }
  913|  23.9k|
  914|  23.9k|        rule SourceSelector() -> NamedNode = iri()
  915|  23.9k|
  916|  23.9k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  23.9k|            p
  918|  23.9k|        }
  919|  23.9k|
  920|  23.9k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  23.9k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  23.9k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  23.9k|                if let Expression::Variable(v) = e {
  924|  23.9k|                    v
  925|  23.9k|                } else {
  926|  23.9k|                    let v = vo.unwrap_or_else(variable);
  927|  23.9k|                    projections.push((e, v.clone()));
  928|  23.9k|                    v
  929|  23.9k|                }
  930|  23.9k|            }).collect();
  931|  23.9k|            (clauses, projections)
  932|  23.9k|        }
  933|  23.9k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  23.9k|
  935|  23.9k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  23.9k|            e:BuiltInCall() { (e, None) } /
  937|  23.9k|            e:FunctionCall() { (e, None) } /
  938|  23.9k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  23.9k|            e:Var() { (e.into(), None) }
  940|  23.9k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  23.9k|
  942|  23.9k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  23.9k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  23.9k|        }
  945|  23.9k|
  946|  23.9k|        rule HavingCondition() -> Expression = Constraint()
  947|  23.9k|
  948|  23.9k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  23.9k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  23.9k|
  951|  23.9k|        rule OrderCondition() -> OrderExpression =
  952|  23.9k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  23.9k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  23.9k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  23.9k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  23.9k|
  957|  23.9k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  23.9k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  23.9k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  23.9k|
  961|  23.9k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  23.9k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  23.9k|        }
  964|  23.9k|
  965|  23.9k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  23.9k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  23.9k|        }
  968|  23.9k|
  969|  23.9k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  23.9k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  23.9k|            { None }
  972|  23.9k|
  973|  23.9k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  23.9k|
  975|  23.9k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  23.9k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  23.9k|
  978|  23.9k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  23.9k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  23.9k|        }
  981|  23.9k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  23.9k|
  983|  23.9k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  23.9k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  23.9k|        }
  986|  23.9k|
  987|  23.9k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  23.9k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  23.9k|        }
  990|  23.9k|
  991|  23.9k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  23.9k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  23.9k|        }
  994|  23.9k|
  995|  23.9k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  23.9k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  23.9k|            if from == to {
  998|  23.9k|                Vec::new() // identity case
  999|  23.9k|            } else {
 1000|  23.9k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  23.9k|                vec![copy_graph(from, to)]
 1002|  23.9k|            }
 1003|  23.9k|        }
 1004|  23.9k|
 1005|  23.9k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  23.9k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  23.9k|            if from == to {
 1008|  23.9k|                Vec::new() // identity case
 1009|  23.9k|            } else {
 1010|  23.9k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  23.9k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  23.9k|            }
 1013|  23.9k|        }
 1014|  23.9k|
 1015|  23.9k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  23.9k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  23.9k|            if from == to {
 1018|  23.9k|                Vec::new() // identity case
 1019|  23.9k|            } else {
 1020|  23.9k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  23.9k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  23.9k|            }
 1023|  23.9k|        }
 1024|  23.9k|
 1025|  23.9k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  23.9k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  23.9k|        }
 1028|  23.9k|
 1029|  23.9k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  23.9k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  23.9k|        }
 1032|  23.9k|
 1033|  23.9k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  23.9k|            let pattern = d.iter().map(|q| {
 1035|  23.9k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  23.9k|                match &q.graph_name {
 1037|  23.9k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  23.9k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  23.9k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  23.9k|                }
 1041|  23.9k|            }).reduce(new_join).unwrap_or_default();
 1042|  23.9k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  23.9k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  23.9k|                delete,
 1045|  23.9k|                insert: Vec::new(),
 1046|  23.9k|                using: None,
 1047|  23.9k|                pattern: Box::new(pattern)
 1048|  23.9k|            }])
 1049|  23.9k|        }
 1050|  23.9k|
 1051|  23.9k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  23.9k|            let (delete, insert) = c;
 1053|  23.9k|            let mut delete = delete.unwrap_or_default();
 1054|  23.9k|            let mut insert = insert.unwrap_or_default();
 1055|  23.9k|            #[allow(clippy::shadow_same)]
 1056|  23.9k|            let mut pattern = pattern;
 1057|  23.9k|
 1058|  23.9k|            let mut using = if u.is_empty() {
 1059|  23.9k|                None
 1060|  23.9k|            } else {
 1061|  23.9k|                let mut default = Vec::new();
 1062|  23.9k|                let mut named = Vec::new();
 1063|  23.9k|                for (d, n) in u {
 1064|  23.9k|                    if let Some(d) = d {
 1065|  23.9k|                        default.push(d)
 1066|  23.9k|                    }
 1067|  23.9k|                    if let Some(n) = n {
 1068|  23.9k|                        named.push(n)
 1069|  23.9k|                    }
 1070|  23.9k|                }
 1071|  23.9k|                Some(QueryDataset { default, named: Some(named) })
 1072|  23.9k|            };
 1073|  23.9k|
 1074|  23.9k|            if let Some(with) = with {
 1075|  23.9k|                // We inject WITH everywhere
 1076|  23.9k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  23.9k|                    GroundQuadPattern {
 1078|  23.9k|                        subject: q.subject,
 1079|  23.9k|                        predicate: q.predicate,
 1080|  23.9k|                        object: q.object,
 1081|  23.9k|                        graph_name: with.clone().into()
 1082|  23.9k|                    }
 1083|  23.9k|                } else {
 1084|  23.9k|                    q
 1085|  23.9k|                }).collect();
 1086|  23.9k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  23.9k|                    QuadPattern {
 1088|  23.9k|                        subject: q.subject,
 1089|  23.9k|                        predicate: q.predicate,
 1090|  23.9k|                        object: q.object,
 1091|  23.9k|                        graph_name: with.clone().into()
 1092|  23.9k|                    }
 1093|  23.9k|                } else {
 1094|  23.9k|                    q
 1095|  23.9k|                }).collect();
 1096|  23.9k|                if using.is_none() {
 1097|  23.9k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  23.9k|                }
 1099|  23.9k|            }
 1100|  23.9k|
 1101|  23.9k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  23.9k|                delete,
 1103|  23.9k|                insert,
 1104|  23.9k|                using,
 1105|  23.9k|                pattern: Box::new(pattern)
 1106|  23.9k|            }]
 1107|  23.9k|        }
 1108|  23.9k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  23.9k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  23.9k|            (Some(d), i)
 1111|  23.9k|        } / i:InsertClause() {
 1112|  23.9k|            (None, Some(i))
 1113|  23.9k|        }
 1114|  23.9k|        rule Modify_clear() = {
 1115|  23.9k|            state.used_bnodes.clear();
 1116|  23.9k|            state.currently_used_bnodes.clear();
 1117|  23.9k|        }
 1118|  23.9k|
 1119|  23.9k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  23.9k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  23.9k|        }
 1122|  23.9k|
 1123|  23.9k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  23.9k|
 1125|  23.9k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  23.9k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  23.9k|            (Some(i), None)
 1128|  23.9k|        }
 1129|  23.9k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  23.9k|            (None, Some(i))
 1131|  23.9k|        }
 1132|  23.9k|
 1133|  23.9k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  23.9k|            GraphName::DefaultGraph
 1135|  23.9k|        } / (i("GRAPH") _)? g:iri() {
 1136|  23.9k|            GraphName::NamedNode(g)
 1137|  23.9k|        }
 1138|  23.9k|
 1139|  23.9k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  23.9k|
 1141|  23.9k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  23.9k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  23.9k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  23.9k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  23.9k|
 1146|  23.9k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  23.9k|
 1148|  23.9k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  23.9k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  23.9k|        }
 1151|  23.9k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  23.9k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  23.9k|        }
 1154|  23.9k|
 1155|  23.9k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  23.9k|            q.into_iter().flatten().collect()
 1157|  23.9k|        }
 1158|  23.9k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  23.9k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  23.9k|        } //TODO: return iter?
 1161|  23.9k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  23.9k|
 1163|  23.9k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  23.9k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  23.9k|        }
 1166|  23.9k|
 1167|  23.9k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  23.9k|            ts.into_iter().flatten().collect()
 1169|  23.9k|        }
 1170|  23.9k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  23.9k|
 1172|  23.9k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  23.9k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  23.9k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  23.9k|        rule GroupGraphPattern_clear() = {
 1176|  23.9k|             // We deal with blank nodes aliases rule
 1177|  23.9k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  23.9k|            state.currently_used_bnodes.clear();
 1179|  23.9k|        }
 1180|  23.9k|
 1181|  23.9k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  23.9k|            let mut filter: Option<Expression> = None;
 1183|  23.9k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  23.9k|            for e in b.into_iter().flatten() {
 1185|  23.9k|                match e {
 1186|  23.9k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  23.9k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  23.9k|                    }
 1189|  23.9k|                    #[cfg(feature = "sep-0006")]
 1190|  23.9k|                    PartialGraphPattern::Lateral(p) => {
 1191|  23.9k|                        let mut defined_variables = HashSet::default();
 1192|  23.9k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  23.9k|                        let mut contains = false;
 1194|  23.9k|                        g.on_in_scope_variable(|v| {
 1195|  23.9k|                            if defined_variables.contains(v) {
 1196|  23.9k|                                contains = true;
 1197|  23.9k|                            }
 1198|  23.9k|                        });
 1199|  23.9k|                        if contains {
 1200|  23.9k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  23.9k|                        }
 1202|  23.9k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  23.9k|                    }
 1204|  23.9k|                    PartialGraphPattern::Minus(p) => {
 1205|  23.9k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  23.9k|                    }
 1207|  23.9k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  23.9k|                        let mut contains = false;
 1209|  23.9k|                        g.on_in_scope_variable(|v| {
 1210|  23.9k|                            if *v == variable {
 1211|  23.9k|                                contains = true;
 1212|  23.9k|                            }
 1213|  23.9k|                        });
 1214|  23.9k|                        if contains {
 1215|  23.9k|                            return Err("BIND is overriding an existing variable")
 1216|  23.9k|                        }
 1217|  23.9k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  23.9k|                    }
 1219|  23.9k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  23.9k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  23.9k|                    } else {
 1222|  23.9k|                        expr
 1223|  23.9k|                    }),
 1224|  23.9k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  23.9k|                }
 1226|  23.9k|            }
 1227|  23.9k|
 1228|  23.9k|            Ok(if let Some(expr) = filter {
 1229|  23.9k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  23.9k|            } else {
 1231|  23.9k|                g
 1232|  23.9k|            })
 1233|  23.9k|        }
 1234|  23.9k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  23.9k|            let mut result = vec![a];
 1236|  23.9k|            if let Some(v) = b {
 1237|  23.9k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  23.9k|            }
 1239|  23.9k|            result
 1240|  23.9k|        }
 1241|  23.9k|
 1242|  23.9k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  23.9k|            hs.into_iter().flatten().collect()
 1244|  23.9k|        }
 1245|  23.9k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  23.9k|
 1247|  23.9k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  23.9k|
 1249|  23.9k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  23.9k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  23.9k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  23.9k|            } else {
 1253|  23.9k|               PartialGraphPattern::Optional(p, None)
 1254|  23.9k|            }
 1255|  23.9k|        }
 1256|  23.9k|
 1257|  23.9k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  23.9k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  23.9k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  23.9k|        }
 1261|  23.9k|
 1262|  23.9k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  23.9k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  23.9k|        }
 1265|  23.9k|
 1266|  23.9k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  23.9k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  23.9k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  23.9k|
 1270|  23.9k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  23.9k|            PartialGraphPattern::Bind(e, v)
 1272|  23.9k|        }
 1273|  23.9k|
 1274|  23.9k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  23.9k|
 1276|  23.9k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  23.9k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  23.9k|        }
 1279|  23.9k|
 1280|  23.9k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  23.9k|            (vec![var], d)
 1282|  23.9k|        }
 1283|  23.9k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  23.9k|
 1285|  23.9k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  23.9k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  23.9k|                Ok((vars, vals))
 1288|  23.9k|            } else {
 1289|  23.9k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  23.9k|            }
 1291|  23.9k|        }
 1292|  23.9k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  23.9k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  23.9k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  23.9k|
 1296|  23.9k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  23.9k|            t:QuotedTripleData() {?
 1298|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  23.9k|            } /
 1301|  23.9k|            i:iri() { Some(i.into()) } /
 1302|  23.9k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  23.9k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  23.9k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  23.9k|            i("UNDEF") { None }
 1306|  23.9k|
 1307|  23.9k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  23.9k|            PartialGraphPattern::Minus(p)
 1309|  23.9k|        }
 1310|  23.9k|
 1311|  23.9k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  23.9k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  23.9k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  23.9k|            }).map(PartialGraphPattern::Other)
 1315|  23.9k|        }
 1316|  23.9k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  23.9k|
 1318|  23.9k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  23.9k|            PartialGraphPattern::Filter(c)
 1320|  23.9k|        }
 1321|  23.9k|
 1322|  23.9k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  23.9k|
 1324|  23.9k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  23.9k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  23.9k|        }
 1327|  23.9k|
 1328|  23.9k|        rule ArgList() -> Vec<Expression> =
 1329|  23.9k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  23.9k|            NIL() { Vec::new() }
 1331|  23.9k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  23.9k|
 1333|  23.9k|        rule ExpressionList() -> Vec<Expression> =
 1334|  23.9k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  23.9k|            NIL() { Vec::new() }
 1336|  23.9k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  23.9k|
 1338|  23.9k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  23.9k|
 1340|  23.9k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  23.9k|            p.into_iter().flatten().collect()
 1342|  23.9k|        }
 1343|  23.9k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  23.9k|
 1345|  23.9k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  23.9k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  23.9k|                let mut patterns = po.patterns;
 1348|  23.9k|                for (p, os) in po.focus {
 1349|  23.9k|                    for o in os {
 1350|  23.9k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  23.9k|                    }
 1352|  23.9k|                }
 1353|  23.9k|                Ok(patterns)
 1354|  23.9k|            } /
 1355|  23.9k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  23.9k|                let mut patterns = s.patterns;
 1357|  23.9k|                patterns.extend(po.patterns);
 1358|  23.9k|                for (p, os) in po.focus {
 1359|  23.9k|                    for o in os {
 1360|  23.9k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  23.9k|                    }
 1362|  23.9k|                }
 1363|  23.9k|                Ok(patterns)
 1364|  23.9k|            }
 1365|  23.9k|
 1366|  23.9k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  23.9k|            PropertyListNotEmpty() /
 1368|  23.9k|            { FocusedTriplePattern::default() }
 1369|  23.9k|
 1370|  23.9k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  23.9k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  23.9k|                a.focus.push(b.focus);
 1373|  23.9k|                a.patterns.extend(b.patterns);
 1374|  23.9k|                a
 1375|  23.9k|            })
 1376|  23.9k|        }
 1377|  23.9k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  23.9k|            FocusedTriplePattern {
 1379|  23.9k|                focus: (p, o.focus),
 1380|  23.9k|                patterns: o.patterns
 1381|  23.9k|            }
 1382|  23.9k|        }
 1383|  23.9k|
 1384|  23.9k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  23.9k|
 1386|  23.9k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  23.9k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  23.9k|                a.focus.push(b.focus);
 1389|  23.9k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  23.9k|                a
 1391|  23.9k|            })
 1392|  23.9k|        }
 1393|  23.9k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  23.9k|
 1395|  23.9k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  23.9k|            if let Some(a) = a {
 1397|  23.9k|                let mut patterns = g.patterns;
 1398|  23.9k|                patterns.extend(a.patterns);
 1399|  23.9k|                FocusedTriplePattern {
 1400|  23.9k|                    focus: AnnotatedTerm {
 1401|  23.9k|                        term: g.focus,
 1402|  23.9k|                        annotations: a.focus
 1403|  23.9k|                    },
 1404|  23.9k|                    patterns
 1405|  23.9k|                }
 1406|  23.9k|            } else {
 1407|  23.9k|                FocusedTriplePattern {
 1408|  23.9k|                    focus: AnnotatedTerm {
 1409|  23.9k|                        term: g.focus,
 1410|  23.9k|                        annotations: Vec::new()
 1411|  23.9k|                    },
 1412|  23.9k|                    patterns: g.patterns
 1413|  23.9k|                }
 1414|  23.9k|            }
 1415|  23.9k|        }
 1416|  23.9k|
 1417|  23.9k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  23.9k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  23.9k|                let mut patterns = po.patterns;
 1420|  23.9k|                for (p, os) in po.focus {
 1421|  23.9k|                    for o in os {
 1422|  23.9k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  23.9k|                    }
 1424|  23.9k|                }
 1425|  23.9k|                Ok(patterns)
 1426|  23.9k|            } /
 1427|  23.9k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  23.9k|                let mut patterns = s.patterns;
 1429|  23.9k|                patterns.extend(po.patterns);
 1430|  23.9k|                for (p, os) in po.focus {
 1431|  23.9k|                    for o in os {
 1432|  23.9k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  23.9k|                    }
 1434|  23.9k|                }
 1435|  23.9k|                Ok(patterns)
 1436|  23.9k|            }
 1437|  23.9k|
 1438|  23.9k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  23.9k|            PropertyListPathNotEmpty() /
 1440|  23.9k|            { FocusedTripleOrPathPattern::default() }
 1441|  23.9k|
 1442|  23.9k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  23.9k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  23.9k|                    focus: vec![(hp, ho.focus)],
 1445|  23.9k|                    patterns: ho.patterns
 1446|  23.9k|                }, |mut a, b| {
 1447|  23.9k|                    a.focus.push(b.focus);
 1448|  23.9k|                    a.patterns.extend(b.patterns);
 1449|  23.9k|                    a
 1450|  23.9k|                })
 1451|  23.9k|        }
 1452|  23.9k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  23.9k|            c
 1454|  23.9k|        }
 1455|  23.9k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  23.9k|            FocusedTripleOrPathPattern {
 1457|  23.9k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  23.9k|                patterns: o.patterns
 1459|  23.9k|            }
 1460|  23.9k|        }
 1461|  23.9k|
 1462|  23.9k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  23.9k|            p.into()
 1464|  23.9k|        }
 1465|  23.9k|
 1466|  23.9k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  23.9k|            v.into()
 1468|  23.9k|        }
 1469|  23.9k|
 1470|  23.9k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  23.9k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  23.9k|                a.focus.push(b.focus);
 1473|  23.9k|                a.patterns.extend(b.patterns);
 1474|  23.9k|                a
 1475|  23.9k|            })
 1476|  23.9k|        }
 1477|  23.9k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  23.9k|
 1479|  23.9k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  23.9k|             if let Some(a) = a {
 1481|  23.9k|                let mut patterns = g.patterns;
 1482|  23.9k|                patterns.extend(a.patterns);
 1483|  23.9k|                FocusedTripleOrPathPattern {
 1484|  23.9k|                    focus: AnnotatedTermPath {
 1485|  23.9k|                        term: g.focus,
 1486|  23.9k|                        annotations: a.focus
 1487|  23.9k|                    },
 1488|  23.9k|                    patterns
 1489|  23.9k|                }
 1490|  23.9k|            } else {
 1491|  23.9k|                FocusedTripleOrPathPattern {
 1492|  23.9k|                    focus: AnnotatedTermPath {
 1493|  23.9k|                        term: g.focus,
 1494|  23.9k|                        annotations: Vec::new()
 1495|  23.9k|                    },
 1496|  23.9k|                    patterns: g.patterns
 1497|  23.9k|                }
 1498|  23.9k|            }
 1499|  23.9k|        }
 1500|  23.9k|
 1501|  23.9k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  23.9k|
 1503|  23.9k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  23.9k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|       |                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  23.9k|            })
 1507|  23.9k|        }
 1508|  23.9k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  23.9k|
 1510|  23.9k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  23.9k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  23.9k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  23.9k|            })
 1514|  23.9k|        }
 1515|  23.9k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  23.9k|
 1517|  23.9k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  23.9k|            match o {
 1519|  23.9k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  23.9k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  23.9k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  23.9k|                Some(_) => unreachable!(),
 1523|  23.9k|                None => p
 1524|  23.9k|            }
 1525|  23.9k|        }
 1526|  23.9k|        rule PathElt_op() -> char =
 1527|  23.9k|            "*" { '*' } /
 1528|  23.9k|            "+" { '+' } /
 1529|  23.9k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  23.9k|
 1531|  23.9k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  23.9k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  23.9k|            PathElt()
 1534|  23.9k|
 1535|  23.9k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  23.9k|            v:iri() { v.into() } /
 1537|  23.9k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  23.9k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  23.9k|            "(" _ p:Path() _ ")" { p }
 1540|  23.9k|
 1541|  23.9k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  23.9k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  23.9k|                let mut direct = Vec::new();
 1544|  23.9k|                let mut inverse = Vec::new();
 1545|  23.9k|                for e in p {
 1546|  23.9k|                    match e {
 1547|  23.9k|                        Either::Left(a) => direct.push(a),
 1548|  23.9k|                        Either::Right(b) => inverse.push(b)
 1549|  23.9k|                    }
 1550|  23.9k|                }
 1551|  23.9k|                if inverse.is_empty() {
 1552|  23.9k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  23.9k|                } else if direct.is_empty() {
 1554|  23.9k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  23.9k|                } else {
 1556|  23.9k|                    PropertyPathExpression::Alternative(
 1557|  23.9k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  23.9k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  23.9k|                    )
 1560|  23.9k|                }
 1561|  23.9k|            } /
 1562|  23.9k|            p:PathOneInPropertySet() {
 1563|  23.9k|                match p {
 1564|  23.9k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  23.9k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  23.9k|                }
 1567|  23.9k|            }
 1568|  23.9k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  23.9k|
 1570|  23.9k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  23.9k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  23.9k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  23.9k|            v:iri() { Either::Left(v) } /
 1574|  23.9k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  23.9k|
 1576|  23.9k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  23.9k|
 1578|  23.9k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  23.9k|            let mut patterns = po.patterns;
 1580|  23.9k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  23.9k|            for (p, os) in po.focus {
 1582|  23.9k|                for o in os {
 1583|  23.9k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  23.9k|                }
 1585|  23.9k|            }
 1586|  23.9k|            Ok(FocusedTriplePattern {
 1587|  23.9k|                focus: bnode,
 1588|  23.9k|                patterns
 1589|  23.9k|            })
 1590|  23.9k|        }
 1591|  23.9k|
 1592|  23.9k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  23.9k|
 1594|  23.9k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  23.9k|            let mut patterns = po.patterns;
 1596|  23.9k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  23.9k|            for (p, os) in po.focus {
 1598|  23.9k|                for o in os {
 1599|  23.9k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  23.9k|                }
 1601|  23.9k|            }
 1602|  23.9k|            Ok(FocusedTripleOrPathPattern {
 1603|  23.9k|                focus: bnode,
 1604|  23.9k|                patterns
 1605|  23.9k|            })
 1606|  23.9k|        }
 1607|  23.9k|
 1608|  23.9k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  23.9k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  23.9k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  23.9k|            for objWithPatterns in o.into_iter().rev() {
 1612|  23.9k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  23.9k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  23.9k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  23.9k|                current_list_node = new_blank_node;
 1616|  23.9k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  23.9k|            }
 1618|  23.9k|            FocusedTriplePattern {
 1619|  23.9k|                focus: current_list_node,
 1620|  23.9k|                patterns
 1621|  23.9k|            }
 1622|  23.9k|        }
 1623|  23.9k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  23.9k|
 1625|  23.9k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  23.9k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  23.9k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  23.9k|            for objWithPatterns in o.into_iter().rev() {
 1629|  23.9k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  23.9k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  23.9k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  23.9k|                current_list_node = new_blank_node;
 1633|  23.9k|                patterns.extend(objWithPatterns.patterns);
 1634|  23.9k|            }
 1635|  23.9k|            FocusedTripleOrPathPattern {
 1636|  23.9k|                focus: current_list_node,
 1637|  23.9k|                patterns
 1638|  23.9k|            }
 1639|  23.9k|        }
 1640|  23.9k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  23.9k|
 1642|  23.9k|
 1643|  23.9k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  23.9k|
 1645|  23.9k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  23.9k|
 1647|  23.9k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  23.9k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  23.9k|            TriplesNode()
 1650|  23.9k|
 1651|  23.9k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  23.9k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  23.9k|            TriplesNodePath()
 1654|  23.9k|
 1655|  23.9k|        rule VarOrTerm() -> TermPattern =
 1656|  23.9k|            v:Var() { v.into() } /
 1657|  23.9k|            t:QuotedTriple() {?
 1658|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  23.9k|            } /
 1661|  23.9k|            t:GraphTerm() { t.into() }
 1662|  23.9k|
 1663|  23.9k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  23.9k|            Ok(TriplePattern {
 1665|  23.9k|                subject: s,
 1666|  23.9k|                predicate: p,
 1667|  23.9k|                object: o
 1668|  23.9k|            })
 1669|  23.9k|        }
 1670|  23.9k|
 1671|  23.9k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  23.9k|            Ok(GroundTriple {
 1673|  23.9k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  23.9k|                predicate: p,
 1675|  23.9k|                object: o
 1676|  23.9k|            })
 1677|  23.9k|        }
 1678|  23.9k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  23.9k|
 1680|  23.9k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  23.9k|            l:RDFLiteral() { l.into() } /
 1682|  23.9k|            l:NumericLiteral() { l.into() } /
 1683|  23.9k|            l:BooleanLiteral() { l.into() } /
 1684|  23.9k|            t:QuotedTripleData() {?
 1685|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  23.9k|            }
 1688|  23.9k|
 1689|  23.9k|        rule VarOrIri() -> NamedNodePattern =
 1690|  23.9k|            v:Var() { v.into() } /
 1691|  23.9k|            i:iri() { i.into() }
 1692|  23.9k|
 1693|  23.9k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  23.9k|
 1695|  23.9k|        rule GraphTerm() -> Term =
 1696|  23.9k|            i:iri() { i.into() } /
 1697|  23.9k|            l:RDFLiteral() { l.into() } /
 1698|  23.9k|            l:NumericLiteral() { l.into() } /
 1699|  23.9k|            l:BooleanLiteral() { l.into() } /
 1700|  23.9k|            b:BlankNode() { b.into() } /
 1701|  23.9k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  23.9k|
 1703|  23.9k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  23.9k|
 1705|  23.9k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  23.9k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  23.9k|        }
 1708|  23.9k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  23.9k|
 1710|  23.9k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  23.9k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  23.9k|        }
 1713|  23.9k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  23.9k|
 1715|  23.9k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  23.9k|
 1717|  23.9k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  23.9k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  23.9k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  23.9k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  23.9k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  23.9k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  23.9k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  23.9k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  23.9k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  23.9k|            Some(_) => unreachable!(),
 1727|  23.9k|            None => a
 1728|  23.9k|        } }
 1729|  23.9k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  23.9k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  23.9k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  23.9k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  23.9k|
 1734|  23.9k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  23.9k|
 1736|  23.9k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  23.9k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  23.9k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  23.9k|            Some(_) => unreachable!(),
 1740|  23.9k|            None => a,
 1741|  23.9k|        } }
 1742|  23.9k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  23.9k|            (s, e)
 1744|  23.9k|        }
 1745|  23.9k|
 1746|  23.9k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  23.9k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  23.9k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  23.9k|            Some(_) => unreachable!(),
 1750|  23.9k|            None => a
 1751|  23.9k|        } }
 1752|  23.9k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  23.9k|            (s, e)
 1754|  23.9k|        }
 1755|  23.9k|
 1756|  23.9k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  23.9k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  23.9k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  23.9k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  23.9k|            Some(_) => unreachable!(),
 1761|  23.9k|            None => e,
 1762|  23.9k|        } }
 1763|  23.9k|
 1764|  23.9k|        rule PrimaryExpression() -> Expression =
 1765|  23.9k|            BrackettedExpression()  /
 1766|  23.9k|            ExprQuotedTriple() /
 1767|  23.9k|            iriOrFunction() /
 1768|  23.9k|            v:Var() { v.into() } /
 1769|  23.9k|            l:RDFLiteral() { l.into() } /
 1770|  23.9k|            l:NumericLiteral() { l.into() } /
 1771|  23.9k|            l:BooleanLiteral() { l.into() } /
 1772|  23.9k|            BuiltInCall()
 1773|  23.9k|
 1774|  23.9k|        rule ExprVarOrTerm() -> Expression =
 1775|  23.9k|            ExprQuotedTriple() /
 1776|  23.9k|            i:iri() { i.into() } /
 1777|  23.9k|            l:RDFLiteral() { l.into() } /
 1778|  23.9k|            l:NumericLiteral() { l.into() } /
 1779|  23.9k|            l:BooleanLiteral() { l.into() } /
 1780|  23.9k|            v:Var() { v.into() }
 1781|  23.9k|
 1782|  23.9k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  23.9k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  23.9k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  23.9k|        }
 1786|  23.9k|
 1787|  23.9k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  23.9k|
 1789|  23.9k|        rule BuiltInCall() -> Expression =
 1790|  23.9k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  23.9k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  23.9k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  23.9k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  23.9k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  23.9k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  23.9k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  23.9k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  23.9k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  23.9k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  23.9k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  23.9k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  23.9k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  23.9k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  23.9k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  23.9k|            SubstringExpression() /
 1806|  23.9k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  23.9k|            StrReplaceExpression() /
 1808|  23.9k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  23.9k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  23.9k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  23.9k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  23.9k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  23.9k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  23.9k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  23.9k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  23.9k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  23.9k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  23.9k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  23.9k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  23.9k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  23.9k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  23.9k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  23.9k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  23.9k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  23.9k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  23.9k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  23.9k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  23.9k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  23.9k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  23.9k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  23.9k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  23.9k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  23.9k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  23.9k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  23.9k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  23.9k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  23.9k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  23.9k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  23.9k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  23.9k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  23.9k|            RegexExpression() /
 1842|  23.9k|            ExistsFunc() /
 1843|  23.9k|            NotExistsFunc() /
 1844|  23.9k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  23.9k|            } /
 1848|  23.9k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  23.9k|            } /
 1852|  23.9k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  23.9k|            } /
 1856|  23.9k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  23.9k|            } /
 1860|  23.9k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  23.9k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  23.9k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  23.9k|            } /
 1864|  23.9k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  23.9k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  23.9k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  23.9k|            }
 1868|  23.9k|
 1869|  23.9k|        rule RegexExpression() -> Expression =
 1870|  23.9k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  23.9k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  23.9k|
 1873|  23.9k|
 1874|  23.9k|        rule SubstringExpression() -> Expression =
 1875|  23.9k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  23.9k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  23.9k|
 1878|  23.9k|
 1879|  23.9k|        rule StrReplaceExpression() -> Expression =
 1880|  23.9k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  23.9k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  23.9k|
 1883|  23.9k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  23.9k|
 1885|  23.9k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  23.9k|
 1887|  23.9k|        rule Aggregate() -> AggregateExpression =
 1888|  23.9k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  23.9k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  23.9k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  23.9k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  23.9k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  23.9k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  23.9k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  23.9k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  23.9k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  23.9k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  23.9k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  23.9k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  23.9k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  23.9k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  23.9k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  23.9k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  23.9k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  23.9k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  23.9k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  23.9k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  23.9k|
 1909|  23.9k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  23.9k|            match a {
 1911|  23.9k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  23.9k|                None => i.into()
 1913|  23.9k|            }
 1914|  23.9k|        }
 1915|  23.9k|
 1916|  23.9k|        rule RDFLiteral() -> Literal =
 1917|  23.9k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  23.9k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  23.9k|            value:String() { Literal::new_simple_literal(value) }
 1920|  23.9k|
 1921|  23.9k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  23.9k|
 1923|  23.9k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  23.9k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  23.9k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  23.9k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  23.9k|
 1928|  23.9k|        rule NumericLiteralPositive() -> Literal =
 1929|  23.9k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  23.9k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  23.9k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  23.9k|
 1933|  23.9k|
 1934|  23.9k|        rule NumericLiteralNegative() -> Literal =
 1935|  23.9k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  23.9k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  23.9k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  23.9k|
 1939|  23.9k|        rule BooleanLiteral() -> Literal =
 1940|  23.9k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  23.9k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  23.9k|
 1943|  23.9k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  23.9k|
 1945|  23.9k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  23.9k|            NamedNode::from(i)
 1947|  23.9k|        }
 1948|  23.9k|
 1949|  23.9k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  23.9k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  23.9k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  23.9k|            } else {
 1953|  23.9k|                Err("Prefix not found")
 1954|  23.9k|            } }
 1955|  23.9k|
 1956|  23.9k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  23.9k|            let node = BlankNode::new_unchecked(id);
 1958|  23.9k|            if state.used_bnodes.contains(&node) {
 1959|  23.9k|                Err("Already used blank node id")
 1960|  23.9k|            } else {
 1961|  23.9k|                state.currently_used_bnodes.insert(node.clone());
 1962|  23.9k|                Ok(node)
 1963|  23.9k|            }
 1964|  23.9k|        } / ANON() { BlankNode::default() }
 1965|  23.9k|
 1966|  23.9k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  23.9k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  23.9k|        }
 1969|  23.9k|
 1970|  23.9k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  23.9k|            ns
 1972|  23.9k|        }
 1973|  23.9k|
 1974|  23.9k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  23.9k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  23.9k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  23.9k|                iri.push_str(base);
 1978|  23.9k|                for chunk in local.split('\\') { // We remove \
 1979|  23.9k|                    iri.push_str(chunk);
 1980|  23.9k|                }
 1981|  23.9k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  23.9k|            } else {
 1983|  23.9k|                Err("Prefix not found")
 1984|  23.9k|            }
 1985|  23.9k|        }
 1986|  23.9k|
 1987|  23.9k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  23.9k|            b
 1989|  23.9k|        }
 1990|  23.9k|
 1991|  23.9k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  23.9k|
 1993|  23.9k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  23.9k|
 1995|  23.9k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  23.9k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  23.9k|        }
 1998|  23.9k|
 1999|  23.9k|        rule INTEGER() = ['0'..='9']+
 2000|  23.9k|
 2001|  23.9k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  23.9k|
 2003|  23.9k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  23.9k|
 2005|  23.9k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  23.9k|
 2007|  23.9k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  23.9k|
 2009|  23.9k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  23.9k|
 2011|  23.9k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  23.9k|
 2013|  23.9k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  23.9k|
 2015|  23.9k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  23.9k|
 2017|  23.9k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  23.9k|
 2019|  23.9k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  23.9k|             unescape_string(l)
 2021|  23.9k|        }
 2022|  23.9k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  23.9k|
 2024|  23.9k|
 2025|  23.9k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  23.9k|             unescape_string(l)
 2027|  23.9k|        }
 2028|  23.9k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  23.9k|
 2030|  23.9k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  23.9k|             unescape_string(l)
 2032|  23.9k|        }
 2033|  23.9k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  23.9k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  23.9k|
 2036|  23.9k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  23.9k|             unescape_string(l)
 2038|  23.9k|        }
 2039|  23.9k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  23.9k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  23.9k|
 2042|  23.9k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  23.9k|
 2044|  23.9k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  23.9k|
 2046|  23.9k|        rule NIL() = "(" WS()* ")"
 2047|  23.9k|
 2048|  23.9k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  23.9k|
 2050|  23.9k|        rule ANON() = "[" WS()* "]"
 2051|  23.9k|
 2052|  23.9k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  23.9k|
 2054|  23.9k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  23.9k|
 2056|  23.9k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  23.9k|
 2058|  23.9k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  23.9k|
 2060|  23.9k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  23.9k|
 2062|  23.9k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  23.9k|
 2064|  23.9k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  23.9k|
 2066|  23.9k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  23.9k|
 2068|  23.9k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  23.9k|
 2070|  23.9k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  23.9k|
 2072|  23.9k|        //space
 2073|  23.9k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  23.9k|
 2075|  23.9k|        //comment
 2076|  23.9k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  23.9k|
 2078|  23.9k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  23.9k|            if input.eq_ignore_ascii_case(literal) {
 2080|  23.9k|                Ok(())
 2081|  23.9k|            } else {
 2082|  23.9k|                Err(literal)
 2083|  23.9k|            }
 2084|  23.9k|        }
 2085|  23.9k|    }
 2086|  23.9k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_PathNegatedPropertySets_0B7_:
 1562|    308|            p:PathOneInPropertySet() {
 1563|    308|                match p {
 1564|    274|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|     34|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_ObjectList_item0B7_:
 1393|  17.0k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_InlineDataFull_values0B7_:
 1293|    299|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser34___parse_RelationalExpression_inners_0B7_:
 1731|    135|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerms3_0B7_:
 1701|  1.10k|            NIL() { rdf::NIL.into_owned().into() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls_0B7_:
 1791|     19|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_SubSelect0B7_:
  778|  1.76k|parser! {
  779|  1.76k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  1.76k|    grammar parser(state: &mut ParserState) for str {
  781|  1.76k|        pub rule QueryUnit() -> Query = Query()
  782|  1.76k|
  783|  1.76k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  1.76k|            q
  785|  1.76k|        }
  786|  1.76k|
  787|  1.76k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  1.76k|
  789|  1.76k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  1.76k|
  791|  1.76k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  1.76k|            state.base_iri = Some(i)
  793|  1.76k|        }
  794|  1.76k|
  795|  1.76k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  1.76k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  1.76k|        }
  798|  1.76k|
  799|  1.76k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  1.76k|            Ok(Query::Select {
  801|  1.76k|                dataset: d,
  802|  1.76k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  1.76k|                base_iri: state.base_iri.clone()
  804|  1.76k|            })
  805|  1.76k|        }
  806|  1.76k|
  807|  1.76k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  1.76k|            build_select(s, w, g, h, o, l, v, state)
  809|  1.76k|        }
  810|  1.76k|
  811|  1.76k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  1.76k|            Selection {
  813|  1.76k|                option: o,
  814|  1.76k|                variables: v
  815|  1.76k|            }
  816|  1.76k|        }
  817|  1.76k|        rule Selection_init() = {
  818|  1.76k|            state.aggregates.push(Vec::new())
  819|  1.76k|        }
  820|  1.76k|        rule SelectClause_option() -> SelectionOption =
  821|  1.76k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  1.76k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  1.76k|            { SelectionOption::Default }
  824|  1.76k|        rule SelectClause_variables() -> SelectionVariables =
  825|  1.76k|            "*" { SelectionVariables::Star } /
  826|  1.76k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  1.76k|        rule SelectClause_member() -> SelectionMember =
  828|  1.76k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  1.76k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  1.76k|
  831|  1.76k|        rule ConstructQuery() -> Query =
  832|  1.76k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  1.76k|                Ok(Query::Construct {
  834|  1.76k|                    template: c,
  835|  1.76k|                    dataset: d,
  836|  1.76k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  1.76k|                    base_iri: state.base_iri.clone()
  838|  1.76k|                })
  839|  1.76k|            } /
  840|  1.76k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  1.76k|                Ok(Query::Construct {
  842|  1.76k|                    template: c.clone(),
  843|  1.76k|                    dataset: d,
  844|  1.76k|                    pattern: build_select(
  845|  1.76k|                        Selection::no_op(),
  846|  1.76k|                        GraphPattern::Bgp { patterns: c },
  847|  1.76k|                        g, h, o, l, v, state
  848|  1.76k|                    )?,
  849|  1.76k|                    base_iri: state.base_iri.clone()
  850|  1.76k|                })
  851|  1.76k|            }
  852|  1.76k|
  853|  1.76k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  1.76k|
  855|  1.76k|        rule DescribeQuery() -> Query =
  856|  1.76k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  1.76k|                Ok(Query::Describe {
  858|  1.76k|                    dataset: d,
  859|  1.76k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  1.76k|                    base_iri: state.base_iri.clone()
  861|  1.76k|                })
  862|  1.76k|            } /
  863|  1.76k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  1.76k|                Ok(Query::Describe {
  865|  1.76k|                    dataset: d,
  866|  1.76k|                    pattern: build_select(Selection {
  867|  1.76k|                        option: SelectionOption::Default,
  868|  1.76k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  1.76k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  1.76k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  1.76k|                        }).collect())
  872|  1.76k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  1.76k|                    base_iri: state.base_iri.clone()
  874|  1.76k|                })
  875|  1.76k|            }
  876|  1.76k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  1.76k|
  878|  1.76k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  1.76k|            Ok(Query::Ask {
  880|  1.76k|                dataset: d,
  881|  1.76k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  1.76k|                base_iri: state.base_iri.clone()
  883|  1.76k|            })
  884|  1.76k|        }
  885|  1.76k|
  886|  1.76k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  1.76k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  1.76k|            if d.is_empty() {
  889|  1.76k|                return None;
  890|  1.76k|            }
  891|  1.76k|            let mut default = Vec::new();
  892|  1.76k|            let mut named = Vec::new();
  893|  1.76k|            for (d, n) in d {
  894|  1.76k|                if let Some(d) = d {
  895|  1.76k|                    default.push(d);
  896|  1.76k|                }
  897|  1.76k|                if let Some(n) = n {
  898|  1.76k|                    named.push(n);
  899|  1.76k|                }
  900|  1.76k|            }
  901|  1.76k|            Some(QueryDataset {
  902|  1.76k|                default, named: Some(named)
  903|  1.76k|            })
  904|  1.76k|        }
  905|  1.76k|
  906|  1.76k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  1.76k|            (Some(s), None)
  908|  1.76k|        }
  909|  1.76k|
  910|  1.76k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  1.76k|            (None, Some(s))
  912|  1.76k|        }
  913|  1.76k|
  914|  1.76k|        rule SourceSelector() -> NamedNode = iri()
  915|  1.76k|
  916|  1.76k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  1.76k|            p
  918|  1.76k|        }
  919|  1.76k|
  920|  1.76k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  1.76k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  1.76k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  1.76k|                if let Expression::Variable(v) = e {
  924|  1.76k|                    v
  925|  1.76k|                } else {
  926|  1.76k|                    let v = vo.unwrap_or_else(variable);
  927|  1.76k|                    projections.push((e, v.clone()));
  928|  1.76k|                    v
  929|  1.76k|                }
  930|  1.76k|            }).collect();
  931|  1.76k|            (clauses, projections)
  932|  1.76k|        }
  933|  1.76k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  1.76k|
  935|  1.76k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  1.76k|            e:BuiltInCall() { (e, None) } /
  937|  1.76k|            e:FunctionCall() { (e, None) } /
  938|  1.76k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  1.76k|            e:Var() { (e.into(), None) }
  940|  1.76k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  1.76k|
  942|  1.76k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  1.76k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  1.76k|        }
  945|  1.76k|
  946|  1.76k|        rule HavingCondition() -> Expression = Constraint()
  947|  1.76k|
  948|  1.76k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  1.76k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  1.76k|
  951|  1.76k|        rule OrderCondition() -> OrderExpression =
  952|  1.76k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  1.76k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  1.76k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  1.76k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  1.76k|
  957|  1.76k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  1.76k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  1.76k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  1.76k|
  961|  1.76k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  1.76k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  1.76k|        }
  964|  1.76k|
  965|  1.76k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  1.76k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  1.76k|        }
  968|  1.76k|
  969|  1.76k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  1.76k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  1.76k|            { None }
  972|  1.76k|
  973|  1.76k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  1.76k|
  975|  1.76k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  1.76k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  1.76k|
  978|  1.76k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  1.76k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  1.76k|        }
  981|  1.76k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  1.76k|
  983|  1.76k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  1.76k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  1.76k|        }
  986|  1.76k|
  987|  1.76k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  1.76k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  1.76k|        }
  990|  1.76k|
  991|  1.76k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  1.76k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  1.76k|        }
  994|  1.76k|
  995|  1.76k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  1.76k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  1.76k|            if from == to {
  998|  1.76k|                Vec::new() // identity case
  999|  1.76k|            } else {
 1000|  1.76k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  1.76k|                vec![copy_graph(from, to)]
 1002|  1.76k|            }
 1003|  1.76k|        }
 1004|  1.76k|
 1005|  1.76k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  1.76k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  1.76k|            if from == to {
 1008|  1.76k|                Vec::new() // identity case
 1009|  1.76k|            } else {
 1010|  1.76k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  1.76k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  1.76k|            }
 1013|  1.76k|        }
 1014|  1.76k|
 1015|  1.76k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  1.76k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  1.76k|            if from == to {
 1018|  1.76k|                Vec::new() // identity case
 1019|  1.76k|            } else {
 1020|  1.76k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  1.76k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  1.76k|            }
 1023|  1.76k|        }
 1024|  1.76k|
 1025|  1.76k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  1.76k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  1.76k|        }
 1028|  1.76k|
 1029|  1.76k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  1.76k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  1.76k|        }
 1032|  1.76k|
 1033|  1.76k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  1.76k|            let pattern = d.iter().map(|q| {
 1035|  1.76k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  1.76k|                match &q.graph_name {
 1037|  1.76k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  1.76k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  1.76k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  1.76k|                }
 1041|  1.76k|            }).reduce(new_join).unwrap_or_default();
 1042|  1.76k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  1.76k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  1.76k|                delete,
 1045|  1.76k|                insert: Vec::new(),
 1046|  1.76k|                using: None,
 1047|  1.76k|                pattern: Box::new(pattern)
 1048|  1.76k|            }])
 1049|  1.76k|        }
 1050|  1.76k|
 1051|  1.76k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  1.76k|            let (delete, insert) = c;
 1053|  1.76k|            let mut delete = delete.unwrap_or_default();
 1054|  1.76k|            let mut insert = insert.unwrap_or_default();
 1055|  1.76k|            #[allow(clippy::shadow_same)]
 1056|  1.76k|            let mut pattern = pattern;
 1057|  1.76k|
 1058|  1.76k|            let mut using = if u.is_empty() {
 1059|  1.76k|                None
 1060|  1.76k|            } else {
 1061|  1.76k|                let mut default = Vec::new();
 1062|  1.76k|                let mut named = Vec::new();
 1063|  1.76k|                for (d, n) in u {
 1064|  1.76k|                    if let Some(d) = d {
 1065|  1.76k|                        default.push(d)
 1066|  1.76k|                    }
 1067|  1.76k|                    if let Some(n) = n {
 1068|  1.76k|                        named.push(n)
 1069|  1.76k|                    }
 1070|  1.76k|                }
 1071|  1.76k|                Some(QueryDataset { default, named: Some(named) })
 1072|  1.76k|            };
 1073|  1.76k|
 1074|  1.76k|            if let Some(with) = with {
 1075|  1.76k|                // We inject WITH everywhere
 1076|  1.76k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  1.76k|                    GroundQuadPattern {
 1078|  1.76k|                        subject: q.subject,
 1079|  1.76k|                        predicate: q.predicate,
 1080|  1.76k|                        object: q.object,
 1081|  1.76k|                        graph_name: with.clone().into()
 1082|  1.76k|                    }
 1083|  1.76k|                } else {
 1084|  1.76k|                    q
 1085|  1.76k|                }).collect();
 1086|  1.76k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  1.76k|                    QuadPattern {
 1088|  1.76k|                        subject: q.subject,
 1089|  1.76k|                        predicate: q.predicate,
 1090|  1.76k|                        object: q.object,
 1091|  1.76k|                        graph_name: with.clone().into()
 1092|  1.76k|                    }
 1093|  1.76k|                } else {
 1094|  1.76k|                    q
 1095|  1.76k|                }).collect();
 1096|  1.76k|                if using.is_none() {
 1097|  1.76k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  1.76k|                }
 1099|  1.76k|            }
 1100|  1.76k|
 1101|  1.76k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  1.76k|                delete,
 1103|  1.76k|                insert,
 1104|  1.76k|                using,
 1105|  1.76k|                pattern: Box::new(pattern)
 1106|  1.76k|            }]
 1107|  1.76k|        }
 1108|  1.76k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  1.76k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  1.76k|            (Some(d), i)
 1111|  1.76k|        } / i:InsertClause() {
 1112|  1.76k|            (None, Some(i))
 1113|  1.76k|        }
 1114|  1.76k|        rule Modify_clear() = {
 1115|  1.76k|            state.used_bnodes.clear();
 1116|  1.76k|            state.currently_used_bnodes.clear();
 1117|  1.76k|        }
 1118|  1.76k|
 1119|  1.76k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  1.76k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  1.76k|        }
 1122|  1.76k|
 1123|  1.76k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  1.76k|
 1125|  1.76k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  1.76k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  1.76k|            (Some(i), None)
 1128|  1.76k|        }
 1129|  1.76k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  1.76k|            (None, Some(i))
 1131|  1.76k|        }
 1132|  1.76k|
 1133|  1.76k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  1.76k|            GraphName::DefaultGraph
 1135|  1.76k|        } / (i("GRAPH") _)? g:iri() {
 1136|  1.76k|            GraphName::NamedNode(g)
 1137|  1.76k|        }
 1138|  1.76k|
 1139|  1.76k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  1.76k|
 1141|  1.76k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  1.76k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  1.76k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  1.76k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  1.76k|
 1146|  1.76k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  1.76k|
 1148|  1.76k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  1.76k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  1.76k|        }
 1151|  1.76k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  1.76k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  1.76k|        }
 1154|  1.76k|
 1155|  1.76k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  1.76k|            q.into_iter().flatten().collect()
 1157|  1.76k|        }
 1158|  1.76k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  1.76k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  1.76k|        } //TODO: return iter?
 1161|  1.76k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  1.76k|
 1163|  1.76k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  1.76k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  1.76k|        }
 1166|  1.76k|
 1167|  1.76k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  1.76k|            ts.into_iter().flatten().collect()
 1169|  1.76k|        }
 1170|  1.76k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  1.76k|
 1172|  1.76k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  1.76k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  1.76k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  1.76k|        rule GroupGraphPattern_clear() = {
 1176|  1.76k|             // We deal with blank nodes aliases rule
 1177|  1.76k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  1.76k|            state.currently_used_bnodes.clear();
 1179|  1.76k|        }
 1180|  1.76k|
 1181|  1.76k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  1.76k|            let mut filter: Option<Expression> = None;
 1183|  1.76k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  1.76k|            for e in b.into_iter().flatten() {
 1185|  1.76k|                match e {
 1186|  1.76k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  1.76k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  1.76k|                    }
 1189|  1.76k|                    #[cfg(feature = "sep-0006")]
 1190|  1.76k|                    PartialGraphPattern::Lateral(p) => {
 1191|  1.76k|                        let mut defined_variables = HashSet::default();
 1192|  1.76k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  1.76k|                        let mut contains = false;
 1194|  1.76k|                        g.on_in_scope_variable(|v| {
 1195|  1.76k|                            if defined_variables.contains(v) {
 1196|  1.76k|                                contains = true;
 1197|  1.76k|                            }
 1198|  1.76k|                        });
 1199|  1.76k|                        if contains {
 1200|  1.76k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  1.76k|                        }
 1202|  1.76k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  1.76k|                    }
 1204|  1.76k|                    PartialGraphPattern::Minus(p) => {
 1205|  1.76k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  1.76k|                    }
 1207|  1.76k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  1.76k|                        let mut contains = false;
 1209|  1.76k|                        g.on_in_scope_variable(|v| {
 1210|  1.76k|                            if *v == variable {
 1211|  1.76k|                                contains = true;
 1212|  1.76k|                            }
 1213|  1.76k|                        });
 1214|  1.76k|                        if contains {
 1215|  1.76k|                            return Err("BIND is overriding an existing variable")
 1216|  1.76k|                        }
 1217|  1.76k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  1.76k|                    }
 1219|  1.76k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  1.76k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  1.76k|                    } else {
 1222|  1.76k|                        expr
 1223|  1.76k|                    }),
 1224|  1.76k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  1.76k|                }
 1226|  1.76k|            }
 1227|  1.76k|
 1228|  1.76k|            Ok(if let Some(expr) = filter {
 1229|  1.76k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  1.76k|            } else {
 1231|  1.76k|                g
 1232|  1.76k|            })
 1233|  1.76k|        }
 1234|  1.76k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  1.76k|            let mut result = vec![a];
 1236|  1.76k|            if let Some(v) = b {
 1237|  1.76k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  1.76k|            }
 1239|  1.76k|            result
 1240|  1.76k|        }
 1241|  1.76k|
 1242|  1.76k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  1.76k|            hs.into_iter().flatten().collect()
 1244|  1.76k|        }
 1245|  1.76k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  1.76k|
 1247|  1.76k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  1.76k|
 1249|  1.76k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  1.76k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  1.76k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  1.76k|            } else {
 1253|  1.76k|               PartialGraphPattern::Optional(p, None)
 1254|  1.76k|            }
 1255|  1.76k|        }
 1256|  1.76k|
 1257|  1.76k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  1.76k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  1.76k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  1.76k|        }
 1261|  1.76k|
 1262|  1.76k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  1.76k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  1.76k|        }
 1265|  1.76k|
 1266|  1.76k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  1.76k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  1.76k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  1.76k|
 1270|  1.76k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  1.76k|            PartialGraphPattern::Bind(e, v)
 1272|  1.76k|        }
 1273|  1.76k|
 1274|  1.76k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  1.76k|
 1276|  1.76k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  1.76k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  1.76k|        }
 1279|  1.76k|
 1280|  1.76k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  1.76k|            (vec![var], d)
 1282|  1.76k|        }
 1283|  1.76k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  1.76k|
 1285|  1.76k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  1.76k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  1.76k|                Ok((vars, vals))
 1288|  1.76k|            } else {
 1289|  1.76k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  1.76k|            }
 1291|  1.76k|        }
 1292|  1.76k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  1.76k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  1.76k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  1.76k|
 1296|  1.76k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  1.76k|            t:QuotedTripleData() {?
 1298|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  1.76k|            } /
 1301|  1.76k|            i:iri() { Some(i.into()) } /
 1302|  1.76k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  1.76k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  1.76k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  1.76k|            i("UNDEF") { None }
 1306|  1.76k|
 1307|  1.76k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  1.76k|            PartialGraphPattern::Minus(p)
 1309|  1.76k|        }
 1310|  1.76k|
 1311|  1.76k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  1.76k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  1.76k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  1.76k|            }).map(PartialGraphPattern::Other)
 1315|  1.76k|        }
 1316|  1.76k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  1.76k|
 1318|  1.76k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  1.76k|            PartialGraphPattern::Filter(c)
 1320|  1.76k|        }
 1321|  1.76k|
 1322|  1.76k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  1.76k|
 1324|  1.76k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  1.76k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  1.76k|        }
 1327|  1.76k|
 1328|  1.76k|        rule ArgList() -> Vec<Expression> =
 1329|  1.76k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  1.76k|            NIL() { Vec::new() }
 1331|  1.76k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  1.76k|
 1333|  1.76k|        rule ExpressionList() -> Vec<Expression> =
 1334|  1.76k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  1.76k|            NIL() { Vec::new() }
 1336|  1.76k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  1.76k|
 1338|  1.76k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  1.76k|
 1340|  1.76k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  1.76k|            p.into_iter().flatten().collect()
 1342|  1.76k|        }
 1343|  1.76k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  1.76k|
 1345|  1.76k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  1.76k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  1.76k|                let mut patterns = po.patterns;
 1348|  1.76k|                for (p, os) in po.focus {
 1349|  1.76k|                    for o in os {
 1350|  1.76k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  1.76k|                    }
 1352|  1.76k|                }
 1353|  1.76k|                Ok(patterns)
 1354|  1.76k|            } /
 1355|  1.76k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  1.76k|                let mut patterns = s.patterns;
 1357|  1.76k|                patterns.extend(po.patterns);
 1358|  1.76k|                for (p, os) in po.focus {
 1359|  1.76k|                    for o in os {
 1360|  1.76k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  1.76k|                    }
 1362|  1.76k|                }
 1363|  1.76k|                Ok(patterns)
 1364|  1.76k|            }
 1365|  1.76k|
 1366|  1.76k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  1.76k|            PropertyListNotEmpty() /
 1368|  1.76k|            { FocusedTriplePattern::default() }
 1369|  1.76k|
 1370|  1.76k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  1.76k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  1.76k|                a.focus.push(b.focus);
 1373|  1.76k|                a.patterns.extend(b.patterns);
 1374|  1.76k|                a
 1375|  1.76k|            })
 1376|  1.76k|        }
 1377|  1.76k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  1.76k|            FocusedTriplePattern {
 1379|  1.76k|                focus: (p, o.focus),
 1380|  1.76k|                patterns: o.patterns
 1381|  1.76k|            }
 1382|  1.76k|        }
 1383|  1.76k|
 1384|  1.76k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  1.76k|
 1386|  1.76k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  1.76k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  1.76k|                a.focus.push(b.focus);
 1389|  1.76k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  1.76k|                a
 1391|  1.76k|            })
 1392|  1.76k|        }
 1393|  1.76k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  1.76k|
 1395|  1.76k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  1.76k|            if let Some(a) = a {
 1397|  1.76k|                let mut patterns = g.patterns;
 1398|  1.76k|                patterns.extend(a.patterns);
 1399|  1.76k|                FocusedTriplePattern {
 1400|  1.76k|                    focus: AnnotatedTerm {
 1401|  1.76k|                        term: g.focus,
 1402|  1.76k|                        annotations: a.focus
 1403|  1.76k|                    },
 1404|  1.76k|                    patterns
 1405|  1.76k|                }
 1406|  1.76k|            } else {
 1407|  1.76k|                FocusedTriplePattern {
 1408|  1.76k|                    focus: AnnotatedTerm {
 1409|  1.76k|                        term: g.focus,
 1410|  1.76k|                        annotations: Vec::new()
 1411|  1.76k|                    },
 1412|  1.76k|                    patterns: g.patterns
 1413|  1.76k|                }
 1414|  1.76k|            }
 1415|  1.76k|        }
 1416|  1.76k|
 1417|  1.76k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  1.76k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  1.76k|                let mut patterns = po.patterns;
 1420|  1.76k|                for (p, os) in po.focus {
 1421|  1.76k|                    for o in os {
 1422|  1.76k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  1.76k|                    }
 1424|  1.76k|                }
 1425|  1.76k|                Ok(patterns)
 1426|  1.76k|            } /
 1427|  1.76k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  1.76k|                let mut patterns = s.patterns;
 1429|  1.76k|                patterns.extend(po.patterns);
 1430|  1.76k|                for (p, os) in po.focus {
 1431|  1.76k|                    for o in os {
 1432|  1.76k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  1.76k|                    }
 1434|  1.76k|                }
 1435|  1.76k|                Ok(patterns)
 1436|  1.76k|            }
 1437|  1.76k|
 1438|  1.76k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  1.76k|            PropertyListPathNotEmpty() /
 1440|  1.76k|            { FocusedTripleOrPathPattern::default() }
 1441|  1.76k|
 1442|  1.76k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  1.76k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  1.76k|                    focus: vec![(hp, ho.focus)],
 1445|  1.76k|                    patterns: ho.patterns
 1446|  1.76k|                }, |mut a, b| {
 1447|  1.76k|                    a.focus.push(b.focus);
 1448|  1.76k|                    a.patterns.extend(b.patterns);
 1449|  1.76k|                    a
 1450|  1.76k|                })
 1451|  1.76k|        }
 1452|  1.76k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  1.76k|            c
 1454|  1.76k|        }
 1455|  1.76k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  1.76k|            FocusedTripleOrPathPattern {
 1457|  1.76k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  1.76k|                patterns: o.patterns
 1459|  1.76k|            }
 1460|  1.76k|        }
 1461|  1.76k|
 1462|  1.76k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  1.76k|            p.into()
 1464|  1.76k|        }
 1465|  1.76k|
 1466|  1.76k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  1.76k|            v.into()
 1468|  1.76k|        }
 1469|  1.76k|
 1470|  1.76k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  1.76k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  1.76k|                a.focus.push(b.focus);
 1473|  1.76k|                a.patterns.extend(b.patterns);
 1474|  1.76k|                a
 1475|  1.76k|            })
 1476|  1.76k|        }
 1477|  1.76k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  1.76k|
 1479|  1.76k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  1.76k|             if let Some(a) = a {
 1481|  1.76k|                let mut patterns = g.patterns;
 1482|  1.76k|                patterns.extend(a.patterns);
 1483|  1.76k|                FocusedTripleOrPathPattern {
 1484|  1.76k|                    focus: AnnotatedTermPath {
 1485|  1.76k|                        term: g.focus,
 1486|  1.76k|                        annotations: a.focus
 1487|  1.76k|                    },
 1488|  1.76k|                    patterns
 1489|  1.76k|                }
 1490|  1.76k|            } else {
 1491|  1.76k|                FocusedTripleOrPathPattern {
 1492|  1.76k|                    focus: AnnotatedTermPath {
 1493|  1.76k|                        term: g.focus,
 1494|  1.76k|                        annotations: Vec::new()
 1495|  1.76k|                    },
 1496|  1.76k|                    patterns: g.patterns
 1497|  1.76k|                }
 1498|  1.76k|            }
 1499|  1.76k|        }
 1500|  1.76k|
 1501|  1.76k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  1.76k|
 1503|  1.76k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  1.76k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  1.76k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  1.76k|            })
 1507|  1.76k|        }
 1508|  1.76k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  1.76k|
 1510|  1.76k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  1.76k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  1.76k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  1.76k|            })
 1514|  1.76k|        }
 1515|  1.76k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  1.76k|
 1517|  1.76k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  1.76k|            match o {
 1519|  1.76k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  1.76k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  1.76k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  1.76k|                Some(_) => unreachable!(),
 1523|  1.76k|                None => p
 1524|  1.76k|            }
 1525|  1.76k|        }
 1526|  1.76k|        rule PathElt_op() -> char =
 1527|  1.76k|            "*" { '*' } /
 1528|  1.76k|            "+" { '+' } /
 1529|  1.76k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  1.76k|
 1531|  1.76k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  1.76k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  1.76k|            PathElt()
 1534|  1.76k|
 1535|  1.76k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  1.76k|            v:iri() { v.into() } /
 1537|  1.76k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  1.76k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  1.76k|            "(" _ p:Path() _ ")" { p }
 1540|  1.76k|
 1541|  1.76k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  1.76k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  1.76k|                let mut direct = Vec::new();
 1544|  1.76k|                let mut inverse = Vec::new();
 1545|  1.76k|                for e in p {
 1546|  1.76k|                    match e {
 1547|  1.76k|                        Either::Left(a) => direct.push(a),
 1548|  1.76k|                        Either::Right(b) => inverse.push(b)
 1549|  1.76k|                    }
 1550|  1.76k|                }
 1551|  1.76k|                if inverse.is_empty() {
 1552|  1.76k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  1.76k|                } else if direct.is_empty() {
 1554|  1.76k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  1.76k|                } else {
 1556|  1.76k|                    PropertyPathExpression::Alternative(
 1557|  1.76k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  1.76k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  1.76k|                    )
 1560|  1.76k|                }
 1561|  1.76k|            } /
 1562|  1.76k|            p:PathOneInPropertySet() {
 1563|  1.76k|                match p {
 1564|  1.76k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  1.76k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  1.76k|                }
 1567|  1.76k|            }
 1568|  1.76k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  1.76k|
 1570|  1.76k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  1.76k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  1.76k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  1.76k|            v:iri() { Either::Left(v) } /
 1574|  1.76k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  1.76k|
 1576|  1.76k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  1.76k|
 1578|  1.76k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  1.76k|            let mut patterns = po.patterns;
 1580|  1.76k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  1.76k|            for (p, os) in po.focus {
 1582|  1.76k|                for o in os {
 1583|  1.76k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  1.76k|                }
 1585|  1.76k|            }
 1586|  1.76k|            Ok(FocusedTriplePattern {
 1587|  1.76k|                focus: bnode,
 1588|  1.76k|                patterns
 1589|  1.76k|            })
 1590|  1.76k|        }
 1591|  1.76k|
 1592|  1.76k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  1.76k|
 1594|  1.76k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  1.76k|            let mut patterns = po.patterns;
 1596|  1.76k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  1.76k|            for (p, os) in po.focus {
 1598|  1.76k|                for o in os {
 1599|  1.76k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  1.76k|                }
 1601|  1.76k|            }
 1602|  1.76k|            Ok(FocusedTripleOrPathPattern {
 1603|  1.76k|                focus: bnode,
 1604|  1.76k|                patterns
 1605|  1.76k|            })
 1606|  1.76k|        }
 1607|  1.76k|
 1608|  1.76k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  1.76k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  1.76k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  1.76k|            for objWithPatterns in o.into_iter().rev() {
 1612|  1.76k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  1.76k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  1.76k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  1.76k|                current_list_node = new_blank_node;
 1616|  1.76k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  1.76k|            }
 1618|  1.76k|            FocusedTriplePattern {
 1619|  1.76k|                focus: current_list_node,
 1620|  1.76k|                patterns
 1621|  1.76k|            }
 1622|  1.76k|        }
 1623|  1.76k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  1.76k|
 1625|  1.76k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  1.76k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  1.76k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  1.76k|            for objWithPatterns in o.into_iter().rev() {
 1629|  1.76k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  1.76k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  1.76k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  1.76k|                current_list_node = new_blank_node;
 1633|  1.76k|                patterns.extend(objWithPatterns.patterns);
 1634|  1.76k|            }
 1635|  1.76k|            FocusedTripleOrPathPattern {
 1636|  1.76k|                focus: current_list_node,
 1637|  1.76k|                patterns
 1638|  1.76k|            }
 1639|  1.76k|        }
 1640|  1.76k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  1.76k|
 1642|  1.76k|
 1643|  1.76k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  1.76k|
 1645|  1.76k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  1.76k|
 1647|  1.76k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  1.76k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  1.76k|            TriplesNode()
 1650|  1.76k|
 1651|  1.76k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  1.76k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  1.76k|            TriplesNodePath()
 1654|  1.76k|
 1655|  1.76k|        rule VarOrTerm() -> TermPattern =
 1656|  1.76k|            v:Var() { v.into() } /
 1657|  1.76k|            t:QuotedTriple() {?
 1658|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  1.76k|            } /
 1661|  1.76k|            t:GraphTerm() { t.into() }
 1662|  1.76k|
 1663|  1.76k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  1.76k|            Ok(TriplePattern {
 1665|  1.76k|                subject: s,
 1666|  1.76k|                predicate: p,
 1667|  1.76k|                object: o
 1668|  1.76k|            })
 1669|  1.76k|        }
 1670|  1.76k|
 1671|  1.76k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  1.76k|            Ok(GroundTriple {
 1673|  1.76k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  1.76k|                predicate: p,
 1675|  1.76k|                object: o
 1676|  1.76k|            })
 1677|  1.76k|        }
 1678|  1.76k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  1.76k|
 1680|  1.76k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  1.76k|            l:RDFLiteral() { l.into() } /
 1682|  1.76k|            l:NumericLiteral() { l.into() } /
 1683|  1.76k|            l:BooleanLiteral() { l.into() } /
 1684|  1.76k|            t:QuotedTripleData() {?
 1685|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  1.76k|            }
 1688|  1.76k|
 1689|  1.76k|        rule VarOrIri() -> NamedNodePattern =
 1690|  1.76k|            v:Var() { v.into() } /
 1691|  1.76k|            i:iri() { i.into() }
 1692|  1.76k|
 1693|  1.76k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  1.76k|
 1695|  1.76k|        rule GraphTerm() -> Term =
 1696|  1.76k|            i:iri() { i.into() } /
 1697|  1.76k|            l:RDFLiteral() { l.into() } /
 1698|  1.76k|            l:NumericLiteral() { l.into() } /
 1699|  1.76k|            l:BooleanLiteral() { l.into() } /
 1700|  1.76k|            b:BlankNode() { b.into() } /
 1701|  1.76k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  1.76k|
 1703|  1.76k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  1.76k|
 1705|  1.76k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  1.76k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  1.76k|        }
 1708|  1.76k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  1.76k|
 1710|  1.76k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  1.76k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  1.76k|        }
 1713|  1.76k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  1.76k|
 1715|  1.76k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  1.76k|
 1717|  1.76k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  1.76k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  1.76k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  1.76k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  1.76k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  1.76k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  1.76k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  1.76k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  1.76k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  1.76k|            Some(_) => unreachable!(),
 1727|  1.76k|            None => a
 1728|  1.76k|        } }
 1729|  1.76k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  1.76k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  1.76k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  1.76k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  1.76k|
 1734|  1.76k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  1.76k|
 1736|  1.76k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  1.76k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  1.76k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  1.76k|            Some(_) => unreachable!(),
 1740|  1.76k|            None => a,
 1741|  1.76k|        } }
 1742|  1.76k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  1.76k|            (s, e)
 1744|  1.76k|        }
 1745|  1.76k|
 1746|  1.76k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  1.76k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  1.76k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  1.76k|            Some(_) => unreachable!(),
 1750|  1.76k|            None => a
 1751|  1.76k|        } }
 1752|  1.76k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  1.76k|            (s, e)
 1754|  1.76k|        }
 1755|  1.76k|
 1756|  1.76k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  1.76k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  1.76k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  1.76k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  1.76k|            Some(_) => unreachable!(),
 1761|  1.76k|            None => e,
 1762|  1.76k|        } }
 1763|  1.76k|
 1764|  1.76k|        rule PrimaryExpression() -> Expression =
 1765|  1.76k|            BrackettedExpression()  /
 1766|  1.76k|            ExprQuotedTriple() /
 1767|  1.76k|            iriOrFunction() /
 1768|  1.76k|            v:Var() { v.into() } /
 1769|  1.76k|            l:RDFLiteral() { l.into() } /
 1770|  1.76k|            l:NumericLiteral() { l.into() } /
 1771|  1.76k|            l:BooleanLiteral() { l.into() } /
 1772|  1.76k|            BuiltInCall()
 1773|  1.76k|
 1774|  1.76k|        rule ExprVarOrTerm() -> Expression =
 1775|  1.76k|            ExprQuotedTriple() /
 1776|  1.76k|            i:iri() { i.into() } /
 1777|  1.76k|            l:RDFLiteral() { l.into() } /
 1778|  1.76k|            l:NumericLiteral() { l.into() } /
 1779|  1.76k|            l:BooleanLiteral() { l.into() } /
 1780|  1.76k|            v:Var() { v.into() }
 1781|  1.76k|
 1782|  1.76k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  1.76k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  1.76k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  1.76k|        }
 1786|  1.76k|
 1787|  1.76k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  1.76k|
 1789|  1.76k|        rule BuiltInCall() -> Expression =
 1790|  1.76k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  1.76k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  1.76k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  1.76k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  1.76k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  1.76k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  1.76k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  1.76k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  1.76k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  1.76k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  1.76k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  1.76k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  1.76k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  1.76k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  1.76k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  1.76k|            SubstringExpression() /
 1806|  1.76k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  1.76k|            StrReplaceExpression() /
 1808|  1.76k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  1.76k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  1.76k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  1.76k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  1.76k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  1.76k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  1.76k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  1.76k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  1.76k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  1.76k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  1.76k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  1.76k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  1.76k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  1.76k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  1.76k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  1.76k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  1.76k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  1.76k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  1.76k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  1.76k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  1.76k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  1.76k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  1.76k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  1.76k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  1.76k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  1.76k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  1.76k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  1.76k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  1.76k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  1.76k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  1.76k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  1.76k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  1.76k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  1.76k|            RegexExpression() /
 1842|  1.76k|            ExistsFunc() /
 1843|  1.76k|            NotExistsFunc() /
 1844|  1.76k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  1.76k|            } /
 1848|  1.76k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  1.76k|            } /
 1852|  1.76k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  1.76k|            } /
 1856|  1.76k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  1.76k|            } /
 1860|  1.76k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  1.76k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  1.76k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  1.76k|            } /
 1864|  1.76k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  1.76k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  1.76k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  1.76k|            }
 1868|  1.76k|
 1869|  1.76k|        rule RegexExpression() -> Expression =
 1870|  1.76k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  1.76k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  1.76k|
 1873|  1.76k|
 1874|  1.76k|        rule SubstringExpression() -> Expression =
 1875|  1.76k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  1.76k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  1.76k|
 1878|  1.76k|
 1879|  1.76k|        rule StrReplaceExpression() -> Expression =
 1880|  1.76k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  1.76k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  1.76k|
 1883|  1.76k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  1.76k|
 1885|  1.76k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  1.76k|
 1887|  1.76k|        rule Aggregate() -> AggregateExpression =
 1888|  1.76k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  1.76k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  1.76k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  1.76k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  1.76k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  1.76k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  1.76k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  1.76k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  1.76k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  1.76k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  1.76k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  1.76k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  1.76k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  1.76k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  1.76k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  1.76k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  1.76k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  1.76k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  1.76k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  1.76k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  1.76k|
 1909|  1.76k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  1.76k|            match a {
 1911|  1.76k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  1.76k|                None => i.into()
 1913|  1.76k|            }
 1914|  1.76k|        }
 1915|  1.76k|
 1916|  1.76k|        rule RDFLiteral() -> Literal =
 1917|  1.76k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  1.76k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  1.76k|            value:String() { Literal::new_simple_literal(value) }
 1920|  1.76k|
 1921|  1.76k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  1.76k|
 1923|  1.76k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  1.76k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  1.76k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  1.76k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  1.76k|
 1928|  1.76k|        rule NumericLiteralPositive() -> Literal =
 1929|  1.76k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  1.76k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  1.76k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  1.76k|
 1933|  1.76k|
 1934|  1.76k|        rule NumericLiteralNegative() -> Literal =
 1935|  1.76k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  1.76k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  1.76k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  1.76k|
 1939|  1.76k|        rule BooleanLiteral() -> Literal =
 1940|  1.76k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  1.76k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  1.76k|
 1943|  1.76k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  1.76k|
 1945|  1.76k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  1.76k|            NamedNode::from(i)
 1947|  1.76k|        }
 1948|  1.76k|
 1949|  1.76k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  1.76k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  1.76k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  1.76k|            } else {
 1953|  1.76k|                Err("Prefix not found")
 1954|  1.76k|            } }
 1955|  1.76k|
 1956|  1.76k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  1.76k|            let node = BlankNode::new_unchecked(id);
 1958|  1.76k|            if state.used_bnodes.contains(&node) {
 1959|  1.76k|                Err("Already used blank node id")
 1960|  1.76k|            } else {
 1961|  1.76k|                state.currently_used_bnodes.insert(node.clone());
 1962|  1.76k|                Ok(node)
 1963|  1.76k|            }
 1964|  1.76k|        } / ANON() { BlankNode::default() }
 1965|  1.76k|
 1966|  1.76k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  1.76k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  1.76k|        }
 1969|  1.76k|
 1970|  1.76k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  1.76k|            ns
 1972|  1.76k|        }
 1973|  1.76k|
 1974|  1.76k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  1.76k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  1.76k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  1.76k|                iri.push_str(base);
 1978|  1.76k|                for chunk in local.split('\\') { // We remove \
 1979|  1.76k|                    iri.push_str(chunk);
 1980|  1.76k|                }
 1981|  1.76k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  1.76k|            } else {
 1983|  1.76k|                Err("Prefix not found")
 1984|  1.76k|            }
 1985|  1.76k|        }
 1986|  1.76k|
 1987|  1.76k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  1.76k|            b
 1989|  1.76k|        }
 1990|  1.76k|
 1991|  1.76k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  1.76k|
 1993|  1.76k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  1.76k|
 1995|  1.76k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  1.76k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  1.76k|        }
 1998|  1.76k|
 1999|  1.76k|        rule INTEGER() = ['0'..='9']+
 2000|  1.76k|
 2001|  1.76k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  1.76k|
 2003|  1.76k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  1.76k|
 2005|  1.76k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  1.76k|
 2007|  1.76k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  1.76k|
 2009|  1.76k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  1.76k|
 2011|  1.76k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  1.76k|
 2013|  1.76k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  1.76k|
 2015|  1.76k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  1.76k|
 2017|  1.76k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  1.76k|
 2019|  1.76k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  1.76k|             unescape_string(l)
 2021|  1.76k|        }
 2022|  1.76k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  1.76k|
 2024|  1.76k|
 2025|  1.76k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  1.76k|             unescape_string(l)
 2027|  1.76k|        }
 2028|  1.76k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  1.76k|
 2030|  1.76k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  1.76k|             unescape_string(l)
 2032|  1.76k|        }
 2033|  1.76k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  1.76k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  1.76k|
 2036|  1.76k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  1.76k|             unescape_string(l)
 2038|  1.76k|        }
 2039|  1.76k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  1.76k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  1.76k|
 2042|  1.76k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  1.76k|
 2044|  1.76k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  1.76k|
 2046|  1.76k|        rule NIL() = "(" WS()* ")"
 2047|  1.76k|
 2048|  1.76k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  1.76k|
 2050|  1.76k|        rule ANON() = "[" WS()* "]"
 2051|  1.76k|
 2052|  1.76k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  1.76k|
 2054|  1.76k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  1.76k|
 2056|  1.76k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  1.76k|
 2058|  1.76k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  1.76k|
 2060|  1.76k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  1.76k|
 2062|  1.76k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  1.76k|
 2064|  1.76k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  1.76k|
 2066|  1.76k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  1.76k|
 2068|  1.76k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  1.76k|
 2070|  1.76k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  1.76k|
 2072|  1.76k|        //space
 2073|  1.76k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  1.76k|
 2075|  1.76k|        //comment
 2076|  1.76k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  1.76k|
 2078|  1.76k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  1.76k|            if input.eq_ignore_ascii_case(literal) {
 2080|  1.76k|                Ok(())
 2081|  1.76k|            } else {
 2082|  1.76k|                Err(literal)
 2083|  1.76k|            }
 2084|  1.76k|        }
 2085|  1.76k|    }
 2086|  1.76k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_VerbPath0B7_:
 1462|  2.11k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  2.11k|            p.into()
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_GroupGraphPatternSub0s_0B9_:
 1209|      6|                        g.on_in_scope_variable(|v| {
 1210|      6|                            if *v == variable {
 1211|      2|                                contains = true;
 1212|      4|                            }
 1213|      6|                        });
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_PathPrimarys1_0B7_:
 1539|  21.8k|            "(" _ p:Path() _ ")" { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GraphGraphPattern0B7_:
 1262|     82|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|     82|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathOneInPropertySets1_0B7_:
 1574|    450|            "a" { Either::Left(rdf::TYPE.into()) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PathElt_op0B7_:
 1527|  1.17k|            "*" { '*' } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser31___parse_ConditionalOrExpression0B7_:
  778|  2.42k|parser! {
  779|  2.42k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  2.42k|    grammar parser(state: &mut ParserState) for str {
  781|  2.42k|        pub rule QueryUnit() -> Query = Query()
  782|  2.42k|
  783|  2.42k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  2.42k|            q
  785|  2.42k|        }
  786|  2.42k|
  787|  2.42k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  2.42k|
  789|  2.42k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  2.42k|
  791|  2.42k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  2.42k|            state.base_iri = Some(i)
  793|  2.42k|        }
  794|  2.42k|
  795|  2.42k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  2.42k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  2.42k|        }
  798|  2.42k|
  799|  2.42k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  2.42k|            Ok(Query::Select {
  801|  2.42k|                dataset: d,
  802|  2.42k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  2.42k|                base_iri: state.base_iri.clone()
  804|  2.42k|            })
  805|  2.42k|        }
  806|  2.42k|
  807|  2.42k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  2.42k|            build_select(s, w, g, h, o, l, v, state)
  809|  2.42k|        }
  810|  2.42k|
  811|  2.42k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  2.42k|            Selection {
  813|  2.42k|                option: o,
  814|  2.42k|                variables: v
  815|  2.42k|            }
  816|  2.42k|        }
  817|  2.42k|        rule Selection_init() = {
  818|  2.42k|            state.aggregates.push(Vec::new())
  819|  2.42k|        }
  820|  2.42k|        rule SelectClause_option() -> SelectionOption =
  821|  2.42k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  2.42k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  2.42k|            { SelectionOption::Default }
  824|  2.42k|        rule SelectClause_variables() -> SelectionVariables =
  825|  2.42k|            "*" { SelectionVariables::Star } /
  826|  2.42k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  2.42k|        rule SelectClause_member() -> SelectionMember =
  828|  2.42k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  2.42k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  2.42k|
  831|  2.42k|        rule ConstructQuery() -> Query =
  832|  2.42k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  2.42k|                Ok(Query::Construct {
  834|  2.42k|                    template: c,
  835|  2.42k|                    dataset: d,
  836|  2.42k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  2.42k|                    base_iri: state.base_iri.clone()
  838|  2.42k|                })
  839|  2.42k|            } /
  840|  2.42k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  2.42k|                Ok(Query::Construct {
  842|  2.42k|                    template: c.clone(),
  843|  2.42k|                    dataset: d,
  844|  2.42k|                    pattern: build_select(
  845|  2.42k|                        Selection::no_op(),
  846|  2.42k|                        GraphPattern::Bgp { patterns: c },
  847|  2.42k|                        g, h, o, l, v, state
  848|  2.42k|                    )?,
  849|  2.42k|                    base_iri: state.base_iri.clone()
  850|  2.42k|                })
  851|  2.42k|            }
  852|  2.42k|
  853|  2.42k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  2.42k|
  855|  2.42k|        rule DescribeQuery() -> Query =
  856|  2.42k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  2.42k|                Ok(Query::Describe {
  858|  2.42k|                    dataset: d,
  859|  2.42k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  2.42k|                    base_iri: state.base_iri.clone()
  861|  2.42k|                })
  862|  2.42k|            } /
  863|  2.42k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  2.42k|                Ok(Query::Describe {
  865|  2.42k|                    dataset: d,
  866|  2.42k|                    pattern: build_select(Selection {
  867|  2.42k|                        option: SelectionOption::Default,
  868|  2.42k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  2.42k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  2.42k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  2.42k|                        }).collect())
  872|  2.42k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  2.42k|                    base_iri: state.base_iri.clone()
  874|  2.42k|                })
  875|  2.42k|            }
  876|  2.42k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  2.42k|
  878|  2.42k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  2.42k|            Ok(Query::Ask {
  880|  2.42k|                dataset: d,
  881|  2.42k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  2.42k|                base_iri: state.base_iri.clone()
  883|  2.42k|            })
  884|  2.42k|        }
  885|  2.42k|
  886|  2.42k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  2.42k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  2.42k|            if d.is_empty() {
  889|  2.42k|                return None;
  890|  2.42k|            }
  891|  2.42k|            let mut default = Vec::new();
  892|  2.42k|            let mut named = Vec::new();
  893|  2.42k|            for (d, n) in d {
  894|  2.42k|                if let Some(d) = d {
  895|  2.42k|                    default.push(d);
  896|  2.42k|                }
  897|  2.42k|                if let Some(n) = n {
  898|  2.42k|                    named.push(n);
  899|  2.42k|                }
  900|  2.42k|            }
  901|  2.42k|            Some(QueryDataset {
  902|  2.42k|                default, named: Some(named)
  903|  2.42k|            })
  904|  2.42k|        }
  905|  2.42k|
  906|  2.42k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  2.42k|            (Some(s), None)
  908|  2.42k|        }
  909|  2.42k|
  910|  2.42k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  2.42k|            (None, Some(s))
  912|  2.42k|        }
  913|  2.42k|
  914|  2.42k|        rule SourceSelector() -> NamedNode = iri()
  915|  2.42k|
  916|  2.42k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  2.42k|            p
  918|  2.42k|        }
  919|  2.42k|
  920|  2.42k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  2.42k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  2.42k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  2.42k|                if let Expression::Variable(v) = e {
  924|  2.42k|                    v
  925|  2.42k|                } else {
  926|  2.42k|                    let v = vo.unwrap_or_else(variable);
  927|  2.42k|                    projections.push((e, v.clone()));
  928|  2.42k|                    v
  929|  2.42k|                }
  930|  2.42k|            }).collect();
  931|  2.42k|            (clauses, projections)
  932|  2.42k|        }
  933|  2.42k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  2.42k|
  935|  2.42k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  2.42k|            e:BuiltInCall() { (e, None) } /
  937|  2.42k|            e:FunctionCall() { (e, None) } /
  938|  2.42k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  2.42k|            e:Var() { (e.into(), None) }
  940|  2.42k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  2.42k|
  942|  2.42k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  2.42k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  2.42k|        }
  945|  2.42k|
  946|  2.42k|        rule HavingCondition() -> Expression = Constraint()
  947|  2.42k|
  948|  2.42k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  2.42k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  2.42k|
  951|  2.42k|        rule OrderCondition() -> OrderExpression =
  952|  2.42k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  2.42k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  2.42k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  2.42k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  2.42k|
  957|  2.42k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  2.42k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  2.42k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  2.42k|
  961|  2.42k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  2.42k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  2.42k|        }
  964|  2.42k|
  965|  2.42k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  2.42k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  2.42k|        }
  968|  2.42k|
  969|  2.42k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  2.42k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  2.42k|            { None }
  972|  2.42k|
  973|  2.42k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  2.42k|
  975|  2.42k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  2.42k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  2.42k|
  978|  2.42k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  2.42k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  2.42k|        }
  981|  2.42k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  2.42k|
  983|  2.42k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  2.42k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  2.42k|        }
  986|  2.42k|
  987|  2.42k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  2.42k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  2.42k|        }
  990|  2.42k|
  991|  2.42k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  2.42k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  2.42k|        }
  994|  2.42k|
  995|  2.42k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  2.42k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  2.42k|            if from == to {
  998|  2.42k|                Vec::new() // identity case
  999|  2.42k|            } else {
 1000|  2.42k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  2.42k|                vec![copy_graph(from, to)]
 1002|  2.42k|            }
 1003|  2.42k|        }
 1004|  2.42k|
 1005|  2.42k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  2.42k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  2.42k|            if from == to {
 1008|  2.42k|                Vec::new() // identity case
 1009|  2.42k|            } else {
 1010|  2.42k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  2.42k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  2.42k|            }
 1013|  2.42k|        }
 1014|  2.42k|
 1015|  2.42k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  2.42k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  2.42k|            if from == to {
 1018|  2.42k|                Vec::new() // identity case
 1019|  2.42k|            } else {
 1020|  2.42k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  2.42k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  2.42k|            }
 1023|  2.42k|        }
 1024|  2.42k|
 1025|  2.42k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  2.42k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  2.42k|        }
 1028|  2.42k|
 1029|  2.42k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  2.42k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  2.42k|        }
 1032|  2.42k|
 1033|  2.42k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  2.42k|            let pattern = d.iter().map(|q| {
 1035|  2.42k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  2.42k|                match &q.graph_name {
 1037|  2.42k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  2.42k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  2.42k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  2.42k|                }
 1041|  2.42k|            }).reduce(new_join).unwrap_or_default();
 1042|  2.42k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  2.42k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  2.42k|                delete,
 1045|  2.42k|                insert: Vec::new(),
 1046|  2.42k|                using: None,
 1047|  2.42k|                pattern: Box::new(pattern)
 1048|  2.42k|            }])
 1049|  2.42k|        }
 1050|  2.42k|
 1051|  2.42k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  2.42k|            let (delete, insert) = c;
 1053|  2.42k|            let mut delete = delete.unwrap_or_default();
 1054|  2.42k|            let mut insert = insert.unwrap_or_default();
 1055|  2.42k|            #[allow(clippy::shadow_same)]
 1056|  2.42k|            let mut pattern = pattern;
 1057|  2.42k|
 1058|  2.42k|            let mut using = if u.is_empty() {
 1059|  2.42k|                None
 1060|  2.42k|            } else {
 1061|  2.42k|                let mut default = Vec::new();
 1062|  2.42k|                let mut named = Vec::new();
 1063|  2.42k|                for (d, n) in u {
 1064|  2.42k|                    if let Some(d) = d {
 1065|  2.42k|                        default.push(d)
 1066|  2.42k|                    }
 1067|  2.42k|                    if let Some(n) = n {
 1068|  2.42k|                        named.push(n)
 1069|  2.42k|                    }
 1070|  2.42k|                }
 1071|  2.42k|                Some(QueryDataset { default, named: Some(named) })
 1072|  2.42k|            };
 1073|  2.42k|
 1074|  2.42k|            if let Some(with) = with {
 1075|  2.42k|                // We inject WITH everywhere
 1076|  2.42k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  2.42k|                    GroundQuadPattern {
 1078|  2.42k|                        subject: q.subject,
 1079|  2.42k|                        predicate: q.predicate,
 1080|  2.42k|                        object: q.object,
 1081|  2.42k|                        graph_name: with.clone().into()
 1082|  2.42k|                    }
 1083|  2.42k|                } else {
 1084|  2.42k|                    q
 1085|  2.42k|                }).collect();
 1086|  2.42k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  2.42k|                    QuadPattern {
 1088|  2.42k|                        subject: q.subject,
 1089|  2.42k|                        predicate: q.predicate,
 1090|  2.42k|                        object: q.object,
 1091|  2.42k|                        graph_name: with.clone().into()
 1092|  2.42k|                    }
 1093|  2.42k|                } else {
 1094|  2.42k|                    q
 1095|  2.42k|                }).collect();
 1096|  2.42k|                if using.is_none() {
 1097|  2.42k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  2.42k|                }
 1099|  2.42k|            }
 1100|  2.42k|
 1101|  2.42k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  2.42k|                delete,
 1103|  2.42k|                insert,
 1104|  2.42k|                using,
 1105|  2.42k|                pattern: Box::new(pattern)
 1106|  2.42k|            }]
 1107|  2.42k|        }
 1108|  2.42k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  2.42k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  2.42k|            (Some(d), i)
 1111|  2.42k|        } / i:InsertClause() {
 1112|  2.42k|            (None, Some(i))
 1113|  2.42k|        }
 1114|  2.42k|        rule Modify_clear() = {
 1115|  2.42k|            state.used_bnodes.clear();
 1116|  2.42k|            state.currently_used_bnodes.clear();
 1117|  2.42k|        }
 1118|  2.42k|
 1119|  2.42k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  2.42k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  2.42k|        }
 1122|  2.42k|
 1123|  2.42k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  2.42k|
 1125|  2.42k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  2.42k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  2.42k|            (Some(i), None)
 1128|  2.42k|        }
 1129|  2.42k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  2.42k|            (None, Some(i))
 1131|  2.42k|        }
 1132|  2.42k|
 1133|  2.42k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  2.42k|            GraphName::DefaultGraph
 1135|  2.42k|        } / (i("GRAPH") _)? g:iri() {
 1136|  2.42k|            GraphName::NamedNode(g)
 1137|  2.42k|        }
 1138|  2.42k|
 1139|  2.42k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  2.42k|
 1141|  2.42k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  2.42k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  2.42k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  2.42k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  2.42k|
 1146|  2.42k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  2.42k|
 1148|  2.42k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  2.42k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  2.42k|        }
 1151|  2.42k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  2.42k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  2.42k|        }
 1154|  2.42k|
 1155|  2.42k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  2.42k|            q.into_iter().flatten().collect()
 1157|  2.42k|        }
 1158|  2.42k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  2.42k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  2.42k|        } //TODO: return iter?
 1161|  2.42k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  2.42k|
 1163|  2.42k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  2.42k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  2.42k|        }
 1166|  2.42k|
 1167|  2.42k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  2.42k|            ts.into_iter().flatten().collect()
 1169|  2.42k|        }
 1170|  2.42k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  2.42k|
 1172|  2.42k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  2.42k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  2.42k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  2.42k|        rule GroupGraphPattern_clear() = {
 1176|  2.42k|             // We deal with blank nodes aliases rule
 1177|  2.42k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  2.42k|            state.currently_used_bnodes.clear();
 1179|  2.42k|        }
 1180|  2.42k|
 1181|  2.42k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  2.42k|            let mut filter: Option<Expression> = None;
 1183|  2.42k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  2.42k|            for e in b.into_iter().flatten() {
 1185|  2.42k|                match e {
 1186|  2.42k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  2.42k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  2.42k|                    }
 1189|  2.42k|                    #[cfg(feature = "sep-0006")]
 1190|  2.42k|                    PartialGraphPattern::Lateral(p) => {
 1191|  2.42k|                        let mut defined_variables = HashSet::default();
 1192|  2.42k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  2.42k|                        let mut contains = false;
 1194|  2.42k|                        g.on_in_scope_variable(|v| {
 1195|  2.42k|                            if defined_variables.contains(v) {
 1196|  2.42k|                                contains = true;
 1197|  2.42k|                            }
 1198|  2.42k|                        });
 1199|  2.42k|                        if contains {
 1200|  2.42k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  2.42k|                        }
 1202|  2.42k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  2.42k|                    }
 1204|  2.42k|                    PartialGraphPattern::Minus(p) => {
 1205|  2.42k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  2.42k|                    }
 1207|  2.42k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  2.42k|                        let mut contains = false;
 1209|  2.42k|                        g.on_in_scope_variable(|v| {
 1210|  2.42k|                            if *v == variable {
 1211|  2.42k|                                contains = true;
 1212|  2.42k|                            }
 1213|  2.42k|                        });
 1214|  2.42k|                        if contains {
 1215|  2.42k|                            return Err("BIND is overriding an existing variable")
 1216|  2.42k|                        }
 1217|  2.42k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  2.42k|                    }
 1219|  2.42k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  2.42k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  2.42k|                    } else {
 1222|  2.42k|                        expr
 1223|  2.42k|                    }),
 1224|  2.42k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  2.42k|                }
 1226|  2.42k|            }
 1227|  2.42k|
 1228|  2.42k|            Ok(if let Some(expr) = filter {
 1229|  2.42k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  2.42k|            } else {
 1231|  2.42k|                g
 1232|  2.42k|            })
 1233|  2.42k|        }
 1234|  2.42k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  2.42k|            let mut result = vec![a];
 1236|  2.42k|            if let Some(v) = b {
 1237|  2.42k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  2.42k|            }
 1239|  2.42k|            result
 1240|  2.42k|        }
 1241|  2.42k|
 1242|  2.42k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  2.42k|            hs.into_iter().flatten().collect()
 1244|  2.42k|        }
 1245|  2.42k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  2.42k|
 1247|  2.42k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  2.42k|
 1249|  2.42k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  2.42k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  2.42k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  2.42k|            } else {
 1253|  2.42k|               PartialGraphPattern::Optional(p, None)
 1254|  2.42k|            }
 1255|  2.42k|        }
 1256|  2.42k|
 1257|  2.42k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  2.42k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  2.42k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  2.42k|        }
 1261|  2.42k|
 1262|  2.42k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  2.42k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  2.42k|        }
 1265|  2.42k|
 1266|  2.42k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  2.42k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  2.42k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  2.42k|
 1270|  2.42k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  2.42k|            PartialGraphPattern::Bind(e, v)
 1272|  2.42k|        }
 1273|  2.42k|
 1274|  2.42k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  2.42k|
 1276|  2.42k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  2.42k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  2.42k|        }
 1279|  2.42k|
 1280|  2.42k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  2.42k|            (vec![var], d)
 1282|  2.42k|        }
 1283|  2.42k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  2.42k|
 1285|  2.42k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  2.42k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  2.42k|                Ok((vars, vals))
 1288|  2.42k|            } else {
 1289|  2.42k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  2.42k|            }
 1291|  2.42k|        }
 1292|  2.42k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  2.42k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  2.42k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  2.42k|
 1296|  2.42k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  2.42k|            t:QuotedTripleData() {?
 1298|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  2.42k|            } /
 1301|  2.42k|            i:iri() { Some(i.into()) } /
 1302|  2.42k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  2.42k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  2.42k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  2.42k|            i("UNDEF") { None }
 1306|  2.42k|
 1307|  2.42k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  2.42k|            PartialGraphPattern::Minus(p)
 1309|  2.42k|        }
 1310|  2.42k|
 1311|  2.42k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  2.42k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  2.42k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  2.42k|            }).map(PartialGraphPattern::Other)
 1315|  2.42k|        }
 1316|  2.42k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  2.42k|
 1318|  2.42k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  2.42k|            PartialGraphPattern::Filter(c)
 1320|  2.42k|        }
 1321|  2.42k|
 1322|  2.42k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  2.42k|
 1324|  2.42k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  2.42k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  2.42k|        }
 1327|  2.42k|
 1328|  2.42k|        rule ArgList() -> Vec<Expression> =
 1329|  2.42k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  2.42k|            NIL() { Vec::new() }
 1331|  2.42k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  2.42k|
 1333|  2.42k|        rule ExpressionList() -> Vec<Expression> =
 1334|  2.42k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  2.42k|            NIL() { Vec::new() }
 1336|  2.42k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  2.42k|
 1338|  2.42k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  2.42k|
 1340|  2.42k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  2.42k|            p.into_iter().flatten().collect()
 1342|  2.42k|        }
 1343|  2.42k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  2.42k|
 1345|  2.42k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  2.42k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  2.42k|                let mut patterns = po.patterns;
 1348|  2.42k|                for (p, os) in po.focus {
 1349|  2.42k|                    for o in os {
 1350|  2.42k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  2.42k|                    }
 1352|  2.42k|                }
 1353|  2.42k|                Ok(patterns)
 1354|  2.42k|            } /
 1355|  2.42k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  2.42k|                let mut patterns = s.patterns;
 1357|  2.42k|                patterns.extend(po.patterns);
 1358|  2.42k|                for (p, os) in po.focus {
 1359|  2.42k|                    for o in os {
 1360|  2.42k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  2.42k|                    }
 1362|  2.42k|                }
 1363|  2.42k|                Ok(patterns)
 1364|  2.42k|            }
 1365|  2.42k|
 1366|  2.42k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  2.42k|            PropertyListNotEmpty() /
 1368|  2.42k|            { FocusedTriplePattern::default() }
 1369|  2.42k|
 1370|  2.42k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  2.42k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  2.42k|                a.focus.push(b.focus);
 1373|  2.42k|                a.patterns.extend(b.patterns);
 1374|  2.42k|                a
 1375|  2.42k|            })
 1376|  2.42k|        }
 1377|  2.42k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  2.42k|            FocusedTriplePattern {
 1379|  2.42k|                focus: (p, o.focus),
 1380|  2.42k|                patterns: o.patterns
 1381|  2.42k|            }
 1382|  2.42k|        }
 1383|  2.42k|
 1384|  2.42k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  2.42k|
 1386|  2.42k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  2.42k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  2.42k|                a.focus.push(b.focus);
 1389|  2.42k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  2.42k|                a
 1391|  2.42k|            })
 1392|  2.42k|        }
 1393|  2.42k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  2.42k|
 1395|  2.42k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  2.42k|            if let Some(a) = a {
 1397|  2.42k|                let mut patterns = g.patterns;
 1398|  2.42k|                patterns.extend(a.patterns);
 1399|  2.42k|                FocusedTriplePattern {
 1400|  2.42k|                    focus: AnnotatedTerm {
 1401|  2.42k|                        term: g.focus,
 1402|  2.42k|                        annotations: a.focus
 1403|  2.42k|                    },
 1404|  2.42k|                    patterns
 1405|  2.42k|                }
 1406|  2.42k|            } else {
 1407|  2.42k|                FocusedTriplePattern {
 1408|  2.42k|                    focus: AnnotatedTerm {
 1409|  2.42k|                        term: g.focus,
 1410|  2.42k|                        annotations: Vec::new()
 1411|  2.42k|                    },
 1412|  2.42k|                    patterns: g.patterns
 1413|  2.42k|                }
 1414|  2.42k|            }
 1415|  2.42k|        }
 1416|  2.42k|
 1417|  2.42k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  2.42k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  2.42k|                let mut patterns = po.patterns;
 1420|  2.42k|                for (p, os) in po.focus {
 1421|  2.42k|                    for o in os {
 1422|  2.42k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  2.42k|                    }
 1424|  2.42k|                }
 1425|  2.42k|                Ok(patterns)
 1426|  2.42k|            } /
 1427|  2.42k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  2.42k|                let mut patterns = s.patterns;
 1429|  2.42k|                patterns.extend(po.patterns);
 1430|  2.42k|                for (p, os) in po.focus {
 1431|  2.42k|                    for o in os {
 1432|  2.42k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  2.42k|                    }
 1434|  2.42k|                }
 1435|  2.42k|                Ok(patterns)
 1436|  2.42k|            }
 1437|  2.42k|
 1438|  2.42k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  2.42k|            PropertyListPathNotEmpty() /
 1440|  2.42k|            { FocusedTripleOrPathPattern::default() }
 1441|  2.42k|
 1442|  2.42k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  2.42k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  2.42k|                    focus: vec![(hp, ho.focus)],
 1445|  2.42k|                    patterns: ho.patterns
 1446|  2.42k|                }, |mut a, b| {
 1447|  2.42k|                    a.focus.push(b.focus);
 1448|  2.42k|                    a.patterns.extend(b.patterns);
 1449|  2.42k|                    a
 1450|  2.42k|                })
 1451|  2.42k|        }
 1452|  2.42k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  2.42k|            c
 1454|  2.42k|        }
 1455|  2.42k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  2.42k|            FocusedTripleOrPathPattern {
 1457|  2.42k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  2.42k|                patterns: o.patterns
 1459|  2.42k|            }
 1460|  2.42k|        }
 1461|  2.42k|
 1462|  2.42k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  2.42k|            p.into()
 1464|  2.42k|        }
 1465|  2.42k|
 1466|  2.42k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  2.42k|            v.into()
 1468|  2.42k|        }
 1469|  2.42k|
 1470|  2.42k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  2.42k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  2.42k|                a.focus.push(b.focus);
 1473|  2.42k|                a.patterns.extend(b.patterns);
 1474|  2.42k|                a
 1475|  2.42k|            })
 1476|  2.42k|        }
 1477|  2.42k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  2.42k|
 1479|  2.42k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  2.42k|             if let Some(a) = a {
 1481|  2.42k|                let mut patterns = g.patterns;
 1482|  2.42k|                patterns.extend(a.patterns);
 1483|  2.42k|                FocusedTripleOrPathPattern {
 1484|  2.42k|                    focus: AnnotatedTermPath {
 1485|  2.42k|                        term: g.focus,
 1486|  2.42k|                        annotations: a.focus
 1487|  2.42k|                    },
 1488|  2.42k|                    patterns
 1489|  2.42k|                }
 1490|  2.42k|            } else {
 1491|  2.42k|                FocusedTripleOrPathPattern {
 1492|  2.42k|                    focus: AnnotatedTermPath {
 1493|  2.42k|                        term: g.focus,
 1494|  2.42k|                        annotations: Vec::new()
 1495|  2.42k|                    },
 1496|  2.42k|                    patterns: g.patterns
 1497|  2.42k|                }
 1498|  2.42k|            }
 1499|  2.42k|        }
 1500|  2.42k|
 1501|  2.42k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  2.42k|
 1503|  2.42k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  2.42k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  2.42k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  2.42k|            })
 1507|  2.42k|        }
 1508|  2.42k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  2.42k|
 1510|  2.42k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  2.42k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  2.42k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  2.42k|            })
 1514|  2.42k|        }
 1515|  2.42k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  2.42k|
 1517|  2.42k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  2.42k|            match o {
 1519|  2.42k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  2.42k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  2.42k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  2.42k|                Some(_) => unreachable!(),
 1523|  2.42k|                None => p
 1524|  2.42k|            }
 1525|  2.42k|        }
 1526|  2.42k|        rule PathElt_op() -> char =
 1527|  2.42k|            "*" { '*' } /
 1528|  2.42k|            "+" { '+' } /
 1529|  2.42k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  2.42k|
 1531|  2.42k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  2.42k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  2.42k|            PathElt()
 1534|  2.42k|
 1535|  2.42k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  2.42k|            v:iri() { v.into() } /
 1537|  2.42k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  2.42k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  2.42k|            "(" _ p:Path() _ ")" { p }
 1540|  2.42k|
 1541|  2.42k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  2.42k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  2.42k|                let mut direct = Vec::new();
 1544|  2.42k|                let mut inverse = Vec::new();
 1545|  2.42k|                for e in p {
 1546|  2.42k|                    match e {
 1547|  2.42k|                        Either::Left(a) => direct.push(a),
 1548|  2.42k|                        Either::Right(b) => inverse.push(b)
 1549|  2.42k|                    }
 1550|  2.42k|                }
 1551|  2.42k|                if inverse.is_empty() {
 1552|  2.42k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  2.42k|                } else if direct.is_empty() {
 1554|  2.42k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  2.42k|                } else {
 1556|  2.42k|                    PropertyPathExpression::Alternative(
 1557|  2.42k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  2.42k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  2.42k|                    )
 1560|  2.42k|                }
 1561|  2.42k|            } /
 1562|  2.42k|            p:PathOneInPropertySet() {
 1563|  2.42k|                match p {
 1564|  2.42k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  2.42k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  2.42k|                }
 1567|  2.42k|            }
 1568|  2.42k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  2.42k|
 1570|  2.42k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  2.42k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  2.42k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  2.42k|            v:iri() { Either::Left(v) } /
 1574|  2.42k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  2.42k|
 1576|  2.42k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  2.42k|
 1578|  2.42k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  2.42k|            let mut patterns = po.patterns;
 1580|  2.42k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  2.42k|            for (p, os) in po.focus {
 1582|  2.42k|                for o in os {
 1583|  2.42k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  2.42k|                }
 1585|  2.42k|            }
 1586|  2.42k|            Ok(FocusedTriplePattern {
 1587|  2.42k|                focus: bnode,
 1588|  2.42k|                patterns
 1589|  2.42k|            })
 1590|  2.42k|        }
 1591|  2.42k|
 1592|  2.42k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  2.42k|
 1594|  2.42k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  2.42k|            let mut patterns = po.patterns;
 1596|  2.42k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  2.42k|            for (p, os) in po.focus {
 1598|  2.42k|                for o in os {
 1599|  2.42k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  2.42k|                }
 1601|  2.42k|            }
 1602|  2.42k|            Ok(FocusedTripleOrPathPattern {
 1603|  2.42k|                focus: bnode,
 1604|  2.42k|                patterns
 1605|  2.42k|            })
 1606|  2.42k|        }
 1607|  2.42k|
 1608|  2.42k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  2.42k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  2.42k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  2.42k|            for objWithPatterns in o.into_iter().rev() {
 1612|  2.42k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  2.42k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  2.42k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  2.42k|                current_list_node = new_blank_node;
 1616|  2.42k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  2.42k|            }
 1618|  2.42k|            FocusedTriplePattern {
 1619|  2.42k|                focus: current_list_node,
 1620|  2.42k|                patterns
 1621|  2.42k|            }
 1622|  2.42k|        }
 1623|  2.42k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  2.42k|
 1625|  2.42k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  2.42k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  2.42k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  2.42k|            for objWithPatterns in o.into_iter().rev() {
 1629|  2.42k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  2.42k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  2.42k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  2.42k|                current_list_node = new_blank_node;
 1633|  2.42k|                patterns.extend(objWithPatterns.patterns);
 1634|  2.42k|            }
 1635|  2.42k|            FocusedTripleOrPathPattern {
 1636|  2.42k|                focus: current_list_node,
 1637|  2.42k|                patterns
 1638|  2.42k|            }
 1639|  2.42k|        }
 1640|  2.42k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  2.42k|
 1642|  2.42k|
 1643|  2.42k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  2.42k|
 1645|  2.42k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  2.42k|
 1647|  2.42k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  2.42k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  2.42k|            TriplesNode()
 1650|  2.42k|
 1651|  2.42k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  2.42k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  2.42k|            TriplesNodePath()
 1654|  2.42k|
 1655|  2.42k|        rule VarOrTerm() -> TermPattern =
 1656|  2.42k|            v:Var() { v.into() } /
 1657|  2.42k|            t:QuotedTriple() {?
 1658|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  2.42k|            } /
 1661|  2.42k|            t:GraphTerm() { t.into() }
 1662|  2.42k|
 1663|  2.42k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  2.42k|            Ok(TriplePattern {
 1665|  2.42k|                subject: s,
 1666|  2.42k|                predicate: p,
 1667|  2.42k|                object: o
 1668|  2.42k|            })
 1669|  2.42k|        }
 1670|  2.42k|
 1671|  2.42k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  2.42k|            Ok(GroundTriple {
 1673|  2.42k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  2.42k|                predicate: p,
 1675|  2.42k|                object: o
 1676|  2.42k|            })
 1677|  2.42k|        }
 1678|  2.42k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  2.42k|
 1680|  2.42k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  2.42k|            l:RDFLiteral() { l.into() } /
 1682|  2.42k|            l:NumericLiteral() { l.into() } /
 1683|  2.42k|            l:BooleanLiteral() { l.into() } /
 1684|  2.42k|            t:QuotedTripleData() {?
 1685|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  2.42k|            }
 1688|  2.42k|
 1689|  2.42k|        rule VarOrIri() -> NamedNodePattern =
 1690|  2.42k|            v:Var() { v.into() } /
 1691|  2.42k|            i:iri() { i.into() }
 1692|  2.42k|
 1693|  2.42k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  2.42k|
 1695|  2.42k|        rule GraphTerm() -> Term =
 1696|  2.42k|            i:iri() { i.into() } /
 1697|  2.42k|            l:RDFLiteral() { l.into() } /
 1698|  2.42k|            l:NumericLiteral() { l.into() } /
 1699|  2.42k|            l:BooleanLiteral() { l.into() } /
 1700|  2.42k|            b:BlankNode() { b.into() } /
 1701|  2.42k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  2.42k|
 1703|  2.42k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  2.42k|
 1705|  2.42k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  2.42k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  2.42k|        }
 1708|  2.42k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  2.42k|
 1710|  2.42k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  2.42k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  2.42k|        }
 1713|  2.42k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  2.42k|
 1715|  2.42k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  2.42k|
 1717|  2.42k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  2.42k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  2.42k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  2.42k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  2.42k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  2.42k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  2.42k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  2.42k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  2.42k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  2.42k|            Some(_) => unreachable!(),
 1727|  2.42k|            None => a
 1728|  2.42k|        } }
 1729|  2.42k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  2.42k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  2.42k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  2.42k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  2.42k|
 1734|  2.42k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  2.42k|
 1736|  2.42k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  2.42k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  2.42k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  2.42k|            Some(_) => unreachable!(),
 1740|  2.42k|            None => a,
 1741|  2.42k|        } }
 1742|  2.42k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  2.42k|            (s, e)
 1744|  2.42k|        }
 1745|  2.42k|
 1746|  2.42k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  2.42k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  2.42k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  2.42k|            Some(_) => unreachable!(),
 1750|  2.42k|            None => a
 1751|  2.42k|        } }
 1752|  2.42k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  2.42k|            (s, e)
 1754|  2.42k|        }
 1755|  2.42k|
 1756|  2.42k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  2.42k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  2.42k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  2.42k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  2.42k|            Some(_) => unreachable!(),
 1761|  2.42k|            None => e,
 1762|  2.42k|        } }
 1763|  2.42k|
 1764|  2.42k|        rule PrimaryExpression() -> Expression =
 1765|  2.42k|            BrackettedExpression()  /
 1766|  2.42k|            ExprQuotedTriple() /
 1767|  2.42k|            iriOrFunction() /
 1768|  2.42k|            v:Var() { v.into() } /
 1769|  2.42k|            l:RDFLiteral() { l.into() } /
 1770|  2.42k|            l:NumericLiteral() { l.into() } /
 1771|  2.42k|            l:BooleanLiteral() { l.into() } /
 1772|  2.42k|            BuiltInCall()
 1773|  2.42k|
 1774|  2.42k|        rule ExprVarOrTerm() -> Expression =
 1775|  2.42k|            ExprQuotedTriple() /
 1776|  2.42k|            i:iri() { i.into() } /
 1777|  2.42k|            l:RDFLiteral() { l.into() } /
 1778|  2.42k|            l:NumericLiteral() { l.into() } /
 1779|  2.42k|            l:BooleanLiteral() { l.into() } /
 1780|  2.42k|            v:Var() { v.into() }
 1781|  2.42k|
 1782|  2.42k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  2.42k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  2.42k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  2.42k|        }
 1786|  2.42k|
 1787|  2.42k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  2.42k|
 1789|  2.42k|        rule BuiltInCall() -> Expression =
 1790|  2.42k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  2.42k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  2.42k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  2.42k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  2.42k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  2.42k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  2.42k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  2.42k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  2.42k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  2.42k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  2.42k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  2.42k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  2.42k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  2.42k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  2.42k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  2.42k|            SubstringExpression() /
 1806|  2.42k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  2.42k|            StrReplaceExpression() /
 1808|  2.42k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  2.42k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  2.42k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  2.42k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  2.42k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  2.42k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  2.42k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  2.42k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  2.42k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  2.42k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  2.42k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  2.42k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  2.42k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  2.42k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  2.42k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  2.42k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  2.42k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  2.42k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  2.42k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  2.42k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  2.42k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  2.42k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  2.42k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  2.42k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  2.42k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  2.42k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  2.42k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  2.42k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  2.42k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  2.42k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  2.42k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  2.42k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  2.42k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  2.42k|            RegexExpression() /
 1842|  2.42k|            ExistsFunc() /
 1843|  2.42k|            NotExistsFunc() /
 1844|  2.42k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  2.42k|            } /
 1848|  2.42k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  2.42k|            } /
 1852|  2.42k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  2.42k|            } /
 1856|  2.42k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  2.42k|            } /
 1860|  2.42k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  2.42k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  2.42k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  2.42k|            } /
 1864|  2.42k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  2.42k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  2.42k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  2.42k|            }
 1868|  2.42k|
 1869|  2.42k|        rule RegexExpression() -> Expression =
 1870|  2.42k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  2.42k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  2.42k|
 1873|  2.42k|
 1874|  2.42k|        rule SubstringExpression() -> Expression =
 1875|  2.42k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  2.42k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  2.42k|
 1878|  2.42k|
 1879|  2.42k|        rule StrReplaceExpression() -> Expression =
 1880|  2.42k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  2.42k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  2.42k|
 1883|  2.42k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  2.42k|
 1885|  2.42k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  2.42k|
 1887|  2.42k|        rule Aggregate() -> AggregateExpression =
 1888|  2.42k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  2.42k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  2.42k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  2.42k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  2.42k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  2.42k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  2.42k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  2.42k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  2.42k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  2.42k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  2.42k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  2.42k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  2.42k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  2.42k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  2.42k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  2.42k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  2.42k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  2.42k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  2.42k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  2.42k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  2.42k|
 1909|  2.42k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  2.42k|            match a {
 1911|  2.42k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  2.42k|                None => i.into()
 1913|  2.42k|            }
 1914|  2.42k|        }
 1915|  2.42k|
 1916|  2.42k|        rule RDFLiteral() -> Literal =
 1917|  2.42k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  2.42k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  2.42k|            value:String() { Literal::new_simple_literal(value) }
 1920|  2.42k|
 1921|  2.42k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  2.42k|
 1923|  2.42k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  2.42k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  2.42k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  2.42k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  2.42k|
 1928|  2.42k|        rule NumericLiteralPositive() -> Literal =
 1929|  2.42k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  2.42k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  2.42k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  2.42k|
 1933|  2.42k|
 1934|  2.42k|        rule NumericLiteralNegative() -> Literal =
 1935|  2.42k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  2.42k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  2.42k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  2.42k|
 1939|  2.42k|        rule BooleanLiteral() -> Literal =
 1940|  2.42k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  2.42k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  2.42k|
 1943|  2.42k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  2.42k|
 1945|  2.42k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  2.42k|            NamedNode::from(i)
 1947|  2.42k|        }
 1948|  2.42k|
 1949|  2.42k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  2.42k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  2.42k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  2.42k|            } else {
 1953|  2.42k|                Err("Prefix not found")
 1954|  2.42k|            } }
 1955|  2.42k|
 1956|  2.42k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  2.42k|            let node = BlankNode::new_unchecked(id);
 1958|  2.42k|            if state.used_bnodes.contains(&node) {
 1959|  2.42k|                Err("Already used blank node id")
 1960|  2.42k|            } else {
 1961|  2.42k|                state.currently_used_bnodes.insert(node.clone());
 1962|  2.42k|                Ok(node)
 1963|  2.42k|            }
 1964|  2.42k|        } / ANON() { BlankNode::default() }
 1965|  2.42k|
 1966|  2.42k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  2.42k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  2.42k|        }
 1969|  2.42k|
 1970|  2.42k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  2.42k|            ns
 1972|  2.42k|        }
 1973|  2.42k|
 1974|  2.42k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  2.42k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  2.42k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  2.42k|                iri.push_str(base);
 1978|  2.42k|                for chunk in local.split('\\') { // We remove \
 1979|  2.42k|                    iri.push_str(chunk);
 1980|  2.42k|                }
 1981|  2.42k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  2.42k|            } else {
 1983|  2.42k|                Err("Prefix not found")
 1984|  2.42k|            }
 1985|  2.42k|        }
 1986|  2.42k|
 1987|  2.42k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  2.42k|            b
 1989|  2.42k|        }
 1990|  2.42k|
 1991|  2.42k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  2.42k|
 1993|  2.42k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  2.42k|
 1995|  2.42k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  2.42k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  2.42k|        }
 1998|  2.42k|
 1999|  2.42k|        rule INTEGER() = ['0'..='9']+
 2000|  2.42k|
 2001|  2.42k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  2.42k|
 2003|  2.42k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  2.42k|
 2005|  2.42k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  2.42k|
 2007|  2.42k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  2.42k|
 2009|  2.42k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  2.42k|
 2011|  2.42k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  2.42k|
 2013|  2.42k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  2.42k|
 2015|  2.42k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  2.42k|
 2017|  2.42k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  2.42k|
 2019|  2.42k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  2.42k|             unescape_string(l)
 2021|  2.42k|        }
 2022|  2.42k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  2.42k|
 2024|  2.42k|
 2025|  2.42k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  2.42k|             unescape_string(l)
 2027|  2.42k|        }
 2028|  2.42k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  2.42k|
 2030|  2.42k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  2.42k|             unescape_string(l)
 2032|  2.42k|        }
 2033|  2.42k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  2.42k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  2.42k|
 2036|  2.42k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  2.42k|             unescape_string(l)
 2038|  2.42k|        }
 2039|  2.42k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  2.42k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  2.42k|
 2042|  2.42k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  2.42k|
 2044|  2.42k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  2.42k|
 2046|  2.42k|        rule NIL() = "(" WS()* ")"
 2047|  2.42k|
 2048|  2.42k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  2.42k|
 2050|  2.42k|        rule ANON() = "[" WS()* "]"
 2051|  2.42k|
 2052|  2.42k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  2.42k|
 2054|  2.42k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  2.42k|
 2056|  2.42k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  2.42k|
 2058|  2.42k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  2.42k|
 2060|  2.42k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  2.42k|
 2062|  2.42k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  2.42k|
 2064|  2.42k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  2.42k|
 2066|  2.42k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  2.42k|
 2068|  2.42k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  2.42k|
 2070|  2.42k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  2.42k|
 2072|  2.42k|        //space
 2073|  2.42k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  2.42k|
 2075|  2.42k|        //comment
 2076|  2.42k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  2.42k|
 2078|  2.42k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  2.42k|            if input.eq_ignore_ascii_case(literal) {
 2080|  2.42k|                Ok(())
 2081|  2.42k|            } else {
 2082|  2.42k|                Err(literal)
 2083|  2.42k|            }
 2084|  2.42k|        }
 2085|  2.42k|    }
 2086|  2.42k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathOneInPropertySet0B7_:
 1571|  2.74k|            "^" _ v:iri() { Either::Right(v) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PrimaryExpressions1_0B7_:
 1771|     28|            l:BooleanLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroupCondition0B7_:
  936|     49|            e:BuiltInCall() { (e, None) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls3_0B7_:
 1795|    712|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_BooleanLiterals_0B7_:
 1941|    400|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GraphOrDefaults_0B7_:
 1135|  1.13k|        } / (i("GRAPH") _)? g:iri() {
 1136|  1.13k|            GraphName::NamedNode(g)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_VarOrIri0B7_:
 1690|  5.64k|            v:Var() { v.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GroupGraphPatterns_0B7_:
 1174|  1.33k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_OptionalGraphPattern0B7_:
 1249|    243|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|    243|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|      0|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|    243|               PartialGraphPattern::Optional(p, None)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ObjectList0B7_:
 1386|  17.0k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  17.0k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|  17.0k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls2_0B7_:
 1794|      1|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_DeleteData0B7_:
 1029|     75|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|     75|            vec![GraphUpdateOperation::DeleteData { data }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_VarOrTerms0_0B7_:
 1661|  22.6k|            t:GraphTerm() { t.into() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Drop0B7_:
  987|    218|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|    218|            vec![GraphUpdateOperation::Drop { silent, graph }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ObjectPath0B7_:
 1479|  15.0k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  15.0k|             if let Some(a) = a {
 1481|      0|                let mut patterns = g.patterns;
 1482|      0|                patterns.extend(a.patterns);
 1483|      0|                FocusedTripleOrPathPattern {
 1484|      0|                    focus: AnnotatedTermPath {
 1485|      0|                        term: g.focus,
 1486|      0|                        annotations: a.focus
 1487|      0|                    },
 1488|      0|                    patterns
 1489|      0|                }
 1490|       |            } else {
 1491|  15.0k|                FocusedTripleOrPathPattern {
 1492|  15.0k|                    focus: AnnotatedTermPath {
 1493|  15.0k|                        term: g.focus,
 1494|  15.0k|                        annotations: Vec::new()
 1495|  15.0k|                    },
 1496|  15.0k|                    patterns: g.patterns
 1497|  15.0k|                }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_LateralGraphPattern0B7_:
  778|    286|parser! {
  779|    286|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|    286|    grammar parser(state: &mut ParserState) for str {
  781|    286|        pub rule QueryUnit() -> Query = Query()
  782|    286|
  783|    286|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|    286|            q
  785|    286|        }
  786|    286|
  787|    286|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|    286|
  789|    286|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|    286|
  791|    286|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|    286|            state.base_iri = Some(i)
  793|    286|        }
  794|    286|
  795|    286|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|    286|            state.namespaces.insert(ns.into(), i.into_inner());
  797|    286|        }
  798|    286|
  799|    286|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|    286|            Ok(Query::Select {
  801|    286|                dataset: d,
  802|    286|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|    286|                base_iri: state.base_iri.clone()
  804|    286|            })
  805|    286|        }
  806|    286|
  807|    286|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|    286|            build_select(s, w, g, h, o, l, v, state)
  809|    286|        }
  810|    286|
  811|    286|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|    286|            Selection {
  813|    286|                option: o,
  814|    286|                variables: v
  815|    286|            }
  816|    286|        }
  817|    286|        rule Selection_init() = {
  818|    286|            state.aggregates.push(Vec::new())
  819|    286|        }
  820|    286|        rule SelectClause_option() -> SelectionOption =
  821|    286|            i("DISTINCT") { SelectionOption::Distinct } /
  822|    286|            i("REDUCED") { SelectionOption::Reduced } /
  823|    286|            { SelectionOption::Default }
  824|    286|        rule SelectClause_variables() -> SelectionVariables =
  825|    286|            "*" { SelectionVariables::Star } /
  826|    286|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|    286|        rule SelectClause_member() -> SelectionMember =
  828|    286|            v:Var() _ { SelectionMember::Variable(v) } /
  829|    286|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|    286|
  831|    286|        rule ConstructQuery() -> Query =
  832|    286|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|    286|                Ok(Query::Construct {
  834|    286|                    template: c,
  835|    286|                    dataset: d,
  836|    286|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|    286|                    base_iri: state.base_iri.clone()
  838|    286|                })
  839|    286|            } /
  840|    286|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|    286|                Ok(Query::Construct {
  842|    286|                    template: c.clone(),
  843|    286|                    dataset: d,
  844|    286|                    pattern: build_select(
  845|    286|                        Selection::no_op(),
  846|    286|                        GraphPattern::Bgp { patterns: c },
  847|    286|                        g, h, o, l, v, state
  848|    286|                    )?,
  849|    286|                    base_iri: state.base_iri.clone()
  850|    286|                })
  851|    286|            }
  852|    286|
  853|    286|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|    286|
  855|    286|        rule DescribeQuery() -> Query =
  856|    286|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|    286|                Ok(Query::Describe {
  858|    286|                    dataset: d,
  859|    286|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|    286|                    base_iri: state.base_iri.clone()
  861|    286|                })
  862|    286|            } /
  863|    286|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|    286|                Ok(Query::Describe {
  865|    286|                    dataset: d,
  866|    286|                    pattern: build_select(Selection {
  867|    286|                        option: SelectionOption::Default,
  868|    286|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|    286|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|    286|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|    286|                        }).collect())
  872|    286|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|    286|                    base_iri: state.base_iri.clone()
  874|    286|                })
  875|    286|            }
  876|    286|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|    286|
  878|    286|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|    286|            Ok(Query::Ask {
  880|    286|                dataset: d,
  881|    286|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|    286|                base_iri: state.base_iri.clone()
  883|    286|            })
  884|    286|        }
  885|    286|
  886|    286|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|    286|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|    286|            if d.is_empty() {
  889|    286|                return None;
  890|    286|            }
  891|    286|            let mut default = Vec::new();
  892|    286|            let mut named = Vec::new();
  893|    286|            for (d, n) in d {
  894|    286|                if let Some(d) = d {
  895|    286|                    default.push(d);
  896|    286|                }
  897|    286|                if let Some(n) = n {
  898|    286|                    named.push(n);
  899|    286|                }
  900|    286|            }
  901|    286|            Some(QueryDataset {
  902|    286|                default, named: Some(named)
  903|    286|            })
  904|    286|        }
  905|    286|
  906|    286|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|    286|            (Some(s), None)
  908|    286|        }
  909|    286|
  910|    286|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|    286|            (None, Some(s))
  912|    286|        }
  913|    286|
  914|    286|        rule SourceSelector() -> NamedNode = iri()
  915|    286|
  916|    286|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|    286|            p
  918|    286|        }
  919|    286|
  920|    286|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|    286|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|    286|            let clauses = c.into_iter().map(|(e, vo)| {
  923|    286|                if let Expression::Variable(v) = e {
  924|    286|                    v
  925|    286|                } else {
  926|    286|                    let v = vo.unwrap_or_else(variable);
  927|    286|                    projections.push((e, v.clone()));
  928|    286|                    v
  929|    286|                }
  930|    286|            }).collect();
  931|    286|            (clauses, projections)
  932|    286|        }
  933|    286|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|    286|
  935|    286|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|    286|            e:BuiltInCall() { (e, None) } /
  937|    286|            e:FunctionCall() { (e, None) } /
  938|    286|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|    286|            e:Var() { (e.into(), None) }
  940|    286|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|    286|
  942|    286|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|    286|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|    286|        }
  945|    286|
  946|    286|        rule HavingCondition() -> Expression = Constraint()
  947|    286|
  948|    286|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|    286|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|    286|
  951|    286|        rule OrderCondition() -> OrderExpression =
  952|    286|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|    286|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|    286|            e: Constraint() { OrderExpression::Asc(e) } /
  955|    286|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|    286|
  957|    286|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|    286|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|    286|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|    286|
  961|    286|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|    286|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|    286|        }
  964|    286|
  965|    286|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|    286|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|    286|        }
  968|    286|
  969|    286|        rule ValuesClause() -> Option<GraphPattern> =
  970|    286|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|    286|            { None }
  972|    286|
  973|    286|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|    286|
  975|    286|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|    286|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|    286|
  978|    286|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|    286|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|    286|        }
  981|    286|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|    286|
  983|    286|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|    286|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|    286|        }
  986|    286|
  987|    286|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|    286|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|    286|        }
  990|    286|
  991|    286|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|    286|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|    286|        }
  994|    286|
  995|    286|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|    286|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|    286|            if from == to {
  998|    286|                Vec::new() // identity case
  999|    286|            } else {
 1000|    286|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|    286|                vec![copy_graph(from, to)]
 1002|    286|            }
 1003|    286|        }
 1004|    286|
 1005|    286|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|    286|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|    286|            if from == to {
 1008|    286|                Vec::new() // identity case
 1009|    286|            } else {
 1010|    286|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|    286|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|    286|            }
 1013|    286|        }
 1014|    286|
 1015|    286|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|    286|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|    286|            if from == to {
 1018|    286|                Vec::new() // identity case
 1019|    286|            } else {
 1020|    286|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|    286|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|    286|            }
 1023|    286|        }
 1024|    286|
 1025|    286|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|    286|            vec![GraphUpdateOperation::InsertData { data }]
 1027|    286|        }
 1028|    286|
 1029|    286|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|    286|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|    286|        }
 1032|    286|
 1033|    286|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|    286|            let pattern = d.iter().map(|q| {
 1035|    286|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|    286|                match &q.graph_name {
 1037|    286|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|    286|                    GraphNamePattern::DefaultGraph => bgp,
 1039|    286|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|    286|                }
 1041|    286|            }).reduce(new_join).unwrap_or_default();
 1042|    286|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|    286|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|    286|                delete,
 1045|    286|                insert: Vec::new(),
 1046|    286|                using: None,
 1047|    286|                pattern: Box::new(pattern)
 1048|    286|            }])
 1049|    286|        }
 1050|    286|
 1051|    286|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|    286|            let (delete, insert) = c;
 1053|    286|            let mut delete = delete.unwrap_or_default();
 1054|    286|            let mut insert = insert.unwrap_or_default();
 1055|    286|            #[allow(clippy::shadow_same)]
 1056|    286|            let mut pattern = pattern;
 1057|    286|
 1058|    286|            let mut using = if u.is_empty() {
 1059|    286|                None
 1060|    286|            } else {
 1061|    286|                let mut default = Vec::new();
 1062|    286|                let mut named = Vec::new();
 1063|    286|                for (d, n) in u {
 1064|    286|                    if let Some(d) = d {
 1065|    286|                        default.push(d)
 1066|    286|                    }
 1067|    286|                    if let Some(n) = n {
 1068|    286|                        named.push(n)
 1069|    286|                    }
 1070|    286|                }
 1071|    286|                Some(QueryDataset { default, named: Some(named) })
 1072|    286|            };
 1073|    286|
 1074|    286|            if let Some(with) = with {
 1075|    286|                // We inject WITH everywhere
 1076|    286|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|    286|                    GroundQuadPattern {
 1078|    286|                        subject: q.subject,
 1079|    286|                        predicate: q.predicate,
 1080|    286|                        object: q.object,
 1081|    286|                        graph_name: with.clone().into()
 1082|    286|                    }
 1083|    286|                } else {
 1084|    286|                    q
 1085|    286|                }).collect();
 1086|    286|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|    286|                    QuadPattern {
 1088|    286|                        subject: q.subject,
 1089|    286|                        predicate: q.predicate,
 1090|    286|                        object: q.object,
 1091|    286|                        graph_name: with.clone().into()
 1092|    286|                    }
 1093|    286|                } else {
 1094|    286|                    q
 1095|    286|                }).collect();
 1096|    286|                if using.is_none() {
 1097|    286|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|    286|                }
 1099|    286|            }
 1100|    286|
 1101|    286|            vec![GraphUpdateOperation::DeleteInsert {
 1102|    286|                delete,
 1103|    286|                insert,
 1104|    286|                using,
 1105|    286|                pattern: Box::new(pattern)
 1106|    286|            }]
 1107|    286|        }
 1108|    286|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|    286|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|    286|            (Some(d), i)
 1111|    286|        } / i:InsertClause() {
 1112|    286|            (None, Some(i))
 1113|    286|        }
 1114|    286|        rule Modify_clear() = {
 1115|    286|            state.used_bnodes.clear();
 1116|    286|            state.currently_used_bnodes.clear();
 1117|    286|        }
 1118|    286|
 1119|    286|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|    286|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|    286|        }
 1122|    286|
 1123|    286|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|    286|
 1125|    286|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|    286|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|    286|            (Some(i), None)
 1128|    286|        }
 1129|    286|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|    286|            (None, Some(i))
 1131|    286|        }
 1132|    286|
 1133|    286|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|    286|            GraphName::DefaultGraph
 1135|    286|        } / (i("GRAPH") _)? g:iri() {
 1136|    286|            GraphName::NamedNode(g)
 1137|    286|        }
 1138|    286|
 1139|    286|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|    286|
 1141|    286|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|    286|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|    286|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|    286|            / i("ALL") { GraphTarget::AllGraphs }
 1145|    286|
 1146|    286|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|    286|
 1148|    286|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|    286|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|    286|        }
 1151|    286|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|    286|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|    286|        }
 1154|    286|
 1155|    286|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|    286|            q.into_iter().flatten().collect()
 1157|    286|        }
 1158|    286|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|    286|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|    286|        } //TODO: return iter?
 1161|    286|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|    286|
 1163|    286|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|    286|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|    286|        }
 1166|    286|
 1167|    286|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|    286|            ts.into_iter().flatten().collect()
 1169|    286|        }
 1170|    286|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|    286|
 1172|    286|        rule GroupGraphPattern() -> GraphPattern =
 1173|    286|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|    286|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|    286|        rule GroupGraphPattern_clear() = {
 1176|    286|             // We deal with blank nodes aliases rule
 1177|    286|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|    286|            state.currently_used_bnodes.clear();
 1179|    286|        }
 1180|    286|
 1181|    286|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|    286|            let mut filter: Option<Expression> = None;
 1183|    286|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|    286|            for e in b.into_iter().flatten() {
 1185|    286|                match e {
 1186|    286|                    PartialGraphPattern::Optional(p, f) => {
 1187|    286|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|    286|                    }
 1189|    286|                    #[cfg(feature = "sep-0006")]
 1190|    286|                    PartialGraphPattern::Lateral(p) => {
 1191|    286|                        let mut defined_variables = HashSet::default();
 1192|    286|                        add_defined_variables(&p, &mut defined_variables);
 1193|    286|                        let mut contains = false;
 1194|    286|                        g.on_in_scope_variable(|v| {
 1195|    286|                            if defined_variables.contains(v) {
 1196|    286|                                contains = true;
 1197|    286|                            }
 1198|    286|                        });
 1199|    286|                        if contains {
 1200|    286|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|    286|                        }
 1202|    286|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|    286|                    }
 1204|    286|                    PartialGraphPattern::Minus(p) => {
 1205|    286|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|    286|                    }
 1207|    286|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|    286|                        let mut contains = false;
 1209|    286|                        g.on_in_scope_variable(|v| {
 1210|    286|                            if *v == variable {
 1211|    286|                                contains = true;
 1212|    286|                            }
 1213|    286|                        });
 1214|    286|                        if contains {
 1215|    286|                            return Err("BIND is overriding an existing variable")
 1216|    286|                        }
 1217|    286|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|    286|                    }
 1219|    286|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|    286|                        Expression::And(Box::new(f), Box::new(expr))
 1221|    286|                    } else {
 1222|    286|                        expr
 1223|    286|                    }),
 1224|    286|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|    286|                }
 1226|    286|            }
 1227|    286|
 1228|    286|            Ok(if let Some(expr) = filter {
 1229|    286|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|    286|            } else {
 1231|    286|                g
 1232|    286|            })
 1233|    286|        }
 1234|    286|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|    286|            let mut result = vec![a];
 1236|    286|            if let Some(v) = b {
 1237|    286|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|    286|            }
 1239|    286|            result
 1240|    286|        }
 1241|    286|
 1242|    286|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|    286|            hs.into_iter().flatten().collect()
 1244|    286|        }
 1245|    286|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|    286|
 1247|    286|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|    286|
 1249|    286|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|    286|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|    286|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|    286|            } else {
 1253|    286|               PartialGraphPattern::Optional(p, None)
 1254|    286|            }
 1255|    286|        }
 1256|    286|
 1257|    286|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|    286|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|    286|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|    286|        }
 1261|    286|
 1262|    286|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|    286|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|    286|        }
 1265|    286|
 1266|    286|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|    286|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|    286|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|    286|
 1270|    286|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|    286|            PartialGraphPattern::Bind(e, v)
 1272|    286|        }
 1273|    286|
 1274|    286|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|    286|
 1276|    286|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|    286|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|    286|        }
 1279|    286|
 1280|    286|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|    286|            (vec![var], d)
 1282|    286|        }
 1283|    286|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|    286|
 1285|    286|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|    286|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|    286|                Ok((vars, vals))
 1288|    286|            } else {
 1289|    286|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|    286|            }
 1291|    286|        }
 1292|    286|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|    286|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|    286|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|    286|
 1296|    286|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|    286|            t:QuotedTripleData() {?
 1298|    286|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|    286|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|    286|            } /
 1301|    286|            i:iri() { Some(i.into()) } /
 1302|    286|            l:RDFLiteral() { Some(l.into()) } /
 1303|    286|            l:NumericLiteral() { Some(l.into()) } /
 1304|    286|            l:BooleanLiteral() { Some(l.into()) } /
 1305|    286|            i("UNDEF") { None }
 1306|    286|
 1307|    286|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|    286|            PartialGraphPattern::Minus(p)
 1309|    286|        }
 1310|    286|
 1311|    286|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|    286|            not_empty_fold(p.into_iter(), |a, b| {
 1313|    286|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|    286|            }).map(PartialGraphPattern::Other)
 1315|    286|        }
 1316|    286|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|    286|
 1318|    286|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|    286|            PartialGraphPattern::Filter(c)
 1320|    286|        }
 1321|    286|
 1322|    286|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|    286|
 1324|    286|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|    286|            Expression::FunctionCall(Function::Custom(f), a)
 1326|    286|        }
 1327|    286|
 1328|    286|        rule ArgList() -> Vec<Expression> =
 1329|    286|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|    286|            NIL() { Vec::new() }
 1331|    286|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|    286|
 1333|    286|        rule ExpressionList() -> Vec<Expression> =
 1334|    286|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|    286|            NIL() { Vec::new() }
 1336|    286|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|    286|
 1338|    286|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|    286|
 1340|    286|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|    286|            p.into_iter().flatten().collect()
 1342|    286|        }
 1343|    286|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|    286|
 1345|    286|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|    286|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|    286|                let mut patterns = po.patterns;
 1348|    286|                for (p, os) in po.focus {
 1349|    286|                    for o in os {
 1350|    286|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|    286|                    }
 1352|    286|                }
 1353|    286|                Ok(patterns)
 1354|    286|            } /
 1355|    286|            s:TriplesNode() _ po:PropertyList() {?
 1356|    286|                let mut patterns = s.patterns;
 1357|    286|                patterns.extend(po.patterns);
 1358|    286|                for (p, os) in po.focus {
 1359|    286|                    for o in os {
 1360|    286|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|    286|                    }
 1362|    286|                }
 1363|    286|                Ok(patterns)
 1364|    286|            }
 1365|    286|
 1366|    286|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|    286|            PropertyListNotEmpty() /
 1368|    286|            { FocusedTriplePattern::default() }
 1369|    286|
 1370|    286|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|    286|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|    286|                a.focus.push(b.focus);
 1373|    286|                a.patterns.extend(b.patterns);
 1374|    286|                a
 1375|    286|            })
 1376|    286|        }
 1377|    286|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|    286|            FocusedTriplePattern {
 1379|    286|                focus: (p, o.focus),
 1380|    286|                patterns: o.patterns
 1381|    286|            }
 1382|    286|        }
 1383|    286|
 1384|    286|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|    286|
 1386|    286|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|    286|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|    286|                a.focus.push(b.focus);
 1389|    286|                a.patterns.extend_from_slice(&b.patterns);
 1390|    286|                a
 1391|    286|            })
 1392|    286|        }
 1393|    286|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|    286|
 1395|    286|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|    286|            if let Some(a) = a {
 1397|    286|                let mut patterns = g.patterns;
 1398|    286|                patterns.extend(a.patterns);
 1399|    286|                FocusedTriplePattern {
 1400|    286|                    focus: AnnotatedTerm {
 1401|    286|                        term: g.focus,
 1402|    286|                        annotations: a.focus
 1403|    286|                    },
 1404|    286|                    patterns
 1405|    286|                }
 1406|    286|            } else {
 1407|    286|                FocusedTriplePattern {
 1408|    286|                    focus: AnnotatedTerm {
 1409|    286|                        term: g.focus,
 1410|    286|                        annotations: Vec::new()
 1411|    286|                    },
 1412|    286|                    patterns: g.patterns
 1413|    286|                }
 1414|    286|            }
 1415|    286|        }
 1416|    286|
 1417|    286|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|    286|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|    286|                let mut patterns = po.patterns;
 1420|    286|                for (p, os) in po.focus {
 1421|    286|                    for o in os {
 1422|    286|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|    286|                    }
 1424|    286|                }
 1425|    286|                Ok(patterns)
 1426|    286|            } /
 1427|    286|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|    286|                let mut patterns = s.patterns;
 1429|    286|                patterns.extend(po.patterns);
 1430|    286|                for (p, os) in po.focus {
 1431|    286|                    for o in os {
 1432|    286|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|    286|                    }
 1434|    286|                }
 1435|    286|                Ok(patterns)
 1436|    286|            }
 1437|    286|
 1438|    286|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|    286|            PropertyListPathNotEmpty() /
 1440|    286|            { FocusedTripleOrPathPattern::default() }
 1441|    286|
 1442|    286|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|    286|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|    286|                    focus: vec![(hp, ho.focus)],
 1445|    286|                    patterns: ho.patterns
 1446|    286|                }, |mut a, b| {
 1447|    286|                    a.focus.push(b.focus);
 1448|    286|                    a.patterns.extend(b.patterns);
 1449|    286|                    a
 1450|    286|                })
 1451|    286|        }
 1452|    286|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|    286|            c
 1454|    286|        }
 1455|    286|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|    286|            FocusedTripleOrPathPattern {
 1457|    286|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|    286|                patterns: o.patterns
 1459|    286|            }
 1460|    286|        }
 1461|    286|
 1462|    286|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|    286|            p.into()
 1464|    286|        }
 1465|    286|
 1466|    286|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|    286|            v.into()
 1468|    286|        }
 1469|    286|
 1470|    286|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|    286|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|    286|                a.focus.push(b.focus);
 1473|    286|                a.patterns.extend(b.patterns);
 1474|    286|                a
 1475|    286|            })
 1476|    286|        }
 1477|    286|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|    286|
 1479|    286|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|    286|             if let Some(a) = a {
 1481|    286|                let mut patterns = g.patterns;
 1482|    286|                patterns.extend(a.patterns);
 1483|    286|                FocusedTripleOrPathPattern {
 1484|    286|                    focus: AnnotatedTermPath {
 1485|    286|                        term: g.focus,
 1486|    286|                        annotations: a.focus
 1487|    286|                    },
 1488|    286|                    patterns
 1489|    286|                }
 1490|    286|            } else {
 1491|    286|                FocusedTripleOrPathPattern {
 1492|    286|                    focus: AnnotatedTermPath {
 1493|    286|                        term: g.focus,
 1494|    286|                        annotations: Vec::new()
 1495|    286|                    },
 1496|    286|                    patterns: g.patterns
 1497|    286|                }
 1498|    286|            }
 1499|    286|        }
 1500|    286|
 1501|    286|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|    286|
 1503|    286|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|    286|            not_empty_fold(p.into_iter(), |a, b| {
 1505|    286|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|    286|            })
 1507|    286|        }
 1508|    286|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|    286|
 1510|    286|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|    286|            not_empty_fold(p.into_iter(), |a, b| {
 1512|    286|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|    286|            })
 1514|    286|        }
 1515|    286|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|    286|
 1517|    286|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|    286|            match o {
 1519|    286|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|    286|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|    286|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|    286|                Some(_) => unreachable!(),
 1523|    286|                None => p
 1524|    286|            }
 1525|    286|        }
 1526|    286|        rule PathElt_op() -> char =
 1527|    286|            "*" { '*' } /
 1528|    286|            "+" { '+' } /
 1529|    286|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|    286|
 1531|    286|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|    286|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|    286|            PathElt()
 1534|    286|
 1535|    286|        rule PathPrimary() -> PropertyPathExpression =
 1536|    286|            v:iri() { v.into() } /
 1537|    286|            "a" { rdf::TYPE.into_owned().into() } /
 1538|    286|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|    286|            "(" _ p:Path() _ ")" { p }
 1540|    286|
 1541|    286|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|    286|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|    286|                let mut direct = Vec::new();
 1544|    286|                let mut inverse = Vec::new();
 1545|    286|                for e in p {
 1546|    286|                    match e {
 1547|    286|                        Either::Left(a) => direct.push(a),
 1548|    286|                        Either::Right(b) => inverse.push(b)
 1549|    286|                    }
 1550|    286|                }
 1551|    286|                if inverse.is_empty() {
 1552|    286|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|    286|                } else if direct.is_empty() {
 1554|    286|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|    286|                } else {
 1556|    286|                    PropertyPathExpression::Alternative(
 1557|    286|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|    286|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|    286|                    )
 1560|    286|                }
 1561|    286|            } /
 1562|    286|            p:PathOneInPropertySet() {
 1563|    286|                match p {
 1564|    286|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|    286|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|    286|                }
 1567|    286|            }
 1568|    286|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|    286|
 1570|    286|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|    286|            "^" _ v:iri() { Either::Right(v) } /
 1572|    286|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|    286|            v:iri() { Either::Left(v) } /
 1574|    286|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|    286|
 1576|    286|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|    286|
 1578|    286|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|    286|            let mut patterns = po.patterns;
 1580|    286|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|    286|            for (p, os) in po.focus {
 1582|    286|                for o in os {
 1583|    286|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|    286|                }
 1585|    286|            }
 1586|    286|            Ok(FocusedTriplePattern {
 1587|    286|                focus: bnode,
 1588|    286|                patterns
 1589|    286|            })
 1590|    286|        }
 1591|    286|
 1592|    286|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|    286|
 1594|    286|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|    286|            let mut patterns = po.patterns;
 1596|    286|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|    286|            for (p, os) in po.focus {
 1598|    286|                for o in os {
 1599|    286|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|    286|                }
 1601|    286|            }
 1602|    286|            Ok(FocusedTripleOrPathPattern {
 1603|    286|                focus: bnode,
 1604|    286|                patterns
 1605|    286|            })
 1606|    286|        }
 1607|    286|
 1608|    286|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|    286|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|    286|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|    286|            for objWithPatterns in o.into_iter().rev() {
 1612|    286|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|    286|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|    286|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|    286|                current_list_node = new_blank_node;
 1616|    286|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|    286|            }
 1618|    286|            FocusedTriplePattern {
 1619|    286|                focus: current_list_node,
 1620|    286|                patterns
 1621|    286|            }
 1622|    286|        }
 1623|    286|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|    286|
 1625|    286|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|    286|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|    286|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|    286|            for objWithPatterns in o.into_iter().rev() {
 1629|    286|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|    286|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|    286|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|    286|                current_list_node = new_blank_node;
 1633|    286|                patterns.extend(objWithPatterns.patterns);
 1634|    286|            }
 1635|    286|            FocusedTripleOrPathPattern {
 1636|    286|                focus: current_list_node,
 1637|    286|                patterns
 1638|    286|            }
 1639|    286|        }
 1640|    286|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|    286|
 1642|    286|
 1643|    286|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|    286|
 1645|    286|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|    286|
 1647|    286|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|    286|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|    286|            TriplesNode()
 1650|    286|
 1651|    286|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|    286|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|    286|            TriplesNodePath()
 1654|    286|
 1655|    286|        rule VarOrTerm() -> TermPattern =
 1656|    286|            v:Var() { v.into() } /
 1657|    286|            t:QuotedTriple() {?
 1658|    286|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|    286|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|    286|            } /
 1661|    286|            t:GraphTerm() { t.into() }
 1662|    286|
 1663|    286|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|    286|            Ok(TriplePattern {
 1665|    286|                subject: s,
 1666|    286|                predicate: p,
 1667|    286|                object: o
 1668|    286|            })
 1669|    286|        }
 1670|    286|
 1671|    286|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|    286|            Ok(GroundTriple {
 1673|    286|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|    286|                predicate: p,
 1675|    286|                object: o
 1676|    286|            })
 1677|    286|        }
 1678|    286|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|    286|
 1680|    286|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|    286|            l:RDFLiteral() { l.into() } /
 1682|    286|            l:NumericLiteral() { l.into() } /
 1683|    286|            l:BooleanLiteral() { l.into() } /
 1684|    286|            t:QuotedTripleData() {?
 1685|    286|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|    286|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|    286|            }
 1688|    286|
 1689|    286|        rule VarOrIri() -> NamedNodePattern =
 1690|    286|            v:Var() { v.into() } /
 1691|    286|            i:iri() { i.into() }
 1692|    286|
 1693|    286|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|    286|
 1695|    286|        rule GraphTerm() -> Term =
 1696|    286|            i:iri() { i.into() } /
 1697|    286|            l:RDFLiteral() { l.into() } /
 1698|    286|            l:NumericLiteral() { l.into() } /
 1699|    286|            l:BooleanLiteral() { l.into() } /
 1700|    286|            b:BlankNode() { b.into() } /
 1701|    286|            NIL() { rdf::NIL.into_owned().into() }
 1702|    286|
 1703|    286|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|    286|
 1705|    286|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|    286|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|    286|        }
 1708|    286|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|    286|
 1710|    286|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|    286|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|    286|        }
 1713|    286|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|    286|
 1715|    286|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|    286|
 1717|    286|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|    286|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|    286|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|    286|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|    286|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|    286|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|    286|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|    286|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|    286|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|    286|            Some(_) => unreachable!(),
 1727|    286|            None => a
 1728|    286|        } }
 1729|    286|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|    286|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|    286|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|    286|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|    286|
 1734|    286|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|    286|
 1736|    286|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|    286|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|    286|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|    286|            Some(_) => unreachable!(),
 1740|    286|            None => a,
 1741|    286|        } }
 1742|    286|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|    286|            (s, e)
 1744|    286|        }
 1745|    286|
 1746|    286|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|    286|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|    286|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|    286|            Some(_) => unreachable!(),
 1750|    286|            None => a
 1751|    286|        } }
 1752|    286|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|    286|            (s, e)
 1754|    286|        }
 1755|    286|
 1756|    286|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|    286|            Some("!") => Expression::Not(Box::new(e)),
 1758|    286|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|    286|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|    286|            Some(_) => unreachable!(),
 1761|    286|            None => e,
 1762|    286|        } }
 1763|    286|
 1764|    286|        rule PrimaryExpression() -> Expression =
 1765|    286|            BrackettedExpression()  /
 1766|    286|            ExprQuotedTriple() /
 1767|    286|            iriOrFunction() /
 1768|    286|            v:Var() { v.into() } /
 1769|    286|            l:RDFLiteral() { l.into() } /
 1770|    286|            l:NumericLiteral() { l.into() } /
 1771|    286|            l:BooleanLiteral() { l.into() } /
 1772|    286|            BuiltInCall()
 1773|    286|
 1774|    286|        rule ExprVarOrTerm() -> Expression =
 1775|    286|            ExprQuotedTriple() /
 1776|    286|            i:iri() { i.into() } /
 1777|    286|            l:RDFLiteral() { l.into() } /
 1778|    286|            l:NumericLiteral() { l.into() } /
 1779|    286|            l:BooleanLiteral() { l.into() } /
 1780|    286|            v:Var() { v.into() }
 1781|    286|
 1782|    286|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|    286|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|    286|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|    286|        }
 1786|    286|
 1787|    286|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|    286|
 1789|    286|        rule BuiltInCall() -> Expression =
 1790|    286|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|    286|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|    286|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|    286|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|    286|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|    286|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|    286|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|    286|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|    286|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|    286|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|    286|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|    286|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|    286|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|    286|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|    286|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|    286|            SubstringExpression() /
 1806|    286|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|    286|            StrReplaceExpression() /
 1808|    286|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|    286|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|    286|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|    286|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|    286|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|    286|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|    286|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|    286|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|    286|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|    286|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|    286|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|    286|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|    286|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|    286|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|    286|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|    286|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|    286|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|    286|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|    286|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|    286|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|    286|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|    286|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|    286|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|    286|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|    286|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|    286|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|    286|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|    286|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|    286|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|    286|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|    286|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|    286|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|    286|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|    286|            RegexExpression() /
 1842|    286|            ExistsFunc() /
 1843|    286|            NotExistsFunc() /
 1844|    286|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|    286|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|    286|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|    286|            } /
 1848|    286|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|    286|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|    286|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|    286|            } /
 1852|    286|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|    286|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|    286|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|    286|            } /
 1856|    286|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|    286|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|    286|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|    286|            } /
 1860|    286|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|    286|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|    286|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|    286|            } /
 1864|    286|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|    286|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|    286|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|    286|            }
 1868|    286|
 1869|    286|        rule RegexExpression() -> Expression =
 1870|    286|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|    286|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|    286|
 1873|    286|
 1874|    286|        rule SubstringExpression() -> Expression =
 1875|    286|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|    286|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|    286|
 1878|    286|
 1879|    286|        rule StrReplaceExpression() -> Expression =
 1880|    286|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|    286|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|    286|
 1883|    286|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|    286|
 1885|    286|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|    286|
 1887|    286|        rule Aggregate() -> AggregateExpression =
 1888|    286|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|    286|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|    286|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|    286|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|    286|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|    286|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|    286|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|    286|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|    286|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|    286|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|    286|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|    286|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|    286|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|    286|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|    286|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|    286|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|    286|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|    286|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|    286|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|    286|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|    286|
 1909|    286|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|    286|            match a {
 1911|    286|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|    286|                None => i.into()
 1913|    286|            }
 1914|    286|        }
 1915|    286|
 1916|    286|        rule RDFLiteral() -> Literal =
 1917|    286|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|    286|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|    286|            value:String() { Literal::new_simple_literal(value) }
 1920|    286|
 1921|    286|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|    286|
 1923|    286|        rule NumericLiteralUnsigned() -> Literal =
 1924|    286|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|    286|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|    286|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|    286|
 1928|    286|        rule NumericLiteralPositive() -> Literal =
 1929|    286|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|    286|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|    286|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|    286|
 1933|    286|
 1934|    286|        rule NumericLiteralNegative() -> Literal =
 1935|    286|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|    286|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|    286|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|    286|
 1939|    286|        rule BooleanLiteral() -> Literal =
 1940|    286|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|    286|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|    286|
 1943|    286|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|    286|
 1945|    286|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|    286|            NamedNode::from(i)
 1947|    286|        }
 1948|    286|
 1949|    286|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|    286|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|    286|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|    286|            } else {
 1953|    286|                Err("Prefix not found")
 1954|    286|            } }
 1955|    286|
 1956|    286|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|    286|            let node = BlankNode::new_unchecked(id);
 1958|    286|            if state.used_bnodes.contains(&node) {
 1959|    286|                Err("Already used blank node id")
 1960|    286|            } else {
 1961|    286|                state.currently_used_bnodes.insert(node.clone());
 1962|    286|                Ok(node)
 1963|    286|            }
 1964|    286|        } / ANON() { BlankNode::default() }
 1965|    286|
 1966|    286|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|    286|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|    286|        }
 1969|    286|
 1970|    286|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|    286|            ns
 1972|    286|        }
 1973|    286|
 1974|    286|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|    286|            if let Some(base) = state.namespaces.get(ns) {
 1976|    286|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|    286|                iri.push_str(base);
 1978|    286|                for chunk in local.split('\\') { // We remove \
 1979|    286|                    iri.push_str(chunk);
 1980|    286|                }
 1981|    286|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|    286|            } else {
 1983|    286|                Err("Prefix not found")
 1984|    286|            }
 1985|    286|        }
 1986|    286|
 1987|    286|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|    286|            b
 1989|    286|        }
 1990|    286|
 1991|    286|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|    286|
 1993|    286|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|    286|
 1995|    286|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|    286|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|    286|        }
 1998|    286|
 1999|    286|        rule INTEGER() = ['0'..='9']+
 2000|    286|
 2001|    286|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|    286|
 2003|    286|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|    286|
 2005|    286|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|    286|
 2007|    286|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|    286|
 2009|    286|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|    286|
 2011|    286|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|    286|
 2013|    286|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|    286|
 2015|    286|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|    286|
 2017|    286|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|    286|
 2019|    286|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|    286|             unescape_string(l)
 2021|    286|        }
 2022|    286|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|    286|
 2024|    286|
 2025|    286|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|    286|             unescape_string(l)
 2027|    286|        }
 2028|    286|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|    286|
 2030|    286|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|    286|             unescape_string(l)
 2032|    286|        }
 2033|    286|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|    286|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|    286|
 2036|    286|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|    286|             unescape_string(l)
 2038|    286|        }
 2039|    286|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|    286|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|    286|
 2042|    286|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|    286|
 2044|    286|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|    286|
 2046|    286|        rule NIL() = "(" WS()* ")"
 2047|    286|
 2048|    286|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|    286|
 2050|    286|        rule ANON() = "[" WS()* "]"
 2051|    286|
 2052|    286|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|    286|
 2054|    286|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|    286|
 2056|    286|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|    286|
 2058|    286|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|    286|
 2060|    286|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|    286|
 2062|    286|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|    286|
 2064|    286|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|    286|
 2066|    286|        rule PERCENT() = ['%'] HEX() HEX()
 2067|    286|
 2068|    286|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|    286|
 2070|    286|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|    286|
 2072|    286|        //space
 2073|    286|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|    286|
 2075|    286|        //comment
 2076|    286|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|    286|
 2078|    286|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|    286|            if input.eq_ignore_ascii_case(literal) {
 2080|    286|                Ok(())
 2081|    286|            } else {
 2082|    286|                Err(literal)
 2083|    286|            }
 2084|    286|        }
 2085|    286|    }
 2086|    286|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_BrackettedExpression0B7_:
 1787|    728|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_Quads_QuadsNotTriples0B7_:
 1161|  14.8k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerms0_0B7_:
 1698|  2.06k|            l:NumericLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCallsG_0B7_:
 1836|      2|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCalls0_0B7_:
 1792|      7|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GraphRefAll0B7_:
 1141|    954|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_BlankNodePropertyListPath0B7_:
  778|  10.1k|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|       |            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|       |            }).reduce(new_join).unwrap_or_default();
 1042|       |            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|       |            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|       |                delete,
 1045|       |                insert: Vec::new(),
 1046|       |                using: None,
 1047|       |                pattern: Box::new(pattern)
 1048|       |            }])
 1049|       |        }
 1050|       |
 1051|       |        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|       |            let (delete, insert) = c;
 1053|       |            let mut delete = delete.unwrap_or_default();
 1054|       |            let mut insert = insert.unwrap_or_default();
 1055|       |            #[allow(clippy::shadow_same)]
 1056|       |            let mut pattern = pattern;
 1057|       |
 1058|       |            let mut using = if u.is_empty() {
 1059|       |                None
 1060|       |            } else {
 1061|       |                let mut default = Vec::new();
 1062|       |                let mut named = Vec::new();
 1063|       |                for (d, n) in u {
 1064|       |                    if let Some(d) = d {
 1065|       |                        default.push(d)
 1066|       |                    }
 1067|       |                    if let Some(n) = n {
 1068|       |                        named.push(n)
 1069|       |                    }
 1070|       |                }
 1071|       |                Some(QueryDataset { default, named: Some(named) })
 1072|       |            };
 1073|       |
 1074|       |            if let Some(with) = with {
 1075|       |                // We inject WITH everywhere
 1076|       |                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|       |                    GroundQuadPattern {
 1078|       |                        subject: q.subject,
 1079|       |                        predicate: q.predicate,
 1080|       |                        object: q.object,
 1081|       |                        graph_name: with.clone().into()
 1082|       |                    }
 1083|       |                } else {
 1084|       |                    q
 1085|       |                }).collect();
 1086|       |                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|       |                    QuadPattern {
 1088|       |                        subject: q.subject,
 1089|       |                        predicate: q.predicate,
 1090|       |                        object: q.object,
 1091|       |                        graph_name: with.clone().into()
 1092|       |                    }
 1093|       |                } else {
 1094|       |                    q
 1095|       |                }).collect();
 1096|       |                if using.is_none() {
 1097|       |                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|       |                }
 1099|       |            }
 1100|       |
 1101|       |            vec![GraphUpdateOperation::DeleteInsert {
 1102|       |                delete,
 1103|       |                insert,
 1104|       |                using,
 1105|       |                pattern: Box::new(pattern)
 1106|       |            }]
 1107|       |        }
 1108|       |        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|       |        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|       |            (Some(d), i)
 1111|       |        } / i:InsertClause() {
 1112|       |            (None, Some(i))
 1113|       |        }
 1114|       |        rule Modify_clear() = {
 1115|       |            state.used_bnodes.clear();
 1116|       |            state.currently_used_bnodes.clear();
 1117|       |        }
 1118|       |
 1119|       |        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|       |            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|       |        }
 1122|       |
 1123|       |        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|       |
 1125|       |        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|       |        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|       |            (Some(i), None)
 1128|       |        }
 1129|       |        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|       |            (None, Some(i))
 1131|       |        }
 1132|       |
 1133|       |        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|       |            GraphName::DefaultGraph
 1135|       |        } / (i("GRAPH") _)? g:iri() {
 1136|       |            GraphName::NamedNode(g)
 1137|       |        }
 1138|       |
 1139|       |        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|       |
 1141|       |        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|       |            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|       |            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|       |            / i("ALL") { GraphTarget::AllGraphs }
 1145|       |
 1146|       |        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|       |
 1148|       |        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|       |            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|       |        }
 1151|       |        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|       |            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|       |        }
 1154|       |
 1155|       |        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|       |            q.into_iter().flatten().collect()
 1157|       |        }
 1158|       |        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|       |            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|       |        } //TODO: return iter?
 1161|       |        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|       |
 1163|       |        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|       |            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|       |        }
 1166|       |
 1167|       |        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|       |            ts.into_iter().flatten().collect()
 1169|       |        }
 1170|       |        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|       |
 1172|       |        rule GroupGraphPattern() -> GraphPattern =
 1173|       |            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|       |            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|       |        rule GroupGraphPattern_clear() = {
 1176|       |             // We deal with blank nodes aliases rule
 1177|       |            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|       |            state.currently_used_bnodes.clear();
 1179|       |        }
 1180|       |
 1181|       |        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|       |            let mut filter: Option<Expression> = None;
 1183|       |            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|       |            for e in b.into_iter().flatten() {
 1185|       |                match e {
 1186|       |                    PartialGraphPattern::Optional(p, f) => {
 1187|       |                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|       |                    }
 1189|       |                    #[cfg(feature = "sep-0006")]
 1190|       |                    PartialGraphPattern::Lateral(p) => {
 1191|       |                        let mut defined_variables = HashSet::default();
 1192|       |                        add_defined_variables(&p, &mut defined_variables);
 1193|       |                        let mut contains = false;
 1194|       |                        g.on_in_scope_variable(|v| {
 1195|       |                            if defined_variables.contains(v) {
 1196|       |                                contains = true;
 1197|       |                            }
 1198|       |                        });
 1199|       |                        if contains {
 1200|       |                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|       |                        }
 1202|       |                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|       |                    }
 1204|       |                    PartialGraphPattern::Minus(p) => {
 1205|       |                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|       |                    }
 1207|       |                    PartialGraphPattern::Bind(expression, variable) => {
 1208|       |                        let mut contains = false;
 1209|       |                        g.on_in_scope_variable(|v| {
 1210|       |                            if *v == variable {
 1211|       |                                contains = true;
 1212|       |                            }
 1213|       |                        });
 1214|       |                        if contains {
 1215|       |                            return Err("BIND is overriding an existing variable")
 1216|       |                        }
 1217|       |                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|       |                    }
 1219|       |                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|       |                        Expression::And(Box::new(f), Box::new(expr))
 1221|       |                    } else {
 1222|       |                        expr
 1223|       |                    }),
 1224|       |                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|       |                }
 1226|       |            }
 1227|       |
 1228|       |            Ok(if let Some(expr) = filter {
 1229|       |                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|       |            } else {
 1231|       |                g
 1232|       |            })
 1233|       |        }
 1234|       |        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|       |            let mut result = vec![a];
 1236|       |            if let Some(v) = b {
 1237|       |                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|       |            }
 1239|       |            result
 1240|       |        }
 1241|       |
 1242|       |        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|       |            hs.into_iter().flatten().collect()
 1244|       |        }
 1245|       |        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|       |
 1247|       |        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|       |
 1249|       |        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|       |            if let GraphPattern::Filter { expr, inner } =  p {
 1251|       |               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|       |            } else {
 1253|       |               PartialGraphPattern::Optional(p, None)
 1254|       |            }
 1255|       |        }
 1256|       |
 1257|       |        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|       |                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|       |                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|       |        }
 1261|       |
 1262|       |        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|       |            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|       |        }
 1265|       |
 1266|       |        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|       |            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|       |            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|       |
 1270|       |        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|       |            PartialGraphPattern::Bind(e, v)
 1272|       |        }
 1273|       |
 1274|       |        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|       |
 1276|       |        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|       |            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|       |        }
 1279|       |
 1280|       |        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|       |            (vec![var], d)
 1282|       |        }
 1283|       |        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|       |
 1285|       |        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|       |            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|       |                Ok((vars, vals))
 1288|       |            } else {
 1289|       |                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|       |            }
 1291|       |        }
 1292|       |        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|       |        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|       |        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|       |
 1296|       |        rule DataBlockValue() -> Option<GroundTerm> =
 1297|       |            t:QuotedTripleData() {?
 1298|       |                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|       |                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|       |            } /
 1301|       |            i:iri() { Some(i.into()) } /
 1302|       |            l:RDFLiteral() { Some(l.into()) } /
 1303|       |            l:NumericLiteral() { Some(l.into()) } /
 1304|       |            l:BooleanLiteral() { Some(l.into()) } /
 1305|       |            i("UNDEF") { None }
 1306|       |
 1307|       |        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|       |            PartialGraphPattern::Minus(p)
 1309|       |        }
 1310|       |
 1311|       |        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|       |            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|       |            }).map(PartialGraphPattern::Other)
 1315|       |        }
 1316|       |        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|       |
 1318|       |        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|       |            PartialGraphPattern::Filter(c)
 1320|       |        }
 1321|       |
 1322|       |        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|       |
 1324|       |        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|       |            Expression::FunctionCall(Function::Custom(f), a)
 1326|       |        }
 1327|       |
 1328|       |        rule ArgList() -> Vec<Expression> =
 1329|       |            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|       |            NIL() { Vec::new() }
 1331|       |        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|       |
 1333|       |        rule ExpressionList() -> Vec<Expression> =
 1334|       |            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|       |            NIL() { Vec::new() }
 1336|       |        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|       |
 1338|       |        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|       |
 1340|       |        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|       |            p.into_iter().flatten().collect()
 1342|       |        }
 1343|       |        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|       |
 1345|       |        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|       |            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|       |                let mut patterns = po.patterns;
 1348|       |                for (p, os) in po.focus {
 1349|       |                    for o in os {
 1350|       |                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|       |                    }
 1352|       |                }
 1353|       |                Ok(patterns)
 1354|       |            } /
 1355|       |            s:TriplesNode() _ po:PropertyList() {?
 1356|       |                let mut patterns = s.patterns;
 1357|       |                patterns.extend(po.patterns);
 1358|       |                for (p, os) in po.focus {
 1359|       |                    for o in os {
 1360|       |                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|       |                    }
 1362|       |                }
 1363|       |                Ok(patterns)
 1364|       |            }
 1365|       |
 1366|       |        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|       |            PropertyListNotEmpty() /
 1368|       |            { FocusedTriplePattern::default() }
 1369|       |
 1370|       |        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|       |            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|       |                a.focus.push(b.focus);
 1373|       |                a.patterns.extend(b.patterns);
 1374|       |                a
 1375|       |            })
 1376|       |        }
 1377|       |        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|       |            FocusedTriplePattern {
 1379|       |                focus: (p, o.focus),
 1380|       |                patterns: o.patterns
 1381|       |            }
 1382|       |        }
 1383|       |
 1384|       |        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|       |
 1386|       |        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|       |            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|       |                a.focus.push(b.focus);
 1389|       |                a.patterns.extend_from_slice(&b.patterns);
 1390|       |                a
 1391|       |            })
 1392|       |        }
 1393|       |        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|       |
 1395|       |        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|       |            if let Some(a) = a {
 1397|       |                let mut patterns = g.patterns;
 1398|       |                patterns.extend(a.patterns);
 1399|       |                FocusedTriplePattern {
 1400|       |                    focus: AnnotatedTerm {
 1401|       |                        term: g.focus,
 1402|       |                        annotations: a.focus
 1403|       |                    },
 1404|       |                    patterns
 1405|       |                }
 1406|       |            } else {
 1407|       |                FocusedTriplePattern {
 1408|       |                    focus: AnnotatedTerm {
 1409|       |                        term: g.focus,
 1410|       |                        annotations: Vec::new()
 1411|       |                    },
 1412|       |                    patterns: g.patterns
 1413|       |                }
 1414|       |            }
 1415|       |        }
 1416|       |
 1417|       |        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|       |            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|       |                let mut patterns = po.patterns;
 1420|       |                for (p, os) in po.focus {
 1421|       |                    for o in os {
 1422|       |                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|       |                    }
 1424|       |                }
 1425|       |                Ok(patterns)
 1426|       |            } /
 1427|       |            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|       |                let mut patterns = s.patterns;
 1429|       |                patterns.extend(po.patterns);
 1430|       |                for (p, os) in po.focus {
 1431|       |                    for o in os {
 1432|       |                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|       |                    }
 1434|       |                }
 1435|       |                Ok(patterns)
 1436|       |            }
 1437|       |
 1438|       |        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|       |            PropertyListPathNotEmpty() /
 1440|       |            { FocusedTripleOrPathPattern::default() }
 1441|       |
 1442|       |        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|       |                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|       |                    focus: vec![(hp, ho.focus)],
 1445|       |                    patterns: ho.patterns
 1446|       |                }, |mut a, b| {
 1447|       |                    a.focus.push(b.focus);
 1448|       |                    a.patterns.extend(b.patterns);
 1449|       |                    a
 1450|       |                })
 1451|       |        }
 1452|       |        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|       |            c
 1454|       |        }
 1455|       |        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|       |            FocusedTripleOrPathPattern {
 1457|       |                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|       |                patterns: o.patterns
 1459|       |            }
 1460|       |        }
 1461|       |
 1462|       |        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|       |            p.into()
 1464|       |        }
 1465|       |
 1466|       |        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|       |            v.into()
 1468|       |        }
 1469|       |
 1470|       |        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|       |            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|       |                a.focus.push(b.focus);
 1473|       |                a.patterns.extend(b.patterns);
 1474|       |                a
 1475|       |            })
 1476|       |        }
 1477|       |        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|       |
 1479|       |        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|       |             if let Some(a) = a {
 1481|       |                let mut patterns = g.patterns;
 1482|       |                patterns.extend(a.patterns);
 1483|       |                FocusedTripleOrPathPattern {
 1484|       |                    focus: AnnotatedTermPath {
 1485|       |                        term: g.focus,
 1486|       |                        annotations: a.focus
 1487|       |                    },
 1488|       |                    patterns
 1489|       |                }
 1490|       |            } else {
 1491|       |                FocusedTripleOrPathPattern {
 1492|       |                    focus: AnnotatedTermPath {
 1493|       |                        term: g.focus,
 1494|       |                        annotations: Vec::new()
 1495|       |                    },
 1496|       |                    patterns: g.patterns
 1497|       |                }
 1498|       |            }
 1499|       |        }
 1500|       |
 1501|       |        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|       |
 1503|       |        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|       |            not_empty_fold(p.into_iter(), |a, b| {
 1505|       |                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|       |            })
 1507|       |        }
 1508|       |        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|       |
 1510|       |        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|       |            not_empty_fold(p.into_iter(), |a, b| {
 1512|       |                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|       |            })
 1514|       |        }
 1515|       |        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|       |
 1517|       |        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|       |            match o {
 1519|       |                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|       |                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|       |                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|       |                Some(_) => unreachable!(),
 1523|       |                None => p
 1524|       |            }
 1525|       |        }
 1526|       |        rule PathElt_op() -> char =
 1527|       |            "*" { '*' } /
 1528|       |            "+" { '+' } /
 1529|       |            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|       |
 1531|       |        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|       |            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|       |            PathElt()
 1534|       |
 1535|       |        rule PathPrimary() -> PropertyPathExpression =
 1536|       |            v:iri() { v.into() } /
 1537|       |            "a" { rdf::TYPE.into_owned().into() } /
 1538|       |            "!" _ p:PathNegatedPropertySet() { p } /
 1539|       |            "(" _ p:Path() _ ")" { p }
 1540|       |
 1541|       |        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|       |            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|       |                let mut direct = Vec::new();
 1544|       |                let mut inverse = Vec::new();
 1545|       |                for e in p {
 1546|       |                    match e {
 1547|       |                        Either::Left(a) => direct.push(a),
 1548|       |                        Either::Right(b) => inverse.push(b)
 1549|       |                    }
 1550|       |                }
 1551|       |                if inverse.is_empty() {
 1552|       |                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|       |                } else if direct.is_empty() {
 1554|       |                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|       |                } else {
 1556|       |                    PropertyPathExpression::Alternative(
 1557|       |                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|       |                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|       |                    )
 1560|       |                }
 1561|       |            } /
 1562|       |            p:PathOneInPropertySet() {
 1563|       |                match p {
 1564|       |                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|       |                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|       |                }
 1567|       |            }
 1568|       |        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|       |
 1570|       |        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|       |            "^" _ v:iri() { Either::Right(v) } /
 1572|       |            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|       |            v:iri() { Either::Left(v) } /
 1574|       |            "a" { Either::Left(rdf::TYPE.into()) }
 1575|       |
 1576|       |        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|       |
 1578|       |        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|       |            let mut patterns = po.patterns;
 1580|       |            let mut bnode = TermPattern::from(BlankNode::default());
 1581|       |            for (p, os) in po.focus {
 1582|       |                for o in os {
 1583|       |                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|       |                }
 1585|       |            }
 1586|       |            Ok(FocusedTriplePattern {
 1587|       |                focus: bnode,
 1588|       |                patterns
 1589|       |            })
 1590|       |        }
 1591|       |
 1592|       |        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|       |
 1594|       |        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  10.1k|            let mut patterns = po.patterns;
 1596|  10.1k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  20.5k|            for (p, os) in po.focus {
 1598|  23.4k|                for o in os {
 1599|  13.0k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|       |                }
 1601|       |            }
 1602|  10.1k|            Ok(FocusedTripleOrPathPattern {
 1603|  10.1k|                focus: bnode,
 1604|  10.1k|                patterns
 1605|  10.1k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_WhereClause0B7_:
  916|  1.76k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  1.76k|            p
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_options0_0B7_:
  823|    742|            { SelectionOption::Default }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ObjectListPath0B7_:
 1470|  11.5k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  11.5k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|       |                a.focus.push(b.focus);
 1473|       |                a.patterns.extend(b.patterns);
 1474|       |                a
 1475|  11.5k|            })
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_ConditionalAndExpression0B7_:
  778|  2.49k|parser! {
  779|  2.49k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  2.49k|    grammar parser(state: &mut ParserState) for str {
  781|  2.49k|        pub rule QueryUnit() -> Query = Query()
  782|  2.49k|
  783|  2.49k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  2.49k|            q
  785|  2.49k|        }
  786|  2.49k|
  787|  2.49k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  2.49k|
  789|  2.49k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  2.49k|
  791|  2.49k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  2.49k|            state.base_iri = Some(i)
  793|  2.49k|        }
  794|  2.49k|
  795|  2.49k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  2.49k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  2.49k|        }
  798|  2.49k|
  799|  2.49k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  2.49k|            Ok(Query::Select {
  801|  2.49k|                dataset: d,
  802|  2.49k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  2.49k|                base_iri: state.base_iri.clone()
  804|  2.49k|            })
  805|  2.49k|        }
  806|  2.49k|
  807|  2.49k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  2.49k|            build_select(s, w, g, h, o, l, v, state)
  809|  2.49k|        }
  810|  2.49k|
  811|  2.49k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  2.49k|            Selection {
  813|  2.49k|                option: o,
  814|  2.49k|                variables: v
  815|  2.49k|            }
  816|  2.49k|        }
  817|  2.49k|        rule Selection_init() = {
  818|  2.49k|            state.aggregates.push(Vec::new())
  819|  2.49k|        }
  820|  2.49k|        rule SelectClause_option() -> SelectionOption =
  821|  2.49k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  2.49k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  2.49k|            { SelectionOption::Default }
  824|  2.49k|        rule SelectClause_variables() -> SelectionVariables =
  825|  2.49k|            "*" { SelectionVariables::Star } /
  826|  2.49k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  2.49k|        rule SelectClause_member() -> SelectionMember =
  828|  2.49k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  2.49k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  2.49k|
  831|  2.49k|        rule ConstructQuery() -> Query =
  832|  2.49k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  2.49k|                Ok(Query::Construct {
  834|  2.49k|                    template: c,
  835|  2.49k|                    dataset: d,
  836|  2.49k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  2.49k|                    base_iri: state.base_iri.clone()
  838|  2.49k|                })
  839|  2.49k|            } /
  840|  2.49k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  2.49k|                Ok(Query::Construct {
  842|  2.49k|                    template: c.clone(),
  843|  2.49k|                    dataset: d,
  844|  2.49k|                    pattern: build_select(
  845|  2.49k|                        Selection::no_op(),
  846|  2.49k|                        GraphPattern::Bgp { patterns: c },
  847|  2.49k|                        g, h, o, l, v, state
  848|  2.49k|                    )?,
  849|  2.49k|                    base_iri: state.base_iri.clone()
  850|  2.49k|                })
  851|  2.49k|            }
  852|  2.49k|
  853|  2.49k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  2.49k|
  855|  2.49k|        rule DescribeQuery() -> Query =
  856|  2.49k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  2.49k|                Ok(Query::Describe {
  858|  2.49k|                    dataset: d,
  859|  2.49k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  2.49k|                    base_iri: state.base_iri.clone()
  861|  2.49k|                })
  862|  2.49k|            } /
  863|  2.49k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  2.49k|                Ok(Query::Describe {
  865|  2.49k|                    dataset: d,
  866|  2.49k|                    pattern: build_select(Selection {
  867|  2.49k|                        option: SelectionOption::Default,
  868|  2.49k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  2.49k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  2.49k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  2.49k|                        }).collect())
  872|  2.49k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  2.49k|                    base_iri: state.base_iri.clone()
  874|  2.49k|                })
  875|  2.49k|            }
  876|  2.49k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  2.49k|
  878|  2.49k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  2.49k|            Ok(Query::Ask {
  880|  2.49k|                dataset: d,
  881|  2.49k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  2.49k|                base_iri: state.base_iri.clone()
  883|  2.49k|            })
  884|  2.49k|        }
  885|  2.49k|
  886|  2.49k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  2.49k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  2.49k|            if d.is_empty() {
  889|  2.49k|                return None;
  890|  2.49k|            }
  891|  2.49k|            let mut default = Vec::new();
  892|  2.49k|            let mut named = Vec::new();
  893|  2.49k|            for (d, n) in d {
  894|  2.49k|                if let Some(d) = d {
  895|  2.49k|                    default.push(d);
  896|  2.49k|                }
  897|  2.49k|                if let Some(n) = n {
  898|  2.49k|                    named.push(n);
  899|  2.49k|                }
  900|  2.49k|            }
  901|  2.49k|            Some(QueryDataset {
  902|  2.49k|                default, named: Some(named)
  903|  2.49k|            })
  904|  2.49k|        }
  905|  2.49k|
  906|  2.49k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  2.49k|            (Some(s), None)
  908|  2.49k|        }
  909|  2.49k|
  910|  2.49k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  2.49k|            (None, Some(s))
  912|  2.49k|        }
  913|  2.49k|
  914|  2.49k|        rule SourceSelector() -> NamedNode = iri()
  915|  2.49k|
  916|  2.49k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  2.49k|            p
  918|  2.49k|        }
  919|  2.49k|
  920|  2.49k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  2.49k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  2.49k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  2.49k|                if let Expression::Variable(v) = e {
  924|  2.49k|                    v
  925|  2.49k|                } else {
  926|  2.49k|                    let v = vo.unwrap_or_else(variable);
  927|  2.49k|                    projections.push((e, v.clone()));
  928|  2.49k|                    v
  929|  2.49k|                }
  930|  2.49k|            }).collect();
  931|  2.49k|            (clauses, projections)
  932|  2.49k|        }
  933|  2.49k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  2.49k|
  935|  2.49k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  2.49k|            e:BuiltInCall() { (e, None) } /
  937|  2.49k|            e:FunctionCall() { (e, None) } /
  938|  2.49k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  2.49k|            e:Var() { (e.into(), None) }
  940|  2.49k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  2.49k|
  942|  2.49k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  2.49k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  2.49k|        }
  945|  2.49k|
  946|  2.49k|        rule HavingCondition() -> Expression = Constraint()
  947|  2.49k|
  948|  2.49k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  2.49k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  2.49k|
  951|  2.49k|        rule OrderCondition() -> OrderExpression =
  952|  2.49k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  2.49k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  2.49k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  2.49k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  2.49k|
  957|  2.49k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  2.49k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  2.49k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  2.49k|
  961|  2.49k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  2.49k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  2.49k|        }
  964|  2.49k|
  965|  2.49k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  2.49k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  2.49k|        }
  968|  2.49k|
  969|  2.49k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  2.49k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  2.49k|            { None }
  972|  2.49k|
  973|  2.49k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  2.49k|
  975|  2.49k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  2.49k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  2.49k|
  978|  2.49k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  2.49k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  2.49k|        }
  981|  2.49k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  2.49k|
  983|  2.49k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  2.49k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  2.49k|        }
  986|  2.49k|
  987|  2.49k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  2.49k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  2.49k|        }
  990|  2.49k|
  991|  2.49k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  2.49k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  2.49k|        }
  994|  2.49k|
  995|  2.49k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  2.49k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  2.49k|            if from == to {
  998|  2.49k|                Vec::new() // identity case
  999|  2.49k|            } else {
 1000|  2.49k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  2.49k|                vec![copy_graph(from, to)]
 1002|  2.49k|            }
 1003|  2.49k|        }
 1004|  2.49k|
 1005|  2.49k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  2.49k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  2.49k|            if from == to {
 1008|  2.49k|                Vec::new() // identity case
 1009|  2.49k|            } else {
 1010|  2.49k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  2.49k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  2.49k|            }
 1013|  2.49k|        }
 1014|  2.49k|
 1015|  2.49k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  2.49k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  2.49k|            if from == to {
 1018|  2.49k|                Vec::new() // identity case
 1019|  2.49k|            } else {
 1020|  2.49k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  2.49k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  2.49k|            }
 1023|  2.49k|        }
 1024|  2.49k|
 1025|  2.49k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  2.49k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  2.49k|        }
 1028|  2.49k|
 1029|  2.49k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  2.49k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  2.49k|        }
 1032|  2.49k|
 1033|  2.49k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  2.49k|            let pattern = d.iter().map(|q| {
 1035|  2.49k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  2.49k|                match &q.graph_name {
 1037|  2.49k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  2.49k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  2.49k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  2.49k|                }
 1041|  2.49k|            }).reduce(new_join).unwrap_or_default();
 1042|  2.49k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  2.49k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  2.49k|                delete,
 1045|  2.49k|                insert: Vec::new(),
 1046|  2.49k|                using: None,
 1047|  2.49k|                pattern: Box::new(pattern)
 1048|  2.49k|            }])
 1049|  2.49k|        }
 1050|  2.49k|
 1051|  2.49k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  2.49k|            let (delete, insert) = c;
 1053|  2.49k|            let mut delete = delete.unwrap_or_default();
 1054|  2.49k|            let mut insert = insert.unwrap_or_default();
 1055|  2.49k|            #[allow(clippy::shadow_same)]
 1056|  2.49k|            let mut pattern = pattern;
 1057|  2.49k|
 1058|  2.49k|            let mut using = if u.is_empty() {
 1059|  2.49k|                None
 1060|  2.49k|            } else {
 1061|  2.49k|                let mut default = Vec::new();
 1062|  2.49k|                let mut named = Vec::new();
 1063|  2.49k|                for (d, n) in u {
 1064|  2.49k|                    if let Some(d) = d {
 1065|  2.49k|                        default.push(d)
 1066|  2.49k|                    }
 1067|  2.49k|                    if let Some(n) = n {
 1068|  2.49k|                        named.push(n)
 1069|  2.49k|                    }
 1070|  2.49k|                }
 1071|  2.49k|                Some(QueryDataset { default, named: Some(named) })
 1072|  2.49k|            };
 1073|  2.49k|
 1074|  2.49k|            if let Some(with) = with {
 1075|  2.49k|                // We inject WITH everywhere
 1076|  2.49k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  2.49k|                    GroundQuadPattern {
 1078|  2.49k|                        subject: q.subject,
 1079|  2.49k|                        predicate: q.predicate,
 1080|  2.49k|                        object: q.object,
 1081|  2.49k|                        graph_name: with.clone().into()
 1082|  2.49k|                    }
 1083|  2.49k|                } else {
 1084|  2.49k|                    q
 1085|  2.49k|                }).collect();
 1086|  2.49k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  2.49k|                    QuadPattern {
 1088|  2.49k|                        subject: q.subject,
 1089|  2.49k|                        predicate: q.predicate,
 1090|  2.49k|                        object: q.object,
 1091|  2.49k|                        graph_name: with.clone().into()
 1092|  2.49k|                    }
 1093|  2.49k|                } else {
 1094|  2.49k|                    q
 1095|  2.49k|                }).collect();
 1096|  2.49k|                if using.is_none() {
 1097|  2.49k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  2.49k|                }
 1099|  2.49k|            }
 1100|  2.49k|
 1101|  2.49k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  2.49k|                delete,
 1103|  2.49k|                insert,
 1104|  2.49k|                using,
 1105|  2.49k|                pattern: Box::new(pattern)
 1106|  2.49k|            }]
 1107|  2.49k|        }
 1108|  2.49k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  2.49k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  2.49k|            (Some(d), i)
 1111|  2.49k|        } / i:InsertClause() {
 1112|  2.49k|            (None, Some(i))
 1113|  2.49k|        }
 1114|  2.49k|        rule Modify_clear() = {
 1115|  2.49k|            state.used_bnodes.clear();
 1116|  2.49k|            state.currently_used_bnodes.clear();
 1117|  2.49k|        }
 1118|  2.49k|
 1119|  2.49k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  2.49k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  2.49k|        }
 1122|  2.49k|
 1123|  2.49k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  2.49k|
 1125|  2.49k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  2.49k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  2.49k|            (Some(i), None)
 1128|  2.49k|        }
 1129|  2.49k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  2.49k|            (None, Some(i))
 1131|  2.49k|        }
 1132|  2.49k|
 1133|  2.49k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  2.49k|            GraphName::DefaultGraph
 1135|  2.49k|        } / (i("GRAPH") _)? g:iri() {
 1136|  2.49k|            GraphName::NamedNode(g)
 1137|  2.49k|        }
 1138|  2.49k|
 1139|  2.49k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  2.49k|
 1141|  2.49k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  2.49k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  2.49k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  2.49k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  2.49k|
 1146|  2.49k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  2.49k|
 1148|  2.49k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  2.49k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  2.49k|        }
 1151|  2.49k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  2.49k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  2.49k|        }
 1154|  2.49k|
 1155|  2.49k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  2.49k|            q.into_iter().flatten().collect()
 1157|  2.49k|        }
 1158|  2.49k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  2.49k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  2.49k|        } //TODO: return iter?
 1161|  2.49k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  2.49k|
 1163|  2.49k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  2.49k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  2.49k|        }
 1166|  2.49k|
 1167|  2.49k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  2.49k|            ts.into_iter().flatten().collect()
 1169|  2.49k|        }
 1170|  2.49k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  2.49k|
 1172|  2.49k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  2.49k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  2.49k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  2.49k|        rule GroupGraphPattern_clear() = {
 1176|  2.49k|             // We deal with blank nodes aliases rule
 1177|  2.49k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  2.49k|            state.currently_used_bnodes.clear();
 1179|  2.49k|        }
 1180|  2.49k|
 1181|  2.49k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  2.49k|            let mut filter: Option<Expression> = None;
 1183|  2.49k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  2.49k|            for e in b.into_iter().flatten() {
 1185|  2.49k|                match e {
 1186|  2.49k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  2.49k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  2.49k|                    }
 1189|  2.49k|                    #[cfg(feature = "sep-0006")]
 1190|  2.49k|                    PartialGraphPattern::Lateral(p) => {
 1191|  2.49k|                        let mut defined_variables = HashSet::default();
 1192|  2.49k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  2.49k|                        let mut contains = false;
 1194|  2.49k|                        g.on_in_scope_variable(|v| {
 1195|  2.49k|                            if defined_variables.contains(v) {
 1196|  2.49k|                                contains = true;
 1197|  2.49k|                            }
 1198|  2.49k|                        });
 1199|  2.49k|                        if contains {
 1200|  2.49k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  2.49k|                        }
 1202|  2.49k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  2.49k|                    }
 1204|  2.49k|                    PartialGraphPattern::Minus(p) => {
 1205|  2.49k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  2.49k|                    }
 1207|  2.49k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  2.49k|                        let mut contains = false;
 1209|  2.49k|                        g.on_in_scope_variable(|v| {
 1210|  2.49k|                            if *v == variable {
 1211|  2.49k|                                contains = true;
 1212|  2.49k|                            }
 1213|  2.49k|                        });
 1214|  2.49k|                        if contains {
 1215|  2.49k|                            return Err("BIND is overriding an existing variable")
 1216|  2.49k|                        }
 1217|  2.49k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  2.49k|                    }
 1219|  2.49k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  2.49k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  2.49k|                    } else {
 1222|  2.49k|                        expr
 1223|  2.49k|                    }),
 1224|  2.49k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  2.49k|                }
 1226|  2.49k|            }
 1227|  2.49k|
 1228|  2.49k|            Ok(if let Some(expr) = filter {
 1229|  2.49k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  2.49k|            } else {
 1231|  2.49k|                g
 1232|  2.49k|            })
 1233|  2.49k|        }
 1234|  2.49k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  2.49k|            let mut result = vec![a];
 1236|  2.49k|            if let Some(v) = b {
 1237|  2.49k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  2.49k|            }
 1239|  2.49k|            result
 1240|  2.49k|        }
 1241|  2.49k|
 1242|  2.49k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  2.49k|            hs.into_iter().flatten().collect()
 1244|  2.49k|        }
 1245|  2.49k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  2.49k|
 1247|  2.49k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  2.49k|
 1249|  2.49k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  2.49k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  2.49k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  2.49k|            } else {
 1253|  2.49k|               PartialGraphPattern::Optional(p, None)
 1254|  2.49k|            }
 1255|  2.49k|        }
 1256|  2.49k|
 1257|  2.49k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  2.49k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  2.49k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  2.49k|        }
 1261|  2.49k|
 1262|  2.49k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  2.49k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  2.49k|        }
 1265|  2.49k|
 1266|  2.49k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  2.49k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  2.49k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  2.49k|
 1270|  2.49k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  2.49k|            PartialGraphPattern::Bind(e, v)
 1272|  2.49k|        }
 1273|  2.49k|
 1274|  2.49k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  2.49k|
 1276|  2.49k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  2.49k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  2.49k|        }
 1279|  2.49k|
 1280|  2.49k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  2.49k|            (vec![var], d)
 1282|  2.49k|        }
 1283|  2.49k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  2.49k|
 1285|  2.49k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  2.49k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  2.49k|                Ok((vars, vals))
 1288|  2.49k|            } else {
 1289|  2.49k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  2.49k|            }
 1291|  2.49k|        }
 1292|  2.49k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  2.49k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  2.49k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  2.49k|
 1296|  2.49k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  2.49k|            t:QuotedTripleData() {?
 1298|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  2.49k|            } /
 1301|  2.49k|            i:iri() { Some(i.into()) } /
 1302|  2.49k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  2.49k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  2.49k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  2.49k|            i("UNDEF") { None }
 1306|  2.49k|
 1307|  2.49k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  2.49k|            PartialGraphPattern::Minus(p)
 1309|  2.49k|        }
 1310|  2.49k|
 1311|  2.49k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  2.49k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  2.49k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  2.49k|            }).map(PartialGraphPattern::Other)
 1315|  2.49k|        }
 1316|  2.49k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  2.49k|
 1318|  2.49k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  2.49k|            PartialGraphPattern::Filter(c)
 1320|  2.49k|        }
 1321|  2.49k|
 1322|  2.49k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  2.49k|
 1324|  2.49k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  2.49k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  2.49k|        }
 1327|  2.49k|
 1328|  2.49k|        rule ArgList() -> Vec<Expression> =
 1329|  2.49k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  2.49k|            NIL() { Vec::new() }
 1331|  2.49k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  2.49k|
 1333|  2.49k|        rule ExpressionList() -> Vec<Expression> =
 1334|  2.49k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  2.49k|            NIL() { Vec::new() }
 1336|  2.49k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  2.49k|
 1338|  2.49k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  2.49k|
 1340|  2.49k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  2.49k|            p.into_iter().flatten().collect()
 1342|  2.49k|        }
 1343|  2.49k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  2.49k|
 1345|  2.49k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  2.49k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  2.49k|                let mut patterns = po.patterns;
 1348|  2.49k|                for (p, os) in po.focus {
 1349|  2.49k|                    for o in os {
 1350|  2.49k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  2.49k|                    }
 1352|  2.49k|                }
 1353|  2.49k|                Ok(patterns)
 1354|  2.49k|            } /
 1355|  2.49k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  2.49k|                let mut patterns = s.patterns;
 1357|  2.49k|                patterns.extend(po.patterns);
 1358|  2.49k|                for (p, os) in po.focus {
 1359|  2.49k|                    for o in os {
 1360|  2.49k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  2.49k|                    }
 1362|  2.49k|                }
 1363|  2.49k|                Ok(patterns)
 1364|  2.49k|            }
 1365|  2.49k|
 1366|  2.49k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  2.49k|            PropertyListNotEmpty() /
 1368|  2.49k|            { FocusedTriplePattern::default() }
 1369|  2.49k|
 1370|  2.49k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  2.49k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  2.49k|                a.focus.push(b.focus);
 1373|  2.49k|                a.patterns.extend(b.patterns);
 1374|  2.49k|                a
 1375|  2.49k|            })
 1376|  2.49k|        }
 1377|  2.49k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  2.49k|            FocusedTriplePattern {
 1379|  2.49k|                focus: (p, o.focus),
 1380|  2.49k|                patterns: o.patterns
 1381|  2.49k|            }
 1382|  2.49k|        }
 1383|  2.49k|
 1384|  2.49k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  2.49k|
 1386|  2.49k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  2.49k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  2.49k|                a.focus.push(b.focus);
 1389|  2.49k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  2.49k|                a
 1391|  2.49k|            })
 1392|  2.49k|        }
 1393|  2.49k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  2.49k|
 1395|  2.49k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  2.49k|            if let Some(a) = a {
 1397|  2.49k|                let mut patterns = g.patterns;
 1398|  2.49k|                patterns.extend(a.patterns);
 1399|  2.49k|                FocusedTriplePattern {
 1400|  2.49k|                    focus: AnnotatedTerm {
 1401|  2.49k|                        term: g.focus,
 1402|  2.49k|                        annotations: a.focus
 1403|  2.49k|                    },
 1404|  2.49k|                    patterns
 1405|  2.49k|                }
 1406|  2.49k|            } else {
 1407|  2.49k|                FocusedTriplePattern {
 1408|  2.49k|                    focus: AnnotatedTerm {
 1409|  2.49k|                        term: g.focus,
 1410|  2.49k|                        annotations: Vec::new()
 1411|  2.49k|                    },
 1412|  2.49k|                    patterns: g.patterns
 1413|  2.49k|                }
 1414|  2.49k|            }
 1415|  2.49k|        }
 1416|  2.49k|
 1417|  2.49k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  2.49k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  2.49k|                let mut patterns = po.patterns;
 1420|  2.49k|                for (p, os) in po.focus {
 1421|  2.49k|                    for o in os {
 1422|  2.49k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  2.49k|                    }
 1424|  2.49k|                }
 1425|  2.49k|                Ok(patterns)
 1426|  2.49k|            } /
 1427|  2.49k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  2.49k|                let mut patterns = s.patterns;
 1429|  2.49k|                patterns.extend(po.patterns);
 1430|  2.49k|                for (p, os) in po.focus {
 1431|  2.49k|                    for o in os {
 1432|  2.49k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  2.49k|                    }
 1434|  2.49k|                }
 1435|  2.49k|                Ok(patterns)
 1436|  2.49k|            }
 1437|  2.49k|
 1438|  2.49k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  2.49k|            PropertyListPathNotEmpty() /
 1440|  2.49k|            { FocusedTripleOrPathPattern::default() }
 1441|  2.49k|
 1442|  2.49k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  2.49k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  2.49k|                    focus: vec![(hp, ho.focus)],
 1445|  2.49k|                    patterns: ho.patterns
 1446|  2.49k|                }, |mut a, b| {
 1447|  2.49k|                    a.focus.push(b.focus);
 1448|  2.49k|                    a.patterns.extend(b.patterns);
 1449|  2.49k|                    a
 1450|  2.49k|                })
 1451|  2.49k|        }
 1452|  2.49k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  2.49k|            c
 1454|  2.49k|        }
 1455|  2.49k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  2.49k|            FocusedTripleOrPathPattern {
 1457|  2.49k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  2.49k|                patterns: o.patterns
 1459|  2.49k|            }
 1460|  2.49k|        }
 1461|  2.49k|
 1462|  2.49k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  2.49k|            p.into()
 1464|  2.49k|        }
 1465|  2.49k|
 1466|  2.49k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  2.49k|            v.into()
 1468|  2.49k|        }
 1469|  2.49k|
 1470|  2.49k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  2.49k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  2.49k|                a.focus.push(b.focus);
 1473|  2.49k|                a.patterns.extend(b.patterns);
 1474|  2.49k|                a
 1475|  2.49k|            })
 1476|  2.49k|        }
 1477|  2.49k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  2.49k|
 1479|  2.49k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  2.49k|             if let Some(a) = a {
 1481|  2.49k|                let mut patterns = g.patterns;
 1482|  2.49k|                patterns.extend(a.patterns);
 1483|  2.49k|                FocusedTripleOrPathPattern {
 1484|  2.49k|                    focus: AnnotatedTermPath {
 1485|  2.49k|                        term: g.focus,
 1486|  2.49k|                        annotations: a.focus
 1487|  2.49k|                    },
 1488|  2.49k|                    patterns
 1489|  2.49k|                }
 1490|  2.49k|            } else {
 1491|  2.49k|                FocusedTripleOrPathPattern {
 1492|  2.49k|                    focus: AnnotatedTermPath {
 1493|  2.49k|                        term: g.focus,
 1494|  2.49k|                        annotations: Vec::new()
 1495|  2.49k|                    },
 1496|  2.49k|                    patterns: g.patterns
 1497|  2.49k|                }
 1498|  2.49k|            }
 1499|  2.49k|        }
 1500|  2.49k|
 1501|  2.49k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  2.49k|
 1503|  2.49k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  2.49k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  2.49k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  2.49k|            })
 1507|  2.49k|        }
 1508|  2.49k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  2.49k|
 1510|  2.49k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  2.49k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  2.49k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  2.49k|            })
 1514|  2.49k|        }
 1515|  2.49k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  2.49k|
 1517|  2.49k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  2.49k|            match o {
 1519|  2.49k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  2.49k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  2.49k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  2.49k|                Some(_) => unreachable!(),
 1523|  2.49k|                None => p
 1524|  2.49k|            }
 1525|  2.49k|        }
 1526|  2.49k|        rule PathElt_op() -> char =
 1527|  2.49k|            "*" { '*' } /
 1528|  2.49k|            "+" { '+' } /
 1529|  2.49k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  2.49k|
 1531|  2.49k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  2.49k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  2.49k|            PathElt()
 1534|  2.49k|
 1535|  2.49k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  2.49k|            v:iri() { v.into() } /
 1537|  2.49k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  2.49k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  2.49k|            "(" _ p:Path() _ ")" { p }
 1540|  2.49k|
 1541|  2.49k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  2.49k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  2.49k|                let mut direct = Vec::new();
 1544|  2.49k|                let mut inverse = Vec::new();
 1545|  2.49k|                for e in p {
 1546|  2.49k|                    match e {
 1547|  2.49k|                        Either::Left(a) => direct.push(a),
 1548|  2.49k|                        Either::Right(b) => inverse.push(b)
 1549|  2.49k|                    }
 1550|  2.49k|                }
 1551|  2.49k|                if inverse.is_empty() {
 1552|  2.49k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  2.49k|                } else if direct.is_empty() {
 1554|  2.49k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  2.49k|                } else {
 1556|  2.49k|                    PropertyPathExpression::Alternative(
 1557|  2.49k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  2.49k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  2.49k|                    )
 1560|  2.49k|                }
 1561|  2.49k|            } /
 1562|  2.49k|            p:PathOneInPropertySet() {
 1563|  2.49k|                match p {
 1564|  2.49k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  2.49k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  2.49k|                }
 1567|  2.49k|            }
 1568|  2.49k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  2.49k|
 1570|  2.49k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  2.49k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  2.49k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  2.49k|            v:iri() { Either::Left(v) } /
 1574|  2.49k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  2.49k|
 1576|  2.49k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  2.49k|
 1578|  2.49k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  2.49k|            let mut patterns = po.patterns;
 1580|  2.49k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  2.49k|            for (p, os) in po.focus {
 1582|  2.49k|                for o in os {
 1583|  2.49k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  2.49k|                }
 1585|  2.49k|            }
 1586|  2.49k|            Ok(FocusedTriplePattern {
 1587|  2.49k|                focus: bnode,
 1588|  2.49k|                patterns
 1589|  2.49k|            })
 1590|  2.49k|        }
 1591|  2.49k|
 1592|  2.49k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  2.49k|
 1594|  2.49k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  2.49k|            let mut patterns = po.patterns;
 1596|  2.49k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  2.49k|            for (p, os) in po.focus {
 1598|  2.49k|                for o in os {
 1599|  2.49k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  2.49k|                }
 1601|  2.49k|            }
 1602|  2.49k|            Ok(FocusedTripleOrPathPattern {
 1603|  2.49k|                focus: bnode,
 1604|  2.49k|                patterns
 1605|  2.49k|            })
 1606|  2.49k|        }
 1607|  2.49k|
 1608|  2.49k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  2.49k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  2.49k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  2.49k|            for objWithPatterns in o.into_iter().rev() {
 1612|  2.49k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  2.49k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  2.49k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  2.49k|                current_list_node = new_blank_node;
 1616|  2.49k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  2.49k|            }
 1618|  2.49k|            FocusedTriplePattern {
 1619|  2.49k|                focus: current_list_node,
 1620|  2.49k|                patterns
 1621|  2.49k|            }
 1622|  2.49k|        }
 1623|  2.49k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  2.49k|
 1625|  2.49k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  2.49k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  2.49k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  2.49k|            for objWithPatterns in o.into_iter().rev() {
 1629|  2.49k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  2.49k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  2.49k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  2.49k|                current_list_node = new_blank_node;
 1633|  2.49k|                patterns.extend(objWithPatterns.patterns);
 1634|  2.49k|            }
 1635|  2.49k|            FocusedTripleOrPathPattern {
 1636|  2.49k|                focus: current_list_node,
 1637|  2.49k|                patterns
 1638|  2.49k|            }
 1639|  2.49k|        }
 1640|  2.49k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  2.49k|
 1642|  2.49k|
 1643|  2.49k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  2.49k|
 1645|  2.49k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  2.49k|
 1647|  2.49k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  2.49k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  2.49k|            TriplesNode()
 1650|  2.49k|
 1651|  2.49k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  2.49k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  2.49k|            TriplesNodePath()
 1654|  2.49k|
 1655|  2.49k|        rule VarOrTerm() -> TermPattern =
 1656|  2.49k|            v:Var() { v.into() } /
 1657|  2.49k|            t:QuotedTriple() {?
 1658|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  2.49k|            } /
 1661|  2.49k|            t:GraphTerm() { t.into() }
 1662|  2.49k|
 1663|  2.49k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  2.49k|            Ok(TriplePattern {
 1665|  2.49k|                subject: s,
 1666|  2.49k|                predicate: p,
 1667|  2.49k|                object: o
 1668|  2.49k|            })
 1669|  2.49k|        }
 1670|  2.49k|
 1671|  2.49k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  2.49k|            Ok(GroundTriple {
 1673|  2.49k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  2.49k|                predicate: p,
 1675|  2.49k|                object: o
 1676|  2.49k|            })
 1677|  2.49k|        }
 1678|  2.49k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  2.49k|
 1680|  2.49k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  2.49k|            l:RDFLiteral() { l.into() } /
 1682|  2.49k|            l:NumericLiteral() { l.into() } /
 1683|  2.49k|            l:BooleanLiteral() { l.into() } /
 1684|  2.49k|            t:QuotedTripleData() {?
 1685|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  2.49k|            }
 1688|  2.49k|
 1689|  2.49k|        rule VarOrIri() -> NamedNodePattern =
 1690|  2.49k|            v:Var() { v.into() } /
 1691|  2.49k|            i:iri() { i.into() }
 1692|  2.49k|
 1693|  2.49k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  2.49k|
 1695|  2.49k|        rule GraphTerm() -> Term =
 1696|  2.49k|            i:iri() { i.into() } /
 1697|  2.49k|            l:RDFLiteral() { l.into() } /
 1698|  2.49k|            l:NumericLiteral() { l.into() } /
 1699|  2.49k|            l:BooleanLiteral() { l.into() } /
 1700|  2.49k|            b:BlankNode() { b.into() } /
 1701|  2.49k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  2.49k|
 1703|  2.49k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  2.49k|
 1705|  2.49k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  2.49k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  2.49k|        }
 1708|  2.49k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  2.49k|
 1710|  2.49k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  2.49k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  2.49k|        }
 1713|  2.49k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  2.49k|
 1715|  2.49k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  2.49k|
 1717|  2.49k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  2.49k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  2.49k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  2.49k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  2.49k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  2.49k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  2.49k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  2.49k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  2.49k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  2.49k|            Some(_) => unreachable!(),
 1727|  2.49k|            None => a
 1728|  2.49k|        } }
 1729|  2.49k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  2.49k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  2.49k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  2.49k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  2.49k|
 1734|  2.49k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  2.49k|
 1736|  2.49k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  2.49k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  2.49k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  2.49k|            Some(_) => unreachable!(),
 1740|  2.49k|            None => a,
 1741|  2.49k|        } }
 1742|  2.49k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  2.49k|            (s, e)
 1744|  2.49k|        }
 1745|  2.49k|
 1746|  2.49k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  2.49k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  2.49k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  2.49k|            Some(_) => unreachable!(),
 1750|  2.49k|            None => a
 1751|  2.49k|        } }
 1752|  2.49k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  2.49k|            (s, e)
 1754|  2.49k|        }
 1755|  2.49k|
 1756|  2.49k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  2.49k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  2.49k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  2.49k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  2.49k|            Some(_) => unreachable!(),
 1761|  2.49k|            None => e,
 1762|  2.49k|        } }
 1763|  2.49k|
 1764|  2.49k|        rule PrimaryExpression() -> Expression =
 1765|  2.49k|            BrackettedExpression()  /
 1766|  2.49k|            ExprQuotedTriple() /
 1767|  2.49k|            iriOrFunction() /
 1768|  2.49k|            v:Var() { v.into() } /
 1769|  2.49k|            l:RDFLiteral() { l.into() } /
 1770|  2.49k|            l:NumericLiteral() { l.into() } /
 1771|  2.49k|            l:BooleanLiteral() { l.into() } /
 1772|  2.49k|            BuiltInCall()
 1773|  2.49k|
 1774|  2.49k|        rule ExprVarOrTerm() -> Expression =
 1775|  2.49k|            ExprQuotedTriple() /
 1776|  2.49k|            i:iri() { i.into() } /
 1777|  2.49k|            l:RDFLiteral() { l.into() } /
 1778|  2.49k|            l:NumericLiteral() { l.into() } /
 1779|  2.49k|            l:BooleanLiteral() { l.into() } /
 1780|  2.49k|            v:Var() { v.into() }
 1781|  2.49k|
 1782|  2.49k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  2.49k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  2.49k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  2.49k|        }
 1786|  2.49k|
 1787|  2.49k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  2.49k|
 1789|  2.49k|        rule BuiltInCall() -> Expression =
 1790|  2.49k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  2.49k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  2.49k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  2.49k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  2.49k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  2.49k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  2.49k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  2.49k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  2.49k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  2.49k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  2.49k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  2.49k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  2.49k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  2.49k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  2.49k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  2.49k|            SubstringExpression() /
 1806|  2.49k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  2.49k|            StrReplaceExpression() /
 1808|  2.49k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  2.49k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  2.49k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  2.49k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  2.49k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  2.49k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  2.49k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  2.49k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  2.49k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  2.49k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  2.49k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  2.49k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  2.49k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  2.49k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  2.49k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  2.49k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  2.49k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  2.49k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  2.49k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  2.49k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  2.49k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  2.49k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  2.49k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  2.49k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  2.49k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  2.49k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  2.49k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  2.49k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  2.49k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  2.49k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  2.49k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  2.49k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  2.49k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  2.49k|            RegexExpression() /
 1842|  2.49k|            ExistsFunc() /
 1843|  2.49k|            NotExistsFunc() /
 1844|  2.49k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  2.49k|            } /
 1848|  2.49k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  2.49k|            } /
 1852|  2.49k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  2.49k|            } /
 1856|  2.49k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  2.49k|            } /
 1860|  2.49k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  2.49k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  2.49k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  2.49k|            } /
 1864|  2.49k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  2.49k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  2.49k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  2.49k|            }
 1868|  2.49k|
 1869|  2.49k|        rule RegexExpression() -> Expression =
 1870|  2.49k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  2.49k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  2.49k|
 1873|  2.49k|
 1874|  2.49k|        rule SubstringExpression() -> Expression =
 1875|  2.49k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  2.49k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  2.49k|
 1878|  2.49k|
 1879|  2.49k|        rule StrReplaceExpression() -> Expression =
 1880|  2.49k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  2.49k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  2.49k|
 1883|  2.49k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  2.49k|
 1885|  2.49k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  2.49k|
 1887|  2.49k|        rule Aggregate() -> AggregateExpression =
 1888|  2.49k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  2.49k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  2.49k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  2.49k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  2.49k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  2.49k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  2.49k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  2.49k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  2.49k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  2.49k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  2.49k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  2.49k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  2.49k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  2.49k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  2.49k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  2.49k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  2.49k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  2.49k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  2.49k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  2.49k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  2.49k|
 1909|  2.49k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  2.49k|            match a {
 1911|  2.49k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  2.49k|                None => i.into()
 1913|  2.49k|            }
 1914|  2.49k|        }
 1915|  2.49k|
 1916|  2.49k|        rule RDFLiteral() -> Literal =
 1917|  2.49k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  2.49k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  2.49k|            value:String() { Literal::new_simple_literal(value) }
 1920|  2.49k|
 1921|  2.49k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  2.49k|
 1923|  2.49k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  2.49k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  2.49k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  2.49k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  2.49k|
 1928|  2.49k|        rule NumericLiteralPositive() -> Literal =
 1929|  2.49k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  2.49k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  2.49k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  2.49k|
 1933|  2.49k|
 1934|  2.49k|        rule NumericLiteralNegative() -> Literal =
 1935|  2.49k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  2.49k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  2.49k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  2.49k|
 1939|  2.49k|        rule BooleanLiteral() -> Literal =
 1940|  2.49k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  2.49k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  2.49k|
 1943|  2.49k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  2.49k|
 1945|  2.49k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  2.49k|            NamedNode::from(i)
 1947|  2.49k|        }
 1948|  2.49k|
 1949|  2.49k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  2.49k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  2.49k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  2.49k|            } else {
 1953|  2.49k|                Err("Prefix not found")
 1954|  2.49k|            } }
 1955|  2.49k|
 1956|  2.49k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  2.49k|            let node = BlankNode::new_unchecked(id);
 1958|  2.49k|            if state.used_bnodes.contains(&node) {
 1959|  2.49k|                Err("Already used blank node id")
 1960|  2.49k|            } else {
 1961|  2.49k|                state.currently_used_bnodes.insert(node.clone());
 1962|  2.49k|                Ok(node)
 1963|  2.49k|            }
 1964|  2.49k|        } / ANON() { BlankNode::default() }
 1965|  2.49k|
 1966|  2.49k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  2.49k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  2.49k|        }
 1969|  2.49k|
 1970|  2.49k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  2.49k|            ns
 1972|  2.49k|        }
 1973|  2.49k|
 1974|  2.49k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  2.49k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  2.49k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  2.49k|                iri.push_str(base);
 1978|  2.49k|                for chunk in local.split('\\') { // We remove \
 1979|  2.49k|                    iri.push_str(chunk);
 1980|  2.49k|                }
 1981|  2.49k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  2.49k|            } else {
 1983|  2.49k|                Err("Prefix not found")
 1984|  2.49k|            }
 1985|  2.49k|        }
 1986|  2.49k|
 1987|  2.49k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  2.49k|            b
 1989|  2.49k|        }
 1990|  2.49k|
 1991|  2.49k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  2.49k|
 1993|  2.49k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  2.49k|
 1995|  2.49k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  2.49k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  2.49k|        }
 1998|  2.49k|
 1999|  2.49k|        rule INTEGER() = ['0'..='9']+
 2000|  2.49k|
 2001|  2.49k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  2.49k|
 2003|  2.49k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  2.49k|
 2005|  2.49k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  2.49k|
 2007|  2.49k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  2.49k|
 2009|  2.49k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  2.49k|
 2011|  2.49k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  2.49k|
 2013|  2.49k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  2.49k|
 2015|  2.49k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  2.49k|
 2017|  2.49k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  2.49k|
 2019|  2.49k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  2.49k|             unescape_string(l)
 2021|  2.49k|        }
 2022|  2.49k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  2.49k|
 2024|  2.49k|
 2025|  2.49k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  2.49k|             unescape_string(l)
 2027|  2.49k|        }
 2028|  2.49k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  2.49k|
 2030|  2.49k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  2.49k|             unescape_string(l)
 2032|  2.49k|        }
 2033|  2.49k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  2.49k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  2.49k|
 2036|  2.49k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  2.49k|             unescape_string(l)
 2038|  2.49k|        }
 2039|  2.49k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  2.49k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  2.49k|
 2042|  2.49k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  2.49k|
 2044|  2.49k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  2.49k|
 2046|  2.49k|        rule NIL() = "(" WS()* ")"
 2047|  2.49k|
 2048|  2.49k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  2.49k|
 2050|  2.49k|        rule ANON() = "[" WS()* "]"
 2051|  2.49k|
 2052|  2.49k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  2.49k|
 2054|  2.49k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  2.49k|
 2056|  2.49k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  2.49k|
 2058|  2.49k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  2.49k|
 2060|  2.49k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  2.49k|
 2062|  2.49k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  2.49k|
 2064|  2.49k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  2.49k|
 2066|  2.49k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  2.49k|
 2068|  2.49k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  2.49k|
 2070|  2.49k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  2.49k|
 2072|  2.49k|        //space
 2073|  2.49k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  2.49k|
 2075|  2.49k|        //comment
 2076|  2.49k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  2.49k|
 2078|  2.49k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  2.49k|            if input.eq_ignore_ascii_case(literal) {
 2080|  2.49k|                Ok(())
 2081|  2.49k|            } else {
 2082|  2.49k|                Err(literal)
 2083|  2.49k|            }
 2084|  2.49k|        }
 2085|  2.49k|    }
 2086|  2.49k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_SelectClause0B7_:
  811|  1.93k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  1.93k|            Selection {
  813|  1.93k|                option: o,
  814|  1.93k|                variables: v
  815|  1.93k|            }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralUnsigneds0_0B7_:
 1926|  2.59k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroupConditions0_0B7_:
  938|      2|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_Quads_TriplesTemplate00B9_:
 1159|  2.28k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_PathPrimary0B7_:
 1536|  8.85k|            v:iri() { v.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser38___parse_MultiplicativeExpression_inner0B7_:
 1752|  5.15k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  5.15k|            (s, e)
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PrimaryExpressions0_0B7_:
 1770|  2.18k|            l:NumericLiteral() { l.into() } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_members_0B7_:
  829|    875|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_InsertData0B7_:
 1025|    239|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|    239|            vec![GraphUpdateOperation::InsertData { data }]
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_DeleteWhere0B7_:
  778|    364|parser! {
  779|       |    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|       |    grammar parser(state: &mut ParserState) for str {
  781|       |        pub rule QueryUnit() -> Query = Query()
  782|       |
  783|       |        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|       |            q
  785|       |        }
  786|       |
  787|       |        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|       |
  789|       |        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|       |
  791|       |        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|       |            state.base_iri = Some(i)
  793|       |        }
  794|       |
  795|       |        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|       |            state.namespaces.insert(ns.into(), i.into_inner());
  797|       |        }
  798|       |
  799|       |        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|       |            Ok(Query::Select {
  801|       |                dataset: d,
  802|       |                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|       |                base_iri: state.base_iri.clone()
  804|       |            })
  805|       |        }
  806|       |
  807|       |        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|       |            build_select(s, w, g, h, o, l, v, state)
  809|       |        }
  810|       |
  811|       |        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|       |            Selection {
  813|       |                option: o,
  814|       |                variables: v
  815|       |            }
  816|       |        }
  817|       |        rule Selection_init() = {
  818|       |            state.aggregates.push(Vec::new())
  819|       |        }
  820|       |        rule SelectClause_option() -> SelectionOption =
  821|       |            i("DISTINCT") { SelectionOption::Distinct } /
  822|       |            i("REDUCED") { SelectionOption::Reduced } /
  823|       |            { SelectionOption::Default }
  824|       |        rule SelectClause_variables() -> SelectionVariables =
  825|       |            "*" { SelectionVariables::Star } /
  826|       |            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|       |        rule SelectClause_member() -> SelectionMember =
  828|       |            v:Var() _ { SelectionMember::Variable(v) } /
  829|       |            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|       |
  831|       |        rule ConstructQuery() -> Query =
  832|       |            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|       |                Ok(Query::Construct {
  834|       |                    template: c,
  835|       |                    dataset: d,
  836|       |                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|       |                    base_iri: state.base_iri.clone()
  838|       |                })
  839|       |            } /
  840|       |            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|       |                Ok(Query::Construct {
  842|       |                    template: c.clone(),
  843|       |                    dataset: d,
  844|       |                    pattern: build_select(
  845|       |                        Selection::no_op(),
  846|       |                        GraphPattern::Bgp { patterns: c },
  847|       |                        g, h, o, l, v, state
  848|       |                    )?,
  849|       |                    base_iri: state.base_iri.clone()
  850|       |                })
  851|       |            }
  852|       |
  853|       |        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|       |
  855|       |        rule DescribeQuery() -> Query =
  856|       |            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|       |                Ok(Query::Describe {
  858|       |                    dataset: d,
  859|       |                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|       |                    base_iri: state.base_iri.clone()
  861|       |                })
  862|       |            } /
  863|       |            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|       |                Ok(Query::Describe {
  865|       |                    dataset: d,
  866|       |                    pattern: build_select(Selection {
  867|       |                        option: SelectionOption::Default,
  868|       |                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|       |                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|       |                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|       |                        }).collect())
  872|       |                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|       |                    base_iri: state.base_iri.clone()
  874|       |                })
  875|       |            }
  876|       |        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|       |
  878|       |        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|       |            Ok(Query::Ask {
  880|       |                dataset: d,
  881|       |                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|       |                base_iri: state.base_iri.clone()
  883|       |            })
  884|       |        }
  885|       |
  886|       |        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|       |        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|       |            if d.is_empty() {
  889|       |                return None;
  890|       |            }
  891|       |            let mut default = Vec::new();
  892|       |            let mut named = Vec::new();
  893|       |            for (d, n) in d {
  894|       |                if let Some(d) = d {
  895|       |                    default.push(d);
  896|       |                }
  897|       |                if let Some(n) = n {
  898|       |                    named.push(n);
  899|       |                }
  900|       |            }
  901|       |            Some(QueryDataset {
  902|       |                default, named: Some(named)
  903|       |            })
  904|       |        }
  905|       |
  906|       |        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|       |            (Some(s), None)
  908|       |        }
  909|       |
  910|       |        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|       |            (None, Some(s))
  912|       |        }
  913|       |
  914|       |        rule SourceSelector() -> NamedNode = iri()
  915|       |
  916|       |        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|       |            p
  918|       |        }
  919|       |
  920|       |        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|       |            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|       |            let clauses = c.into_iter().map(|(e, vo)| {
  923|       |                if let Expression::Variable(v) = e {
  924|       |                    v
  925|       |                } else {
  926|       |                    let v = vo.unwrap_or_else(variable);
  927|       |                    projections.push((e, v.clone()));
  928|       |                    v
  929|       |                }
  930|       |            }).collect();
  931|       |            (clauses, projections)
  932|       |        }
  933|       |        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|       |
  935|       |        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|       |            e:BuiltInCall() { (e, None) } /
  937|       |            e:FunctionCall() { (e, None) } /
  938|       |            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|       |            e:Var() { (e.into(), None) }
  940|       |        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|       |
  942|       |        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|       |            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|       |        }
  945|       |
  946|       |        rule HavingCondition() -> Expression = Constraint()
  947|       |
  948|       |        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|       |        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|       |
  951|       |        rule OrderCondition() -> OrderExpression =
  952|       |            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|       |            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|       |            e: Constraint() { OrderExpression::Asc(e) } /
  955|       |            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|       |
  957|       |        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|       |            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|       |            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|       |
  961|       |        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|       |            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|       |        }
  964|       |
  965|       |        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|       |            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|       |        }
  968|       |
  969|       |        rule ValuesClause() -> Option<GraphPattern> =
  970|       |            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|       |            { None }
  972|       |
  973|       |        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|       |
  975|       |        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|       |        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|       |
  978|       |        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|       |            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|       |        }
  981|       |        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|       |
  983|       |        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|       |            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|       |        }
  986|       |
  987|       |        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|       |            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|       |        }
  990|       |
  991|       |        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|       |            vec![GraphUpdateOperation::Create { silent, graph }]
  993|       |        }
  994|       |
  995|       |        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|       |            if from == to {
  998|       |                Vec::new() // identity case
  999|       |            } else {
 1000|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|       |                vec![copy_graph(from, to)]
 1002|       |            }
 1003|       |        }
 1004|       |
 1005|       |        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|       |            if from == to {
 1008|       |                Vec::new() // identity case
 1009|       |            } else {
 1010|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|       |            }
 1013|       |        }
 1014|       |
 1015|       |        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|       |            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|       |            if from == to {
 1018|       |                Vec::new() // identity case
 1019|       |            } else {
 1020|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|       |                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|       |            }
 1023|       |        }
 1024|       |
 1025|       |        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|       |            vec![GraphUpdateOperation::InsertData { data }]
 1027|       |        }
 1028|       |
 1029|       |        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|       |            vec![GraphUpdateOperation::DeleteData { data }]
 1031|       |        }
 1032|       |
 1033|       |        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|    364|            let pattern = d.iter().map(|q| {
 1035|       |                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|       |                match &q.graph_name {
 1037|       |                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|       |                    GraphNamePattern::DefaultGraph => bgp,
 1039|       |                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|       |                }
 1041|    364|            }).reduce(new_join).unwrap_or_default();
 1042|    364|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|    364|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|    364|                delete,
 1045|    364|                insert: Vec::new(),
 1046|    364|                using: None,
 1047|    364|                pattern: Box::new(pattern)
 1048|    364|            }])
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GraphOrDefault0B7_:
 1133|    887|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|    887|            GraphName::DefaultGraph
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_PathElt0B7_:
 1517|  34.5k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  34.5k|            match o {
 1519|  4.89k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  1.17k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  2.50k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|      0|                Some(_) => unreachable!(),
 1523|  26.0k|                None => p
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_Quads0B7_:
 1155|  5.40k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  5.40k|            q.into_iter().flatten().collect()
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralUnsigneds_0B7_:
 1925|  1.28k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_BooleanLiteral0B7_:
 1940|    225|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_Var0B7_:
 1693|  46.5k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_STRING_LITERAL20B7_:
  778|  5.26k|parser! {
  779|  5.26k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  5.26k|    grammar parser(state: &mut ParserState) for str {
  781|  5.26k|        pub rule QueryUnit() -> Query = Query()
  782|  5.26k|
  783|  5.26k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  5.26k|            q
  785|  5.26k|        }
  786|  5.26k|
  787|  5.26k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  5.26k|
  789|  5.26k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  5.26k|
  791|  5.26k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  5.26k|            state.base_iri = Some(i)
  793|  5.26k|        }
  794|  5.26k|
  795|  5.26k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  5.26k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  5.26k|        }
  798|  5.26k|
  799|  5.26k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  5.26k|            Ok(Query::Select {
  801|  5.26k|                dataset: d,
  802|  5.26k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  5.26k|                base_iri: state.base_iri.clone()
  804|  5.26k|            })
  805|  5.26k|        }
  806|  5.26k|
  807|  5.26k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  5.26k|            build_select(s, w, g, h, o, l, v, state)
  809|  5.26k|        }
  810|  5.26k|
  811|  5.26k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  5.26k|            Selection {
  813|  5.26k|                option: o,
  814|  5.26k|                variables: v
  815|  5.26k|            }
  816|  5.26k|        }
  817|  5.26k|        rule Selection_init() = {
  818|  5.26k|            state.aggregates.push(Vec::new())
  819|  5.26k|        }
  820|  5.26k|        rule SelectClause_option() -> SelectionOption =
  821|  5.26k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  5.26k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  5.26k|            { SelectionOption::Default }
  824|  5.26k|        rule SelectClause_variables() -> SelectionVariables =
  825|  5.26k|            "*" { SelectionVariables::Star } /
  826|  5.26k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  5.26k|        rule SelectClause_member() -> SelectionMember =
  828|  5.26k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  5.26k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  5.26k|
  831|  5.26k|        rule ConstructQuery() -> Query =
  832|  5.26k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  5.26k|                Ok(Query::Construct {
  834|  5.26k|                    template: c,
  835|  5.26k|                    dataset: d,
  836|  5.26k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  5.26k|                    base_iri: state.base_iri.clone()
  838|  5.26k|                })
  839|  5.26k|            } /
  840|  5.26k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  5.26k|                Ok(Query::Construct {
  842|  5.26k|                    template: c.clone(),
  843|  5.26k|                    dataset: d,
  844|  5.26k|                    pattern: build_select(
  845|  5.26k|                        Selection::no_op(),
  846|  5.26k|                        GraphPattern::Bgp { patterns: c },
  847|  5.26k|                        g, h, o, l, v, state
  848|  5.26k|                    )?,
  849|  5.26k|                    base_iri: state.base_iri.clone()
  850|  5.26k|                })
  851|  5.26k|            }
  852|  5.26k|
  853|  5.26k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  5.26k|
  855|  5.26k|        rule DescribeQuery() -> Query =
  856|  5.26k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  5.26k|                Ok(Query::Describe {
  858|  5.26k|                    dataset: d,
  859|  5.26k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  5.26k|                    base_iri: state.base_iri.clone()
  861|  5.26k|                })
  862|  5.26k|            } /
  863|  5.26k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  5.26k|                Ok(Query::Describe {
  865|  5.26k|                    dataset: d,
  866|  5.26k|                    pattern: build_select(Selection {
  867|  5.26k|                        option: SelectionOption::Default,
  868|  5.26k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  5.26k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  5.26k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  5.26k|                        }).collect())
  872|  5.26k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  5.26k|                    base_iri: state.base_iri.clone()
  874|  5.26k|                })
  875|  5.26k|            }
  876|  5.26k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  5.26k|
  878|  5.26k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  5.26k|            Ok(Query::Ask {
  880|  5.26k|                dataset: d,
  881|  5.26k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  5.26k|                base_iri: state.base_iri.clone()
  883|  5.26k|            })
  884|  5.26k|        }
  885|  5.26k|
  886|  5.26k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  5.26k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  5.26k|            if d.is_empty() {
  889|  5.26k|                return None;
  890|  5.26k|            }
  891|  5.26k|            let mut default = Vec::new();
  892|  5.26k|            let mut named = Vec::new();
  893|  5.26k|            for (d, n) in d {
  894|  5.26k|                if let Some(d) = d {
  895|  5.26k|                    default.push(d);
  896|  5.26k|                }
  897|  5.26k|                if let Some(n) = n {
  898|  5.26k|                    named.push(n);
  899|  5.26k|                }
  900|  5.26k|            }
  901|  5.26k|            Some(QueryDataset {
  902|  5.26k|                default, named: Some(named)
  903|  5.26k|            })
  904|  5.26k|        }
  905|  5.26k|
  906|  5.26k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  5.26k|            (Some(s), None)
  908|  5.26k|        }
  909|  5.26k|
  910|  5.26k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  5.26k|            (None, Some(s))
  912|  5.26k|        }
  913|  5.26k|
  914|  5.26k|        rule SourceSelector() -> NamedNode = iri()
  915|  5.26k|
  916|  5.26k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  5.26k|            p
  918|  5.26k|        }
  919|  5.26k|
  920|  5.26k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  5.26k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  5.26k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  5.26k|                if let Expression::Variable(v) = e {
  924|  5.26k|                    v
  925|  5.26k|                } else {
  926|  5.26k|                    let v = vo.unwrap_or_else(variable);
  927|  5.26k|                    projections.push((e, v.clone()));
  928|  5.26k|                    v
  929|  5.26k|                }
  930|  5.26k|            }).collect();
  931|  5.26k|            (clauses, projections)
  932|  5.26k|        }
  933|  5.26k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  5.26k|
  935|  5.26k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  5.26k|            e:BuiltInCall() { (e, None) } /
  937|  5.26k|            e:FunctionCall() { (e, None) } /
  938|  5.26k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  5.26k|            e:Var() { (e.into(), None) }
  940|  5.26k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  5.26k|
  942|  5.26k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  5.26k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  5.26k|        }
  945|  5.26k|
  946|  5.26k|        rule HavingCondition() -> Expression = Constraint()
  947|  5.26k|
  948|  5.26k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  5.26k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  5.26k|
  951|  5.26k|        rule OrderCondition() -> OrderExpression =
  952|  5.26k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  5.26k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  5.26k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  5.26k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  5.26k|
  957|  5.26k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  5.26k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  5.26k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  5.26k|
  961|  5.26k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  5.26k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  5.26k|        }
  964|  5.26k|
  965|  5.26k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  5.26k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  5.26k|        }
  968|  5.26k|
  969|  5.26k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  5.26k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  5.26k|            { None }
  972|  5.26k|
  973|  5.26k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  5.26k|
  975|  5.26k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  5.26k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  5.26k|
  978|  5.26k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  5.26k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  5.26k|        }
  981|  5.26k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  5.26k|
  983|  5.26k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  5.26k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  5.26k|        }
  986|  5.26k|
  987|  5.26k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  5.26k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  5.26k|        }
  990|  5.26k|
  991|  5.26k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  5.26k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  5.26k|        }
  994|  5.26k|
  995|  5.26k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  5.26k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  5.26k|            if from == to {
  998|  5.26k|                Vec::new() // identity case
  999|  5.26k|            } else {
 1000|  5.26k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  5.26k|                vec![copy_graph(from, to)]
 1002|  5.26k|            }
 1003|  5.26k|        }
 1004|  5.26k|
 1005|  5.26k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  5.26k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  5.26k|            if from == to {
 1008|  5.26k|                Vec::new() // identity case
 1009|  5.26k|            } else {
 1010|  5.26k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  5.26k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  5.26k|            }
 1013|  5.26k|        }
 1014|  5.26k|
 1015|  5.26k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  5.26k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  5.26k|            if from == to {
 1018|  5.26k|                Vec::new() // identity case
 1019|  5.26k|            } else {
 1020|  5.26k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  5.26k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  5.26k|            }
 1023|  5.26k|        }
 1024|  5.26k|
 1025|  5.26k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  5.26k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  5.26k|        }
 1028|  5.26k|
 1029|  5.26k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  5.26k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  5.26k|        }
 1032|  5.26k|
 1033|  5.26k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  5.26k|            let pattern = d.iter().map(|q| {
 1035|  5.26k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  5.26k|                match &q.graph_name {
 1037|  5.26k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  5.26k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  5.26k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  5.26k|                }
 1041|  5.26k|            }).reduce(new_join).unwrap_or_default();
 1042|  5.26k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  5.26k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  5.26k|                delete,
 1045|  5.26k|                insert: Vec::new(),
 1046|  5.26k|                using: None,
 1047|  5.26k|                pattern: Box::new(pattern)
 1048|  5.26k|            }])
 1049|  5.26k|        }
 1050|  5.26k|
 1051|  5.26k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  5.26k|            let (delete, insert) = c;
 1053|  5.26k|            let mut delete = delete.unwrap_or_default();
 1054|  5.26k|            let mut insert = insert.unwrap_or_default();
 1055|  5.26k|            #[allow(clippy::shadow_same)]
 1056|  5.26k|            let mut pattern = pattern;
 1057|  5.26k|
 1058|  5.26k|            let mut using = if u.is_empty() {
 1059|  5.26k|                None
 1060|  5.26k|            } else {
 1061|  5.26k|                let mut default = Vec::new();
 1062|  5.26k|                let mut named = Vec::new();
 1063|  5.26k|                for (d, n) in u {
 1064|  5.26k|                    if let Some(d) = d {
 1065|  5.26k|                        default.push(d)
 1066|  5.26k|                    }
 1067|  5.26k|                    if let Some(n) = n {
 1068|  5.26k|                        named.push(n)
 1069|  5.26k|                    }
 1070|  5.26k|                }
 1071|  5.26k|                Some(QueryDataset { default, named: Some(named) })
 1072|  5.26k|            };
 1073|  5.26k|
 1074|  5.26k|            if let Some(with) = with {
 1075|  5.26k|                // We inject WITH everywhere
 1076|  5.26k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  5.26k|                    GroundQuadPattern {
 1078|  5.26k|                        subject: q.subject,
 1079|  5.26k|                        predicate: q.predicate,
 1080|  5.26k|                        object: q.object,
 1081|  5.26k|                        graph_name: with.clone().into()
 1082|  5.26k|                    }
 1083|  5.26k|                } else {
 1084|  5.26k|                    q
 1085|  5.26k|                }).collect();
 1086|  5.26k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  5.26k|                    QuadPattern {
 1088|  5.26k|                        subject: q.subject,
 1089|  5.26k|                        predicate: q.predicate,
 1090|  5.26k|                        object: q.object,
 1091|  5.26k|                        graph_name: with.clone().into()
 1092|  5.26k|                    }
 1093|  5.26k|                } else {
 1094|  5.26k|                    q
 1095|  5.26k|                }).collect();
 1096|  5.26k|                if using.is_none() {
 1097|  5.26k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  5.26k|                }
 1099|  5.26k|            }
 1100|  5.26k|
 1101|  5.26k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  5.26k|                delete,
 1103|  5.26k|                insert,
 1104|  5.26k|                using,
 1105|  5.26k|                pattern: Box::new(pattern)
 1106|  5.26k|            }]
 1107|  5.26k|        }
 1108|  5.26k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  5.26k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  5.26k|            (Some(d), i)
 1111|  5.26k|        } / i:InsertClause() {
 1112|  5.26k|            (None, Some(i))
 1113|  5.26k|        }
 1114|  5.26k|        rule Modify_clear() = {
 1115|  5.26k|            state.used_bnodes.clear();
 1116|  5.26k|            state.currently_used_bnodes.clear();
 1117|  5.26k|        }
 1118|  5.26k|
 1119|  5.26k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  5.26k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  5.26k|        }
 1122|  5.26k|
 1123|  5.26k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  5.26k|
 1125|  5.26k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  5.26k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  5.26k|            (Some(i), None)
 1128|  5.26k|        }
 1129|  5.26k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  5.26k|            (None, Some(i))
 1131|  5.26k|        }
 1132|  5.26k|
 1133|  5.26k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  5.26k|            GraphName::DefaultGraph
 1135|  5.26k|        } / (i("GRAPH") _)? g:iri() {
 1136|  5.26k|            GraphName::NamedNode(g)
 1137|  5.26k|        }
 1138|  5.26k|
 1139|  5.26k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  5.26k|
 1141|  5.26k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  5.26k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  5.26k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  5.26k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  5.26k|
 1146|  5.26k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  5.26k|
 1148|  5.26k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  5.26k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  5.26k|        }
 1151|  5.26k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  5.26k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  5.26k|        }
 1154|  5.26k|
 1155|  5.26k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  5.26k|            q.into_iter().flatten().collect()
 1157|  5.26k|        }
 1158|  5.26k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  5.26k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  5.26k|        } //TODO: return iter?
 1161|  5.26k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  5.26k|
 1163|  5.26k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  5.26k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  5.26k|        }
 1166|  5.26k|
 1167|  5.26k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  5.26k|            ts.into_iter().flatten().collect()
 1169|  5.26k|        }
 1170|  5.26k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  5.26k|
 1172|  5.26k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  5.26k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  5.26k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  5.26k|        rule GroupGraphPattern_clear() = {
 1176|  5.26k|             // We deal with blank nodes aliases rule
 1177|  5.26k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  5.26k|            state.currently_used_bnodes.clear();
 1179|  5.26k|        }
 1180|  5.26k|
 1181|  5.26k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  5.26k|            let mut filter: Option<Expression> = None;
 1183|  5.26k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  5.26k|            for e in b.into_iter().flatten() {
 1185|  5.26k|                match e {
 1186|  5.26k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  5.26k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  5.26k|                    }
 1189|  5.26k|                    #[cfg(feature = "sep-0006")]
 1190|  5.26k|                    PartialGraphPattern::Lateral(p) => {
 1191|  5.26k|                        let mut defined_variables = HashSet::default();
 1192|  5.26k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  5.26k|                        let mut contains = false;
 1194|  5.26k|                        g.on_in_scope_variable(|v| {
 1195|  5.26k|                            if defined_variables.contains(v) {
 1196|  5.26k|                                contains = true;
 1197|  5.26k|                            }
 1198|  5.26k|                        });
 1199|  5.26k|                        if contains {
 1200|  5.26k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  5.26k|                        }
 1202|  5.26k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  5.26k|                    }
 1204|  5.26k|                    PartialGraphPattern::Minus(p) => {
 1205|  5.26k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  5.26k|                    }
 1207|  5.26k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  5.26k|                        let mut contains = false;
 1209|  5.26k|                        g.on_in_scope_variable(|v| {
 1210|  5.26k|                            if *v == variable {
 1211|  5.26k|                                contains = true;
 1212|  5.26k|                            }
 1213|  5.26k|                        });
 1214|  5.26k|                        if contains {
 1215|  5.26k|                            return Err("BIND is overriding an existing variable")
 1216|  5.26k|                        }
 1217|  5.26k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  5.26k|                    }
 1219|  5.26k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  5.26k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  5.26k|                    } else {
 1222|  5.26k|                        expr
 1223|  5.26k|                    }),
 1224|  5.26k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  5.26k|                }
 1226|  5.26k|            }
 1227|  5.26k|
 1228|  5.26k|            Ok(if let Some(expr) = filter {
 1229|  5.26k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  5.26k|            } else {
 1231|  5.26k|                g
 1232|  5.26k|            })
 1233|  5.26k|        }
 1234|  5.26k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  5.26k|            let mut result = vec![a];
 1236|  5.26k|            if let Some(v) = b {
 1237|  5.26k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  5.26k|            }
 1239|  5.26k|            result
 1240|  5.26k|        }
 1241|  5.26k|
 1242|  5.26k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  5.26k|            hs.into_iter().flatten().collect()
 1244|  5.26k|        }
 1245|  5.26k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  5.26k|
 1247|  5.26k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  5.26k|
 1249|  5.26k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  5.26k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  5.26k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  5.26k|            } else {
 1253|  5.26k|               PartialGraphPattern::Optional(p, None)
 1254|  5.26k|            }
 1255|  5.26k|        }
 1256|  5.26k|
 1257|  5.26k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  5.26k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  5.26k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  5.26k|        }
 1261|  5.26k|
 1262|  5.26k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  5.26k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  5.26k|        }
 1265|  5.26k|
 1266|  5.26k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  5.26k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  5.26k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  5.26k|
 1270|  5.26k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  5.26k|            PartialGraphPattern::Bind(e, v)
 1272|  5.26k|        }
 1273|  5.26k|
 1274|  5.26k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  5.26k|
 1276|  5.26k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  5.26k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  5.26k|        }
 1279|  5.26k|
 1280|  5.26k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  5.26k|            (vec![var], d)
 1282|  5.26k|        }
 1283|  5.26k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  5.26k|
 1285|  5.26k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  5.26k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  5.26k|                Ok((vars, vals))
 1288|  5.26k|            } else {
 1289|  5.26k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  5.26k|            }
 1291|  5.26k|        }
 1292|  5.26k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  5.26k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  5.26k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  5.26k|
 1296|  5.26k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  5.26k|            t:QuotedTripleData() {?
 1298|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  5.26k|            } /
 1301|  5.26k|            i:iri() { Some(i.into()) } /
 1302|  5.26k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  5.26k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  5.26k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  5.26k|            i("UNDEF") { None }
 1306|  5.26k|
 1307|  5.26k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  5.26k|            PartialGraphPattern::Minus(p)
 1309|  5.26k|        }
 1310|  5.26k|
 1311|  5.26k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  5.26k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  5.26k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  5.26k|            }).map(PartialGraphPattern::Other)
 1315|  5.26k|        }
 1316|  5.26k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  5.26k|
 1318|  5.26k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  5.26k|            PartialGraphPattern::Filter(c)
 1320|  5.26k|        }
 1321|  5.26k|
 1322|  5.26k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  5.26k|
 1324|  5.26k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  5.26k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  5.26k|        }
 1327|  5.26k|
 1328|  5.26k|        rule ArgList() -> Vec<Expression> =
 1329|  5.26k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  5.26k|            NIL() { Vec::new() }
 1331|  5.26k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  5.26k|
 1333|  5.26k|        rule ExpressionList() -> Vec<Expression> =
 1334|  5.26k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  5.26k|            NIL() { Vec::new() }
 1336|  5.26k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  5.26k|
 1338|  5.26k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  5.26k|
 1340|  5.26k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  5.26k|            p.into_iter().flatten().collect()
 1342|  5.26k|        }
 1343|  5.26k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  5.26k|
 1345|  5.26k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  5.26k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  5.26k|                let mut patterns = po.patterns;
 1348|  5.26k|                for (p, os) in po.focus {
 1349|  5.26k|                    for o in os {
 1350|  5.26k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  5.26k|                    }
 1352|  5.26k|                }
 1353|  5.26k|                Ok(patterns)
 1354|  5.26k|            } /
 1355|  5.26k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  5.26k|                let mut patterns = s.patterns;
 1357|  5.26k|                patterns.extend(po.patterns);
 1358|  5.26k|                for (p, os) in po.focus {
 1359|  5.26k|                    for o in os {
 1360|  5.26k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  5.26k|                    }
 1362|  5.26k|                }
 1363|  5.26k|                Ok(patterns)
 1364|  5.26k|            }
 1365|  5.26k|
 1366|  5.26k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  5.26k|            PropertyListNotEmpty() /
 1368|  5.26k|            { FocusedTriplePattern::default() }
 1369|  5.26k|
 1370|  5.26k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  5.26k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  5.26k|                a.focus.push(b.focus);
 1373|  5.26k|                a.patterns.extend(b.patterns);
 1374|  5.26k|                a
 1375|  5.26k|            })
 1376|  5.26k|        }
 1377|  5.26k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  5.26k|            FocusedTriplePattern {
 1379|  5.26k|                focus: (p, o.focus),
 1380|  5.26k|                patterns: o.patterns
 1381|  5.26k|            }
 1382|  5.26k|        }
 1383|  5.26k|
 1384|  5.26k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  5.26k|
 1386|  5.26k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  5.26k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  5.26k|                a.focus.push(b.focus);
 1389|  5.26k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  5.26k|                a
 1391|  5.26k|            })
 1392|  5.26k|        }
 1393|  5.26k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  5.26k|
 1395|  5.26k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  5.26k|            if let Some(a) = a {
 1397|  5.26k|                let mut patterns = g.patterns;
 1398|  5.26k|                patterns.extend(a.patterns);
 1399|  5.26k|                FocusedTriplePattern {
 1400|  5.26k|                    focus: AnnotatedTerm {
 1401|  5.26k|                        term: g.focus,
 1402|  5.26k|                        annotations: a.focus
 1403|  5.26k|                    },
 1404|  5.26k|                    patterns
 1405|  5.26k|                }
 1406|  5.26k|            } else {
 1407|  5.26k|                FocusedTriplePattern {
 1408|  5.26k|                    focus: AnnotatedTerm {
 1409|  5.26k|                        term: g.focus,
 1410|  5.26k|                        annotations: Vec::new()
 1411|  5.26k|                    },
 1412|  5.26k|                    patterns: g.patterns
 1413|  5.26k|                }
 1414|  5.26k|            }
 1415|  5.26k|        }
 1416|  5.26k|
 1417|  5.26k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  5.26k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  5.26k|                let mut patterns = po.patterns;
 1420|  5.26k|                for (p, os) in po.focus {
 1421|  5.26k|                    for o in os {
 1422|  5.26k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  5.26k|                    }
 1424|  5.26k|                }
 1425|  5.26k|                Ok(patterns)
 1426|  5.26k|            } /
 1427|  5.26k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  5.26k|                let mut patterns = s.patterns;
 1429|  5.26k|                patterns.extend(po.patterns);
 1430|  5.26k|                for (p, os) in po.focus {
 1431|  5.26k|                    for o in os {
 1432|  5.26k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  5.26k|                    }
 1434|  5.26k|                }
 1435|  5.26k|                Ok(patterns)
 1436|  5.26k|            }
 1437|  5.26k|
 1438|  5.26k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  5.26k|            PropertyListPathNotEmpty() /
 1440|  5.26k|            { FocusedTripleOrPathPattern::default() }
 1441|  5.26k|
 1442|  5.26k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  5.26k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  5.26k|                    focus: vec![(hp, ho.focus)],
 1445|  5.26k|                    patterns: ho.patterns
 1446|  5.26k|                }, |mut a, b| {
 1447|  5.26k|                    a.focus.push(b.focus);
 1448|  5.26k|                    a.patterns.extend(b.patterns);
 1449|  5.26k|                    a
 1450|  5.26k|                })
 1451|  5.26k|        }
 1452|  5.26k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  5.26k|            c
 1454|  5.26k|        }
 1455|  5.26k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  5.26k|            FocusedTripleOrPathPattern {
 1457|  5.26k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  5.26k|                patterns: o.patterns
 1459|  5.26k|            }
 1460|  5.26k|        }
 1461|  5.26k|
 1462|  5.26k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  5.26k|            p.into()
 1464|  5.26k|        }
 1465|  5.26k|
 1466|  5.26k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  5.26k|            v.into()
 1468|  5.26k|        }
 1469|  5.26k|
 1470|  5.26k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  5.26k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  5.26k|                a.focus.push(b.focus);
 1473|  5.26k|                a.patterns.extend(b.patterns);
 1474|  5.26k|                a
 1475|  5.26k|            })
 1476|  5.26k|        }
 1477|  5.26k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  5.26k|
 1479|  5.26k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  5.26k|             if let Some(a) = a {
 1481|  5.26k|                let mut patterns = g.patterns;
 1482|  5.26k|                patterns.extend(a.patterns);
 1483|  5.26k|                FocusedTripleOrPathPattern {
 1484|  5.26k|                    focus: AnnotatedTermPath {
 1485|  5.26k|                        term: g.focus,
 1486|  5.26k|                        annotations: a.focus
 1487|  5.26k|                    },
 1488|  5.26k|                    patterns
 1489|  5.26k|                }
 1490|  5.26k|            } else {
 1491|  5.26k|                FocusedTripleOrPathPattern {
 1492|  5.26k|                    focus: AnnotatedTermPath {
 1493|  5.26k|                        term: g.focus,
 1494|  5.26k|                        annotations: Vec::new()
 1495|  5.26k|                    },
 1496|  5.26k|                    patterns: g.patterns
 1497|  5.26k|                }
 1498|  5.26k|            }
 1499|  5.26k|        }
 1500|  5.26k|
 1501|  5.26k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  5.26k|
 1503|  5.26k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  5.26k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  5.26k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  5.26k|            })
 1507|  5.26k|        }
 1508|  5.26k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  5.26k|
 1510|  5.26k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  5.26k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  5.26k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  5.26k|            })
 1514|  5.26k|        }
 1515|  5.26k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  5.26k|
 1517|  5.26k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  5.26k|            match o {
 1519|  5.26k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  5.26k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  5.26k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  5.26k|                Some(_) => unreachable!(),
 1523|  5.26k|                None => p
 1524|  5.26k|            }
 1525|  5.26k|        }
 1526|  5.26k|        rule PathElt_op() -> char =
 1527|  5.26k|            "*" { '*' } /
 1528|  5.26k|            "+" { '+' } /
 1529|  5.26k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  5.26k|
 1531|  5.26k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  5.26k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  5.26k|            PathElt()
 1534|  5.26k|
 1535|  5.26k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  5.26k|            v:iri() { v.into() } /
 1537|  5.26k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  5.26k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  5.26k|            "(" _ p:Path() _ ")" { p }
 1540|  5.26k|
 1541|  5.26k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  5.26k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  5.26k|                let mut direct = Vec::new();
 1544|  5.26k|                let mut inverse = Vec::new();
 1545|  5.26k|                for e in p {
 1546|  5.26k|                    match e {
 1547|  5.26k|                        Either::Left(a) => direct.push(a),
 1548|  5.26k|                        Either::Right(b) => inverse.push(b)
 1549|  5.26k|                    }
 1550|  5.26k|                }
 1551|  5.26k|                if inverse.is_empty() {
 1552|  5.26k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  5.26k|                } else if direct.is_empty() {
 1554|  5.26k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  5.26k|                } else {
 1556|  5.26k|                    PropertyPathExpression::Alternative(
 1557|  5.26k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  5.26k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  5.26k|                    )
 1560|  5.26k|                }
 1561|  5.26k|            } /
 1562|  5.26k|            p:PathOneInPropertySet() {
 1563|  5.26k|                match p {
 1564|  5.26k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  5.26k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  5.26k|                }
 1567|  5.26k|            }
 1568|  5.26k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  5.26k|
 1570|  5.26k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  5.26k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  5.26k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  5.26k|            v:iri() { Either::Left(v) } /
 1574|  5.26k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  5.26k|
 1576|  5.26k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  5.26k|
 1578|  5.26k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  5.26k|            let mut patterns = po.patterns;
 1580|  5.26k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  5.26k|            for (p, os) in po.focus {
 1582|  5.26k|                for o in os {
 1583|  5.26k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  5.26k|                }
 1585|  5.26k|            }
 1586|  5.26k|            Ok(FocusedTriplePattern {
 1587|  5.26k|                focus: bnode,
 1588|  5.26k|                patterns
 1589|  5.26k|            })
 1590|  5.26k|        }
 1591|  5.26k|
 1592|  5.26k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  5.26k|
 1594|  5.26k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  5.26k|            let mut patterns = po.patterns;
 1596|  5.26k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  5.26k|            for (p, os) in po.focus {
 1598|  5.26k|                for o in os {
 1599|  5.26k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  5.26k|                }
 1601|  5.26k|            }
 1602|  5.26k|            Ok(FocusedTripleOrPathPattern {
 1603|  5.26k|                focus: bnode,
 1604|  5.26k|                patterns
 1605|  5.26k|            })
 1606|  5.26k|        }
 1607|  5.26k|
 1608|  5.26k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  5.26k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  5.26k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  5.26k|            for objWithPatterns in o.into_iter().rev() {
 1612|  5.26k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  5.26k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  5.26k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  5.26k|                current_list_node = new_blank_node;
 1616|  5.26k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  5.26k|            }
 1618|  5.26k|            FocusedTriplePattern {
 1619|  5.26k|                focus: current_list_node,
 1620|  5.26k|                patterns
 1621|  5.26k|            }
 1622|  5.26k|        }
 1623|  5.26k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  5.26k|
 1625|  5.26k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  5.26k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  5.26k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  5.26k|            for objWithPatterns in o.into_iter().rev() {
 1629|  5.26k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  5.26k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  5.26k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  5.26k|                current_list_node = new_blank_node;
 1633|  5.26k|                patterns.extend(objWithPatterns.patterns);
 1634|  5.26k|            }
 1635|  5.26k|            FocusedTripleOrPathPattern {
 1636|  5.26k|                focus: current_list_node,
 1637|  5.26k|                patterns
 1638|  5.26k|            }
 1639|  5.26k|        }
 1640|  5.26k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  5.26k|
 1642|  5.26k|
 1643|  5.26k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  5.26k|
 1645|  5.26k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  5.26k|
 1647|  5.26k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  5.26k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  5.26k|            TriplesNode()
 1650|  5.26k|
 1651|  5.26k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  5.26k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  5.26k|            TriplesNodePath()
 1654|  5.26k|
 1655|  5.26k|        rule VarOrTerm() -> TermPattern =
 1656|  5.26k|            v:Var() { v.into() } /
 1657|  5.26k|            t:QuotedTriple() {?
 1658|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  5.26k|            } /
 1661|  5.26k|            t:GraphTerm() { t.into() }
 1662|  5.26k|
 1663|  5.26k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  5.26k|            Ok(TriplePattern {
 1665|  5.26k|                subject: s,
 1666|  5.26k|                predicate: p,
 1667|  5.26k|                object: o
 1668|  5.26k|            })
 1669|  5.26k|        }
 1670|  5.26k|
 1671|  5.26k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  5.26k|            Ok(GroundTriple {
 1673|  5.26k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  5.26k|                predicate: p,
 1675|  5.26k|                object: o
 1676|  5.26k|            })
 1677|  5.26k|        }
 1678|  5.26k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  5.26k|
 1680|  5.26k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  5.26k|            l:RDFLiteral() { l.into() } /
 1682|  5.26k|            l:NumericLiteral() { l.into() } /
 1683|  5.26k|            l:BooleanLiteral() { l.into() } /
 1684|  5.26k|            t:QuotedTripleData() {?
 1685|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  5.26k|            }
 1688|  5.26k|
 1689|  5.26k|        rule VarOrIri() -> NamedNodePattern =
 1690|  5.26k|            v:Var() { v.into() } /
 1691|  5.26k|            i:iri() { i.into() }
 1692|  5.26k|
 1693|  5.26k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  5.26k|
 1695|  5.26k|        rule GraphTerm() -> Term =
 1696|  5.26k|            i:iri() { i.into() } /
 1697|  5.26k|            l:RDFLiteral() { l.into() } /
 1698|  5.26k|            l:NumericLiteral() { l.into() } /
 1699|  5.26k|            l:BooleanLiteral() { l.into() } /
 1700|  5.26k|            b:BlankNode() { b.into() } /
 1701|  5.26k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  5.26k|
 1703|  5.26k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  5.26k|
 1705|  5.26k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  5.26k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  5.26k|        }
 1708|  5.26k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  5.26k|
 1710|  5.26k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  5.26k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  5.26k|        }
 1713|  5.26k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  5.26k|
 1715|  5.26k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  5.26k|
 1717|  5.26k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  5.26k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  5.26k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  5.26k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  5.26k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  5.26k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  5.26k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  5.26k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  5.26k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  5.26k|            Some(_) => unreachable!(),
 1727|  5.26k|            None => a
 1728|  5.26k|        } }
 1729|  5.26k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  5.26k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  5.26k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  5.26k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  5.26k|
 1734|  5.26k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  5.26k|
 1736|  5.26k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  5.26k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  5.26k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  5.26k|            Some(_) => unreachable!(),
 1740|  5.26k|            None => a,
 1741|  5.26k|        } }
 1742|  5.26k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  5.26k|            (s, e)
 1744|  5.26k|        }
 1745|  5.26k|
 1746|  5.26k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  5.26k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  5.26k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  5.26k|            Some(_) => unreachable!(),
 1750|  5.26k|            None => a
 1751|  5.26k|        } }
 1752|  5.26k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  5.26k|            (s, e)
 1754|  5.26k|        }
 1755|  5.26k|
 1756|  5.26k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  5.26k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  5.26k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  5.26k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  5.26k|            Some(_) => unreachable!(),
 1761|  5.26k|            None => e,
 1762|  5.26k|        } }
 1763|  5.26k|
 1764|  5.26k|        rule PrimaryExpression() -> Expression =
 1765|  5.26k|            BrackettedExpression()  /
 1766|  5.26k|            ExprQuotedTriple() /
 1767|  5.26k|            iriOrFunction() /
 1768|  5.26k|            v:Var() { v.into() } /
 1769|  5.26k|            l:RDFLiteral() { l.into() } /
 1770|  5.26k|            l:NumericLiteral() { l.into() } /
 1771|  5.26k|            l:BooleanLiteral() { l.into() } /
 1772|  5.26k|            BuiltInCall()
 1773|  5.26k|
 1774|  5.26k|        rule ExprVarOrTerm() -> Expression =
 1775|  5.26k|            ExprQuotedTriple() /
 1776|  5.26k|            i:iri() { i.into() } /
 1777|  5.26k|            l:RDFLiteral() { l.into() } /
 1778|  5.26k|            l:NumericLiteral() { l.into() } /
 1779|  5.26k|            l:BooleanLiteral() { l.into() } /
 1780|  5.26k|            v:Var() { v.into() }
 1781|  5.26k|
 1782|  5.26k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  5.26k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  5.26k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  5.26k|        }
 1786|  5.26k|
 1787|  5.26k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  5.26k|
 1789|  5.26k|        rule BuiltInCall() -> Expression =
 1790|  5.26k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  5.26k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  5.26k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  5.26k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  5.26k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  5.26k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  5.26k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  5.26k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  5.26k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  5.26k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  5.26k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  5.26k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  5.26k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  5.26k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  5.26k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  5.26k|            SubstringExpression() /
 1806|  5.26k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  5.26k|            StrReplaceExpression() /
 1808|  5.26k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  5.26k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  5.26k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  5.26k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  5.26k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  5.26k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  5.26k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  5.26k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  5.26k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  5.26k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  5.26k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  5.26k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  5.26k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  5.26k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  5.26k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  5.26k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  5.26k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  5.26k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  5.26k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  5.26k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  5.26k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  5.26k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  5.26k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  5.26k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  5.26k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  5.26k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  5.26k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  5.26k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  5.26k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  5.26k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  5.26k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  5.26k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  5.26k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  5.26k|            RegexExpression() /
 1842|  5.26k|            ExistsFunc() /
 1843|  5.26k|            NotExistsFunc() /
 1844|  5.26k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  5.26k|            } /
 1848|  5.26k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  5.26k|            } /
 1852|  5.26k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  5.26k|            } /
 1856|  5.26k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  5.26k|            } /
 1860|  5.26k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  5.26k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  5.26k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  5.26k|            } /
 1864|  5.26k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  5.26k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  5.26k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  5.26k|            }
 1868|  5.26k|
 1869|  5.26k|        rule RegexExpression() -> Expression =
 1870|  5.26k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  5.26k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  5.26k|
 1873|  5.26k|
 1874|  5.26k|        rule SubstringExpression() -> Expression =
 1875|  5.26k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  5.26k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  5.26k|
 1878|  5.26k|
 1879|  5.26k|        rule StrReplaceExpression() -> Expression =
 1880|  5.26k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  5.26k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  5.26k|
 1883|  5.26k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  5.26k|
 1885|  5.26k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  5.26k|
 1887|  5.26k|        rule Aggregate() -> AggregateExpression =
 1888|  5.26k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  5.26k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  5.26k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  5.26k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  5.26k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  5.26k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  5.26k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  5.26k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  5.26k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  5.26k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  5.26k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  5.26k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  5.26k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  5.26k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  5.26k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  5.26k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  5.26k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  5.26k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  5.26k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  5.26k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  5.26k|
 1909|  5.26k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  5.26k|            match a {
 1911|  5.26k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  5.26k|                None => i.into()
 1913|  5.26k|            }
 1914|  5.26k|        }
 1915|  5.26k|
 1916|  5.26k|        rule RDFLiteral() -> Literal =
 1917|  5.26k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  5.26k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  5.26k|            value:String() { Literal::new_simple_literal(value) }
 1920|  5.26k|
 1921|  5.26k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  5.26k|
 1923|  5.26k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  5.26k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  5.26k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  5.26k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  5.26k|
 1928|  5.26k|        rule NumericLiteralPositive() -> Literal =
 1929|  5.26k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  5.26k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  5.26k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  5.26k|
 1933|  5.26k|
 1934|  5.26k|        rule NumericLiteralNegative() -> Literal =
 1935|  5.26k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  5.26k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  5.26k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  5.26k|
 1939|  5.26k|        rule BooleanLiteral() -> Literal =
 1940|  5.26k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  5.26k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  5.26k|
 1943|  5.26k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  5.26k|
 1945|  5.26k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  5.26k|            NamedNode::from(i)
 1947|  5.26k|        }
 1948|  5.26k|
 1949|  5.26k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  5.26k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  5.26k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  5.26k|            } else {
 1953|  5.26k|                Err("Prefix not found")
 1954|  5.26k|            } }
 1955|  5.26k|
 1956|  5.26k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  5.26k|            let node = BlankNode::new_unchecked(id);
 1958|  5.26k|            if state.used_bnodes.contains(&node) {
 1959|  5.26k|                Err("Already used blank node id")
 1960|  5.26k|            } else {
 1961|  5.26k|                state.currently_used_bnodes.insert(node.clone());
 1962|  5.26k|                Ok(node)
 1963|  5.26k|            }
 1964|  5.26k|        } / ANON() { BlankNode::default() }
 1965|  5.26k|
 1966|  5.26k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  5.26k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  5.26k|        }
 1969|  5.26k|
 1970|  5.26k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  5.26k|            ns
 1972|  5.26k|        }
 1973|  5.26k|
 1974|  5.26k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  5.26k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  5.26k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  5.26k|                iri.push_str(base);
 1978|  5.26k|                for chunk in local.split('\\') { // We remove \
 1979|  5.26k|                    iri.push_str(chunk);
 1980|  5.26k|                }
 1981|  5.26k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  5.26k|            } else {
 1983|  5.26k|                Err("Prefix not found")
 1984|  5.26k|            }
 1985|  5.26k|        }
 1986|  5.26k|
 1987|  5.26k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  5.26k|            b
 1989|  5.26k|        }
 1990|  5.26k|
 1991|  5.26k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  5.26k|
 1993|  5.26k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  5.26k|
 1995|  5.26k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  5.26k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  5.26k|        }
 1998|  5.26k|
 1999|  5.26k|        rule INTEGER() = ['0'..='9']+
 2000|  5.26k|
 2001|  5.26k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  5.26k|
 2003|  5.26k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  5.26k|
 2005|  5.26k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  5.26k|
 2007|  5.26k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  5.26k|
 2009|  5.26k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  5.26k|
 2011|  5.26k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  5.26k|
 2013|  5.26k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  5.26k|
 2015|  5.26k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  5.26k|
 2017|  5.26k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  5.26k|
 2019|  5.26k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  5.26k|             unescape_string(l)
 2021|  5.26k|        }
 2022|  5.26k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  5.26k|
 2024|  5.26k|
 2025|  5.26k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  5.26k|             unescape_string(l)
 2027|  5.26k|        }
 2028|  5.26k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  5.26k|
 2030|  5.26k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  5.26k|             unescape_string(l)
 2032|  5.26k|        }
 2033|  5.26k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  5.26k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  5.26k|
 2036|  5.26k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  5.26k|             unescape_string(l)
 2038|  5.26k|        }
 2039|  5.26k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  5.26k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  5.26k|
 2042|  5.26k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  5.26k|
 2044|  5.26k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  5.26k|
 2046|  5.26k|        rule NIL() = "(" WS()* ")"
 2047|  5.26k|
 2048|  5.26k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  5.26k|
 2050|  5.26k|        rule ANON() = "[" WS()* "]"
 2051|  5.26k|
 2052|  5.26k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  5.26k|
 2054|  5.26k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  5.26k|
 2056|  5.26k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  5.26k|
 2058|  5.26k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  5.26k|
 2060|  5.26k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  5.26k|
 2062|  5.26k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  5.26k|
 2064|  5.26k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  5.26k|
 2066|  5.26k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  5.26k|
 2068|  5.26k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  5.26k|
 2070|  5.26k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  5.26k|
 2072|  5.26k|        //space
 2073|  5.26k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  5.26k|
 2075|  5.26k|        //comment
 2076|  5.26k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  5.26k|
 2078|  5.26k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  5.26k|            if input.eq_ignore_ascii_case(literal) {
 2080|  5.26k|                Ok(())
 2081|  5.26k|            } else {
 2082|  5.26k|                Err(literal)
 2083|  5.26k|            }
 2084|  5.26k|        }
 2085|  5.26k|    }
 2086|  5.26k|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Filter0B7_:
 1318|      3|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|      3|            PartialGraphPattern::Filter(c)
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Modify00B9_:
 1076|  6.19k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|    990|                    GroundQuadPattern {
 1078|    990|                        subject: q.subject,
 1079|    990|                        predicate: q.predicate,
 1080|    990|                        object: q.object,
 1081|    990|                        graph_name: with.clone().into()
 1082|    990|                    }
 1083|       |                } else {
 1084|  5.20k|                    q
 1085|  6.19k|                }).collect();
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_PathEltOrInverse0B7_:
 1532|  23.9k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_GroupOrUnionGraphPattern0B7_:
  778|    130|parser! {
  779|    130|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|    130|    grammar parser(state: &mut ParserState) for str {
  781|    130|        pub rule QueryUnit() -> Query = Query()
  782|    130|
  783|    130|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|    130|            q
  785|    130|        }
  786|    130|
  787|    130|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|    130|
  789|    130|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|    130|
  791|    130|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|    130|            state.base_iri = Some(i)
  793|    130|        }
  794|    130|
  795|    130|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|    130|            state.namespaces.insert(ns.into(), i.into_inner());
  797|    130|        }
  798|    130|
  799|    130|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|    130|            Ok(Query::Select {
  801|    130|                dataset: d,
  802|    130|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|    130|                base_iri: state.base_iri.clone()
  804|    130|            })
  805|    130|        }
  806|    130|
  807|    130|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|    130|            build_select(s, w, g, h, o, l, v, state)
  809|    130|        }
  810|    130|
  811|    130|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|    130|            Selection {
  813|    130|                option: o,
  814|    130|                variables: v
  815|    130|            }
  816|    130|        }
  817|    130|        rule Selection_init() = {
  818|    130|            state.aggregates.push(Vec::new())
  819|    130|        }
  820|    130|        rule SelectClause_option() -> SelectionOption =
  821|    130|            i("DISTINCT") { SelectionOption::Distinct } /
  822|    130|            i("REDUCED") { SelectionOption::Reduced } /
  823|    130|            { SelectionOption::Default }
  824|    130|        rule SelectClause_variables() -> SelectionVariables =
  825|    130|            "*" { SelectionVariables::Star } /
  826|    130|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|    130|        rule SelectClause_member() -> SelectionMember =
  828|    130|            v:Var() _ { SelectionMember::Variable(v) } /
  829|    130|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|    130|
  831|    130|        rule ConstructQuery() -> Query =
  832|    130|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|    130|                Ok(Query::Construct {
  834|    130|                    template: c,
  835|    130|                    dataset: d,
  836|    130|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|    130|                    base_iri: state.base_iri.clone()
  838|    130|                })
  839|    130|            } /
  840|    130|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|    130|                Ok(Query::Construct {
  842|    130|                    template: c.clone(),
  843|    130|                    dataset: d,
  844|    130|                    pattern: build_select(
  845|    130|                        Selection::no_op(),
  846|    130|                        GraphPattern::Bgp { patterns: c },
  847|    130|                        g, h, o, l, v, state
  848|    130|                    )?,
  849|    130|                    base_iri: state.base_iri.clone()
  850|    130|                })
  851|    130|            }
  852|    130|
  853|    130|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|    130|
  855|    130|        rule DescribeQuery() -> Query =
  856|    130|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|    130|                Ok(Query::Describe {
  858|    130|                    dataset: d,
  859|    130|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|    130|                    base_iri: state.base_iri.clone()
  861|    130|                })
  862|    130|            } /
  863|    130|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|    130|                Ok(Query::Describe {
  865|    130|                    dataset: d,
  866|    130|                    pattern: build_select(Selection {
  867|    130|                        option: SelectionOption::Default,
  868|    130|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|    130|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|    130|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|    130|                        }).collect())
  872|    130|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|    130|                    base_iri: state.base_iri.clone()
  874|    130|                })
  875|    130|            }
  876|    130|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|    130|
  878|    130|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|    130|            Ok(Query::Ask {
  880|    130|                dataset: d,
  881|    130|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|    130|                base_iri: state.base_iri.clone()
  883|    130|            })
  884|    130|        }
  885|    130|
  886|    130|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|    130|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|    130|            if d.is_empty() {
  889|    130|                return None;
  890|    130|            }
  891|    130|            let mut default = Vec::new();
  892|    130|            let mut named = Vec::new();
  893|    130|            for (d, n) in d {
  894|    130|                if let Some(d) = d {
  895|    130|                    default.push(d);
  896|    130|                }
  897|    130|                if let Some(n) = n {
  898|    130|                    named.push(n);
  899|    130|                }
  900|    130|            }
  901|    130|            Some(QueryDataset {
  902|    130|                default, named: Some(named)
  903|    130|            })
  904|    130|        }
  905|    130|
  906|    130|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|    130|            (Some(s), None)
  908|    130|        }
  909|    130|
  910|    130|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|    130|            (None, Some(s))
  912|    130|        }
  913|    130|
  914|    130|        rule SourceSelector() -> NamedNode = iri()
  915|    130|
  916|    130|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|    130|            p
  918|    130|        }
  919|    130|
  920|    130|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|    130|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|    130|            let clauses = c.into_iter().map(|(e, vo)| {
  923|    130|                if let Expression::Variable(v) = e {
  924|    130|                    v
  925|    130|                } else {
  926|    130|                    let v = vo.unwrap_or_else(variable);
  927|    130|                    projections.push((e, v.clone()));
  928|    130|                    v
  929|    130|                }
  930|    130|            }).collect();
  931|    130|            (clauses, projections)
  932|    130|        }
  933|    130|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|    130|
  935|    130|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|    130|            e:BuiltInCall() { (e, None) } /
  937|    130|            e:FunctionCall() { (e, None) } /
  938|    130|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|    130|            e:Var() { (e.into(), None) }
  940|    130|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|    130|
  942|    130|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|    130|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|    130|        }
  945|    130|
  946|    130|        rule HavingCondition() -> Expression = Constraint()
  947|    130|
  948|    130|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|    130|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|    130|
  951|    130|        rule OrderCondition() -> OrderExpression =
  952|    130|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|    130|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|    130|            e: Constraint() { OrderExpression::Asc(e) } /
  955|    130|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|    130|
  957|    130|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|    130|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|    130|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|    130|
  961|    130|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|    130|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|    130|        }
  964|    130|
  965|    130|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|    130|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|    130|        }
  968|    130|
  969|    130|        rule ValuesClause() -> Option<GraphPattern> =
  970|    130|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|    130|            { None }
  972|    130|
  973|    130|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|    130|
  975|    130|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|    130|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|    130|
  978|    130|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|    130|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|    130|        }
  981|    130|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|    130|
  983|    130|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|    130|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|    130|        }
  986|    130|
  987|    130|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|    130|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|    130|        }
  990|    130|
  991|    130|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|    130|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|    130|        }
  994|    130|
  995|    130|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|    130|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|    130|            if from == to {
  998|    130|                Vec::new() // identity case
  999|    130|            } else {
 1000|    130|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|    130|                vec![copy_graph(from, to)]
 1002|    130|            }
 1003|    130|        }
 1004|    130|
 1005|    130|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|    130|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|    130|            if from == to {
 1008|    130|                Vec::new() // identity case
 1009|    130|            } else {
 1010|    130|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|    130|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|    130|            }
 1013|    130|        }
 1014|    130|
 1015|    130|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|    130|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|    130|            if from == to {
 1018|    130|                Vec::new() // identity case
 1019|    130|            } else {
 1020|    130|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|    130|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|    130|            }
 1023|    130|        }
 1024|    130|
 1025|    130|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|    130|            vec![GraphUpdateOperation::InsertData { data }]
 1027|    130|        }
 1028|    130|
 1029|    130|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|    130|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|    130|        }
 1032|    130|
 1033|    130|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|    130|            let pattern = d.iter().map(|q| {
 1035|    130|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|    130|                match &q.graph_name {
 1037|    130|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|    130|                    GraphNamePattern::DefaultGraph => bgp,
 1039|    130|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|    130|                }
 1041|    130|            }).reduce(new_join).unwrap_or_default();
 1042|    130|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|    130|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|    130|                delete,
 1045|    130|                insert: Vec::new(),
 1046|    130|                using: None,
 1047|    130|                pattern: Box::new(pattern)
 1048|    130|            }])
 1049|    130|        }
 1050|    130|
 1051|    130|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|    130|            let (delete, insert) = c;
 1053|    130|            let mut delete = delete.unwrap_or_default();
 1054|    130|            let mut insert = insert.unwrap_or_default();
 1055|    130|            #[allow(clippy::shadow_same)]
 1056|    130|            let mut pattern = pattern;
 1057|    130|
 1058|    130|            let mut using = if u.is_empty() {
 1059|    130|                None
 1060|    130|            } else {
 1061|    130|                let mut default = Vec::new();
 1062|    130|                let mut named = Vec::new();
 1063|    130|                for (d, n) in u {
 1064|    130|                    if let Some(d) = d {
 1065|    130|                        default.push(d)
 1066|    130|                    }
 1067|    130|                    if let Some(n) = n {
 1068|    130|                        named.push(n)
 1069|    130|                    }
 1070|    130|                }
 1071|    130|                Some(QueryDataset { default, named: Some(named) })
 1072|    130|            };
 1073|    130|
 1074|    130|            if let Some(with) = with {
 1075|    130|                // We inject WITH everywhere
 1076|    130|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|    130|                    GroundQuadPattern {
 1078|    130|                        subject: q.subject,
 1079|    130|                        predicate: q.predicate,
 1080|    130|                        object: q.object,
 1081|    130|                        graph_name: with.clone().into()
 1082|    130|                    }
 1083|    130|                } else {
 1084|    130|                    q
 1085|    130|                }).collect();
 1086|    130|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|    130|                    QuadPattern {
 1088|    130|                        subject: q.subject,
 1089|    130|                        predicate: q.predicate,
 1090|    130|                        object: q.object,
 1091|    130|                        graph_name: with.clone().into()
 1092|    130|                    }
 1093|    130|                } else {
 1094|    130|                    q
 1095|    130|                }).collect();
 1096|    130|                if using.is_none() {
 1097|    130|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|    130|                }
 1099|    130|            }
 1100|    130|
 1101|    130|            vec![GraphUpdateOperation::DeleteInsert {
 1102|    130|                delete,
 1103|    130|                insert,
 1104|    130|                using,
 1105|    130|                pattern: Box::new(pattern)
 1106|    130|            }]
 1107|    130|        }
 1108|    130|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|    130|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|    130|            (Some(d), i)
 1111|    130|        } / i:InsertClause() {
 1112|    130|            (None, Some(i))
 1113|    130|        }
 1114|    130|        rule Modify_clear() = {
 1115|    130|            state.used_bnodes.clear();
 1116|    130|            state.currently_used_bnodes.clear();
 1117|    130|        }
 1118|    130|
 1119|    130|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|    130|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|    130|        }
 1122|    130|
 1123|    130|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|    130|
 1125|    130|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|    130|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|    130|            (Some(i), None)
 1128|    130|        }
 1129|    130|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|    130|            (None, Some(i))
 1131|    130|        }
 1132|    130|
 1133|    130|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|    130|            GraphName::DefaultGraph
 1135|    130|        } / (i("GRAPH") _)? g:iri() {
 1136|    130|            GraphName::NamedNode(g)
 1137|    130|        }
 1138|    130|
 1139|    130|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|    130|
 1141|    130|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|    130|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|    130|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|    130|            / i("ALL") { GraphTarget::AllGraphs }
 1145|    130|
 1146|    130|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|    130|
 1148|    130|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|    130|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|    130|        }
 1151|    130|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|    130|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|    130|        }
 1154|    130|
 1155|    130|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|    130|            q.into_iter().flatten().collect()
 1157|    130|        }
 1158|    130|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|    130|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|    130|        } //TODO: return iter?
 1161|    130|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|    130|
 1163|    130|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|    130|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|    130|        }
 1166|    130|
 1167|    130|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|    130|            ts.into_iter().flatten().collect()
 1169|    130|        }
 1170|    130|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|    130|
 1172|    130|        rule GroupGraphPattern() -> GraphPattern =
 1173|    130|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|    130|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|    130|        rule GroupGraphPattern_clear() = {
 1176|    130|             // We deal with blank nodes aliases rule
 1177|    130|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|    130|            state.currently_used_bnodes.clear();
 1179|    130|        }
 1180|    130|
 1181|    130|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|    130|            let mut filter: Option<Expression> = None;
 1183|    130|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|    130|            for e in b.into_iter().flatten() {
 1185|    130|                match e {
 1186|    130|                    PartialGraphPattern::Optional(p, f) => {
 1187|    130|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|    130|                    }
 1189|    130|                    #[cfg(feature = "sep-0006")]
 1190|    130|                    PartialGraphPattern::Lateral(p) => {
 1191|    130|                        let mut defined_variables = HashSet::default();
 1192|    130|                        add_defined_variables(&p, &mut defined_variables);
 1193|    130|                        let mut contains = false;
 1194|    130|                        g.on_in_scope_variable(|v| {
 1195|    130|                            if defined_variables.contains(v) {
 1196|    130|                                contains = true;
 1197|    130|                            }
 1198|    130|                        });
 1199|    130|                        if contains {
 1200|    130|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|    130|                        }
 1202|    130|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|    130|                    }
 1204|    130|                    PartialGraphPattern::Minus(p) => {
 1205|    130|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|    130|                    }
 1207|    130|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|    130|                        let mut contains = false;
 1209|    130|                        g.on_in_scope_variable(|v| {
 1210|    130|                            if *v == variable {
 1211|    130|                                contains = true;
 1212|    130|                            }
 1213|    130|                        });
 1214|    130|                        if contains {
 1215|    130|                            return Err("BIND is overriding an existing variable")
 1216|    130|                        }
 1217|    130|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|    130|                    }
 1219|    130|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|    130|                        Expression::And(Box::new(f), Box::new(expr))
 1221|    130|                    } else {
 1222|    130|                        expr
 1223|    130|                    }),
 1224|    130|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|    130|                }
 1226|    130|            }
 1227|    130|
 1228|    130|            Ok(if let Some(expr) = filter {
 1229|    130|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|    130|            } else {
 1231|    130|                g
 1232|    130|            })
 1233|    130|        }
 1234|    130|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|    130|            let mut result = vec![a];
 1236|    130|            if let Some(v) = b {
 1237|    130|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|    130|            }
 1239|    130|            result
 1240|    130|        }
 1241|    130|
 1242|    130|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|    130|            hs.into_iter().flatten().collect()
 1244|    130|        }
 1245|    130|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|    130|
 1247|    130|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|    130|
 1249|    130|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|    130|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|    130|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|    130|            } else {
 1253|    130|               PartialGraphPattern::Optional(p, None)
 1254|    130|            }
 1255|    130|        }
 1256|    130|
 1257|    130|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|    130|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|    130|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|    130|        }
 1261|    130|
 1262|    130|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|    130|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|    130|        }
 1265|    130|
 1266|    130|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|    130|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|    130|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|    130|
 1270|    130|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|    130|            PartialGraphPattern::Bind(e, v)
 1272|    130|        }
 1273|    130|
 1274|    130|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|    130|
 1276|    130|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|    130|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|    130|        }
 1279|    130|
 1280|    130|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|    130|            (vec![var], d)
 1282|    130|        }
 1283|    130|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|    130|
 1285|    130|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|    130|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|    130|                Ok((vars, vals))
 1288|    130|            } else {
 1289|    130|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|    130|            }
 1291|    130|        }
 1292|    130|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|    130|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|    130|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|    130|
 1296|    130|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|    130|            t:QuotedTripleData() {?
 1298|    130|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|    130|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|    130|            } /
 1301|    130|            i:iri() { Some(i.into()) } /
 1302|    130|            l:RDFLiteral() { Some(l.into()) } /
 1303|    130|            l:NumericLiteral() { Some(l.into()) } /
 1304|    130|            l:BooleanLiteral() { Some(l.into()) } /
 1305|    130|            i("UNDEF") { None }
 1306|    130|
 1307|    130|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|    130|            PartialGraphPattern::Minus(p)
 1309|    130|        }
 1310|    130|
 1311|    130|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|    130|            not_empty_fold(p.into_iter(), |a, b| {
 1313|       |                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|    130|            }).map(PartialGraphPattern::Other)
 1315|    130|        }
 1316|    130|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|    130|
 1318|    130|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|    130|            PartialGraphPattern::Filter(c)
 1320|    130|        }
 1321|    130|
 1322|    130|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|    130|
 1324|    130|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|    130|            Expression::FunctionCall(Function::Custom(f), a)
 1326|    130|        }
 1327|    130|
 1328|    130|        rule ArgList() -> Vec<Expression> =
 1329|    130|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|    130|            NIL() { Vec::new() }
 1331|    130|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|    130|
 1333|    130|        rule ExpressionList() -> Vec<Expression> =
 1334|    130|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|    130|            NIL() { Vec::new() }
 1336|    130|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|    130|
 1338|    130|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|    130|
 1340|    130|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|    130|            p.into_iter().flatten().collect()
 1342|    130|        }
 1343|    130|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|    130|
 1345|    130|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|    130|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|    130|                let mut patterns = po.patterns;
 1348|    130|                for (p, os) in po.focus {
 1349|    130|                    for o in os {
 1350|    130|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|    130|                    }
 1352|    130|                }
 1353|    130|                Ok(patterns)
 1354|    130|            } /
 1355|    130|            s:TriplesNode() _ po:PropertyList() {?
 1356|    130|                let mut patterns = s.patterns;
 1357|    130|                patterns.extend(po.patterns);
 1358|    130|                for (p, os) in po.focus {
 1359|    130|                    for o in os {
 1360|    130|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|    130|                    }
 1362|    130|                }
 1363|    130|                Ok(patterns)
 1364|    130|            }
 1365|    130|
 1366|    130|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|    130|            PropertyListNotEmpty() /
 1368|    130|            { FocusedTriplePattern::default() }
 1369|    130|
 1370|    130|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|    130|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|    130|                a.focus.push(b.focus);
 1373|    130|                a.patterns.extend(b.patterns);
 1374|    130|                a
 1375|    130|            })
 1376|    130|        }
 1377|    130|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|    130|            FocusedTriplePattern {
 1379|    130|                focus: (p, o.focus),
 1380|    130|                patterns: o.patterns
 1381|    130|            }
 1382|    130|        }
 1383|    130|
 1384|    130|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|    130|
 1386|    130|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|    130|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|    130|                a.focus.push(b.focus);
 1389|    130|                a.patterns.extend_from_slice(&b.patterns);
 1390|    130|                a
 1391|    130|            })
 1392|    130|        }
 1393|    130|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|    130|
 1395|    130|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|    130|            if let Some(a) = a {
 1397|    130|                let mut patterns = g.patterns;
 1398|    130|                patterns.extend(a.patterns);
 1399|    130|                FocusedTriplePattern {
 1400|    130|                    focus: AnnotatedTerm {
 1401|    130|                        term: g.focus,
 1402|    130|                        annotations: a.focus
 1403|    130|                    },
 1404|    130|                    patterns
 1405|    130|                }
 1406|    130|            } else {
 1407|    130|                FocusedTriplePattern {
 1408|    130|                    focus: AnnotatedTerm {
 1409|    130|                        term: g.focus,
 1410|    130|                        annotations: Vec::new()
 1411|    130|                    },
 1412|    130|                    patterns: g.patterns
 1413|    130|                }
 1414|    130|            }
 1415|    130|        }
 1416|    130|
 1417|    130|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|    130|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|    130|                let mut patterns = po.patterns;
 1420|    130|                for (p, os) in po.focus {
 1421|    130|                    for o in os {
 1422|    130|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|    130|                    }
 1424|    130|                }
 1425|    130|                Ok(patterns)
 1426|    130|            } /
 1427|    130|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|    130|                let mut patterns = s.patterns;
 1429|    130|                patterns.extend(po.patterns);
 1430|    130|                for (p, os) in po.focus {
 1431|    130|                    for o in os {
 1432|    130|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|    130|                    }
 1434|    130|                }
 1435|    130|                Ok(patterns)
 1436|    130|            }
 1437|    130|
 1438|    130|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|    130|            PropertyListPathNotEmpty() /
 1440|    130|            { FocusedTripleOrPathPattern::default() }
 1441|    130|
 1442|    130|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|    130|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|    130|                    focus: vec![(hp, ho.focus)],
 1445|    130|                    patterns: ho.patterns
 1446|    130|                }, |mut a, b| {
 1447|    130|                    a.focus.push(b.focus);
 1448|    130|                    a.patterns.extend(b.patterns);
 1449|    130|                    a
 1450|    130|                })
 1451|    130|        }
 1452|    130|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|    130|            c
 1454|    130|        }
 1455|    130|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|    130|            FocusedTripleOrPathPattern {
 1457|    130|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|    130|                patterns: o.patterns
 1459|    130|            }
 1460|    130|        }
 1461|    130|
 1462|    130|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|    130|            p.into()
 1464|    130|        }
 1465|    130|
 1466|    130|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|    130|            v.into()
 1468|    130|        }
 1469|    130|
 1470|    130|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|    130|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|    130|                a.focus.push(b.focus);
 1473|    130|                a.patterns.extend(b.patterns);
 1474|    130|                a
 1475|    130|            })
 1476|    130|        }
 1477|    130|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|    130|
 1479|    130|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|    130|             if let Some(a) = a {
 1481|    130|                let mut patterns = g.patterns;
 1482|    130|                patterns.extend(a.patterns);
 1483|    130|                FocusedTripleOrPathPattern {
 1484|    130|                    focus: AnnotatedTermPath {
 1485|    130|                        term: g.focus,
 1486|    130|                        annotations: a.focus
 1487|    130|                    },
 1488|    130|                    patterns
 1489|    130|                }
 1490|    130|            } else {
 1491|    130|                FocusedTripleOrPathPattern {
 1492|    130|                    focus: AnnotatedTermPath {
 1493|    130|                        term: g.focus,
 1494|    130|                        annotations: Vec::new()
 1495|    130|                    },
 1496|    130|                    patterns: g.patterns
 1497|    130|                }
 1498|    130|            }
 1499|    130|        }
 1500|    130|
 1501|    130|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|    130|
 1503|    130|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|    130|            not_empty_fold(p.into_iter(), |a, b| {
 1505|    130|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|    130|            })
 1507|    130|        }
 1508|    130|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|    130|
 1510|    130|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|    130|            not_empty_fold(p.into_iter(), |a, b| {
 1512|    130|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|    130|            })
 1514|    130|        }
 1515|    130|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|    130|
 1517|    130|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|    130|            match o {
 1519|    130|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|    130|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|    130|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|    130|                Some(_) => unreachable!(),
 1523|    130|                None => p
 1524|    130|            }
 1525|    130|        }
 1526|    130|        rule PathElt_op() -> char =
 1527|    130|            "*" { '*' } /
 1528|    130|            "+" { '+' } /
 1529|    130|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|    130|
 1531|    130|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|    130|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|    130|            PathElt()
 1534|    130|
 1535|    130|        rule PathPrimary() -> PropertyPathExpression =
 1536|    130|            v:iri() { v.into() } /
 1537|    130|            "a" { rdf::TYPE.into_owned().into() } /
 1538|    130|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|    130|            "(" _ p:Path() _ ")" { p }
 1540|    130|
 1541|    130|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|    130|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|    130|                let mut direct = Vec::new();
 1544|    130|                let mut inverse = Vec::new();
 1545|    130|                for e in p {
 1546|    130|                    match e {
 1547|    130|                        Either::Left(a) => direct.push(a),
 1548|    130|                        Either::Right(b) => inverse.push(b)
 1549|    130|                    }
 1550|    130|                }
 1551|    130|                if inverse.is_empty() {
 1552|    130|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|    130|                } else if direct.is_empty() {
 1554|    130|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|    130|                } else {
 1556|    130|                    PropertyPathExpression::Alternative(
 1557|    130|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|    130|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|    130|                    )
 1560|    130|                }
 1561|    130|            } /
 1562|    130|            p:PathOneInPropertySet() {
 1563|    130|                match p {
 1564|    130|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|    130|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|    130|                }
 1567|    130|            }
 1568|    130|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|    130|
 1570|    130|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|    130|            "^" _ v:iri() { Either::Right(v) } /
 1572|    130|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|    130|            v:iri() { Either::Left(v) } /
 1574|    130|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|    130|
 1576|    130|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|    130|
 1578|    130|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|    130|            let mut patterns = po.patterns;
 1580|    130|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|    130|            for (p, os) in po.focus {
 1582|    130|                for o in os {
 1583|    130|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|    130|                }
 1585|    130|            }
 1586|    130|            Ok(FocusedTriplePattern {
 1587|    130|                focus: bnode,
 1588|    130|                patterns
 1589|    130|            })
 1590|    130|        }
 1591|    130|
 1592|    130|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|    130|
 1594|    130|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|    130|            let mut patterns = po.patterns;
 1596|    130|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|    130|            for (p, os) in po.focus {
 1598|    130|                for o in os {
 1599|    130|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|    130|                }
 1601|    130|            }
 1602|    130|            Ok(FocusedTripleOrPathPattern {
 1603|    130|                focus: bnode,
 1604|    130|                patterns
 1605|    130|            })
 1606|    130|        }
 1607|    130|
 1608|    130|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|    130|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|    130|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|    130|            for objWithPatterns in o.into_iter().rev() {
 1612|    130|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|    130|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|    130|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|    130|                current_list_node = new_blank_node;
 1616|    130|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|    130|            }
 1618|    130|            FocusedTriplePattern {
 1619|    130|                focus: current_list_node,
 1620|    130|                patterns
 1621|    130|            }
 1622|    130|        }
 1623|    130|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|    130|
 1625|    130|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|    130|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|    130|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|    130|            for objWithPatterns in o.into_iter().rev() {
 1629|    130|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|    130|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|    130|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|    130|                current_list_node = new_blank_node;
 1633|    130|                patterns.extend(objWithPatterns.patterns);
 1634|    130|            }
 1635|    130|            FocusedTripleOrPathPattern {
 1636|    130|                focus: current_list_node,
 1637|    130|                patterns
 1638|    130|            }
 1639|    130|        }
 1640|    130|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|    130|
 1642|    130|
 1643|    130|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|    130|
 1645|    130|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|    130|
 1647|    130|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|    130|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|    130|            TriplesNode()
 1650|    130|
 1651|    130|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|    130|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|    130|            TriplesNodePath()
 1654|    130|
 1655|    130|        rule VarOrTerm() -> TermPattern =
 1656|    130|            v:Var() { v.into() } /
 1657|    130|            t:QuotedTriple() {?
 1658|    130|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|    130|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|    130|            } /
 1661|    130|            t:GraphTerm() { t.into() }
 1662|    130|
 1663|    130|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|    130|            Ok(TriplePattern {
 1665|    130|                subject: s,
 1666|    130|                predicate: p,
 1667|    130|                object: o
 1668|    130|            })
 1669|    130|        }
 1670|    130|
 1671|    130|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|    130|            Ok(GroundTriple {
 1673|    130|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|    130|                predicate: p,
 1675|    130|                object: o
 1676|    130|            })
 1677|    130|        }
 1678|    130|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|    130|
 1680|    130|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|    130|            l:RDFLiteral() { l.into() } /
 1682|    130|            l:NumericLiteral() { l.into() } /
 1683|    130|            l:BooleanLiteral() { l.into() } /
 1684|    130|            t:QuotedTripleData() {?
 1685|    130|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|    130|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|    130|            }
 1688|    130|
 1689|    130|        rule VarOrIri() -> NamedNodePattern =
 1690|    130|            v:Var() { v.into() } /
 1691|    130|            i:iri() { i.into() }
 1692|    130|
 1693|    130|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|    130|
 1695|    130|        rule GraphTerm() -> Term =
 1696|    130|            i:iri() { i.into() } /
 1697|    130|            l:RDFLiteral() { l.into() } /
 1698|    130|            l:NumericLiteral() { l.into() } /
 1699|    130|            l:BooleanLiteral() { l.into() } /
 1700|    130|            b:BlankNode() { b.into() } /
 1701|    130|            NIL() { rdf::NIL.into_owned().into() }
 1702|    130|
 1703|    130|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|    130|
 1705|    130|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|    130|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|    130|        }
 1708|    130|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|    130|
 1710|    130|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|    130|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|    130|        }
 1713|    130|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|    130|
 1715|    130|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|    130|
 1717|    130|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|    130|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|    130|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|    130|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|    130|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|    130|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|    130|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|    130|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|    130|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|    130|            Some(_) => unreachable!(),
 1727|    130|            None => a
 1728|    130|        } }
 1729|    130|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|    130|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|    130|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|    130|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|    130|
 1734|    130|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|    130|
 1736|    130|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|    130|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|    130|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|    130|            Some(_) => unreachable!(),
 1740|    130|            None => a,
 1741|    130|        } }
 1742|    130|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|    130|            (s, e)
 1744|    130|        }
 1745|    130|
 1746|    130|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|    130|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|    130|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|    130|            Some(_) => unreachable!(),
 1750|    130|            None => a
 1751|    130|        } }
 1752|    130|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|    130|            (s, e)
 1754|    130|        }
 1755|    130|
 1756|    130|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|    130|            Some("!") => Expression::Not(Box::new(e)),
 1758|    130|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|    130|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|    130|            Some(_) => unreachable!(),
 1761|    130|            None => e,
 1762|    130|        } }
 1763|    130|
 1764|    130|        rule PrimaryExpression() -> Expression =
 1765|    130|            BrackettedExpression()  /
 1766|    130|            ExprQuotedTriple() /
 1767|    130|            iriOrFunction() /
 1768|    130|            v:Var() { v.into() } /
 1769|    130|            l:RDFLiteral() { l.into() } /
 1770|    130|            l:NumericLiteral() { l.into() } /
 1771|    130|            l:BooleanLiteral() { l.into() } /
 1772|    130|            BuiltInCall()
 1773|    130|
 1774|    130|        rule ExprVarOrTerm() -> Expression =
 1775|    130|            ExprQuotedTriple() /
 1776|    130|            i:iri() { i.into() } /
 1777|    130|            l:RDFLiteral() { l.into() } /
 1778|    130|            l:NumericLiteral() { l.into() } /
 1779|    130|            l:BooleanLiteral() { l.into() } /
 1780|    130|            v:Var() { v.into() }
 1781|    130|
 1782|    130|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|    130|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|    130|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|    130|        }
 1786|    130|
 1787|    130|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|    130|
 1789|    130|        rule BuiltInCall() -> Expression =
 1790|    130|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|    130|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|    130|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|    130|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|    130|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|    130|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|    130|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|    130|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|    130|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|    130|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|    130|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|    130|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|    130|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|    130|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|    130|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|    130|            SubstringExpression() /
 1806|    130|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|    130|            StrReplaceExpression() /
 1808|    130|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|    130|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|    130|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|    130|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|    130|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|    130|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|    130|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|    130|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|    130|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|    130|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|    130|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|    130|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|    130|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|    130|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|    130|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|    130|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|    130|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|    130|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|    130|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|    130|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|    130|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|    130|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|    130|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|    130|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|    130|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|    130|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|    130|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|    130|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|    130|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|    130|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|    130|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|    130|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|    130|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|    130|            RegexExpression() /
 1842|    130|            ExistsFunc() /
 1843|    130|            NotExistsFunc() /
 1844|    130|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|    130|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|    130|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|    130|            } /
 1848|    130|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|    130|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|    130|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|    130|            } /
 1852|    130|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|    130|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|    130|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|    130|            } /
 1856|    130|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|    130|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|    130|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|    130|            } /
 1860|    130|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|    130|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|    130|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|    130|            } /
 1864|    130|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|    130|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|    130|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|    130|            }
 1868|    130|
 1869|    130|        rule RegexExpression() -> Expression =
 1870|    130|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|    130|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|    130|
 1873|    130|
 1874|    130|        rule SubstringExpression() -> Expression =
 1875|    130|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|    130|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|    130|
 1878|    130|
 1879|    130|        rule StrReplaceExpression() -> Expression =
 1880|    130|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|    130|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|    130|
 1883|    130|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|    130|
 1885|    130|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|    130|
 1887|    130|        rule Aggregate() -> AggregateExpression =
 1888|    130|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|    130|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|    130|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|    130|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|    130|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|    130|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|    130|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|    130|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|    130|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|    130|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|    130|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|    130|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|    130|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|    130|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|    130|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|    130|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|    130|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|    130|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|    130|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|    130|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|    130|
 1909|    130|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|    130|            match a {
 1911|    130|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|    130|                None => i.into()
 1913|    130|            }
 1914|    130|        }
 1915|    130|
 1916|    130|        rule RDFLiteral() -> Literal =
 1917|    130|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|    130|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|    130|            value:String() { Literal::new_simple_literal(value) }
 1920|    130|
 1921|    130|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|    130|
 1923|    130|        rule NumericLiteralUnsigned() -> Literal =
 1924|    130|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|    130|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|    130|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|    130|
 1928|    130|        rule NumericLiteralPositive() -> Literal =
 1929|    130|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|    130|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|    130|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|    130|
 1933|    130|
 1934|    130|        rule NumericLiteralNegative() -> Literal =
 1935|    130|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|    130|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|    130|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|    130|
 1939|    130|        rule BooleanLiteral() -> Literal =
 1940|    130|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|    130|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|    130|
 1943|    130|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|    130|
 1945|    130|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|    130|            NamedNode::from(i)
 1947|    130|        }
 1948|    130|
 1949|    130|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|    130|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|    130|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|    130|            } else {
 1953|    130|                Err("Prefix not found")
 1954|    130|            } }
 1955|    130|
 1956|    130|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|    130|            let node = BlankNode::new_unchecked(id);
 1958|    130|            if state.used_bnodes.contains(&node) {
 1959|    130|                Err("Already used blank node id")
 1960|    130|            } else {
 1961|    130|                state.currently_used_bnodes.insert(node.clone());
 1962|    130|                Ok(node)
 1963|    130|            }
 1964|    130|        } / ANON() { BlankNode::default() }
 1965|    130|
 1966|    130|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|    130|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|    130|        }
 1969|    130|
 1970|    130|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|    130|            ns
 1972|    130|        }
 1973|    130|
 1974|    130|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|    130|            if let Some(base) = state.namespaces.get(ns) {
 1976|    130|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|    130|                iri.push_str(base);
 1978|    130|                for chunk in local.split('\\') { // We remove \
 1979|    130|                    iri.push_str(chunk);
 1980|    130|                }
 1981|    130|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|    130|            } else {
 1983|    130|                Err("Prefix not found")
 1984|    130|            }
 1985|    130|        }
 1986|    130|
 1987|    130|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|    130|            b
 1989|    130|        }
 1990|    130|
 1991|    130|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|    130|
 1993|    130|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|    130|
 1995|    130|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|    130|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|    130|        }
 1998|    130|
 1999|    130|        rule INTEGER() = ['0'..='9']+
 2000|    130|
 2001|    130|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|    130|
 2003|    130|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|    130|
 2005|    130|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|    130|
 2007|    130|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|    130|
 2009|    130|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|    130|
 2011|    130|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|    130|
 2013|    130|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|    130|
 2015|    130|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|    130|
 2017|    130|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|    130|
 2019|    130|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|    130|             unescape_string(l)
 2021|    130|        }
 2022|    130|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|    130|
 2024|    130|
 2025|    130|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|    130|             unescape_string(l)
 2027|    130|        }
 2028|    130|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|    130|
 2030|    130|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|    130|             unescape_string(l)
 2032|    130|        }
 2033|    130|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|    130|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|    130|
 2036|    130|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|    130|             unescape_string(l)
 2038|    130|        }
 2039|    130|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|    130|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|    130|
 2042|    130|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|    130|
 2044|    130|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|    130|
 2046|    130|        rule NIL() = "(" WS()* ")"
 2047|    130|
 2048|    130|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|    130|
 2050|    130|        rule ANON() = "[" WS()* "]"
 2051|    130|
 2052|    130|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|    130|
 2054|    130|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|    130|
 2056|    130|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|    130|
 2058|    130|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|    130|
 2060|    130|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|    130|
 2062|    130|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|    130|
 2064|    130|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|    130|
 2066|    130|        rule PERCENT() = ['%'] HEX() HEX()
 2067|    130|
 2068|    130|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|    130|
 2070|    130|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|    130|
 2072|    130|        //space
 2073|    130|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|    130|
 2075|    130|        //comment
 2076|    130|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|    130|
 2078|    130|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|    130|            if input.eq_ignore_ascii_case(literal) {
 2080|    130|                Ok(())
 2081|    130|            } else {
 2082|    130|                Err(literal)
 2083|    130|            }
 2084|    130|        }
 2085|    130|    }
 2086|    130|}
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_ExpressionList_item0B7_:
 1336|    713|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Modify0s_0B9_:
 1086|  1.72k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|    242|                    QuadPattern {
 1088|    242|                        subject: q.subject,
 1089|    242|                        predicate: q.predicate,
 1090|    242|                        object: q.object,
 1091|    242|                        graph_name: with.clone().into()
 1092|    242|                    }
 1093|       |                } else {
 1094|  1.47k|                    q
 1095|  1.72k|                }).collect();
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_GroupOrUnionGraphPattern_item0B7_:
 1316|    149|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ExpressionList0B7_:
 1334|    707|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser31___parse_ConditionalOrExpression00B9_:
 1706|     63|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser31___parse_GroupGraphPattern_clear0B7_:
 1175|  13.7k|        rule GroupGraphPattern_clear() = {
 1176|  13.7k|             // We deal with blank nodes aliases rule
 1177|  13.7k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  13.7k|            state.currently_used_bnodes.clear();
 1179|  13.7k|        }
_RNCNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_InlineDataFull00B9_:
 1286|    299|            if vals.iter().all(|vs| vs.len() == vars.len()) {
_RNCNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ExpressionLists_0B7_:
 1335|  1.02k|            NIL() { Vec::new() }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_PN_PREFIX:
 2060|   226k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_PNAME_NS:
 1970|   226k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser9___parse__:
 2073|   713k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_DOUBLE:
 2003|  50.0k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_DOUBLE_NEGATIVE:
 2015|  45.5k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_iriOrFunction:
 1909|  11.8k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser35___parse_STRING_LITERAL2_simple_char:
 2028|  21.0k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ObjectList:
 1386|  17.0k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_InlineDataOneVar_value:
 1283|    413|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_QuadsNotTriples:
 1163|  20.2k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GraphGraphPattern:
 1262|  5.49k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_GraphRef:
 1139|  1.82k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_QuadData:
 1148|    239|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Load:
  978|  8.38k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_Quads_TriplesTemplate:
 1158|  22.3k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Create:
  991|  5.83k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_PropertyListPathNotEmpty:
 1442|  11.8k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PathSequence_item:
 1515|  44.8k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_Var:
 1693|   144k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser35___parse_PathNegatedPropertySet_item:
 1568|  7.69k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_TriplesSameSubjectPath:
 1417|  6.24k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_InlineDataFull_values:
 1293|    498|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_VAR1:
 1991|   144k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_QuotedTripleData:
 1671|  5.51k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_PNAME_LN:
 1974|   113k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_ExprQuotedTriple:
 1782|  11.8k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_ECHAR:
 2044|  5.26k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_VARNAME:
 2056|  46.5k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_IRIREF:
 1966|   169k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_RegexExpression:
 1869|  1.54k|        rule RegexExpression() -> Expression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ExistsFunc:
 1883|  1.54k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_INTEGER:
 1999|  48.1k|        rule INTEGER() = ['0'..='9']+
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_ServiceGraphPattern:
 1266|  5.41k|        rule ServiceGraphPattern() -> PartialGraphPattern =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_LimitClause:
  961|  1.76k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GraphRefAll:
 1141|  1.53k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Update:
  973|  2.93k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_Add:
  995|  6.84k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_PathElt:
 1517|  44.8k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_InsertClause:
 1123|  4.86k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GraphOrDefault:
 1133|  2.02k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Update1_silent:
  976|  2.83k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_InlineDataFull_value:
 1294|  5.09k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PN_CHARS_U:
 2054|   326k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_ObjectPath:
 1479|  15.0k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_PathSequence:
 1510|  35.7k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_VarOrIri:
 1689|  31.9k|        rule VarOrIri() -> NamedNodePattern =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_PathNegatedPropertySet:
 1541|  1.60k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_PropertyListNotEmpty_item:
 1377|  17.0k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_PathAlternative:
 1503|  34.2k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_BrackettedExpression:
 1787|  12.5k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_STRING_LITERAL_LONG2:
 2036|   155k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_AdditiveExpression:
 1736|  7.36k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_UnaryExpression:
 1756|  12.5k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_GraphNodePath:
 1651|  19.5k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_NotExistsFunc:
 1885|  1.47k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_OptionalGraphPattern:
 1249|  6.04k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_EXPONENT:
 2017|  4.50k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_STRING_LITERAL_LONG1:
 2030|   155k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_Update1:
  975|  8.38k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_BlankNode:
 1956|  40.9k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser21___parse_PN_CHARS_BASE:
 2052|   553k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser31___parse_GroupGraphPattern_clear:
 1175|  13.7k|        rule GroupGraphPattern_clear() = {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_OrderClause:
  948|  1.76k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_UsingClause:
 1125|  2.36k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_LimitOffsetClauses:
  957|  1.76k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_option:
  820|  1.94k|        rule SelectClause_option() -> SelectionOption =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_ValuesClause:
  969|  1.76k|        rule ValuesClause() -> Option<GraphPattern> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_iri:
 1945|   169k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_GroupOrUnionGraphPattern_item:
 1316|  6.19k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_TriplesTemplate_inner:
 1170|  39.4k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Path:
 1501|  34.2k|        rule Path() -> PropertyPathExpression = PathAlternative()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_GraphPatternNotTriples:
 1247|  6.17k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_DeleteClause:
 1119|  4.86k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_TriplesNodePath:
 1592|  17.5k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_NumericExpression:
 1734|  4.66k|        rule NumericExpression() -> Expression = AdditiveExpression()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser45___parse_PropertyListPathNotEmpty_item_content:
 1455|    592|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_MinusGraphPattern:
 1307|  5.51k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_Collection:
 1608|  22.3k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_AdditiveExpression_inner:
 1742|  6.33k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_Annotation:
 1643|  17.0k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_PrimaryExpression:
 1764|  12.5k|        rule PrimaryExpression() -> Expression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_VarOrTerm:
 1655|  82.2k|        rule VarOrTerm() -> TermPattern =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_HavingCondition:
  946|     44|        rule HavingCondition() -> Expression = Constraint()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_String:
 1943|   155k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_InsertData:
 1025|  5.54k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_GroupGraphPatternSub:
 1181|  5.23k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_DECIMAL:
 2001|  49.4k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_DECIMAL_NEGATIVE:
 2013|  45.5k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GroupCondition_as:
  940|      2|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_Prologue:
  789|  2.93k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_SubSelect:
  807|  1.98k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralUnsigned:
 1923|  50.0k|        rule NumericLiteralUnsigned() -> Literal =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Filter:
 1318|  5.41k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser25___parse_GroupGraphPattern:
 1172|  11.2k|        rule GroupGraphPattern() -> GraphPattern =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_GroupGraphPatternSub_item:
 1234|  6.17k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_RDFLiteral:
 1916|  52.5k|        rule RDFLiteral() -> Literal =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_InlineDataFull:
 1285|    199|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_VerbPath:
 1462|  12.3k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_GroupOrUnionGraphPattern:
 1311|  6.17k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_FunctionCall:
 1324|    404|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_INTEGER_NEGATIVE:
 2011|  45.5k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_UpdateInit:
  787|  2.93k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphTerm:
 1695|  62.5k|        rule GraphTerm() -> Term =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_NumericLiteral:
 1921|  50.0k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathOneInPropertySet:
 1570|  8.00k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_VAR2:
 1993|  97.5k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_GroupCondition_item:
  933|    426|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_BaseDecl:
  791|  2.93k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_WhereClause:
  916|  1.93k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_DOUBLE_POSITIVE:
 2009|  45.5k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser10UpdateInit:
  787|  2.71k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_DataBlock:
 1276|    248|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_Clear:
  983|  8.38k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Move:
 1005|  6.57k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser9___parse_i:
 2078|   355k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PathElt_op:
 1526|  34.5k|        rule PathElt_op() -> char =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_ObjectList_item:
 1393|  17.0k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_StrReplaceExpression:
 1879|  1.75k|        rule StrReplaceExpression() -> Expression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_PathEltOrInverse:
 1531|  44.8k|        rule PathEltOrInverse() -> PropertyPathExpression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_Expression:
 1703|  3.45k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Verb:
 1384|  17.0k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_BuiltInCall:
 1789|  2.51k|        rule BuiltInCall() -> Expression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_SelectClause_variables:
  824|  1.94k|        rule SelectClause_variables() -> SelectionVariables =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_ANON:
 2050|  40.9k|        rule ANON() = "[" WS()* "]"
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_comment:
 2076|   713k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_Aggregate:
 1887|  2.51k|        rule Aggregate() -> AggregateExpression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_INTEGER_POSITIVE:
 2005|  45.5k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Modify_clauses:
 1109|  4.86k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_LateralGraphPattern:
 1257|  5.79k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PropertyListNotEmpty:
 1370|  17.0k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_QuadPattern:
 1146|  5.09k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_Quads:
 1155|  5.40k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Drop:
  987|  7.06k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_BLANK_NODE_LABEL:
 1987|  40.9k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_ExpressionList_item:
 1336|  1.74k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_TriplesSameSubject:
 1345|  39.4k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_InlineDataFull_var:
 1292|  3.62k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser10___parse_WS:
 2048|  36.0k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_QuotedTriple:
 1663|  62.5k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_PathPrimary:
 1535|  44.8k|        rule PathPrimary() -> PropertyPathExpression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Bind:
 1270|  5.40k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_PrefixedName:
 1949|   113k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SubstringExpression:
 1874|  1.75k|        rule SubstringExpression() -> Expression =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralPositive:
 1928|  45.5k|        rule NumericLiteralPositive() -> Literal =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_OffsetClause:
  965|  1.76k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_MultiplicativeExpression:
 1746|  12.5k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_AnnotationPath:
 1645|  15.0k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser30___parse_NumericLiteralNegative:
 1934|  45.5k|        rule NumericLiteralNegative() -> Literal =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser11___parse_NIL:
 2046|  42.7k|        rule NIL() = "(" WS()* ")"
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser16___parse_PN_CHARS:
 2058|   275k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_DeleteData:
 1029|  5.30k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
_RNvMNtNtCshSv3hUzq9FP_9spargebra6parser6parserNtB2_10ParseState3new:
  778|  2.93k|parser! {
  779|  2.93k|    //See https://www.w3.org/TR/turtle/#sec-grammar
  780|  2.93k|    grammar parser(state: &mut ParserState) for str {
  781|  2.93k|        pub rule QueryUnit() -> Query = Query()
  782|  2.93k|
  783|  2.93k|        rule Query() -> Query = _ Prologue() _ q:(SelectQuery() / ConstructQuery() / DescribeQuery() / AskQuery()) _ {
  784|  2.93k|            q
  785|  2.93k|        }
  786|  2.93k|
  787|  2.93k|        pub rule UpdateInit() -> Vec<GraphUpdateOperation> = Update()
  788|  2.93k|
  789|  2.93k|        rule Prologue() = (BaseDecl() _ / PrefixDecl() _)* {}
  790|  2.93k|
  791|  2.93k|        rule BaseDecl() = i("BASE") _ i:IRIREF() {
  792|  2.93k|            state.base_iri = Some(i)
  793|  2.93k|        }
  794|  2.93k|
  795|  2.93k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
  796|  2.93k|            state.namespaces.insert(ns.into(), i.into_inner());
  797|  2.93k|        }
  798|  2.93k|
  799|  2.93k|        rule SelectQuery() -> Query = s:SelectClause() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  800|  2.93k|            Ok(Query::Select {
  801|  2.93k|                dataset: d,
  802|  2.93k|                pattern: build_select(s, w, g, h, o, l, v, state)?,
  803|  2.93k|                base_iri: state.base_iri.clone()
  804|  2.93k|            })
  805|  2.93k|        }
  806|  2.93k|
  807|  2.93k|        rule SubSelect() -> GraphPattern = s:SelectClause() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  808|  2.93k|            build_select(s, w, g, h, o, l, v, state)
  809|  2.93k|        }
  810|  2.93k|
  811|  2.93k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
  812|  2.93k|            Selection {
  813|  2.93k|                option: o,
  814|  2.93k|                variables: v
  815|  2.93k|            }
  816|  2.93k|        }
  817|  2.93k|        rule Selection_init() = {
  818|  2.93k|            state.aggregates.push(Vec::new())
  819|  2.93k|        }
  820|  2.93k|        rule SelectClause_option() -> SelectionOption =
  821|  2.93k|            i("DISTINCT") { SelectionOption::Distinct } /
  822|  2.93k|            i("REDUCED") { SelectionOption::Reduced } /
  823|  2.93k|            { SelectionOption::Default }
  824|  2.93k|        rule SelectClause_variables() -> SelectionVariables =
  825|  2.93k|            "*" { SelectionVariables::Star } /
  826|  2.93k|            p:SelectClause_member()+ { SelectionVariables::Explicit(p) }
  827|  2.93k|        rule SelectClause_member() -> SelectionMember =
  828|  2.93k|            v:Var() _ { SelectionMember::Variable(v) } /
  829|  2.93k|            "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" _ { SelectionMember::Expression(e, v) }
  830|  2.93k|
  831|  2.93k|        rule ConstructQuery() -> Query =
  832|  2.93k|            i("CONSTRUCT") _ c:ConstructTemplate() _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  833|  2.93k|                Ok(Query::Construct {
  834|  2.93k|                    template: c,
  835|  2.93k|                    dataset: d,
  836|  2.93k|                    pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  837|  2.93k|                    base_iri: state.base_iri.clone()
  838|  2.93k|                })
  839|  2.93k|            } /
  840|  2.93k|            i("CONSTRUCT") _ d:DatasetClauses() _ i("WHERE") _ "{" _ c:ConstructQuery_optional_triple_template() _ "}" _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  841|  2.93k|                Ok(Query::Construct {
  842|  2.93k|                    template: c.clone(),
  843|  2.93k|                    dataset: d,
  844|  2.93k|                    pattern: build_select(
  845|  2.93k|                        Selection::no_op(),
  846|  2.93k|                        GraphPattern::Bgp { patterns: c },
  847|  2.93k|                        g, h, o, l, v, state
  848|  2.93k|                    )?,
  849|  2.93k|                    base_iri: state.base_iri.clone()
  850|  2.93k|                })
  851|  2.93k|            }
  852|  2.93k|
  853|  2.93k|        rule ConstructQuery_optional_triple_template() -> Vec<TriplePattern> = TriplesTemplate() / { Vec::new() }
  854|  2.93k|
  855|  2.93k|        rule DescribeQuery() -> Query =
  856|  2.93k|            i("DESCRIBE") _ "*" _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  857|  2.93k|                Ok(Query::Describe {
  858|  2.93k|                    dataset: d,
  859|  2.93k|                    pattern: build_select(Selection::no_op(), w.unwrap_or_default(), g, h, o, l, v, state)?,
  860|  2.93k|                    base_iri: state.base_iri.clone()
  861|  2.93k|                })
  862|  2.93k|            } /
  863|  2.93k|            i("DESCRIBE") _ p:DescribeQuery_item()+ _ d:DatasetClauses() _ w:WhereClause()? _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  864|  2.93k|                Ok(Query::Describe {
  865|  2.93k|                    dataset: d,
  866|  2.93k|                    pattern: build_select(Selection {
  867|  2.93k|                        option: SelectionOption::Default,
  868|  2.93k|                        variables: SelectionVariables::Explicit(p.into_iter().map(|var_or_iri| match var_or_iri {
  869|  2.93k|                            NamedNodePattern::NamedNode(n) => SelectionMember::Expression(n.into(), variable()),
  870|  2.93k|                            NamedNodePattern::Variable(v) => SelectionMember::Variable(v)
  871|  2.93k|                        }).collect())
  872|  2.93k|                    }, w.unwrap_or_default(), g, h, o, l, v, state)?,
  873|  2.93k|                    base_iri: state.base_iri.clone()
  874|  2.93k|                })
  875|  2.93k|            }
  876|  2.93k|        rule DescribeQuery_item() -> NamedNodePattern = i:VarOrIri() _ { i }
  877|  2.93k|
  878|  2.93k|        rule AskQuery() -> Query = i("ASK") _ d:DatasetClauses() _ w:WhereClause() _ g:GroupClause()? _ h:HavingClause()? _ o:OrderClause()? _ l:LimitOffsetClauses()? _ v:ValuesClause() {?
  879|  2.93k|            Ok(Query::Ask {
  880|  2.93k|                dataset: d,
  881|  2.93k|                pattern: build_select(Selection::no_op(), w, g, h, o, l, v, state)?,
  882|  2.93k|                base_iri: state.base_iri.clone()
  883|  2.93k|            })
  884|  2.93k|        }
  885|  2.93k|
  886|  2.93k|        rule DatasetClause() -> (Option<NamedNode>, Option<NamedNode>) = i("FROM") _ d:(DefaultGraphClause() / NamedGraphClause()) { d }
  887|  2.93k|        rule DatasetClauses() -> Option<QueryDataset> = d:DatasetClause() ** (_) {
  888|  2.93k|            if d.is_empty() {
  889|  2.93k|                return None;
  890|  2.93k|            }
  891|  2.93k|            let mut default = Vec::new();
  892|  2.93k|            let mut named = Vec::new();
  893|  2.93k|            for (d, n) in d {
  894|  2.93k|                if let Some(d) = d {
  895|  2.93k|                    default.push(d);
  896|  2.93k|                }
  897|  2.93k|                if let Some(n) = n {
  898|  2.93k|                    named.push(n);
  899|  2.93k|                }
  900|  2.93k|            }
  901|  2.93k|            Some(QueryDataset {
  902|  2.93k|                default, named: Some(named)
  903|  2.93k|            })
  904|  2.93k|        }
  905|  2.93k|
  906|  2.93k|        rule DefaultGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = s:SourceSelector() {
  907|  2.93k|            (Some(s), None)
  908|  2.93k|        }
  909|  2.93k|
  910|  2.93k|        rule NamedGraphClause() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ s:SourceSelector() {
  911|  2.93k|            (None, Some(s))
  912|  2.93k|        }
  913|  2.93k|
  914|  2.93k|        rule SourceSelector() -> NamedNode = iri()
  915|  2.93k|
  916|  2.93k|        rule WhereClause() -> GraphPattern = i("WHERE")? _ p:GroupGraphPattern() {
  917|  2.93k|            p
  918|  2.93k|        }
  919|  2.93k|
  920|  2.93k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
  921|  2.93k|            let mut projections: Vec<(Expression,Variable)> = Vec::new();
  922|  2.93k|            let clauses = c.into_iter().map(|(e, vo)| {
  923|  2.93k|                if let Expression::Variable(v) = e {
  924|  2.93k|                    v
  925|  2.93k|                } else {
  926|  2.93k|                    let v = vo.unwrap_or_else(variable);
  927|  2.93k|                    projections.push((e, v.clone()));
  928|  2.93k|                    v
  929|  2.93k|                }
  930|  2.93k|            }).collect();
  931|  2.93k|            (clauses, projections)
  932|  2.93k|        }
  933|  2.93k|        rule GroupCondition_item() -> (Expression, Option<Variable>) = c:GroupCondition() _ { c }
  934|  2.93k|
  935|  2.93k|        rule GroupCondition() -> (Expression, Option<Variable>) =
  936|  2.93k|            e:BuiltInCall() { (e, None) } /
  937|  2.93k|            e:FunctionCall() { (e, None) } /
  938|  2.93k|            "(" _ e:Expression() _ v:GroupCondition_as()? ")" { (e, v) } /
  939|  2.93k|            e:Var() { (e.into(), None) }
  940|  2.93k|        rule GroupCondition_as() -> Variable = i("AS") _ v:Var() _ { v }
  941|  2.93k|
  942|  2.93k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
  943|  2.93k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
  944|  2.93k|        }
  945|  2.93k|
  946|  2.93k|        rule HavingCondition() -> Expression = Constraint()
  947|  2.93k|
  948|  2.93k|        rule OrderClause() -> Vec<OrderExpression> = i("ORDER") _ i("BY") _ c:OrderClause_item()+ { c }
  949|  2.93k|        rule OrderClause_item() -> OrderExpression = c:OrderCondition() _ { c }
  950|  2.93k|
  951|  2.93k|        rule OrderCondition() -> OrderExpression =
  952|  2.93k|            i("ASC") _ e: BrackettedExpression() { OrderExpression::Asc(e) } /
  953|  2.93k|            i("DESC") _ e: BrackettedExpression() { OrderExpression::Desc(e) } /
  954|  2.93k|            e: Constraint() { OrderExpression::Asc(e) } /
  955|  2.93k|            v: Var() { OrderExpression::Asc(Expression::from(v)) }
  956|  2.93k|
  957|  2.93k|        rule LimitOffsetClauses() -> (usize, Option<usize>) =
  958|  2.93k|            l:LimitClause() _ o:OffsetClause()? { (o.unwrap_or(0), Some(l)) } /
  959|  2.93k|            o:OffsetClause() _ l:LimitClause()? { (o, l) }
  960|  2.93k|
  961|  2.93k|        rule LimitClause() -> usize = i("LIMIT") _ l:$(INTEGER()) {?
  962|  2.93k|            usize::from_str(l).map_err(|_| "The query limit should be a non negative integer")
  963|  2.93k|        }
  964|  2.93k|
  965|  2.93k|        rule OffsetClause() -> usize = i("OFFSET") _ o:$(INTEGER()) {?
  966|  2.93k|            usize::from_str(o).map_err(|_| "The query offset should be a non negative integer")
  967|  2.93k|        }
  968|  2.93k|
  969|  2.93k|        rule ValuesClause() -> Option<GraphPattern> =
  970|  2.93k|            i("VALUES") _ p:DataBlock() { Some(p) } /
  971|  2.93k|            { None }
  972|  2.93k|
  973|  2.93k|        rule Update() -> Vec<GraphUpdateOperation> = _ Prologue() _ u:(Update1() ** (_ ";" _))  _ ( ";" _)? { u.into_iter().flatten().collect() }
  974|  2.93k|
  975|  2.93k|        rule Update1() -> Vec<GraphUpdateOperation> = Load() / Clear() / Drop() / Add() / Move() / Copy() / Create() / InsertData() / DeleteData() / DeleteWhere() / Modify()
  976|  2.93k|        rule Update1_silent() -> bool = i("SILENT") { true } / { false }
  977|  2.93k|
  978|  2.93k|        rule Load() -> Vec<GraphUpdateOperation> = i("LOAD") _ silent:Update1_silent() _ source:iri() _ destination:Load_to()? {
  979|  2.93k|            vec![GraphUpdateOperation::Load { silent, source, destination: destination.map_or(GraphName::DefaultGraph, GraphName::NamedNode) }]
  980|  2.93k|        }
  981|  2.93k|        rule Load_to() -> NamedNode = i("INTO") _ g: GraphRef() { g }
  982|  2.93k|
  983|  2.93k|        rule Clear() -> Vec<GraphUpdateOperation> = i("CLEAR") _ silent:Update1_silent() _ graph:GraphRefAll() {
  984|  2.93k|            vec![GraphUpdateOperation::Clear { silent, graph }]
  985|  2.93k|        }
  986|  2.93k|
  987|  2.93k|        rule Drop() -> Vec<GraphUpdateOperation> = i("DROP") _ silent:Update1_silent() _ graph:GraphRefAll() {
  988|  2.93k|            vec![GraphUpdateOperation::Drop { silent, graph }]
  989|  2.93k|        }
  990|  2.93k|
  991|  2.93k|        rule Create() -> Vec<GraphUpdateOperation> = i("CREATE") _ silent:Update1_silent() _ graph:GraphRef() {
  992|  2.93k|            vec![GraphUpdateOperation::Create { silent, graph }]
  993|  2.93k|        }
  994|  2.93k|
  995|  2.93k|        rule Add() -> Vec<GraphUpdateOperation> = i("ADD") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
  996|  2.93k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#add
  997|  2.93k|            if from == to {
  998|  2.93k|                Vec::new() // identity case
  999|  2.93k|            } else {
 1000|  2.93k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1001|  2.93k|                vec![copy_graph(from, to)]
 1002|  2.93k|            }
 1003|  2.93k|        }
 1004|  2.93k|
 1005|  2.93k|        rule Move() -> Vec<GraphUpdateOperation> = i("MOVE") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1006|  2.93k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#move
 1007|  2.93k|            if from == to {
 1008|  2.93k|                Vec::new() // identity case
 1009|  2.93k|            } else {
 1010|  2.93k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1011|  2.93k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from.clone(), to), GraphUpdateOperation::Drop { silent, graph: from.into() }]
 1012|  2.93k|            }
 1013|  2.93k|        }
 1014|  2.93k|
 1015|  2.93k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
 1016|  2.93k|            // Rewriting defined by https://www.w3.org/TR/sparql11-update/#copy
 1017|  2.93k|            if from == to {
 1018|  2.93k|                Vec::new() // identity case
 1019|  2.93k|            } else {
 1020|  2.93k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(Variable::new_unchecked("s"), Variable::new_unchecked("p"), Variable::new_unchecked("o"))] };
 1021|  2.93k|                vec![GraphUpdateOperation::Drop { silent: true, graph: to.clone().into() }, copy_graph(from, to)]
 1022|  2.93k|            }
 1023|  2.93k|        }
 1024|  2.93k|
 1025|  2.93k|        rule InsertData() -> Vec<GraphUpdateOperation> = i("INSERT") _ i("DATA") _ data:QuadData() {
 1026|  2.93k|            vec![GraphUpdateOperation::InsertData { data }]
 1027|  2.93k|        }
 1028|  2.93k|
 1029|  2.93k|        rule DeleteData() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("DATA") _ data:GroundQuadData() {
 1030|  2.93k|            vec![GraphUpdateOperation::DeleteData { data }]
 1031|  2.93k|        }
 1032|  2.93k|
 1033|  2.93k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
 1034|  2.93k|            let pattern = d.iter().map(|q| {
 1035|  2.93k|                let bgp = GraphPattern::Bgp { patterns: vec![TriplePattern::new(q.subject.clone(), q.predicate.clone(), q.object.clone())] };
 1036|  2.93k|                match &q.graph_name {
 1037|  2.93k|                    GraphNamePattern::NamedNode(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1038|  2.93k|                    GraphNamePattern::DefaultGraph => bgp,
 1039|  2.93k|                    GraphNamePattern::Variable(graph_name) => GraphPattern::Graph { name: graph_name.clone().into(), inner: Box::new(bgp) },
 1040|  2.93k|                }
 1041|  2.93k|            }).reduce(new_join).unwrap_or_default();
 1042|  2.93k|            let delete = d.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")?;
 1043|  2.93k|            Ok(vec![GraphUpdateOperation::DeleteInsert {
 1044|  2.93k|                delete,
 1045|  2.93k|                insert: Vec::new(),
 1046|  2.93k|                using: None,
 1047|  2.93k|                pattern: Box::new(pattern)
 1048|  2.93k|            }])
 1049|  2.93k|        }
 1050|  2.93k|
 1051|  2.93k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
 1052|  2.93k|            let (delete, insert) = c;
 1053|  2.93k|            let mut delete = delete.unwrap_or_default();
 1054|  2.93k|            let mut insert = insert.unwrap_or_default();
 1055|  2.93k|            #[allow(clippy::shadow_same)]
 1056|  2.93k|            let mut pattern = pattern;
 1057|  2.93k|
 1058|  2.93k|            let mut using = if u.is_empty() {
 1059|  2.93k|                None
 1060|  2.93k|            } else {
 1061|  2.93k|                let mut default = Vec::new();
 1062|  2.93k|                let mut named = Vec::new();
 1063|  2.93k|                for (d, n) in u {
 1064|  2.93k|                    if let Some(d) = d {
 1065|  2.93k|                        default.push(d)
 1066|  2.93k|                    }
 1067|  2.93k|                    if let Some(n) = n {
 1068|  2.93k|                        named.push(n)
 1069|  2.93k|                    }
 1070|  2.93k|                }
 1071|  2.93k|                Some(QueryDataset { default, named: Some(named) })
 1072|  2.93k|            };
 1073|  2.93k|
 1074|  2.93k|            if let Some(with) = with {
 1075|  2.93k|                // We inject WITH everywhere
 1076|  2.93k|                delete = delete.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1077|  2.93k|                    GroundQuadPattern {
 1078|  2.93k|                        subject: q.subject,
 1079|  2.93k|                        predicate: q.predicate,
 1080|  2.93k|                        object: q.object,
 1081|  2.93k|                        graph_name: with.clone().into()
 1082|  2.93k|                    }
 1083|  2.93k|                } else {
 1084|  2.93k|                    q
 1085|  2.93k|                }).collect();
 1086|  2.93k|                insert = insert.into_iter().map(|q| if q.graph_name == GraphNamePattern::DefaultGraph {
 1087|  2.93k|                    QuadPattern {
 1088|  2.93k|                        subject: q.subject,
 1089|  2.93k|                        predicate: q.predicate,
 1090|  2.93k|                        object: q.object,
 1091|  2.93k|                        graph_name: with.clone().into()
 1092|  2.93k|                    }
 1093|  2.93k|                } else {
 1094|  2.93k|                    q
 1095|  2.93k|                }).collect();
 1096|  2.93k|                if using.is_none() {
 1097|  2.93k|                    using = Some(QueryDataset { default: vec![with], named: None });
 1098|  2.93k|                }
 1099|  2.93k|            }
 1100|  2.93k|
 1101|  2.93k|            vec![GraphUpdateOperation::DeleteInsert {
 1102|  2.93k|                delete,
 1103|  2.93k|                insert,
 1104|  2.93k|                using,
 1105|  2.93k|                pattern: Box::new(pattern)
 1106|  2.93k|            }]
 1107|  2.93k|        }
 1108|  2.93k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
 1109|  2.93k|        rule Modify_clauses() -> (Option<Vec<GroundQuadPattern>>, Option<Vec<QuadPattern>>) = d:DeleteClause() _ i:InsertClause()? {
 1110|  2.93k|            (Some(d), i)
 1111|  2.93k|        } / i:InsertClause() {
 1112|  2.93k|            (None, Some(i))
 1113|  2.93k|        }
 1114|  2.93k|        rule Modify_clear() = {
 1115|  2.93k|            state.used_bnodes.clear();
 1116|  2.93k|            state.currently_used_bnodes.clear();
 1117|  2.93k|        }
 1118|  2.93k|
 1119|  2.93k|        rule DeleteClause() -> Vec<GroundQuadPattern> = i("DELETE") _ q:QuadPattern() {?
 1120|  2.93k|            q.into_iter().map(GroundQuadPattern::try_from).collect::<Result<Vec<_>,_>>().map_err(|()| "Blank nodes are not allowed in DELETE WHERE")
 1121|  2.93k|        }
 1122|  2.93k|
 1123|  2.93k|        rule InsertClause() -> Vec<QuadPattern> = i("INSERT") _ q:QuadPattern() { q }
 1124|  2.93k|
 1125|  2.93k|        rule UsingClause() -> (Option<NamedNode>, Option<NamedNode>) = i("USING") _ d:(UsingClause_default() / UsingClause_named()) { d }
 1126|  2.93k|        rule UsingClause_default() -> (Option<NamedNode>, Option<NamedNode>) = i:iri() {
 1127|  2.93k|            (Some(i), None)
 1128|  2.93k|        }
 1129|  2.93k|        rule UsingClause_named() -> (Option<NamedNode>, Option<NamedNode>) = i("NAMED") _ i:iri() {
 1130|  2.93k|            (None, Some(i))
 1131|  2.93k|        }
 1132|  2.93k|
 1133|  2.93k|        rule GraphOrDefault() -> GraphName = i("DEFAULT") {
 1134|  2.93k|            GraphName::DefaultGraph
 1135|  2.93k|        } / (i("GRAPH") _)? g:iri() {
 1136|  2.93k|            GraphName::NamedNode(g)
 1137|  2.93k|        }
 1138|  2.93k|
 1139|  2.93k|        rule GraphRef() -> NamedNode = i("GRAPH") _ g:iri() { g }
 1140|  2.93k|
 1141|  2.93k|        rule GraphRefAll() -> GraphTarget  = i: GraphRef() { i.into() }
 1142|  2.93k|            / i("DEFAULT") { GraphTarget::DefaultGraph }
 1143|  2.93k|            / i("NAMED") { GraphTarget::NamedGraphs }
 1144|  2.93k|            / i("ALL") { GraphTarget::AllGraphs }
 1145|  2.93k|
 1146|  2.93k|        rule QuadPattern() -> Vec<QuadPattern> = "{" _ q:Quads() _ "}" { q }
 1147|  2.93k|
 1148|  2.93k|        rule QuadData() -> Vec<Quad> = "{" _ q:Quads() _ "}" {?
 1149|  2.93k|            q.into_iter().map(Quad::try_from).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables are not allowed in INSERT DATA")
 1150|  2.93k|        }
 1151|  2.93k|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
 1152|  2.93k|            q.into_iter().map(|q| GroundQuad::try_from(Quad::try_from(q)?)).collect::<Result<Vec<_>, ()>>().map_err(|()| "Variables and blank nodes are not allowed in DELETE DATA")
 1153|  2.93k|        }
 1154|  2.93k|
 1155|  2.93k|        rule Quads() -> Vec<QuadPattern> = q:(Quads_TriplesTemplate() / Quads_QuadsNotTriples()) ** (_) {
 1156|  2.93k|            q.into_iter().flatten().collect()
 1157|  2.93k|        }
 1158|  2.93k|        rule Quads_TriplesTemplate() -> Vec<QuadPattern> = t:TriplesTemplate() {
 1159|  2.93k|            t.into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, GraphNamePattern::DefaultGraph)).collect()
 1160|  2.93k|        } //TODO: return iter?
 1161|  2.93k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
 1162|  2.93k|
 1163|  2.93k|        rule QuadsNotTriples() -> Vec<QuadPattern> = i("GRAPH") _ g:VarOrIri() _ "{" _ t:TriplesTemplate()? _ "}" {
 1164|  2.93k|            t.unwrap_or_default().into_iter().map(|t| QuadPattern::new(t.subject, t.predicate, t.object, g.clone())).collect()
 1165|  2.93k|        }
 1166|  2.93k|
 1167|  2.93k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
 1168|  2.93k|            ts.into_iter().flatten().collect()
 1169|  2.93k|        }
 1170|  2.93k|        rule TriplesTemplate_inner() -> Vec<TriplePattern> = _ t:TriplesSameSubject() _ { t }
 1171|  2.93k|
 1172|  2.93k|        rule GroupGraphPattern() -> GraphPattern =
 1173|  2.93k|            "{" _ GroupGraphPattern_clear() p:GroupGraphPatternSub() GroupGraphPattern_clear() _ "}" { p } /
 1174|  2.93k|            "{" _ GroupGraphPattern_clear() p:SubSelect() GroupGraphPattern_clear() _ "}" { p }
 1175|  2.93k|        rule GroupGraphPattern_clear() = {
 1176|  2.93k|             // We deal with blank nodes aliases rule
 1177|  2.93k|            state.used_bnodes.extend(state.currently_used_bnodes.iter().cloned());
 1178|  2.93k|            state.currently_used_bnodes.clear();
 1179|  2.93k|        }
 1180|  2.93k|
 1181|  2.93k|        rule GroupGraphPatternSub() -> GraphPattern = a:TriplesBlock()? _ b:GroupGraphPatternSub_item()* {?
 1182|  2.93k|            let mut filter: Option<Expression> = None;
 1183|  2.93k|            let mut g = a.map_or_else(GraphPattern::default, build_bgp);
 1184|  2.93k|            for e in b.into_iter().flatten() {
 1185|  2.93k|                match e {
 1186|  2.93k|                    PartialGraphPattern::Optional(p, f) => {
 1187|  2.93k|                        g = GraphPattern::LeftJoin { left: Box::new(g), right: Box::new(p), expression: f }
 1188|  2.93k|                    }
 1189|  2.93k|                    #[cfg(feature = "sep-0006")]
 1190|  2.93k|                    PartialGraphPattern::Lateral(p) => {
 1191|  2.93k|                        let mut defined_variables = HashSet::default();
 1192|  2.93k|                        add_defined_variables(&p, &mut defined_variables);
 1193|  2.93k|                        let mut contains = false;
 1194|  2.93k|                        g.on_in_scope_variable(|v| {
 1195|  2.93k|                            if defined_variables.contains(v) {
 1196|  2.93k|                                contains = true;
 1197|  2.93k|                            }
 1198|  2.93k|                        });
 1199|  2.93k|                        if contains {
 1200|  2.93k|                            return Err("An existing variable is overridden in the right side of LATERAL");
 1201|  2.93k|                        }
 1202|  2.93k|                        g = GraphPattern::Lateral { left: Box::new(g), right: Box::new(p) }
 1203|  2.93k|                    }
 1204|  2.93k|                    PartialGraphPattern::Minus(p) => {
 1205|  2.93k|                        g = GraphPattern::Minus { left: Box::new(g), right: Box::new(p) }
 1206|  2.93k|                    }
 1207|  2.93k|                    PartialGraphPattern::Bind(expression, variable) => {
 1208|  2.93k|                        let mut contains = false;
 1209|  2.93k|                        g.on_in_scope_variable(|v| {
 1210|  2.93k|                            if *v == variable {
 1211|  2.93k|                                contains = true;
 1212|  2.93k|                            }
 1213|  2.93k|                        });
 1214|  2.93k|                        if contains {
 1215|  2.93k|                            return Err("BIND is overriding an existing variable")
 1216|  2.93k|                        }
 1217|  2.93k|                        g = GraphPattern::Extend { inner: Box::new(g), variable, expression }
 1218|  2.93k|                    }
 1219|  2.93k|                    PartialGraphPattern::Filter(expr) => filter = Some(if let Some(f) = filter {
 1220|  2.93k|                        Expression::And(Box::new(f), Box::new(expr))
 1221|  2.93k|                    } else {
 1222|  2.93k|                        expr
 1223|  2.93k|                    }),
 1224|  2.93k|                    PartialGraphPattern::Other(e) => g = new_join(g, e),
 1225|  2.93k|                }
 1226|  2.93k|            }
 1227|  2.93k|
 1228|  2.93k|            Ok(if let Some(expr) = filter {
 1229|  2.93k|                GraphPattern::Filter { expr, inner: Box::new(g) }
 1230|  2.93k|            } else {
 1231|  2.93k|                g
 1232|  2.93k|            })
 1233|  2.93k|        }
 1234|  2.93k|        rule GroupGraphPatternSub_item() -> Vec<PartialGraphPattern> = a:GraphPatternNotTriples() _ ("." _)? b:TriplesBlock()? _ {
 1235|  2.93k|            let mut result = vec![a];
 1236|  2.93k|            if let Some(v) = b {
 1237|  2.93k|                result.push(PartialGraphPattern::Other(build_bgp(v)));
 1238|  2.93k|            }
 1239|  2.93k|            result
 1240|  2.93k|        }
 1241|  2.93k|
 1242|  2.93k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
 1243|  2.93k|            hs.into_iter().flatten().collect()
 1244|  2.93k|        }
 1245|  2.93k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
 1246|  2.93k|
 1247|  2.93k|        rule GraphPatternNotTriples() -> PartialGraphPattern = GroupOrUnionGraphPattern() / OptionalGraphPattern() / LateralGraphPattern() / MinusGraphPattern() / GraphGraphPattern() / ServiceGraphPattern() / Filter() / Bind() / InlineData()
 1248|  2.93k|
 1249|  2.93k|        rule OptionalGraphPattern() -> PartialGraphPattern = i("OPTIONAL") _ p:GroupGraphPattern() {
 1250|  2.93k|            if let GraphPattern::Filter { expr, inner } =  p {
 1251|  2.93k|               PartialGraphPattern::Optional(*inner, Some(expr))
 1252|  2.93k|            } else {
 1253|  2.93k|               PartialGraphPattern::Optional(p, None)
 1254|  2.93k|            }
 1255|  2.93k|        }
 1256|  2.93k|
 1257|  2.93k|        rule LateralGraphPattern() -> PartialGraphPattern = i("LATERAL") _ p:GroupGraphPattern() {?
 1258|  2.93k|                #[cfg(feature = "sep-0006")]{Ok(PartialGraphPattern::Lateral(p))}
 1259|  2.93k|                #[cfg(not(feature = "sep-0006"))]{Err("The LATERAL modifier is not supported")}
 1260|  2.93k|        }
 1261|  2.93k|
 1262|  2.93k|        rule GraphGraphPattern() -> PartialGraphPattern = i("GRAPH") _ name:VarOrIri() _ p:GroupGraphPattern() {
 1263|  2.93k|            PartialGraphPattern::Other(GraphPattern::Graph { name, inner: Box::new(p) })
 1264|  2.93k|        }
 1265|  2.93k|
 1266|  2.93k|        rule ServiceGraphPattern() -> PartialGraphPattern =
 1267|  2.93k|            i("SERVICE") _ i("SILENT") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service { name, inner: Box::new(p), silent: true }) } /
 1268|  2.93k|            i("SERVICE") _ name:VarOrIri() _ p:GroupGraphPattern() { PartialGraphPattern::Other(GraphPattern::Service{ name, inner: Box::new(p), silent: false }) }
 1269|  2.93k|
 1270|  2.93k|        rule Bind() -> PartialGraphPattern = i("BIND") _ "(" _ e:Expression() _ i("AS") _ v:Var() _ ")" {
 1271|  2.93k|            PartialGraphPattern::Bind(e, v)
 1272|  2.93k|        }
 1273|  2.93k|
 1274|  2.93k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
 1275|  2.93k|
 1276|  2.93k|        rule DataBlock() -> GraphPattern = l:(InlineDataOneVar() / InlineDataFull()) {
 1277|  2.93k|            GraphPattern::Values { variables: l.0, bindings: l.1 }
 1278|  2.93k|        }
 1279|  2.93k|
 1280|  2.93k|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
 1281|  2.93k|            (vec![var], d)
 1282|  2.93k|        }
 1283|  2.93k|        rule InlineDataOneVar_value() -> Vec<Option<GroundTerm>> = t:DataBlockValue() _ { vec![t] }
 1284|  2.93k|
 1285|  2.93k|        rule InlineDataFull() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = "(" _ vars:InlineDataFull_var()* _ ")" _ "{" _ vals:InlineDataFull_values()* "}" {?
 1286|  2.93k|            if vals.iter().all(|vs| vs.len() == vars.len()) {
 1287|  2.93k|                Ok((vars, vals))
 1288|  2.93k|            } else {
 1289|  2.93k|                Err("The VALUES clause rows should have exactly the same number of values as there are variables. To set a value to undefined use UNDEF.")
 1290|  2.93k|            }
 1291|  2.93k|        }
 1292|  2.93k|        rule InlineDataFull_var() -> Variable = v:Var() _ { v }
 1293|  2.93k|        rule InlineDataFull_values() -> Vec<Option<GroundTerm>> = "(" _ v:InlineDataFull_value()* _ ")" _ { v }
 1294|  2.93k|        rule InlineDataFull_value() -> Option<GroundTerm> = v:DataBlockValue() _ { v }
 1295|  2.93k|
 1296|  2.93k|        rule DataBlockValue() -> Option<GroundTerm> =
 1297|  2.93k|            t:QuotedTripleData() {?
 1298|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Some(t.into()))}
 1299|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1300|  2.93k|            } /
 1301|  2.93k|            i:iri() { Some(i.into()) } /
 1302|  2.93k|            l:RDFLiteral() { Some(l.into()) } /
 1303|  2.93k|            l:NumericLiteral() { Some(l.into()) } /
 1304|  2.93k|            l:BooleanLiteral() { Some(l.into()) } /
 1305|  2.93k|            i("UNDEF") { None }
 1306|  2.93k|
 1307|  2.93k|        rule MinusGraphPattern() -> PartialGraphPattern = i("MINUS") _ p: GroupGraphPattern() {
 1308|  2.93k|            PartialGraphPattern::Minus(p)
 1309|  2.93k|        }
 1310|  2.93k|
 1311|  2.93k|        rule GroupOrUnionGraphPattern() -> PartialGraphPattern = p:GroupOrUnionGraphPattern_item() **<1,> (i("UNION") _) {?
 1312|  2.93k|            not_empty_fold(p.into_iter(), |a, b| {
 1313|  2.93k|                GraphPattern::Union { left: Box::new(a), right: Box::new(b) }
 1314|  2.93k|            }).map(PartialGraphPattern::Other)
 1315|  2.93k|        }
 1316|  2.93k|        rule GroupOrUnionGraphPattern_item() -> GraphPattern = p:GroupGraphPattern() _ { p }
 1317|  2.93k|
 1318|  2.93k|        rule Filter() -> PartialGraphPattern = i("FILTER") _ c:Constraint() {
 1319|  2.93k|            PartialGraphPattern::Filter(c)
 1320|  2.93k|        }
 1321|  2.93k|
 1322|  2.93k|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
 1323|  2.93k|
 1324|  2.93k|        rule FunctionCall() -> Expression = f: iri() _ a: ArgList() {
 1325|  2.93k|            Expression::FunctionCall(Function::Custom(f), a)
 1326|  2.93k|        }
 1327|  2.93k|
 1328|  2.93k|        rule ArgList() -> Vec<Expression> =
 1329|  2.93k|            "(" _ e:ArgList_item() **<1,> ("," _) _ ")" { e } /
 1330|  2.93k|            NIL() { Vec::new() }
 1331|  2.93k|        rule ArgList_item() -> Expression = e:Expression() _ { e }
 1332|  2.93k|
 1333|  2.93k|        rule ExpressionList() -> Vec<Expression> =
 1334|  2.93k|            "(" _ e:ExpressionList_item() **<1,> ("," _) ")" { e } /
 1335|  2.93k|            NIL() { Vec::new() }
 1336|  2.93k|        rule ExpressionList_item() -> Expression = e:Expression() _ { e }
 1337|  2.93k|
 1338|  2.93k|        rule ConstructTemplate() -> Vec<TriplePattern> = "{" _ t:ConstructTriples() _ "}" { t }
 1339|  2.93k|
 1340|  2.93k|        rule ConstructTriples() -> Vec<TriplePattern> = p:ConstructTriples_item() ** ("." _) "."? {
 1341|  2.93k|            p.into_iter().flatten().collect()
 1342|  2.93k|        }
 1343|  2.93k|        rule ConstructTriples_item() -> Vec<TriplePattern> = t:TriplesSameSubject() _ { t }
 1344|  2.93k|
 1345|  2.93k|        rule TriplesSameSubject() -> Vec<TriplePattern> =
 1346|  2.93k|            s:VarOrTerm() _ po:PropertyListNotEmpty() {?
 1347|  2.93k|                let mut patterns = po.patterns;
 1348|  2.93k|                for (p, os) in po.focus {
 1349|  2.93k|                    for o in os {
 1350|  2.93k|                        add_to_triple_patterns(s.clone(), p.clone(), o, &mut patterns)?
 1351|  2.93k|                    }
 1352|  2.93k|                }
 1353|  2.93k|                Ok(patterns)
 1354|  2.93k|            } /
 1355|  2.93k|            s:TriplesNode() _ po:PropertyList() {?
 1356|  2.93k|                let mut patterns = s.patterns;
 1357|  2.93k|                patterns.extend(po.patterns);
 1358|  2.93k|                for (p, os) in po.focus {
 1359|  2.93k|                    for o in os {
 1360|  2.93k|                        add_to_triple_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?
 1361|  2.93k|                    }
 1362|  2.93k|                }
 1363|  2.93k|                Ok(patterns)
 1364|  2.93k|            }
 1365|  2.93k|
 1366|  2.93k|        rule PropertyList() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> =
 1367|  2.93k|            PropertyListNotEmpty() /
 1368|  2.93k|            { FocusedTriplePattern::default() }
 1369|  2.93k|
 1370|  2.93k|        rule PropertyListNotEmpty() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = l:PropertyListNotEmpty_item() **<1,> (";" _) {
 1371|  2.93k|            l.into_iter().fold(FocusedTriplePattern::<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>>::default(), |mut a, b| {
 1372|  2.93k|                a.focus.push(b.focus);
 1373|  2.93k|                a.patterns.extend(b.patterns);
 1374|  2.93k|                a
 1375|  2.93k|            })
 1376|  2.93k|        }
 1377|  2.93k|        rule PropertyListNotEmpty_item() -> FocusedTriplePattern<(NamedNodePattern,Vec<AnnotatedTerm>)> = p:Verb() _ o:ObjectList() _ {
 1378|  2.93k|            FocusedTriplePattern {
 1379|  2.93k|                focus: (p, o.focus),
 1380|  2.93k|                patterns: o.patterns
 1381|  2.93k|            }
 1382|  2.93k|        }
 1383|  2.93k|
 1384|  2.93k|        rule Verb() -> NamedNodePattern = VarOrIri() / "a" { rdf::TYPE.into_owned().into() }
 1385|  2.93k|
 1386|  2.93k|        rule ObjectList() -> FocusedTriplePattern<Vec<AnnotatedTerm>> = o:ObjectList_item() **<1,> ("," _) {
 1387|  2.93k|            o.into_iter().fold(FocusedTriplePattern::<Vec<AnnotatedTerm>>::default(), |mut a, b| {
 1388|  2.93k|                a.focus.push(b.focus);
 1389|  2.93k|                a.patterns.extend_from_slice(&b.patterns);
 1390|  2.93k|                a
 1391|  2.93k|            })
 1392|  2.93k|        }
 1393|  2.93k|        rule ObjectList_item() -> FocusedTriplePattern<AnnotatedTerm> = o:Object() _ { o }
 1394|  2.93k|
 1395|  2.93k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
 1396|  2.93k|            if let Some(a) = a {
 1397|  2.93k|                let mut patterns = g.patterns;
 1398|  2.93k|                patterns.extend(a.patterns);
 1399|  2.93k|                FocusedTriplePattern {
 1400|  2.93k|                    focus: AnnotatedTerm {
 1401|  2.93k|                        term: g.focus,
 1402|  2.93k|                        annotations: a.focus
 1403|  2.93k|                    },
 1404|  2.93k|                    patterns
 1405|  2.93k|                }
 1406|  2.93k|            } else {
 1407|  2.93k|                FocusedTriplePattern {
 1408|  2.93k|                    focus: AnnotatedTerm {
 1409|  2.93k|                        term: g.focus,
 1410|  2.93k|                        annotations: Vec::new()
 1411|  2.93k|                    },
 1412|  2.93k|                    patterns: g.patterns
 1413|  2.93k|                }
 1414|  2.93k|            }
 1415|  2.93k|        }
 1416|  2.93k|
 1417|  2.93k|        rule TriplesSameSubjectPath() -> Vec<TripleOrPathPattern> =
 1418|  2.93k|            s:VarOrTerm() _ po:PropertyListPathNotEmpty() {?
 1419|  2.93k|                let mut patterns = po.patterns;
 1420|  2.93k|                for (p, os) in po.focus {
 1421|  2.93k|                    for o in os {
 1422|  2.93k|                        add_to_triple_or_path_patterns(s.clone(), p.clone(), o, &mut patterns)?;
 1423|  2.93k|                    }
 1424|  2.93k|                }
 1425|  2.93k|                Ok(patterns)
 1426|  2.93k|            } /
 1427|  2.93k|            s:TriplesNodePath() _ po:PropertyListPath() {?
 1428|  2.93k|                let mut patterns = s.patterns;
 1429|  2.93k|                patterns.extend(po.patterns);
 1430|  2.93k|                for (p, os) in po.focus {
 1431|  2.93k|                    for o in os {
 1432|  2.93k|                        add_to_triple_or_path_patterns(s.focus.clone(), p.clone(), o, &mut patterns)?;
 1433|  2.93k|                    }
 1434|  2.93k|                }
 1435|  2.93k|                Ok(patterns)
 1436|  2.93k|            }
 1437|  2.93k|
 1438|  2.93k|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
 1439|  2.93k|            PropertyListPathNotEmpty() /
 1440|  2.93k|            { FocusedTripleOrPathPattern::default() }
 1441|  2.93k|
 1442|  2.93k|        rule PropertyListPathNotEmpty() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = hp:(VerbPath() / VerbSimple()) _ ho:ObjectListPath() _ t:PropertyListPathNotEmpty_item()* {
 1443|  2.93k|                t.into_iter().flatten().fold(FocusedTripleOrPathPattern {
 1444|  2.93k|                    focus: vec![(hp, ho.focus)],
 1445|  2.93k|                    patterns: ho.patterns
 1446|  2.93k|                }, |mut a, b| {
 1447|  2.93k|                    a.focus.push(b.focus);
 1448|  2.93k|                    a.patterns.extend(b.patterns);
 1449|  2.93k|                    a
 1450|  2.93k|                })
 1451|  2.93k|        }
 1452|  2.93k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
 1453|  2.93k|            c
 1454|  2.93k|        }
 1455|  2.93k|        rule PropertyListPathNotEmpty_item_content() -> FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)> = p:(VerbPath() / VerbSimple()) _ o:ObjectListPath() _ {
 1456|  2.93k|            FocusedTripleOrPathPattern {
 1457|  2.93k|                focus: (p, o.focus.into_iter().map(AnnotatedTermPath::from).collect()),
 1458|  2.93k|                patterns: o.patterns
 1459|  2.93k|            }
 1460|  2.93k|        }
 1461|  2.93k|
 1462|  2.93k|        rule VerbPath() -> VariableOrPropertyPath = p:Path() {
 1463|  2.93k|            p.into()
 1464|  2.93k|        }
 1465|  2.93k|
 1466|  2.93k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
 1467|  2.93k|            v.into()
 1468|  2.93k|        }
 1469|  2.93k|
 1470|  2.93k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
 1471|  2.93k|            o.into_iter().fold(FocusedTripleOrPathPattern::<Vec<AnnotatedTermPath>>::default(), |mut a, b| {
 1472|  2.93k|                a.focus.push(b.focus);
 1473|  2.93k|                a.patterns.extend(b.patterns);
 1474|  2.93k|                a
 1475|  2.93k|            })
 1476|  2.93k|        }
 1477|  2.93k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
 1478|  2.93k|
 1479|  2.93k|        rule ObjectPath() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = g:GraphNodePath() _ a:AnnotationPath()? {
 1480|  2.93k|             if let Some(a) = a {
 1481|  2.93k|                let mut patterns = g.patterns;
 1482|  2.93k|                patterns.extend(a.patterns);
 1483|  2.93k|                FocusedTripleOrPathPattern {
 1484|  2.93k|                    focus: AnnotatedTermPath {
 1485|  2.93k|                        term: g.focus,
 1486|  2.93k|                        annotations: a.focus
 1487|  2.93k|                    },
 1488|  2.93k|                    patterns
 1489|  2.93k|                }
 1490|  2.93k|            } else {
 1491|  2.93k|                FocusedTripleOrPathPattern {
 1492|  2.93k|                    focus: AnnotatedTermPath {
 1493|  2.93k|                        term: g.focus,
 1494|  2.93k|                        annotations: Vec::new()
 1495|  2.93k|                    },
 1496|  2.93k|                    patterns: g.patterns
 1497|  2.93k|                }
 1498|  2.93k|            }
 1499|  2.93k|        }
 1500|  2.93k|
 1501|  2.93k|        rule Path() -> PropertyPathExpression = PathAlternative()
 1502|  2.93k|
 1503|  2.93k|        rule PathAlternative() -> PropertyPathExpression = p:PathAlternative_item() **<1,> ("|" _) {?
 1504|  2.93k|            not_empty_fold(p.into_iter(), |a, b| {
 1505|  2.93k|                PropertyPathExpression::Alternative(Box::new(a), Box::new(b))
 1506|  2.93k|            })
 1507|  2.93k|        }
 1508|  2.93k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
 1509|  2.93k|
 1510|  2.93k|        rule PathSequence() -> PropertyPathExpression = p:PathSequence_item() **<1,> ("/" _) {?
 1511|  2.93k|            not_empty_fold(p.into_iter(), |a, b| {
 1512|  2.93k|                PropertyPathExpression::Sequence(Box::new(a), Box::new(b))
 1513|  2.93k|            })
 1514|  2.93k|        }
 1515|  2.93k|        rule PathSequence_item() -> PropertyPathExpression = p:PathEltOrInverse() _ { p }
 1516|  2.93k|
 1517|  2.93k|        rule PathElt() -> PropertyPathExpression = p:PathPrimary() _ o:PathElt_op()? {
 1518|  2.93k|            match o {
 1519|  2.93k|                Some('?') => PropertyPathExpression::ZeroOrOne(Box::new(p)),
 1520|  2.93k|                Some('*') => PropertyPathExpression::ZeroOrMore(Box::new(p)),
 1521|  2.93k|                Some('+') => PropertyPathExpression::OneOrMore(Box::new(p)),
 1522|  2.93k|                Some(_) => unreachable!(),
 1523|  2.93k|                None => p
 1524|  2.93k|            }
 1525|  2.93k|        }
 1526|  2.93k|        rule PathElt_op() -> char =
 1527|  2.93k|            "*" { '*' } /
 1528|  2.93k|            "+" { '+' } /
 1529|  2.93k|            "?" !(['0'..='9'] / PN_CHARS_U()) { '?' } // We mandate that this is not a variable
 1530|  2.93k|
 1531|  2.93k|        rule PathEltOrInverse() -> PropertyPathExpression =
 1532|  2.93k|            "^" _ p:PathElt() { PropertyPathExpression::Reverse(Box::new(p)) } /
 1533|  2.93k|            PathElt()
 1534|  2.93k|
 1535|  2.93k|        rule PathPrimary() -> PropertyPathExpression =
 1536|  2.93k|            v:iri() { v.into() } /
 1537|  2.93k|            "a" { rdf::TYPE.into_owned().into() } /
 1538|  2.93k|            "!" _ p:PathNegatedPropertySet() { p } /
 1539|  2.93k|            "(" _ p:Path() _ ")" { p }
 1540|  2.93k|
 1541|  2.93k|        rule PathNegatedPropertySet() -> PropertyPathExpression =
 1542|  2.93k|            "(" _ p:PathNegatedPropertySet_item() **<1,> ("|" _) ")" {
 1543|  2.93k|                let mut direct = Vec::new();
 1544|  2.93k|                let mut inverse = Vec::new();
 1545|  2.93k|                for e in p {
 1546|  2.93k|                    match e {
 1547|  2.93k|                        Either::Left(a) => direct.push(a),
 1548|  2.93k|                        Either::Right(b) => inverse.push(b)
 1549|  2.93k|                    }
 1550|  2.93k|                }
 1551|  2.93k|                if inverse.is_empty() {
 1552|  2.93k|                    PropertyPathExpression::NegatedPropertySet(direct)
 1553|  2.93k|                } else if direct.is_empty() {
 1554|  2.93k|                   PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse)))
 1555|  2.93k|                } else {
 1556|  2.93k|                    PropertyPathExpression::Alternative(
 1557|  2.93k|                        Box::new(PropertyPathExpression::NegatedPropertySet(direct)),
 1558|  2.93k|                        Box::new(PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(inverse))))
 1559|  2.93k|                    )
 1560|  2.93k|                }
 1561|  2.93k|            } /
 1562|  2.93k|            p:PathOneInPropertySet() {
 1563|  2.93k|                match p {
 1564|  2.93k|                    Either::Left(a) => PropertyPathExpression::NegatedPropertySet(vec![a]),
 1565|  2.93k|                    Either::Right(b) => PropertyPathExpression::Reverse(Box::new(PropertyPathExpression::NegatedPropertySet(vec![b]))),
 1566|  2.93k|                }
 1567|  2.93k|            }
 1568|  2.93k|        rule PathNegatedPropertySet_item() -> Either<NamedNode,NamedNode> = p:PathOneInPropertySet() _ { p }
 1569|  2.93k|
 1570|  2.93k|        rule PathOneInPropertySet() -> Either<NamedNode,NamedNode> =
 1571|  2.93k|            "^" _ v:iri() { Either::Right(v) } /
 1572|  2.93k|            "^" _ "a" { Either::Right(rdf::TYPE.into()) } /
 1573|  2.93k|            v:iri() { Either::Left(v) } /
 1574|  2.93k|            "a" { Either::Left(rdf::TYPE.into()) }
 1575|  2.93k|
 1576|  2.93k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
 1577|  2.93k|
 1578|  2.93k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
 1579|  2.93k|            let mut patterns = po.patterns;
 1580|  2.93k|            let mut bnode = TermPattern::from(BlankNode::default());
 1581|  2.93k|            for (p, os) in po.focus {
 1582|  2.93k|                for o in os {
 1583|  2.93k|                    add_to_triple_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1584|  2.93k|                }
 1585|  2.93k|            }
 1586|  2.93k|            Ok(FocusedTriplePattern {
 1587|  2.93k|                focus: bnode,
 1588|  2.93k|                patterns
 1589|  2.93k|            })
 1590|  2.93k|        }
 1591|  2.93k|
 1592|  2.93k|        rule TriplesNodePath() -> FocusedTripleOrPathPattern<TermPattern> = CollectionPath() / BlankNodePropertyListPath()
 1593|  2.93k|
 1594|  2.93k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
 1595|  2.93k|            let mut patterns = po.patterns;
 1596|  2.93k|            let mut bnode = TermPattern::from(BlankNode::default());
 1597|  2.93k|            for (p, os) in po.focus {
 1598|  2.93k|                for o in os {
 1599|  2.93k|                    add_to_triple_or_path_patterns(bnode.clone(), p.clone(), o, &mut patterns)?;
 1600|  2.93k|                }
 1601|  2.93k|            }
 1602|  2.93k|            Ok(FocusedTripleOrPathPattern {
 1603|  2.93k|                focus: bnode,
 1604|  2.93k|                patterns
 1605|  2.93k|            })
 1606|  2.93k|        }
 1607|  2.93k|
 1608|  2.93k|        rule Collection() -> FocusedTriplePattern<TermPattern> = "(" _ o:Collection_item()+ ")" {
 1609|  2.93k|            let mut patterns: Vec<TriplePattern> = Vec::new();
 1610|  2.93k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1611|  2.93k|            for objWithPatterns in o.into_iter().rev() {
 1612|  2.93k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1613|  2.93k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()));
 1614|  2.93k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node));
 1615|  2.93k|                current_list_node = new_blank_node;
 1616|  2.93k|                patterns.extend_from_slice(&objWithPatterns.patterns);
 1617|  2.93k|            }
 1618|  2.93k|            FocusedTriplePattern {
 1619|  2.93k|                focus: current_list_node,
 1620|  2.93k|                patterns
 1621|  2.93k|            }
 1622|  2.93k|        }
 1623|  2.93k|        rule Collection_item() -> FocusedTriplePattern<TermPattern> = o:GraphNode() _ { o }
 1624|  2.93k|
 1625|  2.93k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
 1626|  2.93k|            let mut patterns: Vec<TripleOrPathPattern> = Vec::new();
 1627|  2.93k|            let mut current_list_node = TermPattern::from(rdf::NIL.into_owned());
 1628|  2.93k|            for objWithPatterns in o.into_iter().rev() {
 1629|  2.93k|                let new_blank_node = TermPattern::from(BlankNode::default());
 1630|  2.93k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::FIRST.into_owned(), objWithPatterns.focus.clone()).into());
 1631|  2.93k|                patterns.push(TriplePattern::new(new_blank_node.clone(), rdf::REST.into_owned(), current_list_node).into());
 1632|  2.93k|                current_list_node = new_blank_node;
 1633|  2.93k|                patterns.extend(objWithPatterns.patterns);
 1634|  2.93k|            }
 1635|  2.93k|            FocusedTripleOrPathPattern {
 1636|  2.93k|                focus: current_list_node,
 1637|  2.93k|                patterns
 1638|  2.93k|            }
 1639|  2.93k|        }
 1640|  2.93k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
 1641|  2.93k|
 1642|  2.93k|
 1643|  2.93k|        rule Annotation() -> FocusedTriplePattern<Vec<(NamedNodePattern,Vec<AnnotatedTerm>)>> = "{|" _ a:PropertyListNotEmpty() _ "|}" { a }
 1644|  2.93k|
 1645|  2.93k|        rule AnnotationPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = "{|" _ a: PropertyListPathNotEmpty() _ "|}" { a }
 1646|  2.93k|
 1647|  2.93k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
 1648|  2.93k|            t:VarOrTerm() { FocusedTriplePattern::new(t) } /
 1649|  2.93k|            TriplesNode()
 1650|  2.93k|
 1651|  2.93k|        rule GraphNodePath() -> FocusedTripleOrPathPattern<TermPattern> =
 1652|  2.93k|            t:VarOrTerm() { FocusedTripleOrPathPattern::new(t) } /
 1653|  2.93k|            TriplesNodePath()
 1654|  2.93k|
 1655|  2.93k|        rule VarOrTerm() -> TermPattern =
 1656|  2.93k|            v:Var() { v.into() } /
 1657|  2.93k|            t:QuotedTriple() {?
 1658|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1659|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1660|  2.93k|            } /
 1661|  2.93k|            t:GraphTerm() { t.into() }
 1662|  2.93k|
 1663|  2.93k|        rule QuotedTriple() -> TriplePattern = "<<" _ s:VarOrTerm() _ p:Verb() _ o:VarOrTerm() _ ">>" {?
 1664|  2.93k|            Ok(TriplePattern {
 1665|  2.93k|                subject: s,
 1666|  2.93k|                predicate: p,
 1667|  2.93k|                object: o
 1668|  2.93k|            })
 1669|  2.93k|        }
 1670|  2.93k|
 1671|  2.93k|        rule QuotedTripleData() -> GroundTriple = "<<" _ s:DataValueTerm() _ p:QuotedTripleData_p() _ o:DataValueTerm() _ ">>" {?
 1672|  2.93k|            Ok(GroundTriple {
 1673|  2.93k|                subject: s.try_into().map_err(|()| "Literals are not allowed in subject position of nested patterns")?,
 1674|  2.93k|                predicate: p,
 1675|  2.93k|                object: o
 1676|  2.93k|            })
 1677|  2.93k|        }
 1678|  2.93k|        rule QuotedTripleData_p() -> NamedNode = i: iri() { i } / "a" { rdf::TYPE.into() }
 1679|  2.93k|
 1680|  2.93k|        rule DataValueTerm() -> GroundTerm = i:iri() { i.into() } /
 1681|  2.93k|            l:RDFLiteral() { l.into() } /
 1682|  2.93k|            l:NumericLiteral() { l.into() } /
 1683|  2.93k|            l:BooleanLiteral() { l.into() } /
 1684|  2.93k|            t:QuotedTripleData() {?
 1685|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(t.into())}
 1686|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1687|  2.93k|            }
 1688|  2.93k|
 1689|  2.93k|        rule VarOrIri() -> NamedNodePattern =
 1690|  2.93k|            v:Var() { v.into() } /
 1691|  2.93k|            i:iri() { i.into() }
 1692|  2.93k|
 1693|  2.93k|        rule Var() -> Variable = name:(VAR1() / VAR2()) { Variable::new_unchecked(name) }
 1694|  2.93k|
 1695|  2.93k|        rule GraphTerm() -> Term =
 1696|  2.93k|            i:iri() { i.into() } /
 1697|  2.93k|            l:RDFLiteral() { l.into() } /
 1698|  2.93k|            l:NumericLiteral() { l.into() } /
 1699|  2.93k|            l:BooleanLiteral() { l.into() } /
 1700|  2.93k|            b:BlankNode() { b.into() } /
 1701|  2.93k|            NIL() { rdf::NIL.into_owned().into() }
 1702|  2.93k|
 1703|  2.93k|        rule Expression() -> Expression = e:ConditionalOrExpression() {e}
 1704|  2.93k|
 1705|  2.93k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
 1706|  2.93k|            not_empty_fold(e.into_iter(), |a, b| Expression::Or(Box::new(a), Box::new(b)))
 1707|  2.93k|        }
 1708|  2.93k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
 1709|  2.93k|
 1710|  2.93k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
 1711|  2.93k|            not_empty_fold(e.into_iter(), |a, b| Expression::And(Box::new(a), Box::new(b)))
 1712|  2.93k|        }
 1713|  2.93k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
 1714|  2.93k|
 1715|  2.93k|        rule ValueLogical() -> Expression = RelationalExpression()
 1716|  2.93k|
 1717|  2.93k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
 1718|  2.93k|            Some(("=", Some(b), None)) => Expression::Equal(Box::new(a), Box::new(b)),
 1719|  2.93k|            Some(("!=", Some(b), None)) => Expression::Not(Box::new(Expression::Equal(Box::new(a), Box::new(b)))),
 1720|  2.93k|            Some((">", Some(b), None)) => Expression::Greater(Box::new(a), Box::new(b)),
 1721|  2.93k|            Some((">=", Some(b), None)) => Expression::GreaterOrEqual(Box::new(a), Box::new(b)),
 1722|  2.93k|            Some(("<", Some(b), None)) => Expression::Less(Box::new(a), Box::new(b)),
 1723|  2.93k|            Some(("<=", Some(b), None)) => Expression::LessOrEqual(Box::new(a), Box::new(b)),
 1724|  2.93k|            Some(("IN", None, Some(l))) => Expression::In(Box::new(a), l),
 1725|  2.93k|            Some(("NOT IN", None, Some(l))) => Expression::Not(Box::new(Expression::In(Box::new(a), l))),
 1726|  2.93k|            Some(_) => unreachable!(),
 1727|  2.93k|            None => a
 1728|  2.93k|        } }
 1729|  2.93k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
 1730|  2.93k|            s: $("="  / "!=" / ">=" / ">" / "<=" / "<") _ e:NumericExpression() { (s, Some(e), None) } /
 1731|  2.93k|            i("IN") _ l:ExpressionList() { ("IN", None, Some(l)) } /
 1732|  2.93k|            i("NOT") _ i("IN") _ l:ExpressionList() { ("NOT IN", None, Some(l)) }
 1733|  2.93k|
 1734|  2.93k|        rule NumericExpression() -> Expression = AdditiveExpression()
 1735|  2.93k|
 1736|  2.93k|        rule AdditiveExpression() -> Expression = a:MultiplicativeExpression() _ o:AdditiveExpression_inner()? { match o {
 1737|  2.93k|            Some(("+", b)) => Expression::Add(Box::new(a), Box::new(b)),
 1738|  2.93k|            Some(("-", b)) => Expression::Subtract(Box::new(a), Box::new(b)),
 1739|  2.93k|            Some(_) => unreachable!(),
 1740|  2.93k|            None => a,
 1741|  2.93k|        } }
 1742|  2.93k|        rule AdditiveExpression_inner() -> (&'input str, Expression) = s: $("+" / "-") _ e:AdditiveExpression() {
 1743|  2.93k|            (s, e)
 1744|  2.93k|        }
 1745|  2.93k|
 1746|  2.93k|        rule MultiplicativeExpression() -> Expression = a:UnaryExpression() _ o: MultiplicativeExpression_inner()? { match o {
 1747|  2.93k|            Some(("*", b)) => Expression::Multiply(Box::new(a), Box::new(b)),
 1748|  2.93k|            Some(("/", b)) => Expression::Divide(Box::new(a), Box::new(b)),
 1749|  2.93k|            Some(_) => unreachable!(),
 1750|  2.93k|            None => a
 1751|  2.93k|        } }
 1752|  2.93k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
 1753|  2.93k|            (s, e)
 1754|  2.93k|        }
 1755|  2.93k|
 1756|  2.93k|        rule UnaryExpression() -> Expression = s: $("!" / "+" / "-")? _ e:PrimaryExpression() { match s {
 1757|  2.93k|            Some("!") => Expression::Not(Box::new(e)),
 1758|  2.93k|            Some("+") => Expression::UnaryPlus(Box::new(e)),
 1759|  2.93k|            Some("-") => Expression::UnaryMinus(Box::new(e)),
 1760|  2.93k|            Some(_) => unreachable!(),
 1761|  2.93k|            None => e,
 1762|  2.93k|        } }
 1763|  2.93k|
 1764|  2.93k|        rule PrimaryExpression() -> Expression =
 1765|  2.93k|            BrackettedExpression()  /
 1766|  2.93k|            ExprQuotedTriple() /
 1767|  2.93k|            iriOrFunction() /
 1768|  2.93k|            v:Var() { v.into() } /
 1769|  2.93k|            l:RDFLiteral() { l.into() } /
 1770|  2.93k|            l:NumericLiteral() { l.into() } /
 1771|  2.93k|            l:BooleanLiteral() { l.into() } /
 1772|  2.93k|            BuiltInCall()
 1773|  2.93k|
 1774|  2.93k|        rule ExprVarOrTerm() -> Expression =
 1775|  2.93k|            ExprQuotedTriple() /
 1776|  2.93k|            i:iri() { i.into() } /
 1777|  2.93k|            l:RDFLiteral() { l.into() } /
 1778|  2.93k|            l:NumericLiteral() { l.into() } /
 1779|  2.93k|            l:BooleanLiteral() { l.into() } /
 1780|  2.93k|            v:Var() { v.into() }
 1781|  2.93k|
 1782|  2.93k|        rule ExprQuotedTriple() -> Expression = "<<" _ s:ExprVarOrTerm() _ p:Verb() _ o:ExprVarOrTerm() _ ">>" {?
 1783|  2.93k|            #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p.into(), o]))}
 1784|  2.93k|            #[cfg(not(feature = "rdf-star"))]{Err("Embedded triples are only available in SPARQL-star")}
 1785|  2.93k|        }
 1786|  2.93k|
 1787|  2.93k|        rule BrackettedExpression() -> Expression = "(" _ e:Expression() _ ")" { e }
 1788|  2.93k|
 1789|  2.93k|        rule BuiltInCall() -> Expression =
 1790|  2.93k|            a:Aggregate() {? state.new_aggregation(a).map(Into::into) } /
 1791|  2.93k|            i("STR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Str, vec![e]) } /
 1792|  2.93k|            i("LANG") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Lang, vec![e]) } /
 1793|  2.93k|            i("LANGMATCHES") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::LangMatches, vec![a, b]) } /
 1794|  2.93k|            i("DATATYPE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Datatype, vec![e]) } /
 1795|  2.93k|            i("BOUND") _ "(" _ v:Var() _ ")" { Expression::Bound(v) } /
 1796|  2.93k|            (i("IRI") / i("URI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Iri, vec![e]) } /
 1797|  2.93k|            i("BNODE") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::BNode, vec![e]) } /
 1798|  2.93k|            i("BNODE") NIL() { Expression::FunctionCall(Function::BNode, vec![]) }  /
 1799|  2.93k|            i("RAND") _ NIL() { Expression::FunctionCall(Function::Rand, vec![]) } /
 1800|  2.93k|            i("ABS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Abs, vec![e]) } /
 1801|  2.93k|            i("CEIL") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Ceil, vec![e]) } /
 1802|  2.93k|            i("FLOOR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Floor, vec![e]) } /
 1803|  2.93k|            i("ROUND") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Round, vec![e]) } /
 1804|  2.93k|            i("CONCAT") e:ExpressionList() { Expression::FunctionCall(Function::Concat, e) } /
 1805|  2.93k|            SubstringExpression() /
 1806|  2.93k|            i("STRLEN") _ "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::StrLen, vec![e]) } /
 1807|  2.93k|            StrReplaceExpression() /
 1808|  2.93k|            i("UCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::UCase, vec![e]) } /
 1809|  2.93k|            i("LCASE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::LCase, vec![e]) } /
 1810|  2.93k|            i("ENCODE_FOR_URI") "(" _ e: Expression() _ ")" { Expression::FunctionCall(Function::EncodeForUri, vec![e]) } /
 1811|  2.93k|            i("CONTAINS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Contains, vec![a, b]) } /
 1812|  2.93k|            i("STRSTARTS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrStarts, vec![a, b]) } /
 1813|  2.93k|            i("STRENDS") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrEnds, vec![a, b]) } /
 1814|  2.93k|            i("STRBEFORE") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrBefore, vec![a, b]) } /
 1815|  2.93k|            i("STRAFTER") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrAfter, vec![a, b]) } /
 1816|  2.93k|            i("YEAR") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Year, vec![e]) } /
 1817|  2.93k|            i("MONTH") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Month, vec![e]) } /
 1818|  2.93k|            i("DAY") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Day, vec![e]) } /
 1819|  2.93k|            i("HOURS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Hours, vec![e]) } /
 1820|  2.93k|            i("MINUTES") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Minutes, vec![e]) } /
 1821|  2.93k|            i("SECONDS") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Seconds, vec![e]) } /
 1822|  2.93k|            i("TIMEZONE") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Timezone, vec![e]) } /
 1823|  2.93k|            i("TZ") _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Tz, vec![e]) } /
 1824|  2.93k|            i("NOW") _ NIL() { Expression::FunctionCall(Function::Now, vec![]) } /
 1825|  2.93k|            i("UUID") _ NIL() { Expression::FunctionCall(Function::Uuid, vec![]) }/
 1826|  2.93k|            i("STRUUID") _ NIL() { Expression::FunctionCall(Function::StrUuid, vec![]) } /
 1827|  2.93k|            i("MD5") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Md5, vec![e]) } /
 1828|  2.93k|            i("SHA1") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha1, vec![e]) } /
 1829|  2.93k|            i("SHA256") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha256, vec![e]) } /
 1830|  2.93k|            i("SHA384") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha384, vec![e]) } /
 1831|  2.93k|            i("SHA512") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::Sha512, vec![e]) } /
 1832|  2.93k|            i("COALESCE") e:ExpressionList() { Expression::Coalesce(e) } /
 1833|  2.93k|            i("IF") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::If(Box::new(a), Box::new(b), Box::new(c)) } /
 1834|  2.93k|            i("STRLANG") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrLang, vec![a, b]) }  /
 1835|  2.93k|            i("STRDT") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::StrDt, vec![a, b]) } /
 1836|  2.93k|            i("sameTerm") "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::SameTerm(Box::new(a), Box::new(b)) } /
 1837|  2.93k|            (i("isIRI") / i("isURI")) _ "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsIri, vec![e]) } /
 1838|  2.93k|            i("isBLANK") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsBlank, vec![e]) } /
 1839|  2.93k|            i("isLITERAL") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsLiteral, vec![e]) } /
 1840|  2.93k|            i("isNUMERIC") "(" _ e:Expression() _ ")" { Expression::FunctionCall(Function::IsNumeric, vec![e]) } /
 1841|  2.93k|            RegexExpression() /
 1842|  2.93k|            ExistsFunc() /
 1843|  2.93k|            NotExistsFunc() /
 1844|  2.93k|            i("TRIPLE") "(" _ s:Expression() _ "," _ p:Expression() "," _ o:Expression() ")" {?
 1845|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Triple, vec![s, p, o]))}
 1846|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("The TRIPLE function is only available in SPARQL-star")}
 1847|  2.93k|            } /
 1848|  2.93k|            i("SUBJECT") "(" _ e:Expression() _ ")" {?
 1849|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Subject, vec![e]))}
 1850|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("The SUBJECT function is only available in SPARQL-star")}
 1851|  2.93k|            } /
 1852|  2.93k|            i("PREDICATE") "(" _ e:Expression() _ ")" {?
 1853|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Predicate, vec![e]))}
 1854|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("The PREDICATE function is only available in SPARQL-star")}
 1855|  2.93k|            } /
 1856|  2.93k|            i("OBJECT") "(" _ e:Expression() _ ")" {?
 1857|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::Object, vec![e]))}
 1858|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("The OBJECT function is only available in SPARQL-star")}
 1859|  2.93k|            } /
 1860|  2.93k|            i("isTriple") "(" _ e:Expression() _ ")" {?
 1861|  2.93k|                #[cfg(feature = "rdf-star")]{Ok(Expression::FunctionCall(Function::IsTriple, vec![e]))}
 1862|  2.93k|                #[cfg(not(feature = "rdf-star"))]{Err("The isTriple function is only available in SPARQL-star")}
 1863|  2.93k|            } /
 1864|  2.93k|            i("ADJUST") "("  _ a:Expression() _ "," _ b:Expression() _ ")" {?
 1865|  2.93k|                #[cfg(feature = "sep-0002")]{Ok(Expression::FunctionCall(Function::Adjust, vec![a, b]))}
 1866|  2.93k|                #[cfg(not(feature = "sep-0002"))]{Err("The ADJUST function is only available in SPARQL 1.2 SEP 0002")}
 1867|  2.93k|            }
 1868|  2.93k|
 1869|  2.93k|        rule RegexExpression() -> Expression =
 1870|  2.93k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b, c]) } /
 1871|  2.93k|            i("REGEX") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::Regex, vec![a, b]) }
 1872|  2.93k|
 1873|  2.93k|
 1874|  2.93k|        rule SubstringExpression() -> Expression =
 1875|  2.93k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b, c]) } /
 1876|  2.93k|            i("SUBSTR") _ "(" _ a:Expression() _ "," _ b:Expression() _ ")" { Expression::FunctionCall(Function::SubStr, vec![a, b]) }
 1877|  2.93k|
 1878|  2.93k|
 1879|  2.93k|        rule StrReplaceExpression() -> Expression =
 1880|  2.93k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ "," _ d:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c, d]) } /
 1881|  2.93k|            i("REPLACE") _ "(" _ a:Expression() _ "," _ b:Expression() _ "," _ c:Expression() _ ")" { Expression::FunctionCall(Function::Replace, vec![a, b, c]) }
 1882|  2.93k|
 1883|  2.93k|        rule ExistsFunc() -> Expression = i("EXISTS") _ p:GroupGraphPattern() { Expression::Exists(Box::new(p)) }
 1884|  2.93k|
 1885|  2.93k|        rule NotExistsFunc() -> Expression = i("NOT") _ i("EXISTS") _ p:GroupGraphPattern() { Expression::Not(Box::new(Expression::Exists(Box::new(p)))) }
 1886|  2.93k|
 1887|  2.93k|        rule Aggregate() -> AggregateExpression =
 1888|  2.93k|            i("COUNT") _ "(" _ i("DISTINCT") _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: true } } /
 1889|  2.93k|            i("COUNT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: true } } /
 1890|  2.93k|            i("COUNT") _ "(" _ "*" _ ")" { AggregateExpression::CountSolutions { distinct: false } } /
 1891|  2.93k|            i("COUNT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Count, expr, distinct: false } } /
 1892|  2.93k|            i("SUM") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: true } } /
 1893|  2.93k|            i("SUM") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sum, expr, distinct: false } } /
 1894|  2.93k|            i("MIN") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: true } } /
 1895|  2.93k|            i("MIN") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Min, expr, distinct: false } } /
 1896|  2.93k|            i("MAX") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: true } } /
 1897|  2.93k|            i("MAX") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Max, expr, distinct: false } } /
 1898|  2.93k|            i("AVG") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: true } } /
 1899|  2.93k|            i("AVG") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Avg, expr, distinct: false } } /
 1900|  2.93k|            i("SAMPLE") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: true } } /
 1901|  2.93k|            i("SAMPLE") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Sample, expr, distinct: false } } /
 1902|  2.93k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1903|  2.93k|            i("GROUP_CONCAT") _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: true } } /
 1904|  2.93k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ";" _ i("SEPARATOR") _ "=" _ s:String() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: Some(s) }, expr, distinct: true } } /
 1905|  2.93k|            i("GROUP_CONCAT") _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::GroupConcat { separator: None }, expr, distinct: false } } /
 1906|  2.93k|            name:iri() _ "(" _ i("DISTINCT") _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: true } } /
 1907|  2.93k|            name:iri() _ "(" _ expr:Expression() _ ")" { AggregateExpression::FunctionCall { name: AggregateFunction::Custom(name), expr, distinct: false } }
 1908|  2.93k|
 1909|  2.93k|        rule iriOrFunction() -> Expression = i: iri() _ a: ArgList()? {
 1910|  2.93k|            match a {
 1911|  2.93k|                Some(a) => Expression::FunctionCall(Function::Custom(i), a),
 1912|  2.93k|                None => i.into()
 1913|  2.93k|            }
 1914|  2.93k|        }
 1915|  2.93k|
 1916|  2.93k|        rule RDFLiteral() -> Literal =
 1917|  2.93k|            value:String() _ "^^" _ datatype:iri() { Literal::new_typed_literal(value, datatype) } /
 1918|  2.93k|            value:String() _ language:LANGTAG() { Literal::new_language_tagged_literal_unchecked(value, language.into_inner()) } /
 1919|  2.93k|            value:String() { Literal::new_simple_literal(value) }
 1920|  2.93k|
 1921|  2.93k|        rule NumericLiteral() -> Literal  = NumericLiteralUnsigned() / NumericLiteralPositive() / NumericLiteralNegative()
 1922|  2.93k|
 1923|  2.93k|        rule NumericLiteralUnsigned() -> Literal =
 1924|  2.93k|            d:$(DOUBLE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1925|  2.93k|            d:$(DECIMAL()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1926|  2.93k|            i:$(INTEGER()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1927|  2.93k|
 1928|  2.93k|        rule NumericLiteralPositive() -> Literal =
 1929|  2.93k|            d:$(DOUBLE_POSITIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1930|  2.93k|            d:$(DECIMAL_POSITIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1931|  2.93k|            i:$(INTEGER_POSITIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1932|  2.93k|
 1933|  2.93k|
 1934|  2.93k|        rule NumericLiteralNegative() -> Literal =
 1935|  2.93k|            d:$(DOUBLE_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DOUBLE) } /
 1936|  2.93k|            d:$(DECIMAL_NEGATIVE()) { Literal::new_typed_literal(d, xsd::DECIMAL) } /
 1937|  2.93k|            i:$(INTEGER_NEGATIVE()) { Literal::new_typed_literal(i, xsd::INTEGER) }
 1938|  2.93k|
 1939|  2.93k|        rule BooleanLiteral() -> Literal =
 1940|  2.93k|            "true" { Literal::new_typed_literal("true", xsd::BOOLEAN) } /
 1941|  2.93k|            "false" { Literal::new_typed_literal("false", xsd::BOOLEAN) }
 1942|  2.93k|
 1943|  2.93k|        rule String() -> String = STRING_LITERAL_LONG1() / STRING_LITERAL_LONG2() / STRING_LITERAL1() / STRING_LITERAL2()
 1944|  2.93k|
 1945|  2.93k|        rule iri() -> NamedNode = i:(IRIREF() / PrefixedName()) {
 1946|  2.93k|            NamedNode::from(i)
 1947|  2.93k|        }
 1948|  2.93k|
 1949|  2.93k|        rule PrefixedName() -> Iri<String> = PNAME_LN() /
 1950|  2.93k|            ns:PNAME_NS() {? if let Some(iri) = state.namespaces.get(ns).cloned() {
 1951|  2.93k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1952|  2.93k|            } else {
 1953|  2.93k|                Err("Prefix not found")
 1954|  2.93k|            } }
 1955|  2.93k|
 1956|  2.93k|        rule BlankNode() -> BlankNode = id:BLANK_NODE_LABEL() {?
 1957|  2.93k|            let node = BlankNode::new_unchecked(id);
 1958|  2.93k|            if state.used_bnodes.contains(&node) {
 1959|  2.93k|                Err("Already used blank node id")
 1960|  2.93k|            } else {
 1961|  2.93k|                state.currently_used_bnodes.insert(node.clone());
 1962|  2.93k|                Ok(node)
 1963|  2.93k|            }
 1964|  2.93k|        } / ANON() { BlankNode::default() }
 1965|  2.93k|
 1966|  2.93k|        rule IRIREF() -> Iri<String> = "<" i:$((!['>'] [_])*) ">" {?
 1967|  2.93k|            state.parse_iri(unescape_iriref(i)?).map_err(|_| "IRI parsing failed")
 1968|  2.93k|        }
 1969|  2.93k|
 1970|  2.93k|        rule PNAME_NS() -> &'input str = ns:$(PN_PREFIX()?) ":" {
 1971|  2.93k|            ns
 1972|  2.93k|        }
 1973|  2.93k|
 1974|  2.93k|        rule PNAME_LN() -> Iri<String> = ns:PNAME_NS() local:$(PN_LOCAL()) {?
 1975|  2.93k|            if let Some(base) = state.namespaces.get(ns) {
 1976|  2.93k|                let mut iri = String::with_capacity(base.len() + local.len());
 1977|  2.93k|                iri.push_str(base);
 1978|  2.93k|                for chunk in local.split('\\') { // We remove \
 1979|  2.93k|                    iri.push_str(chunk);
 1980|  2.93k|                }
 1981|  2.93k|                Iri::parse(iri).map_err(|_| "IRI parsing failed")
 1982|  2.93k|            } else {
 1983|  2.93k|                Err("Prefix not found")
 1984|  2.93k|            }
 1985|  2.93k|        }
 1986|  2.93k|
 1987|  2.93k|        rule BLANK_NODE_LABEL() -> &'input str = "_:" b:$((['0'..='9'] / PN_CHARS_U()) PN_CHARS()* ("."+ PN_CHARS()+)*) {
 1988|  2.93k|            b
 1989|  2.93k|        }
 1990|  2.93k|
 1991|  2.93k|        rule VAR1() -> &'input str = "?" v:$(VARNAME()) { v }
 1992|  2.93k|
 1993|  2.93k|        rule VAR2() -> &'input str = "$" v:$(VARNAME()) { v }
 1994|  2.93k|
 1995|  2.93k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
 1996|  2.93k|            LanguageTag::parse(l.to_ascii_lowercase()).map_err(|_| "language tag parsing failed")
 1997|  2.93k|        }
 1998|  2.93k|
 1999|  2.93k|        rule INTEGER() = ['0'..='9']+
 2000|  2.93k|
 2001|  2.93k|        rule DECIMAL() = ['0'..='9']* "." ['0'..='9']+
 2002|  2.93k|
 2003|  2.93k|        rule DOUBLE() = (['0'..='9']+ "." ['0'..='9']* / "." ['0'..='9']+ / ['0'..='9']+) EXPONENT()
 2004|  2.93k|
 2005|  2.93k|        rule INTEGER_POSITIVE() = "+" _ INTEGER()
 2006|  2.93k|
 2007|  2.93k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
 2008|  2.93k|
 2009|  2.93k|        rule DOUBLE_POSITIVE() = "+" _ DOUBLE()
 2010|  2.93k|
 2011|  2.93k|        rule INTEGER_NEGATIVE() = "-" _ INTEGER()
 2012|  2.93k|
 2013|  2.93k|        rule DECIMAL_NEGATIVE() = "-" _ DECIMAL()
 2014|  2.93k|
 2015|  2.93k|        rule DOUBLE_NEGATIVE() = "-" _ DOUBLE()
 2016|  2.93k|
 2017|  2.93k|        rule EXPONENT() = ['e' | 'E'] ['+' | '-']? ['0'..='9']+
 2018|  2.93k|
 2019|  2.93k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
 2020|  2.93k|             unescape_string(l)
 2021|  2.93k|        }
 2022|  2.93k|        rule STRING_LITERAL1_simple_char() = !['\u{27}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2023|  2.93k|
 2024|  2.93k|
 2025|  2.93k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
 2026|  2.93k|             unescape_string(l)
 2027|  2.93k|        }
 2028|  2.93k|        rule STRING_LITERAL2_simple_char() = !['\u{22}' | '\u{5C}' | '\u{0A}' | '\u{0D}'] [_]
 2029|  2.93k|
 2030|  2.93k|        rule STRING_LITERAL_LONG1() -> String = "'''" l:$(STRING_LITERAL_LONG1_inner()*) "'''" {?
 2031|  2.93k|             unescape_string(l)
 2032|  2.93k|        }
 2033|  2.93k|        rule STRING_LITERAL_LONG1_inner() = ("''" / "'")? (STRING_LITERAL_LONG1_simple_char() / ECHAR() / UCHAR())
 2034|  2.93k|        rule STRING_LITERAL_LONG1_simple_char() = !['\'' | '\\'] [_]
 2035|  2.93k|
 2036|  2.93k|        rule STRING_LITERAL_LONG2() -> String = "\"\"\"" l:$(STRING_LITERAL_LONG2_inner()*) "\"\"\"" {?
 2037|  2.93k|             unescape_string(l)
 2038|  2.93k|        }
 2039|  2.93k|        rule STRING_LITERAL_LONG2_inner() = ("\"\"" / "\"")? (STRING_LITERAL_LONG2_simple_char() / ECHAR() / UCHAR())
 2040|  2.93k|        rule STRING_LITERAL_LONG2_simple_char() = !['"' | '\\'] [_]
 2041|  2.93k|
 2042|  2.93k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
 2043|  2.93k|
 2044|  2.93k|        rule ECHAR() = "\\" ['t' | 'b' | 'n' | 'r' | 'f' | '"' |'\'' | '\\']
 2045|  2.93k|
 2046|  2.93k|        rule NIL() = "(" WS()* ")"
 2047|  2.93k|
 2048|  2.93k|        rule WS() = quiet! { ['\u{20}' | '\u{09}' | '\u{0D}' | '\u{0A}'] }
 2049|  2.93k|
 2050|  2.93k|        rule ANON() = "[" WS()* "]"
 2051|  2.93k|
 2052|  2.93k|        rule PN_CHARS_BASE() = ['A' ..= 'Z' | 'a' ..= 'z' | '\u{00C0}'..='\u{00D6}' | '\u{00D8}'..='\u{00F6}' | '\u{00F8}'..='\u{02FF}' | '\u{0370}'..='\u{037D}' | '\u{037F}'..='\u{1FFF}' | '\u{200C}'..='\u{200D}' | '\u{2070}'..='\u{218F}' | '\u{2C00}'..='\u{2FEF}' | '\u{3001}'..='\u{D7FF}' | '\u{F900}'..='\u{FDCF}' | '\u{FDF0}'..='\u{FFFD}']
 2053|  2.93k|
 2054|  2.93k|        rule PN_CHARS_U() = ['_'] / PN_CHARS_BASE()
 2055|  2.93k|
 2056|  2.93k|        rule VARNAME() = (['0'..='9'] / PN_CHARS_U()) (['0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U())*
 2057|  2.93k|
 2058|  2.93k|        rule PN_CHARS() = ['-' | '0' ..= '9' | '\u{00B7}' | '\u{0300}'..='\u{036F}' | '\u{203F}'..='\u{2040}'] / PN_CHARS_U()
 2059|  2.93k|
 2060|  2.93k|        rule PN_PREFIX() = PN_CHARS_BASE() PN_CHARS()* ("."+ PN_CHARS()+)*
 2061|  2.93k|
 2062|  2.93k|        rule PN_LOCAL() = (PN_CHARS_U() / [':' | '0'..='9'] / PLX()) (PN_CHARS() / [':'] / PLX())* (['.']+ (PN_CHARS() / [':'] / PLX())+)?
 2063|  2.93k|
 2064|  2.93k|        rule PLX() = PERCENT() / PN_LOCAL_ESC()
 2065|  2.93k|
 2066|  2.93k|        rule PERCENT() = ['%'] HEX() HEX()
 2067|  2.93k|
 2068|  2.93k|        rule HEX() = ['0' ..= '9' | 'A' ..= 'F' | 'a' ..= 'f']
 2069|  2.93k|
 2070|  2.93k|        rule PN_LOCAL_ESC() = ['\\'] ['_' | '~' | '.' | '-' | '!' | '$' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%'] //TODO: added '/' to make tests pass but is it valid?
 2071|  2.93k|
 2072|  2.93k|        //space
 2073|  2.93k|        rule _() = quiet! { ([' ' | '\t' | '\n' | '\r'] / comment())* }
 2074|  2.93k|
 2075|  2.93k|        //comment
 2076|  2.93k|        rule comment() = quiet! { ['#'] (!['\r' | '\n'] [_])* }
 2077|  2.93k|
 2078|  2.93k|        rule i(literal: &'static str) = input: $([_]*<{literal.len()}>) {?
 2079|  2.93k|            if input.eq_ignore_ascii_case(literal) {
 2080|  2.93k|                Ok(())
 2081|  2.93k|            } else {
 2082|  2.93k|                Err(literal)
 2083|  2.93k|            }
 2084|  2.93k|        }
 2085|  2.93k|    }
 2086|  2.93k|}
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_HavingClause:
  942|  1.76k|        rule HavingClause() -> Expression = i("HAVING") _ e:HavingCondition()+ {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_SelectClause:
  811|  1.98k|        rule SelectClause() -> Selection = i("SELECT") _ Selection_init() o:SelectClause_option() _ v:SelectClause_variables() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_BooleanLiteral:
 1939|  45.5k|        rule BooleanLiteral() -> Literal =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_ObjectListPath_item:
 1477|  15.0k|        rule ObjectListPath_item() -> FocusedTripleOrPathPattern<AnnotatedTermPath> = o:ObjectPath() _ { o }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_Constraint:
 1322|     47|        rule Constraint() -> Expression = BrackettedExpression() / FunctionCall() / BuiltInCall()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_PathAlternative_item:
 1508|  35.7k|        rule PathAlternative_item() -> PropertyPathExpression = p:PathSequence() _ { p }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ExpressionList:
 1333|  1.73k|        rule ExpressionList() -> Vec<Expression> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_TriplesBlock:
 1242|  6.17k|        rule TriplesBlock() -> Vec<TripleOrPathPattern> = hs:TriplesBlock_inner() ++ (".") ("." _)? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_InlineData:
 1274|  5.40k|        rule InlineData() -> PartialGraphPattern = i("VALUES") _ p:DataBlock() { PartialGraphPattern::Other(p) }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_VerbSimple:
 1466|  10.2k|        rule VerbSimple() -> VariableOrPropertyPath = v:Var() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_ArgList:
 1328|    730|        rule ArgList() -> Vec<Expression> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_ConditionalAndExpression_item:
 1713|  3.91k|        rule ConditionalAndExpression_item() -> Expression = e:ValueLogical() _ { e }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_CollectionPath:
 1625|  17.5k|        rule CollectionPath() -> FocusedTripleOrPathPattern<TermPattern> = "(" _ o:CollectionPath_item()+ _ ")" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser38___parse_MultiplicativeExpression_inner:
 1752|  11.4k|        rule MultiplicativeExpression_inner() -> (&'input str, Expression) = s: $("*" / "/") _ e:MultiplicativeExpression() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser17___parse_GraphNode:
 1647|  17.0k|        rule GraphNode() -> FocusedTriplePattern<TermPattern> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser36___parse_ConditionalOrExpression_item:
 1708|  3.51k|        rule ConditionalOrExpression_item() -> Expression = e:ConditionalAndExpression() _ { e }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser28___parse_RelationalExpression:
 1717|  3.91k|        rule RelationalExpression() -> Expression = a:NumericExpression() _ o: RelationalExpression_inner()? { match o {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_DeleteWhere:
 1033|  5.22k|        rule DeleteWhere() -> Vec<GraphUpdateOperation> = i("DELETE") _ i("WHERE") _ d:QuadPattern() {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_DECIMAL_POSITIVE:
 2007|  45.5k|        rule DECIMAL_POSITIVE() = "+" _ DECIMAL()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroupCondition:
  935|    426|        rule GroupCondition() -> (Expression, Option<Variable>) =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_STRING_LITERAL1:
 2019|   155k|        rule STRING_LITERAL1() -> String = "'" l:$((STRING_LITERAL1_simple_char() / ECHAR() / UCHAR())*) "'" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser18___parse_PrefixDecl:
  795|  2.93k|        rule PrefixDecl() = i("PREFIX") _ ns:PNAME_NS() _ i:IRIREF() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser15___parse_LANGTAG:
 1995|  2.34k|        rule LANGTAG() -> LanguageTag<String> = "@" l:$(['a' ..= 'z' | 'A' ..= 'Z']+ ("-" ['a' ..= 'z' | 'A' ..= 'Z' | '0' ..= '9']+)*) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_Selection_init:
  817|  1.94k|        rule Selection_init() = {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser13___parse_UCHAR:
 2042|  5.26k|        rule UCHAR() = "\\u" HEX() HEX() HEX() HEX() / "\\U" HEX() HEX() HEX() HEX() HEX() HEX() HEX() HEX()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_SelectClause_member:
  827|  2.59k|        rule SelectClause_member() -> SelectionMember =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_DataBlockValue:
 1296|  5.51k|        rule DataBlockValue() -> Option<GroundTerm> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_TriplesTemplate:
 1167|  37.1k|        rule TriplesTemplate() -> Vec<TriplePattern> = ts:TriplesTemplate_inner() ++ (".") ("." _)? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_GroupClause:
  920|  1.76k|        rule GroupClause() -> (Vec<Variable>, Vec<(Expression,Variable)>) = i("GROUP") _ i("BY") _ c:GroupCondition_item()+ {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Modify:
 1051|  4.86k|        rule Modify() -> Vec<GraphUpdateOperation> = with:Modify_with()? _ Modify_clear() c:Modify_clauses() _ u:(UsingClause() ** (_)) _ i("WHERE") _ pattern:GroupGraphPattern() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser26___parse_TriplesBlock_inner:
 1245|  6.24k|        rule TriplesBlock_inner() -> Vec<TripleOrPathPattern> = _ h:TriplesSameSubjectPath() _ { h }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_Modify_clear:
 1114|  4.86k|        rule Modify_clear() = {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser23___parse_STRING_LITERAL2:
 2025|   155k|        rule STRING_LITERAL2() -> String = "\"" l:$((STRING_LITERAL2_simple_char() / ECHAR() / UCHAR())*) "\"" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_InlineDataOneVar:
 1280|    248|        rule InlineDataOneVar() -> (Vec<Variable>, Vec<Vec<Option<GroundTerm>>>) = var:Var() _ "{" _ d:InlineDataOneVar_value()* "}" {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_BlankNodePropertyList:
 1578|  22.3k|        rule BlankNodePropertyList() -> FocusedTriplePattern<TermPattern> = "[" _ po:PropertyListNotEmpty() _ "]" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_GroundQuadData:
 1151|     75|        rule GroundQuadData() -> Vec<GroundQuad> = "{" _ q:Quads() _ "}" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser37___parse_PropertyListPathNotEmpty_item:
 1452|  11.7k|        rule PropertyListPathNotEmpty_item() -> Option<FocusedTripleOrPathPattern<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> = ";" _ c:PropertyListPathNotEmpty_item_content()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser29___parse_Quads_QuadsNotTriples:
 1161|  20.2k|        rule Quads_QuadsNotTriples() -> Vec<QuadPattern> = q:QuadsNotTriples() _ "."? { q }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser22___parse_ObjectListPath:
 1470|  11.5k|        rule ObjectListPath() -> FocusedTripleOrPathPattern<Vec<AnnotatedTermPath>> = o:ObjectListPath_item() **<1,> ("," _) {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_Modify_with:
 1108|  4.86k|        rule Modify_with() -> NamedNode = i("WITH") _ i:iri() _ { i }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser20___parse_ValueLogical:
 1715|  3.91k|        rule ValueLogical() -> Expression = RelationalExpression()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser33___parse_BlankNodePropertyListPath:
 1594|  16.0k|        rule BlankNodePropertyListPath() -> FocusedTripleOrPathPattern<TermPattern> = "[" _ po:PropertyListPathNotEmpty() _ "]" {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser24___parse_PropertyListPath:
 1438|    626|        rule PropertyListPath() -> FocusedTripleOrPathPattern<Vec<(VariableOrPropertyPath,Vec<AnnotatedTermPath>)>> =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser27___parse_CollectionPath_item:
 1640|  4.45k|        rule CollectionPath_item() -> FocusedTripleOrPathPattern<TermPattern> = p:GraphNodePath() _ { p }
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser32___parse_ConditionalAndExpression:
 1710|  3.51k|        rule ConditionalAndExpression() -> Expression = e:ConditionalAndExpression_item() **<1,> ("&&" _) {?
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser19___parse_TriplesNode:
 1576|  22.3k|        rule TriplesNode() -> FocusedTriplePattern<TermPattern> = Collection() / BlankNodePropertyList()
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser14___parse_Object:
 1395|  17.0k|        rule Object() -> FocusedTriplePattern<AnnotatedTerm> = g:GraphNode() _ a:Annotation()? {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser34___parse_RelationalExpression_inner:
 1729|  2.89k|        rule RelationalExpression_inner() -> (&'input str, Option<Expression>, Option<Vec<Expression>>) =
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser12___parse_Copy:
 1015|  5.83k|        rule Copy() -> Vec<GraphUpdateOperation> = i("COPY") _ silent:Update1_silent() _ from:GraphOrDefault() _ i("TO") _ to:GraphOrDefault() {
_RNvNtNtCshSv3hUzq9FP_9spargebra6parser6parser31___parse_ConditionalOrExpression:
 1705|  3.45k|        rule ConditionalOrExpression() -> Expression = e:ConditionalOrExpression_item() **<1,> ("||" _) {?
_RNvXsp_NtCshSv3hUzq9FP_9spargebra6parserINtB5_26FocusedTripleOrPathPatternINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtB5_17AnnotatedTermPathEENtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
  272|  11.5k|#[derive(Debug, Default)]
_RNCNvNtCshSv3hUzq9FP_9spargebra6parser12parse_update0B5_:
   27|    217|        .map_err(|e| SparqlSyntaxError(ParseErrorKind::Syntax(e)))?;
_RINvNtCshSv3hUzq9FP_9spargebra6parser37add_triple_to_triple_or_path_patternsNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeEB4_:
  186|  1.80k|fn add_triple_to_triple_or_path_patterns(
  187|  1.80k|    subject: TermPattern,
  188|  1.80k|    predicate: impl Into<NamedNodePattern>,
  189|  1.80k|    object: AnnotatedTermPath,
  190|  1.80k|    patterns: &mut Vec<TripleOrPathPattern>,
  191|  1.80k|) -> Result<(), &'static str> {
  192|  1.80k|    let triple = TriplePattern::new(subject, predicate, object.term);
  193|       |    #[cfg(feature = "rdf-star")]
  194|  1.80k|    for (p, os) in object.annotations {
  195|      0|        for o in os {
  196|      0|            add_to_triple_or_path_patterns(triple.clone().into(), p.clone(), o, patterns)?
  197|       |        }
  198|       |    }
  199|       |    #[cfg(not(feature = "rdf-star"))]
  200|       |    if !object.annotations.is_empty() {
  201|       |        return Err("Embedded triples are only available in SPARQL-star");
  202|       |    }
  203|  1.80k|    patterns.push(triple.into());
  204|  1.80k|    Ok(())
  205|  1.80k|}
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser31___parse_ConditionalOrExpression00EB4_:
  346|  2.42k|fn not_empty_fold<T>(
  347|  2.42k|    iter: impl Iterator<Item = T>,
  348|  2.42k|    combine: impl Fn(T, T) -> T,
  349|  2.42k|) -> Result<T, &'static str> {
  350|  2.42k|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|  2.42k|    })
  354|  2.42k|    .ok_or("The iterator should not be empty")
  355|  2.42k|}
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra22PropertyPathExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser20___parse_PathSequence00EB4_:
  346|  25.5k|fn not_empty_fold<T>(
  347|  25.5k|    iter: impl Iterator<Item = T>,
  348|  25.5k|    combine: impl Fn(T, T) -> T,
  349|  25.5k|) -> Result<T, &'static str> {
  350|  25.5k|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|  25.5k|    })
  354|  25.5k|    .ok_or("The iterator should not be empty")
  355|  25.5k|}
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser31___parse_ConditionalOrExpression00E0B6_:
  350|  2.49k|    iter.fold(None, |a, b| match a {
  351|     63|        Some(av) => Some(combine(av, b)),
  352|  2.42k|        None => Some(b),
  353|  2.49k|    })
_RINvNtCshSv3hUzq9FP_9spargebra6parser37add_triple_to_triple_or_path_patternsNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableEB4_:
  186|  11.7k|fn add_triple_to_triple_or_path_patterns(
  187|  11.7k|    subject: TermPattern,
  188|  11.7k|    predicate: impl Into<NamedNodePattern>,
  189|  11.7k|    object: AnnotatedTermPath,
  190|  11.7k|    patterns: &mut Vec<TripleOrPathPattern>,
  191|  11.7k|) -> Result<(), &'static str> {
  192|  11.7k|    let triple = TriplePattern::new(subject, predicate, object.term);
  193|       |    #[cfg(feature = "rdf-star")]
  194|  11.7k|    for (p, os) in object.annotations {
  195|      0|        for o in os {
  196|      0|            add_to_triple_or_path_patterns(triple.clone().into(), p.clone(), o, patterns)?
  197|       |        }
  198|       |    }
  199|       |    #[cfg(not(feature = "rdf-star"))]
  200|       |    if !object.annotations.is_empty() {
  201|       |        return Err("Embedded triples are only available in SPARQL-star");
  202|       |    }
  203|  11.7k|    patterns.push(triple.into());
  204|  11.7k|    Ok(())
  205|  11.7k|}
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra22PropertyPathExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser23___parse_PathAlternative00EB4_:
  346|  23.9k|fn not_empty_fold<T>(
  347|  23.9k|    iter: impl Iterator<Item = T>,
  348|  23.9k|    combine: impl Fn(T, T) -> T,
  349|  23.9k|) -> Result<T, &'static str> {
  350|  23.9k|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|  23.9k|    })
  354|  23.9k|    .ok_or("The iterator should not be empty")
  355|  23.9k|}
_RNCNvNtCshSv3hUzq9FP_9spargebra6parser12build_selects_0B5_:
  486|  7.91k|            p.on_in_scope_variable(|v| {
  487|  7.91k|                if !pv.contains(v) {
  488|  1.54k|                    pv.push(v.clone());
  489|  6.36k|                }
  490|  7.91k|            });
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser20___parse_HavingClause00E0B6_:
  350|     22|    iter.fold(None, |a, b| match a {
  351|      0|        Some(av) => Some(combine(av, b)),
  352|     22|        None => Some(b),
  353|     22|    })
_RINvNtCshSv3hUzq9FP_9spargebra6parser30add_to_triple_or_path_patternsNtNtB4_7algebra22PropertyPathExpressionEB4_:
  124|  22.6k|fn add_to_triple_or_path_patterns(
  125|  22.6k|    subject: TermPattern,
  126|  22.6k|    predicate: impl Into<VariableOrPropertyPath>,
  127|  22.6k|    object: AnnotatedTermPath,
  128|  22.6k|    patterns: &mut Vec<TripleOrPathPattern>,
  129|  22.6k|) -> Result<(), &'static str> {
  130|  22.6k|    match predicate.into() {
  131|      0|        VariableOrPropertyPath::Variable(p) => {
  132|      0|            add_triple_to_triple_or_path_patterns(subject, p, object, patterns)?;
  133|       |        }
  134|  22.6k|        VariableOrPropertyPath::PropertyPath(p) => match p {
  135|  1.35k|            PropertyPathExpression::NamedNode(p) => {
  136|  1.35k|                add_triple_to_triple_or_path_patterns(subject, p, object, patterns)?;
  137|       |            }
  138|  10.3k|            PropertyPathExpression::Reverse(p) => add_to_triple_or_path_patterns(
  139|  10.3k|                object.term,
  140|  10.3k|                *p,
  141|  10.3k|                AnnotatedTermPath {
  142|  10.3k|                    term: subject,
  143|  10.3k|                    annotations: object.annotations,
  144|  10.3k|                },
  145|  10.3k|                patterns,
  146|  10.3k|            )?,
  147|  4.45k|            PropertyPathExpression::Sequence(a, b) => {
  148|  4.45k|                if !object.annotations.is_empty() {
  149|      0|                    return Err("Annotations are not allowed on property paths");
  150|  4.45k|                }
  151|  4.45k|                let middle = BlankNode::default();
  152|  4.45k|                add_to_triple_or_path_patterns(
  153|  4.45k|                    subject,
  154|  4.45k|                    *a,
  155|  4.45k|                    AnnotatedTermPath {
  156|  4.45k|                        term: middle.clone().into(),
  157|  4.45k|                        annotations: Vec::new(),
  158|  4.45k|                    },
  159|  4.45k|                    patterns,
  160|  4.45k|                )?;
  161|  4.45k|                add_to_triple_or_path_patterns(
  162|  4.45k|                    middle.into(),
  163|  4.45k|                    *b,
  164|  4.45k|                    AnnotatedTermPath {
  165|  4.45k|                        term: object.term,
  166|  4.45k|                        annotations: Vec::new(),
  167|  4.45k|                    },
  168|  4.45k|                    patterns,
  169|  4.45k|                )?;
  170|       |            }
  171|  6.42k|            path => {
  172|  6.42k|                if !object.annotations.is_empty() {
  173|      0|                    return Err("Annotations are not allowed on property paths");
  174|  6.42k|                }
  175|  6.42k|                patterns.push(TripleOrPathPattern::Path {
  176|  6.42k|                    subject,
  177|  6.42k|                    path,
  178|  6.42k|                    object: object.term,
  179|  6.42k|                })
  180|       |            }
  181|       |        },
  182|       |    }
  183|  22.6k|    Ok(())
  184|  22.6k|}
_RNCNvNtCshSv3hUzq9FP_9spargebra6parser19are_variables_bound0B5_:
  557|      2|            are_variables_bound(a, variables) && b.iter().all(|b| are_variables_bound(b, variables))
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser32___parse_ConditionalAndExpression00EB4_:
  346|  2.49k|fn not_empty_fold<T>(
  347|  2.49k|    iter: impl Iterator<Item = T>,
  348|  2.49k|    combine: impl Fn(T, T) -> T,
  349|  2.49k|) -> Result<T, &'static str> {
  350|  2.49k|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|  2.49k|    })
  354|  2.49k|    .ok_or("The iterator should not be empty")
  355|  2.49k|}
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra12GraphPatternINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser32___parse_GroupOrUnionGraphPattern00EB4_:
  346|    130|fn not_empty_fold<T>(
  347|    130|    iter: impl Iterator<Item = T>,
  348|    130|    combine: impl Fn(T, T) -> T,
  349|    130|) -> Result<T, &'static str> {
  350|    130|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|    130|    })
  354|    130|    .ok_or("The iterator should not be empty")
  355|    130|}
_RNvXsj_NtCshSv3hUzq9FP_9spargebra6parserINtB5_20FocusedTriplePatternINtNtCsjOdcKtOMjJI_5alloc3vec3VecNtB5_13AnnotatedTermEENtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
   52|  17.0k|#[derive(Default)]
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra22PropertyPathExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser20___parse_PathSequence00E0B6_:
  350|  34.5k|    iter.fold(None, |a, b| match a {
  351|  9.08k|        Some(av) => Some(combine(av, b)),
  352|  25.5k|        None => Some(b),
  353|  34.5k|    })
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra22PropertyPathExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser23___parse_PathAlternative00E0B6_:
  350|  25.5k|    iter.fold(None, |a, b| match a {
  351|  1.58k|        Some(av) => Some(combine(av, b)),
  352|  23.9k|        None => Some(b),
  353|  25.5k|    })
_RNvMNtCshSv3hUzq9FP_9spargebra6parserINtB2_20FocusedTriplePatternNtNtB4_4term11TermPatternE3newB4_:
   59|  17.0k|    fn new(focus: F) -> Self {
   60|  17.0k|        Self {
   61|  17.0k|            focus,
   62|  17.0k|            patterns: Vec::new(),
   63|  17.0k|        }
   64|  17.0k|    }
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser32___parse_ConditionalAndExpression00E0B6_:
  350|  2.89k|    iter.fold(None, |a, b| match a {
  351|    400|        Some(av) => Some(combine(av, b)),
  352|  2.49k|        None => Some(b),
  353|  2.89k|    })
_RINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB4_7algebra10ExpressionINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBP_ENCNCNvNtB2_6parser20___parse_HavingClause00EB4_:
  346|     22|fn not_empty_fold<T>(
  347|     22|    iter: impl Iterator<Item = T>,
  348|     22|    combine: impl Fn(T, T) -> T,
  349|     22|) -> Result<T, &'static str> {
  350|     22|    iter.fold(None, |a, b| match a {
  351|       |        Some(av) => Some(combine(av, b)),
  352|       |        None => Some(b),
  353|     22|    })
  354|     22|    .ok_or("The iterator should not be empty")
  355|     22|}
_RINvNtCshSv3hUzq9FP_9spargebra6parser30add_to_triple_or_path_patternsNtB2_22VariableOrPropertyPathEB4_:
  124|  15.0k|fn add_to_triple_or_path_patterns(
  125|  15.0k|    subject: TermPattern,
  126|  15.0k|    predicate: impl Into<VariableOrPropertyPath>,
  127|  15.0k|    object: AnnotatedTermPath,
  128|  15.0k|    patterns: &mut Vec<TripleOrPathPattern>,
  129|  15.0k|) -> Result<(), &'static str> {
  130|  15.0k|    match predicate.into() {
  131|  11.7k|        VariableOrPropertyPath::Variable(p) => {
  132|  11.7k|            add_triple_to_triple_or_path_patterns(subject, p, object, patterns)?;
  133|       |        }
  134|  3.25k|        VariableOrPropertyPath::PropertyPath(p) => match p {
  135|    456|            PropertyPathExpression::NamedNode(p) => {
  136|    456|                add_triple_to_triple_or_path_patterns(subject, p, object, patterns)?;
  137|       |            }
  138|    788|            PropertyPathExpression::Reverse(p) => add_to_triple_or_path_patterns(
  139|    788|                object.term,
  140|    788|                *p,
  141|    788|                AnnotatedTermPath {
  142|    788|                    term: subject,
  143|    788|                    annotations: object.annotations,
  144|    788|                },
  145|    788|                patterns,
  146|    788|            )?,
  147|  1.26k|            PropertyPathExpression::Sequence(a, b) => {
  148|  1.26k|                if !object.annotations.is_empty() {
  149|      0|                    return Err("Annotations are not allowed on property paths");
  150|  1.26k|                }
  151|  1.26k|                let middle = BlankNode::default();
  152|  1.26k|                add_to_triple_or_path_patterns(
  153|  1.26k|                    subject,
  154|  1.26k|                    *a,
  155|  1.26k|                    AnnotatedTermPath {
  156|  1.26k|                        term: middle.clone().into(),
  157|  1.26k|                        annotations: Vec::new(),
  158|  1.26k|                    },
  159|  1.26k|                    patterns,
  160|  1.26k|                )?;
  161|  1.26k|                add_to_triple_or_path_patterns(
  162|  1.26k|                    middle.into(),
  163|  1.26k|                    *b,
  164|  1.26k|                    AnnotatedTermPath {
  165|  1.26k|                        term: object.term,
  166|  1.26k|                        annotations: Vec::new(),
  167|  1.26k|                    },
  168|  1.26k|                    patterns,
  169|  1.26k|                )?;
  170|       |            }
  171|    748|            path => {
  172|    748|                if !object.annotations.is_empty() {
  173|      0|                    return Err("Annotations are not allowed on property paths");
  174|    748|                }
  175|    748|                patterns.push(TripleOrPathPattern::Path {
  176|    748|                    subject,
  177|    748|                    path,
  178|    748|                    object: object.term,
  179|    748|                })
  180|       |            }
  181|       |        },
  182|       |    }
  183|  15.0k|    Ok(())
  184|  15.0k|}
_RNvMs5_NtCshSv3hUzq9FP_9spargebra6parserINtB5_26FocusedTripleOrPathPatternNtNtB7_4term11TermPatternE3newB7_:
  279|  7.17k|    fn new(focus: F) -> Self {
  280|  7.17k|        Self {
  281|  7.17k|            focus,
  282|  7.17k|            patterns: Vec::new(),
  283|  7.17k|        }
  284|  7.17k|    }
_RNCINvNtCshSv3hUzq9FP_9spargebra6parser14not_empty_foldNtNtB6_7algebra12GraphPatternINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBR_ENCNCNvNtB4_6parser32___parse_GroupOrUnionGraphPattern00E0B6_:
  350|    149|    iter.fold(None, |a, b| match a {
  351|     19|        Some(av) => Some(combine(av, b)),
  352|    130|        None => Some(b),
  353|    149|    })
_RNvXsj_NtCshSv3hUzq9FP_9spargebra6parserINtB5_20FocusedTriplePatternINtNtCsjOdcKtOMjJI_5alloc3vec3VecTNtNtB7_4term16NamedNodePatternIB15_NtB5_13AnnotatedTermEEEENtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
   52|  17.0k|#[derive(Default)]
_RNCNvNtCshSv3hUzq9FP_9spargebra6parser12build_select0B5_:
  441|  3.25k|            p.on_in_scope_variable(|v| {
  442|  3.25k|                visible.insert(v.clone());
  443|  3.25k|            });
_RNCNvNtCshSv3hUzq9FP_9spargebra6parser19are_variables_bounds_0B5_:
  560|      4|            parameters.iter().all(|p| are_variables_bound(p, variables))
_RINvNtCshSv3hUzq9FP_9spargebra6parser10copy_graphNtNtB4_4term9GraphNameBL_EB4_:
  631|    259|fn copy_graph(from: impl Into<GraphName>, to: impl Into<GraphNamePattern>) -> GraphUpdateOperation {
  632|    259|    let bgp = GraphPattern::Bgp {
  633|    259|        patterns: vec![TriplePattern::new(
  634|    259|            Variable::new_unchecked("s"),
  635|    259|            Variable::new_unchecked("p"),
  636|    259|            Variable::new_unchecked("o"),
  637|    259|        )],
  638|    259|    };
  639|    259|    GraphUpdateOperation::DeleteInsert {
  640|    259|        delete: Vec::new(),
  641|    259|        insert: vec![QuadPattern::new(
  642|    259|            Variable::new_unchecked("s"),
  643|    259|            Variable::new_unchecked("p"),
  644|    259|            Variable::new_unchecked("o"),
  645|    259|            to,
  646|    259|        )],
  647|    259|        using: None,
  648|    259|        pattern: Box::new(match from.into() {
  649|    151|            GraphName::NamedNode(from) => GraphPattern::Graph {
  650|    151|                name: from.into(),
  651|    151|                inner: Box::new(bgp),
  652|    151|            },
  653|    108|            GraphName::DefaultGraph => bgp,
  654|       |        }),
  655|       |    }
  656|    259|}
_RNvXsp_NtCshSv3hUzq9FP_9spargebra6parserINtB5_26FocusedTripleOrPathPatternINtNtCsjOdcKtOMjJI_5alloc3vec3VecTNtB5_22VariableOrPropertyPathIB1b_NtB5_17AnnotatedTermPathEEEENtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
  272|    600|#[derive(Debug, Default)]

_RNvXs1L_NtCshSv3hUzq9FP_9spargebra4termNtB6_10GroundQuadNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  327|  1.16k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs26_NtCshSv3hUzq9FP_9spargebra4termNtB6_17GroundTermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  590|  19.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2d_NtCshSv3hUzq9FP_9spargebra4termNtB6_16GraphNamePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  703|  11.8k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1b_NtCshSv3hUzq9FP_9spargebra4termNtB6_13GroundSubjectNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   10|  1.16k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2y_NtCshSv3hUzq9FP_9spargebra4termNtB6_11QuadPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  895|  2.14k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2F_NtCshSv3hUzq9FP_9spargebra4termNtB6_17GroundQuadPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  955|  9.70k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1i_NtCshSv3hUzq9FP_9spargebra4termNtB6_10GroundTermNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   78|  1.16k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1S_NtCshSv3hUzq9FP_9spargebra4termNtB6_16NamedNodePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  385|  11.8k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1w_NtCshSv3hUzq9FP_9spargebra4termNtB6_9GraphNameNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  187|  3.55k|#[derive(Eq, PartialEq, Debug, Clone, Hash, Default)]
_RNvXs1E_NtCshSv3hUzq9FP_9spargebra4termNtB6_4QuadNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  252|  2.38k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1Z_NtCshSv3hUzq9FP_9spargebra4termNtB6_11TermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
  438|  4.29k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsD_NtCshSv3hUzq9FP_9spargebra4termNtB5_17GroundTermPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtCs2ek33vt1YA5_8oxigraph:
  614|  98.6k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  615|  98.6k|        match self {
  616|  8.91k|            Self::NamedNode(term) => term.fmt(f),
  617|  1.32k|            Self::Literal(term) => term.fmt(f),
  618|  88.4k|            Self::Variable(var) => var.fmt(f),
  619|       |            #[cfg(feature = "rdf-star")]
  620|      0|            Self::Triple(triple) => write!(f, "<<{triple}>>"),
  621|       |        }
  622|  98.6k|    }
_RNvXs1S_NtCshSv3hUzq9FP_9spargebra4termNtB6_16NamedNodePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  385|  2.25k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs26_NtCshSv3hUzq9FP_9spargebra4termNtB6_17GroundTermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  590|      4|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1Z_NtCshSv3hUzq9FP_9spargebra4termNtB6_11TermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  438|  12.1k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXs1T_NtCshSv3hUzq9FP_9spargebra4termNtB7_16NamedNodePatternNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
  385|  1.06k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXs27_NtCshSv3hUzq9FP_9spargebra4termNtB7_17GroundTermPatternNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherECsaDAmlQ5xRbD_7sparopt:
  590|  2.55k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1i_NtCshSv3hUzq9FP_9spargebra4termNtB6_10GroundTermNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
   78|  10.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1S_NtCshSv3hUzq9FP_9spargebra4termNtB6_16NamedNodePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
  385|  65.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs26_NtCshSv3hUzq9FP_9spargebra4termNtB6_17GroundTermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCsaDAmlQ5xRbD_7sparopt:
  590|  49.7k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsz_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_17GroundTermPatternE4fromCsaDAmlQ5xRbD_7sparopt:
  548|  1.60k|    fn from(element: GroundTermPattern) -> Self {
  549|  1.60k|        match element {
  550|     33|            GroundTermPattern::NamedNode(node) => node.into(),
  551|      0|            GroundTermPattern::Literal(literal) => literal.into(),
  552|       |            #[cfg(feature = "rdf-star")]
  553|      0|            GroundTermPattern::Triple(t) => TriplePattern::from(*t).into(),
  554|  1.56k|            GroundTermPattern::Variable(variable) => variable.into(),
  555|       |        }
  556|  1.60k|    }
_RNvXso_NtCshSv3hUzq9FP_9spargebra4termNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_16NamedNodePatternE8try_fromB7_:
  429|  3.57k|    fn try_from(pattern: NamedNodePattern) -> Result<Self, Self::Error> {
  430|  3.57k|        match pattern {
  431|  3.57k|            NamedNodePattern::NamedNode(t) => Ok(t),
  432|      0|            NamedNodePattern::Variable(_) => Err(()),
  433|       |        }
  434|  3.57k|    }
_RINvMs11_NtCshSv3hUzq9FP_9spargebra4termNtB7_11QuadPattern3newNtB7_11TermPatternNtB7_16NamedNodePatternBY_NtB7_16GraphNamePatternEB9_:
  904|  2.28k|    pub(crate) fn new(
  905|  2.28k|        subject: impl Into<TermPattern>,
  906|  2.28k|        predicate: impl Into<NamedNodePattern>,
  907|  2.28k|        object: impl Into<TermPattern>,
  908|  2.28k|        graph_name: impl Into<GraphNamePattern>,
  909|  2.28k|    ) -> Self {
  910|  2.28k|        Self {
  911|  2.28k|            subject: subject.into(),
  912|  2.28k|            predicate: predicate.into(),
  913|  2.28k|            object: object.into(),
  914|  2.28k|            graph_name: graph_name.into(),
  915|  2.28k|        }
  916|  2.28k|    }
_RINvMsS_NtCshSv3hUzq9FP_9spargebra4termNtB6_13TriplePattern3newNtB6_11TermPatternNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableBZ_EB8_:
  775|  11.7k|    pub(crate) fn new(
  776|  11.7k|        subject: impl Into<TermPattern>,
  777|  11.7k|        predicate: impl Into<NamedNodePattern>,
  778|  11.7k|        object: impl Into<TermPattern>,
  779|  11.7k|    ) -> Self {
  780|  11.7k|        Self {
  781|  11.7k|            subject: subject.into(),
  782|  11.7k|            predicate: predicate.into(),
  783|  11.7k|            object: object.into(),
  784|  11.7k|        }
  785|  11.7k|    }
_RINvMs11_NtCshSv3hUzq9FP_9spargebra4termNtB7_11QuadPattern3newNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableBY_BY_NtB7_9GraphNameEB9_:
  904|    259|    pub(crate) fn new(
  905|    259|        subject: impl Into<TermPattern>,
  906|    259|        predicate: impl Into<NamedNodePattern>,
  907|    259|        object: impl Into<TermPattern>,
  908|    259|        graph_name: impl Into<GraphNamePattern>,
  909|    259|    ) -> Self {
  910|    259|        Self {
  911|    259|            subject: subject.into(),
  912|    259|            predicate: predicate.into(),
  913|    259|            object: object.into(),
  914|    259|            graph_name: graph_name.into(),
  915|    259|        }
  916|    259|    }
_RINvMsS_NtCshSv3hUzq9FP_9spargebra4termNtB6_13TriplePattern3newNtB6_11TermPatternNtB6_16NamedNodePatternBZ_EB8_:
  775|  19.4k|    pub(crate) fn new(
  776|  19.4k|        subject: impl Into<TermPattern>,
  777|  19.4k|        predicate: impl Into<NamedNodePattern>,
  778|  19.4k|        object: impl Into<TermPattern>,
  779|  19.4k|    ) -> Self {
  780|  19.4k|        Self {
  781|  19.4k|            subject: subject.into(),
  782|  19.4k|            predicate: predicate.into(),
  783|  19.4k|            object: object.into(),
  784|  19.4k|        }
  785|  19.4k|    }
_RINvMsS_NtCshSv3hUzq9FP_9spargebra4termNtB6_13TriplePattern3newNtB6_11TermPatternNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeBZ_EB8_:
  775|  7.88k|    pub(crate) fn new(
  776|  7.88k|        subject: impl Into<TermPattern>,
  777|  7.88k|        predicate: impl Into<NamedNodePattern>,
  778|  7.88k|        object: impl Into<TermPattern>,
  779|  7.88k|    ) -> Self {
  780|  7.88k|        Self {
  781|  7.88k|            subject: subject.into(),
  782|  7.88k|            predicate: predicate.into(),
  783|  7.88k|            object: object.into(),
  784|  7.88k|        }
  785|  7.88k|    }
_RINvMs11_NtCshSv3hUzq9FP_9spargebra4termNtB7_11QuadPattern3newNtB7_11TermPatternNtB7_16NamedNodePatternBY_B1g_EB9_:
  904|  14.8k|    pub(crate) fn new(
  905|  14.8k|        subject: impl Into<TermPattern>,
  906|  14.8k|        predicate: impl Into<NamedNodePattern>,
  907|  14.8k|        object: impl Into<TermPattern>,
  908|  14.8k|        graph_name: impl Into<GraphNamePattern>,
  909|  14.8k|    ) -> Self {
  910|  14.8k|        Self {
  911|  14.8k|            subject: subject.into(),
  912|  14.8k|            predicate: predicate.into(),
  913|  14.8k|            object: object.into(),
  914|  14.8k|            graph_name: graph_name.into(),
  915|  14.8k|        }
  916|  14.8k|    }
_RINvMsS_NtCshSv3hUzq9FP_9spargebra4termNtB6_13TriplePattern3newNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableBZ_BZ_EB8_:
  775|    518|    pub(crate) fn new(
  776|    518|        subject: impl Into<TermPattern>,
  777|    518|        predicate: impl Into<NamedNodePattern>,
  778|    518|        object: impl Into<TermPattern>,
  779|    518|    ) -> Self {
  780|    518|        Self {
  781|    518|            subject: subject.into(),
  782|    518|            predicate: predicate.into(),
  783|    518|            object: object.into(),
  784|    518|        }
  785|    518|    }
_RNvXsA_NtCshSv3hUzq9FP_9spargebra4termNtNtCshJ9d6mhVUZV_5oxrdf6triple7SubjectINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_11TermPatternE8try_fromB7_:
  563|  3.57k|    fn try_from(term: TermPattern) -> Result<Self, Self::Error> {
  564|  3.57k|        match term {
  565|  3.57k|            TermPattern::NamedNode(t) => Ok(t.into()),
  566|      0|            TermPattern::BlankNode(t) => Ok(t.into()),
  567|       |            #[cfg(feature = "rdf-star")]
  568|      0|            TermPattern::Triple(t) => Ok(Triple::try_from(*t)?.into()),
  569|      0|            TermPattern::Literal(_) | TermPattern::Variable(_) => Err(()),
  570|       |        }
  571|  3.57k|    }
_RNvXsB_NtCshSv3hUzq9FP_9spargebra4termNtNtCshJ9d6mhVUZV_5oxrdf6triple4TermINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_11TermPatternE8try_fromB7_:
  578|  3.57k|    fn try_from(pattern: TermPattern) -> Result<Self, Self::Error> {
  579|  3.57k|        match pattern {
  580|  1.21k|            TermPattern::NamedNode(t) => Ok(t.into()),
  581|      0|            TermPattern::BlankNode(t) => Ok(t.into()),
  582|  2.35k|            TermPattern::Literal(t) => Ok(t.into()),
  583|       |            #[cfg(feature = "rdf-star")]
  584|      0|            TermPattern::Triple(t) => Ok(Triple::try_from(*t)?.into()),
  585|      0|            TermPattern::Variable(_) => Err(()),
  586|       |        }
  587|  3.57k|    }
_RNvXsP_NtCshSv3hUzq9FP_9spargebra4termNtB5_16GraphNamePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4fromB7_:
  741|  2.75k|    fn from(var: Variable) -> Self {
  742|  2.75k|        Self::Variable(var)
  743|  2.75k|    }
_RNvXs4_NtCshSv3hUzq9FP_9spargebra4termNtB5_10GroundTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  104|  3.74k|    fn from(node: NamedNode) -> Self {
  105|  3.74k|        Self::NamedNode(node)
  106|  3.74k|    }
_RNvXsl_NtCshSv3hUzq9FP_9spargebra4termNtB5_16NamedNodePatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtB7_:
  403|  44.3k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  404|  44.3k|        match self {
  405|  20.0k|            Self::NamedNode(node) => node.fmt(f),
  406|  24.2k|            Self::Variable(var) => var.fmt(f),
  407|       |        }
  408|  44.3k|    }
_RNvXs7_NtCshSv3hUzq9FP_9spargebra4termNtB5_10GroundTermINtNtCs9nhK3FOW46N_4core7convert7TryFromNtNtCshJ9d6mhVUZV_5oxrdf6triple4TermE8try_fromB7_:
  128|  1.18k|    fn try_from(term: Term) -> Result<Self, Self::Error> {
  129|  1.18k|        match term {
  130|    545|            Term::NamedNode(t) => Ok(t.into()),
  131|      0|            Term::BlankNode(_) => Err(()),
  132|    636|            Term::Literal(t) => Ok(t.into()),
  133|       |            #[cfg(feature = "rdf-star")]
  134|      0|            Term::Triple(t) => Ok(GroundTriple::try_from(*t)?.into()),
  135|       |        }
  136|  1.18k|    }
_RNvXsL_NtCshSv3hUzq9FP_9spargebra4termNtB5_17GroundTermPatternINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_11TermPatternE8try_fromB7_:
  690|  22.6k|    fn try_from(pattern: TermPattern) -> Result<Self, Self::Error> {
  691|  22.6k|        Ok(match pattern {
  692|  10.5k|            TermPattern::NamedNode(named_node) => named_node.into(),
  693|      0|            TermPattern::BlankNode(_) => return Err(()),
  694|  1.17k|            TermPattern::Literal(literal) => literal.into(),
  695|       |            #[cfg(feature = "rdf-star")]
  696|      0|            TermPattern::Triple(triple) => GroundTriplePattern::try_from(*triple)?.into(),
  697|  10.9k|            TermPattern::Variable(variable) => variable.into(),
  698|       |        })
  699|  22.6k|    }
_RNvXsO_NtCshSv3hUzq9FP_9spargebra4termNtB5_16GraphNamePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  734|  13.4k|    fn from(node: NamedNode) -> Self {
  735|  13.4k|        Self::NamedNode(node)
  736|  13.4k|    }
_RNvXsR_NtCshSv3hUzq9FP_9spargebra4termNtB5_16GraphNamePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_16NamedNodePatternE4fromB7_:
  758|  14.8k|    fn from(graph_name: NamedNodePattern) -> Self {
  759|  14.8k|        match graph_name {
  760|  12.0k|            NamedNodePattern::NamedNode(node) => node.into(),
  761|  2.75k|            NamedNodePattern::Variable(var) => var.into(),
  762|       |        }
  763|  14.8k|    }
_RNvXs1u_NtCshSv3hUzq9FP_9spargebra4termNtB6_9GraphNameNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB8_:
  187|  1.01k|#[derive(Eq, PartialEq, Debug, Clone, Hash, Default)]
_RNvXsF_NtCshSv3hUzq9FP_9spargebra4termNtB5_17GroundTermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE4fromB7_:
  634|  2.49k|    fn from(literal: Literal) -> Self {
  635|  2.49k|        Self::Literal(literal)
  636|  2.49k|    }
_RNvXsq_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtB7_:
  464|  1.60k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  465|  1.60k|        match self {
  466|     33|            Self::NamedNode(term) => term.fmt(f),
  467|      0|            Self::BlankNode(term) => term.fmt(f),
  468|      0|            Self::Literal(term) => term.fmt(f),
  469|       |            #[cfg(feature = "rdf-star")]
  470|      0|            Self::Triple(triple) => write!(f, "<<{triple}>>"),
  471|  1.56k|            Self::Variable(var) => var.fmt(f),
  472|       |        }
  473|  1.60k|    }
_RNvXs1Z_NtCshSv3hUzq9FP_9spargebra4termNtB6_11TermPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  438|  84.2k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2b_NtCshSv3hUzq9FP_9spargebra4termNtB6_16GraphNamePatternNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB8_:
  703|  7.91k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs1w_NtCshSv3hUzq9FP_9spargebra4termNtB6_9GraphNameNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  187|    424|#[derive(Eq, PartialEq, Debug, Clone, Hash, Default)]
_RNvXs1_NtCshSv3hUzq9FP_9spargebra4termNtB5_13GroundSubjectINtNtCs9nhK3FOW46N_4core7convert7TryFromNtNtCshJ9d6mhVUZV_5oxrdf6triple7SubjectE8try_fromB7_:
   51|  1.18k|    fn try_from(subject: Subject) -> Result<Self, Self::Error> {
   52|  1.18k|        match subject {
   53|  1.18k|            Subject::NamedNode(t) => Ok(t.into()),
   54|      0|            Subject::BlankNode(_) => Err(()),
   55|       |            #[cfg(feature = "rdf-star")]
   56|      0|            Subject::Triple(t) => Ok(GroundTriple::try_from(*t)?.into()),
   57|       |        }
   58|  1.18k|    }
_RNvXsn_NtCshSv3hUzq9FP_9spargebra4termNtB5_16NamedNodePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4fromB7_:
  420|  18.8k|    fn from(var: Variable) -> Self {
  421|  18.8k|        Self::Variable(var)
  422|  18.8k|    }
_RNvXst_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE4fromB7_:
  492|  3.92k|    fn from(literal: Literal) -> Self {
  493|  3.92k|        Self::Literal(literal)
  494|  3.92k|    }
_RNvXsT_NtCshSv3hUzq9FP_9spargebra4termNtB5_13TriplePatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtB7_:
  801|    290|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  802|    290|        write!(f, "{} {} {}", self.subject, self.predicate, self.object)
  803|    290|    }
_RNvXsE_NtCshSv3hUzq9FP_9spargebra4termNtB5_17GroundTermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  627|  19.4k|    fn from(node: NamedNode) -> Self {
  628|  19.4k|        Self::NamedNode(node)
  629|  19.4k|    }
_RNvXs3_NtCshSv3hUzq9FP_9spargebra4termNtB5_10GroundTermNtNtCs9nhK3FOW46N_4core3fmt7Display3fmtB7_:
   88|      4|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   89|      4|        match self {
   90|      2|            Self::NamedNode(node) => node.fmt(f),
   91|      2|            Self::Literal(literal) => literal.fmt(f),
   92|       |            #[cfg(feature = "rdf-star")]
   93|      0|            Self::Triple(triple) => write!(
   94|      0|                f,
   95|      0|                "<<{} {} {}>>",
   96|      0|                triple.subject, triple.predicate, triple.object
   97|      0|            ),
   98|       |        }
   99|      4|    }
_RNvXsH_NtCshSv3hUzq9FP_9spargebra4termNtB5_17GroundTermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4fromB7_:
  649|  99.6k|    fn from(var: Variable) -> Self {
  650|  99.6k|        Self::Variable(var)
  651|  99.6k|    }
_RNvXsc_NtCshSv3hUzq9FP_9spargebra4termNtB5_9GraphNameINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  216|  3.27k|    fn from(node: NamedNode) -> Self {
  217|  3.27k|        Self::NamedNode(node)
  218|  3.27k|    }
_RNvXsQ_NtCshSv3hUzq9FP_9spargebra4termNtB5_16GraphNamePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtB5_9GraphNameE4fromB7_:
  748|    259|    fn from(graph_name: GraphName) -> Self {
  749|    259|        match graph_name {
  750|    200|            GraphName::NamedNode(node) => node.into(),
  751|     59|            GraphName::DefaultGraph => Self::DefaultGraph,
  752|       |        }
  753|    259|    }
_RNvXsj_NtCshSv3hUzq9FP_9spargebra4termNtB5_10GroundQuadINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_4QuadE8try_fromB7_:
  374|  1.18k|    fn try_from(quad: Quad) -> Result<Self, Self::Error> {
  375|  1.18k|        Ok(Self {
  376|  1.18k|            subject: quad.subject.try_into()?,
  377|  1.18k|            predicate: quad.predicate,
  378|  1.18k|            object: quad.object.try_into()?,
  379|  1.18k|            graph_name: quad.graph_name,
  380|       |        })
  381|  1.18k|    }
_RNvXsm_NtCshSv3hUzq9FP_9spargebra4termNtB5_16NamedNodePatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  413|  35.7k|    fn from(node: NamedNode) -> Self {
  414|  35.7k|        Self::NamedNode(node)
  415|  35.7k|    }
_RNvXss_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10blank_node9BlankNodeE4fromB7_:
  485|  24.5k|    fn from(node: BlankNode) -> Self {
  486|  24.5k|        Self::BlankNode(node)
  487|  24.5k|    }
_RNvXsv_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4from:
  506|  22.8k|    fn from(var: Variable) -> Self {
  507|  22.8k|        Self::Variable(var)
  508|  22.8k|    }
_RNvXsg_NtCshSv3hUzq9FP_9spargebra4termNtB5_4QuadINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_11QuadPatternE8try_fromB7_:
  299|  3.57k|    fn try_from(quad: QuadPattern) -> Result<Self, Self::Error> {
  300|  3.57k|        Ok(Self {
  301|  3.57k|            subject: quad.subject.try_into()?,
  302|  3.57k|            predicate: quad.predicate.try_into()?,
  303|  3.57k|            object: quad.object.try_into()?,
  304|  3.57k|            graph_name: quad.graph_name.try_into()?,
  305|       |        })
  306|  3.57k|    }
_RNvXs1S_NtCshSv3hUzq9FP_9spargebra4termNtB6_16NamedNodePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  385|  53.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs2k_NtCshSv3hUzq9FP_9spargebra4termNtB6_13TriplePatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB8_:
  767|  19.1k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsd_NtCshSv3hUzq9FP_9spargebra4termNtB5_9GraphNameINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB5_16GraphNamePatternE8try_fromB7_:
  225|  3.57k|    fn try_from(pattern: GraphNamePattern) -> Result<Self, Self::Error> {
  226|  3.57k|        match pattern {
  227|  3.27k|            GraphNamePattern::NamedNode(t) => Ok(t.into()),
  228|    297|            GraphNamePattern::DefaultGraph => Ok(Self::DefaultGraph),
  229|      0|            GraphNamePattern::Variable(_) => Err(()),
  230|       |        }
  231|  3.57k|    }
_RNvXs5_NtCshSv3hUzq9FP_9spargebra4termNtB5_10GroundTermINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE4fromB7_:
  111|  1.07k|    fn from(literal: Literal) -> Self {
  112|  1.07k|        Self::Literal(literal)
  113|  1.07k|    }
_RNvXs15_NtCshSv3hUzq9FP_9spargebra4termNtB6_17GroundQuadPatternINtNtCs9nhK3FOW46N_4core7convert7TryFromNtB6_11QuadPatternE8try_fromB8_:
 1004|  11.3k|    fn try_from(pattern: QuadPattern) -> Result<Self, Self::Error> {
 1005|  11.3k|        Ok(Self {
 1006|  11.3k|            subject: pattern.subject.try_into()?,
 1007|  11.3k|            predicate: pattern.predicate,
 1008|  11.3k|            object: pattern.object.try_into()?,
 1009|  11.3k|            graph_name: pattern.graph_name,
 1010|       |        })
 1011|  11.3k|    }
_RNvXsr_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB7_:
  478|  20.1k|    fn from(node: NamedNode) -> Self {
  479|  20.1k|        Self::NamedNode(node)
  480|  20.1k|    }
_RNvXs_NtCshSv3hUzq9FP_9spargebra4termNtB4_13GroundSubjectINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4fromB6_:
   34|  1.18k|    fn from(node: NamedNode) -> Self {
   35|  1.18k|        Self::NamedNode(node)
   36|  1.18k|    }
_RNvXsx_NtCshSv3hUzq9FP_9spargebra4termNtB5_11TermPatternINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf6triple4TermE4fromB7_:
  525|  22.6k|    fn from(term: Term) -> Self {
  526|  22.6k|        match term {
  527|  18.7k|            Term::NamedNode(node) => node.into(),
  528|      0|            Term::BlankNode(node) => node.into(),
  529|  3.92k|            Term::Literal(literal) => literal.into(),
  530|       |            #[cfg(feature = "rdf-star")]
  531|      0|            Term::Triple(t) => TriplePattern::from(*t).into(),
  532|       |        }
  533|  22.6k|    }

_RNvXsa_NtCshSv3hUzq9FP_9spargebra6updateNtB5_6UpdateNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   19|  2.49k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsh_NtCshSv3hUzq9FP_9spargebra6updateNtB5_20GraphUpdateOperationNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCslmM25dSh1d8_18sparql_update_eval:
   95|  4.95k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCshSv3hUzq9FP_9spargebra6updateNtB2_6Update5parse:
   29|  2.71k|    pub fn parse(update: &str, base_iri: Option<&str>) -> Result<Self, SparqlSyntaxError> {
   30|  2.71k|        parse_update(update, base_iri)
   31|  2.71k|    }

_RNvXsE_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
  636|     37|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsx_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneCs2ek33vt1YA5_8oxigraph:
   22|     37|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXs9_NtCsaDAmlQ5xRbD_7sparopt7algebraNtNtCshSv3hUzq9FP_9spargebra7algebra10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromRNtB5_10ExpressionE4from:
  486|  22.6k|    fn from(expression: &Expression) -> Self {
  487|  22.6k|        match expression {
  488|    600|            Expression::NamedNode(node) => Self::NamedNode(node.clone()),
  489|  4.15k|            Expression::Literal(literal) => Self::Literal(literal.clone()),
  490|  4.62k|            Expression::Variable(variable) => Self::Variable(variable.clone()),
  491|     36|            Expression::Or(inner) => inner
  492|     36|                .iter()
  493|     36|                .map(Into::into)
  494|     36|                .reduce(|a, b| Self::Or(Box::new(a), Box::new(b)))
  495|     36|                .unwrap_or_else(|| Literal::from(false).into()),
  496|    273|            Expression::And(inner) => inner
  497|    273|                .iter()
  498|    273|                .map(Into::into)
  499|    273|                .reduce(|a, b| Self::And(Box::new(a), Box::new(b)))
  500|    273|                .unwrap_or_else(|| Literal::from(true).into()),
  501|    871|            Expression::Equal(left, right) => Self::Equal(
  502|    871|                Box::new(left.as_ref().into()),
  503|    871|                Box::new(right.as_ref().into()),
  504|    871|            ),
  505|      3|            Expression::SameTerm(left, right) => Self::SameTerm(
  506|      3|                Box::new(left.as_ref().into()),
  507|      3|                Box::new(right.as_ref().into()),
  508|      3|            ),
  509|     36|            Expression::Greater(left, right) => Self::Greater(
  510|     36|                Box::new(left.as_ref().into()),
  511|     36|                Box::new(right.as_ref().into()),
  512|     36|            ),
  513|    152|            Expression::GreaterOrEqual(left, right) => Self::GreaterOrEqual(
  514|    152|                Box::new(left.as_ref().into()),
  515|    152|                Box::new(right.as_ref().into()),
  516|    152|            ),
  517|     16|            Expression::Less(left, right) => Self::Less(
  518|     16|                Box::new(left.as_ref().into()),
  519|     16|                Box::new(right.as_ref().into()),
  520|     16|            ),
  521|     26|            Expression::LessOrEqual(left, right) => Self::LessOrEqual(
  522|     26|                Box::new(left.as_ref().into()),
  523|     26|                Box::new(right.as_ref().into()),
  524|     26|            ),
  525|    268|            Expression::Add(left, right) => Self::Add(
  526|    268|                Box::new(left.as_ref().into()),
  527|    268|                Box::new(right.as_ref().into()),
  528|    268|            ),
  529|  1.72k|            Expression::Subtract(left, right) => Self::Subtract(
  530|  1.72k|                Box::new(left.as_ref().into()),
  531|  1.72k|                Box::new(right.as_ref().into()),
  532|  1.72k|            ),
  533|    590|            Expression::Multiply(left, right) => Self::Multiply(
  534|    590|                Box::new(left.as_ref().into()),
  535|    590|                Box::new(right.as_ref().into()),
  536|    590|            ),
  537|  3.26k|            Expression::Divide(left, right) => Self::Divide(
  538|  3.26k|                Box::new(left.as_ref().into()),
  539|  3.26k|                Box::new(right.as_ref().into()),
  540|  3.26k|            ),
  541|    324|            Expression::UnaryPlus(inner) => Self::UnaryPlus(Box::new(inner.as_ref().into())),
  542|  2.26k|            Expression::UnaryMinus(inner) => Self::UnaryMinus(Box::new(inner.as_ref().into())),
  543|  2.24k|            Expression::Not(inner) => Self::Not(Box::new(inner.as_ref().into())),
  544|    126|            Expression::Exists(inner) => Self::Exists(Box::new(inner.as_ref().into())),
  545|    197|            Expression::Bound(variable) => Self::Bound(variable.clone()),
  546|    718|            Expression::If(cond, yes, no) => Self::If(
  547|    718|                Box::new(cond.as_ref().into()),
  548|    718|                Box::new(yes.as_ref().into()),
  549|    718|                Box::new(no.as_ref().into()),
  550|    718|            ),
  551|     82|            Expression::Coalesce(inner) => Self::Coalesce(inner.iter().map(Into::into).collect()),
  552|     60|            Expression::FunctionCall(name, args) => {
  553|     60|                Self::FunctionCall(name.clone(), args.iter().map(Into::into).collect())
  554|       |            }
  555|       |        }
  556|  22.6k|    }
_RNvXsk_NtCsaDAmlQ5xRbD_7sparopt7algebraNtNtCshSv3hUzq9FP_9spargebra7algebra12GraphPatternINtNtCs9nhK3FOW46N_4core7convert4FromRNtB5_12GraphPatternE4from:
 1323|  1.85k|    fn from(pattern: &GraphPattern) -> Self {
 1324|  1.85k|        match pattern {
 1325|       |            GraphPattern::QuadPattern {
 1326|    290|                subject,
 1327|    290|                predicate,
 1328|    290|                object,
 1329|    290|                graph_name,
 1330|    290|            } => {
 1331|    290|                let pattern = Self::Bgp {
 1332|    290|                    patterns: vec![TriplePattern {
 1333|    290|                        subject: subject.clone().into(),
 1334|    290|                        predicate: predicate.clone(),
 1335|    290|                        object: object.clone().into(),
 1336|    290|                    }],
 1337|    290|                };
 1338|    290|                if let Some(graph_name) = graph_name {
 1339|     52|                    Self::Graph {
 1340|     52|                        inner: Box::new(pattern),
 1341|     52|                        name: graph_name.clone(),
 1342|     52|                    }
 1343|       |                } else {
 1344|    238|                    pattern
 1345|       |                }
 1346|       |            }
 1347|       |            GraphPattern::Path {
 1348|    510|                subject,
 1349|    510|                path,
 1350|    510|                object,
 1351|    510|                graph_name,
 1352|    510|            } => {
 1353|    510|                let pattern = Self::Path {
 1354|    510|                    subject: subject.clone().into(),
 1355|    510|                    path: path.clone(),
 1356|    510|                    object: object.clone().into(),
 1357|    510|                };
 1358|    510|                if let Some(graph_name) = graph_name {
 1359|    366|                    Self::Graph {
 1360|    366|                        inner: Box::new(pattern),
 1361|    366|                        name: graph_name.clone(),
 1362|    366|                    }
 1363|       |                } else {
 1364|    144|                    pattern
 1365|       |                }
 1366|       |            }
 1367|    722|            GraphPattern::Join { left, right, .. } => {
 1368|    722|                match (left.as_ref().into(), right.as_ref().into()) {
 1369|    187|                    (Self::Bgp { patterns: mut left }, Self::Bgp { patterns: right }) => {
 1370|    187|                        left.extend(right);
 1371|    187|                        Self::Bgp { patterns: left }
 1372|       |                    }
 1373|    535|                    (left, right) => Self::Join {
 1374|    535|                        left: Box::new(left),
 1375|    535|                        right: Box::new(right),
 1376|    535|                    },
 1377|       |                }
 1378|       |            }
 1379|       |            GraphPattern::LeftJoin {
 1380|     10|                left,
 1381|     10|                right,
 1382|     10|                expression,
 1383|       |                ..
 1384|       |            } => {
 1385|     10|                let empty_expr = if let Expression::Literal(l) = expression {
 1386|     10|                    l.datatype() == xsd::BOOLEAN && l.value() == "true"
 1387|       |                } else {
 1388|      0|                    false
 1389|       |                };
 1390|       |                Self::LeftJoin {
 1391|     10|                    left: Box::new(left.as_ref().into()),
 1392|     10|                    right: Box::new(right.as_ref().into()),
 1393|     10|                    expression: if empty_expr {
 1394|     10|                        None
 1395|       |                    } else {
 1396|      0|                        Some(expression.into())
 1397|       |                    },
 1398|       |                }
 1399|       |            }
 1400|       |            #[cfg(feature = "sep-0006")]
 1401|      2|            GraphPattern::Lateral { left, right } => {
 1402|      2|                match (left.as_ref().into(), right.as_ref().into()) {
 1403|      0|                    (Self::Bgp { patterns: mut left }, Self::Bgp { patterns: right }) => {
 1404|      0|                        left.extend(right);
 1405|      0|                        Self::Bgp { patterns: left }
 1406|       |                    }
 1407|      2|                    (left, right) => Self::Lateral {
 1408|      2|                        left: Box::new(left),
 1409|      2|                        right: Box::new(right),
 1410|      2|                    },
 1411|       |                }
 1412|       |            }
 1413|      0|            GraphPattern::Filter { inner, expression } => Self::Filter {
 1414|      0|                inner: Box::new(inner.as_ref().into()),
 1415|      0|                expr: expression.into(),
 1416|      0|            },
 1417|      0|            GraphPattern::Union { inner } => inner
 1418|      0|                .iter()
 1419|      0|                .map(Into::into)
 1420|      0|                .reduce(|a, b| Self::Union {
 1421|       |                    left: Box::new(a),
 1422|       |                    right: Box::new(b),
 1423|      0|                })
 1424|      0|                .unwrap_or_else(|| Self::Values {
 1425|       |                    variables: Vec::new(),
 1426|       |                    bindings: Vec::new(),
 1427|      0|                }),
 1428|       |            GraphPattern::Extend {
 1429|     32|                inner,
 1430|     32|                expression,
 1431|     32|                variable,
 1432|     32|            } => Self::Extend {
 1433|     32|                inner: Box::new(inner.as_ref().into()),
 1434|     32|                expression: expression.into(),
 1435|     32|                variable: variable.clone(),
 1436|     32|            },
 1437|      0|            GraphPattern::Minus { left, right, .. } => Self::Minus {
 1438|      0|                left: Box::new(left.as_ref().into()),
 1439|      0|                right: Box::new(right.as_ref().into()),
 1440|      0|            },
 1441|       |            GraphPattern::Values {
 1442|     60|                variables,
 1443|     60|                bindings,
 1444|     60|            } => Self::Values {
 1445|     60|                variables: variables.clone(),
 1446|     60|                bindings: bindings.clone(),
 1447|     60|            },
 1448|      0|            GraphPattern::OrderBy { inner, expression } => Self::OrderBy {
 1449|      0|                inner: Box::new(inner.as_ref().into()),
 1450|      0|                expression: expression.iter().map(Into::into).collect(),
 1451|      0|            },
 1452|    126|            GraphPattern::Project { inner, variables } => Self::Project {
 1453|    126|                inner: Box::new(inner.as_ref().into()),
 1454|    126|                variables: variables.clone(),
 1455|    126|            },
 1456|    102|            GraphPattern::Distinct { inner } => Self::Distinct {
 1457|    102|                inner: Box::new(inner.as_ref().into()),
 1458|    102|            },
 1459|      0|            GraphPattern::Reduced { inner } => Self::Distinct {
 1460|      0|                inner: Box::new(inner.as_ref().into()),
 1461|      0|            },
 1462|       |            GraphPattern::Slice {
 1463|      0|                inner,
 1464|      0|                start,
 1465|      0|                length,
 1466|      0|            } => Self::Slice {
 1467|      0|                inner: Box::new(inner.as_ref().into()),
 1468|      0|                start: *start,
 1469|      0|                length: *length,
 1470|      0|            },
 1471|       |            GraphPattern::Group {
 1472|      0|                inner,
 1473|      0|                variables,
 1474|      0|                aggregates,
 1475|      0|            } => Self::Group {
 1476|      0|                inner: Box::new(inner.as_ref().into()),
 1477|      0|                variables: variables.clone(),
 1478|      0|                aggregates: aggregates
 1479|      0|                    .iter()
 1480|      0|                    .map(|(var, expr)| (var.clone(), expr.into()))
 1481|      0|                    .collect(),
 1482|      0|            },
 1483|       |            GraphPattern::Service {
 1484|      0|                inner,
 1485|      0|                name,
 1486|      0|                silent,
 1487|      0|            } => Self::Service {
 1488|      0|                inner: Box::new(inner.as_ref().into()),
 1489|      0|                name: name.clone(),
 1490|      0|                silent: *silent,
 1491|      0|            },
 1492|       |        }
 1493|  1.85k|    }
_RNvXs7_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf8variable8VariableE4from:
  474|  2.18k|    fn from(value: Variable) -> Self {
  475|  2.18k|        Self::Variable(value)
  476|  2.18k|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression15returns_boolean:
  365|    138|    fn returns_boolean(&self) -> bool {
  366|      3|        match self {
  367|       |            Self::Or(_)
  368|       |            | Self::And(_)
  369|       |            | Self::Equal(_, _)
  370|       |            | Self::SameTerm(_, _)
  371|       |            | Self::Greater(_, _)
  372|       |            | Self::GreaterOrEqual(_, _)
  373|       |            | Self::Less(_, _)
  374|       |            | Self::LessOrEqual(_, _)
  375|       |            | Self::Not(_)
  376|       |            | Self::Exists(_)
  377|       |            | Self::Bound(_)
  378|       |            | Self::FunctionCall(
  379|       |                Function::IsBlank | Function::IsIri | Function::IsLiteral | Function::IsNumeric,
  380|       |                _,
  381|     56|            ) => true,
  382|       |            #[cfg(feature = "rdf-star")]
  383|      0|            Self::FunctionCall(Function::IsTriple, _) => true,
  384|     47|            Self::Literal(literal) => literal.datatype() == xsd::BOOLEAN,
  385|     22|            Self::If(_, a, b) => a.returns_boolean() && b.returns_boolean(),
  386|     13|            _ => false,
  387|       |        }
  388|    138|    }
_RNvXsE_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPatternNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  636|  24.6k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsZ_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_14MinusAlgorithmNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
 1525|      3|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsL_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_13JoinAlgorithmNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
 1497|    168|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression5equal:
  126|    409|    pub fn equal(left: Self, right: Self) -> Self {
  127|    409|        match (left, right) {
  128|      0|            (Self::NamedNode(left), Self::NamedNode(right)) => (left == right).into(),
  129|      5|            (Self::Literal(left), Self::Literal(right)) if left == right => true.into(),
  130|    407|            (left, right) => {
  131|    407|                let (left, right) = order_pair(left, right);
  132|    407|                Self::Equal(Box::new(left), Box::new(right))
  133|       |            }
  134|       |        }
  135|    409|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern7reduced:
  969|  7.29k|    pub fn reduced(inner: Self) -> Self {
  970|  7.29k|        if inner.is_empty() {
  971|     21|            return Self::empty();
  972|  7.27k|        }
  973|  7.27k|        Self::Reduced {
  974|  7.27k|            inner: Box::new(inner),
  975|  7.27k|        }
  976|  7.29k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern19from_sparql_algebra:
 1114|  52.1k|    fn from_sparql_algebra(
 1115|  52.1k|        pattern: &AlGraphPattern,
 1116|  52.1k|        graph_name: Option<&NamedNodePattern>,
 1117|  52.1k|        blank_nodes: &mut HashMap<BlankNode, Variable>,
 1118|  52.1k|    ) -> Self {
 1119|  52.1k|        match pattern {
 1120|  11.8k|            AlGraphPattern::Bgp { patterns } => patterns
 1121|  11.8k|                .iter()
 1122|  11.8k|                .map(|p| {
 1123|       |                    let (subject, predicate, object) =
 1124|       |                        Self::triple_pattern_from_algebra(p, blank_nodes);
 1125|       |                    Self::QuadPattern {
 1126|       |                        subject,
 1127|       |                        predicate,
 1128|       |                        object,
 1129|       |                        graph_name: graph_name.cloned(),
 1130|       |                    }
 1131|  11.8k|                })
 1132|  11.8k|                .reduce(|a, b| Self::Join {
 1133|       |                    left: Box::new(a),
 1134|       |                    right: Box::new(b),
 1135|       |                    algorithm: JoinAlgorithm::default(),
 1136|  11.8k|                })
 1137|  11.8k|                .unwrap_or_else(Self::empty_singleton),
 1138|       |            AlGraphPattern::Path {
 1139|  11.9k|                subject,
 1140|  11.9k|                path,
 1141|  11.9k|                object,
 1142|  11.9k|            } => Self::Path {
 1143|  11.9k|                subject: Self::term_pattern_from_algebra(subject, blank_nodes),
 1144|  11.9k|                path: path.clone(),
 1145|  11.9k|                object: Self::term_pattern_from_algebra(object, blank_nodes),
 1146|  11.9k|                graph_name: graph_name.cloned(),
 1147|  11.9k|            },
 1148|  18.1k|            AlGraphPattern::Join { left, right } => Self::Join {
 1149|  18.1k|                left: Box::new(Self::from_sparql_algebra(left, graph_name, blank_nodes)),
 1150|  18.1k|                right: Box::new(Self::from_sparql_algebra(right, graph_name, blank_nodes)),
 1151|  18.1k|                algorithm: JoinAlgorithm::default(),
 1152|  18.1k|            },
 1153|       |            AlGraphPattern::LeftJoin {
 1154|    442|                left,
 1155|    442|                right,
 1156|    442|                expression,
 1157|    442|            } => Self::LeftJoin {
 1158|    442|                left: Box::new(Self::from_sparql_algebra(left, graph_name, blank_nodes)),
 1159|    442|                right: Box::new(Self::from_sparql_algebra(right, graph_name, blank_nodes)),
 1160|    442|                expression: expression.as_ref().map_or_else(
 1161|    442|                    || true.into(),
 1162|    442|                    |e| Expression::from_sparql_algebra(e, graph_name),
 1163|    442|                ),
 1164|    442|                algorithm: LeftJoinAlgorithm::default(),
 1165|    442|            },
 1166|       |            #[cfg(feature = "sep-0006")]
 1167|    538|            AlGraphPattern::Lateral { left, right } => Self::Lateral {
 1168|    538|                left: Box::new(Self::from_sparql_algebra(left, graph_name, blank_nodes)),
 1169|    538|                right: Box::new(Self::from_sparql_algebra(right, graph_name, blank_nodes)),
 1170|    538|            },
 1171|     44|            AlGraphPattern::Filter { inner, expr } => Self::Filter {
 1172|     44|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1173|     44|                expression: Expression::from_sparql_algebra(expr, graph_name),
 1174|     44|            },
 1175|     38|            AlGraphPattern::Union { left, right } => Self::Union {
 1176|     38|                inner: vec![
 1177|     38|                    Self::from_sparql_algebra(left, graph_name, blank_nodes),
 1178|     38|                    Self::from_sparql_algebra(right, graph_name, blank_nodes),
 1179|     38|                ],
 1180|     38|            },
 1181|  4.46k|            AlGraphPattern::Graph { inner, name } => {
 1182|  4.46k|                Self::from_sparql_algebra(inner, Some(name), blank_nodes)
 1183|       |            }
 1184|       |            AlGraphPattern::Extend {
 1185|    588|                inner,
 1186|    588|                expression,
 1187|    588|                variable,
 1188|    588|            } => Self::Extend {
 1189|    588|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1190|    588|                expression: Expression::from_sparql_algebra(expression, graph_name),
 1191|    588|                variable: variable.clone(),
 1192|    588|            },
 1193|     40|            AlGraphPattern::Minus { left, right } => Self::Minus {
 1194|     40|                left: Box::new(Self::from_sparql_algebra(left, graph_name, blank_nodes)),
 1195|     40|                right: Box::new(Self::from_sparql_algebra(right, graph_name, blank_nodes)),
 1196|     40|                algorithm: MinusAlgorithm::default(),
 1197|     40|            },
 1198|       |            AlGraphPattern::Values {
 1199|    390|                variables,
 1200|    390|                bindings,
 1201|    390|            } => Self::Values {
 1202|    390|                variables: variables.clone(),
 1203|    390|                bindings: bindings.clone(),
 1204|    390|            },
 1205|      0|            AlGraphPattern::OrderBy { inner, expression } => Self::OrderBy {
 1206|      0|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1207|      0|                expression: expression
 1208|      0|                    .iter()
 1209|      0|                    .map(|e| OrderExpression::from_sparql_algebra(e, graph_name))
 1210|      0|                    .collect(),
 1211|      0|            },
 1212|  2.01k|            AlGraphPattern::Project { inner, variables } => {
 1213|  2.01k|                let graph_name = if let Some(NamedNodePattern::Variable(graph_name)) = graph_name {
 1214|       |                    Some(NamedNodePattern::Variable(
 1215|      8|                        if variables.contains(graph_name) {
 1216|      2|                            graph_name.clone()
 1217|       |                        } else {
 1218|      6|                            new_var()
 1219|       |                        },
 1220|       |                    ))
 1221|       |                } else {
 1222|  2.00k|                    graph_name.cloned()
 1223|       |                };
 1224|  2.01k|                Self::Project {
 1225|  2.01k|                    inner: Box::new(Self::from_sparql_algebra(
 1226|  2.01k|                        inner,
 1227|  2.01k|                        graph_name.as_ref(),
 1228|  2.01k|                        &mut HashMap::new(),
 1229|  2.01k|                    )),
 1230|  2.01k|                    variables: variables.clone(),
 1231|  2.01k|                }
 1232|       |            }
 1233|    500|            AlGraphPattern::Distinct { inner } => Self::Distinct {
 1234|    500|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1235|    500|            },
 1236|  1.04k|            AlGraphPattern::Reduced { inner } => Self::Distinct {
 1237|  1.04k|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1238|  1.04k|            },
 1239|       |            AlGraphPattern::Slice {
 1240|      0|                inner,
 1241|      0|                start,
 1242|      0|                length,
 1243|      0|            } => Self::Slice {
 1244|      0|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1245|      0|                start: *start,
 1246|      0|                length: *length,
 1247|      0|            },
 1248|       |            AlGraphPattern::Group {
 1249|     12|                inner,
 1250|     12|                variables,
 1251|     12|                aggregates,
 1252|     12|            } => Self::Group {
 1253|     12|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1254|     12|                variables: variables.clone(),
 1255|     12|                aggregates: aggregates
 1256|     12|                    .iter()
 1257|     12|                    .map(|(var, expr)| {
 1258|       |                        (
 1259|       |                            var.clone(),
 1260|       |                            AggregateExpression::from_sparql_algebra(expr, graph_name),
 1261|       |                        )
 1262|     12|                    })
 1263|     12|                    .collect(),
 1264|     12|            },
 1265|       |            AlGraphPattern::Service {
 1266|      0|                inner,
 1267|      0|                name,
 1268|      0|                silent,
 1269|      0|            } => Self::Service {
 1270|      0|                inner: Box::new(Self::from_sparql_algebra(inner, graph_name, blank_nodes)),
 1271|      0|                name: name.clone(),
 1272|      0|                silent: *silent,
 1273|      0|            },
 1274|       |        }
 1275|  52.1k|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression10unary_plus:
  164|    155|    pub fn unary_plus(inner: Self) -> Self {
  165|    155|        Self::UnaryPlus(Box::new(inner))
  166|    155|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression14used_variables:
  210|     96|    pub fn used_variables(&self) -> HashSet<&Variable> {
  211|     96|        let mut variables = HashSet::new();
  212|     96|        self.lookup_used_variables(&mut |v| {
  213|       |            variables.insert(v);
  214|     96|        });
  215|     96|        variables
  216|     96|    }
_RNvXs0_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf7literal7LiteralE4from:
  398|  30.9k|    fn from(value: Literal) -> Self {
  399|  30.9k|        Self::Literal(value)
  400|  30.9k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern27triple_pattern_from_algebra:
 1277|  37.4k|    fn triple_pattern_from_algebra(
 1278|  37.4k|        pattern: &TriplePattern,
 1279|  37.4k|        blank_nodes: &mut HashMap<BlankNode, Variable>,
 1280|  37.4k|    ) -> (GroundTermPattern, NamedNodePattern, GroundTermPattern) {
 1281|  37.4k|        (
 1282|  37.4k|            Self::term_pattern_from_algebra(&pattern.subject, blank_nodes),
 1283|  37.4k|            pattern.predicate.clone(),
 1284|  37.4k|            Self::term_pattern_from_algebra(&pattern.object, blank_nodes),
 1285|  37.4k|        )
 1286|  37.4k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern18is_empty_singleton:
  750|   136k|    pub fn is_empty_singleton(&self) -> bool {
  751|   136k|        if let Self::Values { bindings, .. } = self {
  752|    658|            bindings.len() == 1 && bindings.iter().all(|b| b.iter().all(Option::is_none))
  753|       |        } else {
  754|   136k|            false
  755|       |        }
  756|   136k|    }
_RNvXsm_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_17LeftJoinAlgorithmNtNtCs9nhK3FOW46N_4core7default7Default7default:
 1517|    442|    fn default() -> Self {
 1518|    442|        Self::HashBuildRightProbeLeft {
 1519|    442|            keys: Vec::default(),
 1520|    442|        }
 1521|    442|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern8distinct:
  960|  2.18k|    pub fn distinct(inner: Self) -> Self {
  961|  2.18k|        if inner.is_empty() {
  962|      0|            return Self::empty();
  963|  2.18k|        }
  964|  2.18k|        Self::Distinct {
  965|  2.18k|            inner: Box::new(inner),
  966|  2.18k|        }
  967|  2.18k|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression13less_or_equal:
  160|     13|    pub fn less_or_equal(left: Self, right: Self) -> Self {
  161|     13|        Self::LessOrEqual(Box::new(left), Box::new(right))
  162|     13|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression23effective_boolean_value:
  194|  29.7k|    pub fn effective_boolean_value(&self) -> Option<bool> {
  195|  29.7k|        if let Self::Literal(literal) = self {
  196|  27.3k|            match literal.datatype() {
  197|  27.3k|                xsd::BOOLEAN => match literal.value() {
  198|  27.2k|                    "true" | "1" => Some(true),
  199|    134|                    "false" | "0" => Some(false),
  200|      0|                    _ => None, // TODO
  201|       |                },
  202|     52|                xsd::STRING => Some(!literal.value().is_empty()),
  203|     46|                _ => None, // TODO
  204|       |            }
  205|       |        } else {
  206|  2.42k|            None
  207|       |        }
  208|  29.7k|    }
_RNvXsc_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops3bit3Not3not:
  578|  1.20k|    fn not(self) -> Self {
  579|  1.20k|        if let Some(v) = self.effective_boolean_value() {
  580|    151|            (!v).into()
  581|  1.05k|        } else if let Self::Not(v) = self {
  582|     76|            if v.returns_boolean() {
  583|     62|                *v
  584|       |            } else {
  585|     14|                Self::And(vec![*v])
  586|       |            }
  587|       |        } else {
  588|    978|            Self::Not(Box::new(self))
  589|       |        }
  590|  1.20k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern9left_join:
  792|    563|    pub fn left_join(
  793|    563|        left: Self,
  794|    563|        right: Self,
  795|    563|        expression: Expression,
  796|    563|        algorithm: LeftJoinAlgorithm,
  797|    563|    ) -> Self {
  798|    563|        let expression_ebv = expression.effective_boolean_value();
  799|    563|        if left.is_empty()
  800|    562|            || right.is_empty()
  801|    561|            || right.is_empty_singleton()
  802|    524|            || expression_ebv == Some(false)
  803|       |        {
  804|     39|            return left;
  805|    524|        }
  806|    524|        Self::LeftJoin {
  807|    524|            left: Box::new(left),
  808|    524|            right: Box::new(right),
  809|    524|            expression: if expression_ebv == Some(true) {
  810|    524|                true.into()
  811|       |            } else {
  812|      0|                expression
  813|       |            },
  814|    524|            algorithm,
  815|       |        }
  816|    563|    }
_RNvXse_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops5arith3Sub3sub:
  605|    811|    fn sub(self, rhs: Self) -> Self {
  606|    811|        Self::Subtract(Box::new(self), Box::new(rhs))
  607|    811|    }
_RNvXsg_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops5arith3Div3div:
  622|  1.53k|    fn div(self, rhs: Self) -> Self {
  623|  1.53k|        Self::Divide(Box::new(self), Box::new(rhs))
  624|  1.53k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern8is_empty:
  735|   174k|    fn is_empty(&self) -> bool {
  736|   174k|        if let Self::Values { bindings, .. } = self {
  737|  3.83k|            bindings.is_empty()
  738|       |        } else {
  739|   170k|            false
  740|       |        }
  741|   174k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern15empty_singleton:
  743|  2.43k|    pub fn empty_singleton() -> Self {
  744|  2.43k|        Self::Values {
  745|  2.43k|            variables: Vec::new(),
  746|  2.43k|            bindings: vec![Vec::new()],
  747|  2.43k|        }
  748|  2.43k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern5minus:
  818|     57|    pub fn minus(left: Self, right: Self, algorithm: MinusAlgorithm) -> Self {
  819|     57|        if left.is_empty() {
  820|      0|            return Self::empty();
  821|     57|        }
  822|     57|        if right.is_empty() {
  823|      0|            return left;
  824|     57|        }
  825|     57|        Self::Minus {
  826|     57|            left: Box::new(left),
  827|     57|            right: Box::new(right),
  828|     57|            algorithm,
  829|     57|        }
  830|     57|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt7algebra7new_var:
 1624|  31.3k|fn new_var() -> Variable {
 1625|  31.3k|    Variable::new_unchecked(format!("{:x}", random::<u128>()))
 1626|  31.3k|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression4less:
  156|      7|    pub fn less(left: Self, right: Self) -> Self {
  157|      7|        Self::Less(Box::new(left), Box::new(right))
  158|      7|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression4call:
  190|     29|    pub fn call(name: Function, args: Vec<Self>) -> Self {
  191|     29|        Self::FunctionCall(name, args)
  192|     29|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression19from_sparql_algebra:
  255|  19.9k|    fn from_sparql_algebra(
  256|  19.9k|        expression: &AlExpression,
  257|  19.9k|        graph_name: Option<&NamedNodePattern>,
  258|  19.9k|    ) -> Self {
  259|  19.9k|        match expression {
  260|    580|            AlExpression::NamedNode(node) => Self::NamedNode(node.clone()),
  261|  2.01k|            AlExpression::Literal(literal) => Self::Literal(literal.clone()),
  262|  4.33k|            AlExpression::Variable(variable) => Self::Variable(variable.clone()),
  263|     22|            AlExpression::Or(left, right) => Self::Or(vec![
  264|     22|                Self::from_sparql_algebra(left, graph_name),
  265|     22|                Self::from_sparql_algebra(right, graph_name),
  266|     22|            ]),
  267|    270|            AlExpression::And(left, right) => Self::And(vec![
  268|    270|                Self::from_sparql_algebra(left, graph_name),
  269|    270|                Self::from_sparql_algebra(right, graph_name),
  270|    270|            ]),
  271|    174|            AlExpression::Equal(left, right) => Self::Equal(
  272|    174|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  273|    174|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  274|    174|            ),
  275|      0|            AlExpression::SameTerm(left, right) => Self::SameTerm(
  276|      0|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  277|      0|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  278|      0|            ),
  279|     36|            AlExpression::Greater(left, right) => Self::Greater(
  280|     36|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  281|     36|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  282|     36|            ),
  283|    148|            AlExpression::GreaterOrEqual(left, right) => Self::GreaterOrEqual(
  284|    148|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  285|    148|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  286|    148|            ),
  287|     14|            AlExpression::Less(left, right) => Self::Less(
  288|     14|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  289|     14|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  290|     14|            ),
  291|     26|            AlExpression::LessOrEqual(left, right) => Self::LessOrEqual(
  292|     26|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  293|     26|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  294|     26|            ),
  295|  1.31k|            AlExpression::In(left, right) => {
  296|  1.31k|                let left = Self::from_sparql_algebra(left, graph_name);
  297|  1.31k|                match right.len() {
  298|    674|                    0 => Self::if_cond(left, false.into(), false.into()),
  299|    634|                    1 => Self::Equal(
  300|    634|                        Box::new(left),
  301|    634|                        Box::new(Self::from_sparql_algebra(&right[0], graph_name)),
  302|    634|                    ),
  303|      8|                    _ => Self::Or(
  304|      8|                        right
  305|      8|                            .iter()
  306|      8|                            .map(|e| {
  307|       |                                Self::Equal(
  308|       |                                    Box::new(left.clone()),
  309|       |                                    Box::new(Self::from_sparql_algebra(e, graph_name)),
  310|       |                                )
  311|      8|                            })
  312|      8|                            .collect(),
  313|      8|                    ),
  314|       |                }
  315|       |            }
  316|    268|            AlExpression::Add(left, right) => Self::Add(
  317|    268|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  318|    268|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  319|    268|            ),
  320|  1.61k|            AlExpression::Subtract(left, right) => Self::Subtract(
  321|  1.61k|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  322|  1.61k|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  323|  1.61k|            ),
  324|    580|            AlExpression::Multiply(left, right) => Self::Multiply(
  325|    580|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  326|    580|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  327|    580|            ),
  328|  3.05k|            AlExpression::Divide(left, right) => Self::Divide(
  329|  3.05k|                Box::new(Self::from_sparql_algebra(left, graph_name)),
  330|  3.05k|                Box::new(Self::from_sparql_algebra(right, graph_name)),
  331|  3.05k|            ),
  332|    310|            AlExpression::UnaryPlus(inner) => {
  333|    310|                Self::UnaryPlus(Box::new(Self::from_sparql_algebra(inner, graph_name)))
  334|       |            }
  335|  2.14k|            AlExpression::UnaryMinus(inner) => {
  336|  2.14k|                Self::UnaryMinus(Box::new(Self::from_sparql_algebra(inner, graph_name)))
  337|       |            }
  338|  2.40k|            AlExpression::Not(inner) => {
  339|  2.40k|                Self::Not(Box::new(Self::from_sparql_algebra(inner, graph_name)))
  340|       |            }
  341|    128|            AlExpression::Exists(inner) => Self::Exists(Box::new(
  342|    128|                GraphPattern::from_sparql_algebra(inner, graph_name, &mut HashMap::new()),
  343|    128|            )),
  344|    376|            AlExpression::Bound(variable) => Self::Bound(variable.clone()),
  345|      0|            AlExpression::If(cond, yes, no) => Self::If(
  346|      0|                Box::new(Self::from_sparql_algebra(cond, graph_name)),
  347|      0|                Box::new(Self::from_sparql_algebra(yes, graph_name)),
  348|      0|                Box::new(Self::from_sparql_algebra(no, graph_name)),
  349|      0|            ),
  350|     80|            AlExpression::Coalesce(inner) => Self::Coalesce(
  351|     80|                inner
  352|     80|                    .iter()
  353|     80|                    .map(|e| Self::from_sparql_algebra(e, graph_name))
  354|     80|                    .collect(),
  355|     80|            ),
  356|     58|            AlExpression::FunctionCall(name, args) => Self::FunctionCall(
  357|     58|                name.clone(),
  358|     58|                args.iter()
  359|     58|                    .map(|e| Self::from_sparql_algebra(e, graph_name))
  360|     58|                    .collect(),
  361|     58|            ),
  362|       |        }
  363|  19.9k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern7project:
  953|  2.85k|    pub fn project(inner: Self, variables: Vec<Variable>) -> Self {
  954|  2.85k|        Self::Project {
  955|  2.85k|            inner: Box::new(inner),
  956|  2.85k|            variables,
  957|  2.85k|        }
  958|  2.85k|    }
_RNvXsj_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPatternINtNtCs9nhK3FOW46N_4core7convert4FromRNtNtCshSv3hUzq9FP_9spargebra7algebra12GraphPatternE4from:
 1317|  4.89k|    fn from(pattern: &AlGraphPattern) -> Self {
 1318|  4.89k|        Self::from_sparql_algebra(pattern, None, &mut HashMap::new())
 1319|  4.89k|    }
_RNvXsl_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_13JoinAlgorithmNtNtCs9nhK3FOW46N_4core7default7Default7default:
 1503|  46.1k|    fn default() -> Self {
 1504|  46.1k|        Self::HashBuildLeftProbeRight {
 1505|  46.1k|            keys: Vec::default(),
 1506|  46.1k|        }
 1507|  46.1k|    }
_RNvXsx_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
   22|    153|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvXsS_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_17LeftJoinAlgorithmNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
 1511|     12|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression16greater_or_equal:
  152|     74|    pub fn greater_or_equal(left: Self, right: Self) -> Self {
  153|     74|        Self::GreaterOrEqual(Box::new(left), Box::new(right))
  154|     74|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression8coalesce:
  186|     40|    pub fn coalesce(args: Vec<Self>) -> Self {
  187|     40|        Self::Coalesce(args)
  188|     40|    }
_RNvXs_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB4_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromNtNtCshJ9d6mhVUZV_5oxrdf10named_node9NamedNodeE4from:
  392|    290|    fn from(value: NamedNode) -> Self {
  393|    290|        Self::NamedNode(value)
  394|    290|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern6extend:
  886|    843|    pub fn extend(inner: Self, variable: Variable, expression: Expression) -> Self {
  887|    843|        if inner.is_empty() {
  888|      1|            return Self::empty();
  889|    842|        }
  890|    842|        Self::Extend {
  891|    842|            inner: Box::new(inner),
  892|    842|            variable,
  893|    842|            expression,
  894|    842|        }
  895|    843|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression7greater:
  148|     18|    pub fn greater(left: Self, right: Self) -> Self {
  149|     18|        Self::Greater(Box::new(left), Box::new(right))
  150|     18|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression7if_cond:
  178|  1.01k|    pub fn if_cond(cond: Self, then: Self, els: Self) -> Self {
  179|  1.01k|        match cond.effective_boolean_value() {
  180|      1|            Some(true) => then,
  181|      0|            Some(false) => els,
  182|  1.01k|            None => Self::If(Box::new(cond), Box::new(then), Box::new(els)),
  183|       |        }
  184|  1.01k|    }
_RNvXs8_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FrombE4from:
  480|  29.0k|    fn from(value: bool) -> Self {
  481|  29.0k|        Literal::from(value).into()
  482|  29.0k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern5empty:
  727|     97|    pub fn empty() -> Self {
  728|     97|        Self::Values {
  729|     97|            variables: Vec::new(),
  730|     97|            bindings: Vec::new(),
  731|     97|        }
  732|     97|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern7lateral:
  776|  43.7k|    pub fn lateral(left: Self, right: Self) -> Self {
  777|  43.7k|        if left.is_empty() || right.is_empty() {
  778|      1|            return Self::empty();
  779|  43.7k|        }
  780|  43.7k|        if left.is_empty_singleton() {
  781|    242|            return right;
  782|  43.5k|        }
  783|  43.5k|        if right.is_empty_singleton() {
  784|      7|            return left;
  785|  43.5k|        }
  786|  43.5k|        Self::Lateral {
  787|  43.5k|            left: Box::new(left),
  788|  43.5k|            right: Box::new(right),
  789|  43.5k|        }
  790|  43.7k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern6values:
  897|  1.39k|    pub fn values(
  898|  1.39k|        mut variables: Vec<Variable>,
  899|  1.39k|        mut bindings: Vec<Vec<Option<GroundTerm>>>,
  900|  1.39k|    ) -> Self {
  901|  1.39k|        let empty_rows = (0..variables.len())
  902|  1.39k|            .filter(|row| !bindings.iter().any(|binding| binding.get(*row).is_some()))
  903|  1.39k|            .collect::<Vec<_>>();
  904|  1.39k|        if !empty_rows.is_empty() {
  905|     50|            // We remove empty rows
  906|     50|            variables = variables
  907|     50|                .into_iter()
  908|     50|                .enumerate()
  909|     50|                .filter_map(|(i, v)| {
  910|       |                    if empty_rows.contains(&i) {
  911|       |                        None
  912|       |                    } else {
  913|       |                        Some(v)
  914|       |                    }
  915|     50|                })
  916|     50|                .collect();
  917|     50|            bindings = bindings
  918|     50|                .into_iter()
  919|     50|                .map(|binding| {
  920|       |                    binding
  921|       |                        .into_iter()
  922|       |                        .enumerate()
  923|       |                        .filter_map(|(i, v)| {
  924|       |                            if empty_rows.contains(&i) {
  925|       |                                None
  926|       |                            } else {
  927|       |                                Some(v)
  928|       |                            }
  929|       |                        })
  930|       |                        .collect()
  931|     50|                })
  932|     50|                .collect();
  933|  1.34k|        }
  934|  1.39k|        Self::Values {
  935|  1.39k|            variables,
  936|  1.39k|            bindings,
  937|  1.39k|        }
  938|  1.39k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern4join:
  758|  24.4k|    pub fn join(left: Self, right: Self, algorithm: JoinAlgorithm) -> Self {
  759|  24.4k|        if left.is_empty() || right.is_empty() {
  760|     27|            return Self::empty();
  761|  24.4k|        }
  762|  24.4k|        if left.is_empty_singleton() {
  763|    136|            return right;
  764|  24.2k|        }
  765|  24.2k|        if right.is_empty_singleton() {
  766|      2|            return left;
  767|  24.2k|        }
  768|  24.2k|        Self::Join {
  769|  24.2k|            left: Box::new(left),
  770|  24.2k|            right: Box::new(right),
  771|  24.2k|            algorithm,
  772|  24.2k|        }
  773|  24.4k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern6filter:
  858|  26.4k|    pub fn filter(inner: Self, expression: Expression) -> Self {
  859|  26.4k|        if inner.is_empty() {
  860|     47|            return Self::empty();
  861|  26.4k|        }
  862|       |        // We unwrap singleton And
  863|  26.4k|        let expression = match expression {
  864|     16|            Expression::And(mut l) if l.len() == 1 => l.pop().unwrap(),
  865|  26.4k|            e => e,
  866|       |        };
  867|  26.4k|        match expression.effective_boolean_value() {
  868|  26.3k|            Some(true) => inner,
  869|      0|            Some(false) => Self::empty(),
  870|     75|            None => match inner {
  871|       |                Self::Filter {
  872|      0|                    inner,
  873|      0|                    expression: e2,
  874|      0|                } => Self::Filter {
  875|      0|                    inner,
  876|      0|                    expression: expression & e2,
  877|      0|                },
  878|     75|                _ => Self::Filter {
  879|     75|                    inner: Box::new(inner),
  880|     75|                    expression,
  881|     75|                },
  882|       |            },
  883|       |        }
  884|  26.4k|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression9same_term:
  137|      3|    pub fn same_term(left: Self, right: Self) -> Self {
  138|      3|        match (left, right) {
  139|      0|            (Self::NamedNode(left), Self::NamedNode(right)) => (left == right).into(),
  140|      0|            (Self::Literal(left), Self::Literal(right)) if left == right => true.into(),
  141|      3|            (left, right) => {
  142|      3|                let (left, right) = order_pair(left, right);
  143|      3|                Self::SameTerm(Box::new(left), Box::new(right))
  144|       |            }
  145|       |        }
  146|      3|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB2_10Expression6exists:
  168|     64|    pub fn exists(inner: GraphPattern) -> Self {
  169|     64|        if inner.is_empty() {
  170|      0|            return false.into();
  171|     64|        }
  172|     64|        if inner.is_empty_singleton() {
  173|      2|            return true.into();
  174|     62|        }
  175|     62|        Self::Exists(Box::new(inner))
  176|     64|    }
_RNvXsn_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_14MinusAlgorithmNtNtCs9nhK3FOW46N_4core7default7Default7default:
 1531|     40|    fn default() -> Self {
 1532|     40|        Self::HashBuildRightProbeLeft {
 1533|     40|            keys: Vec::default(),
 1534|     40|        }
 1535|     40|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern5group:
  992|     18|    pub fn group(
  993|     18|        inner: Self,
  994|     18|        variables: Vec<Variable>,
  995|     18|        aggregates: Vec<(Variable, AggregateExpression)>,
  996|     18|    ) -> Self {
  997|     18|        if inner.is_empty() {
  998|      0|            return Self::empty();
  999|     18|        }
 1000|     18|        Self::Group {
 1001|     18|            inner: Box::new(inner),
 1002|     18|            variables,
 1003|     18|            aggregates,
 1004|     18|        }
 1005|     18|    }
_RNvXsd_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops5arith3Add3add:
  596|    134|    fn add(self, rhs: Self) -> Self {
  597|    134|        let (left, right) = order_pair(self, rhs);
  598|    134|        Self::Add(Box::new(left), Box::new(right))
  599|    134|    }
_RNvXsf_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops5arith3Mul3mul:
  613|    290|    fn mul(self, rhs: Self) -> Self {
  614|    290|        let (left, right) = order_pair(self, rhs);
  615|    290|        Self::Multiply(Box::new(left), Box::new(right))
  616|    290|    }
_RNvXsh_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_10ExpressionNtNtNtCs9nhK3FOW46N_4core3ops5arith3Neg3neg:
  630|  1.07k|    fn neg(self) -> Self {
  631|  1.07k|        Self::UnaryMinus(Box::new(self))
  632|  1.07k|    }
_RNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB5_12GraphPattern25term_pattern_from_algebra:
 1288|  98.9k|    fn term_pattern_from_algebra(
 1289|  98.9k|        pattern: &TermPattern,
 1290|  98.9k|        blank_nodes: &mut HashMap<BlankNode, Variable>,
 1291|  98.9k|    ) -> GroundTermPattern {
 1292|  98.9k|        match pattern {
 1293|  8.93k|            TermPattern::NamedNode(node) => node.clone().into(),
 1294|  71.6k|            TermPattern::BlankNode(node) => blank_nodes
 1295|  71.6k|                .entry(node.clone())
 1296|  71.6k|                .or_insert_with(new_var)
 1297|  71.6k|                .clone()
 1298|  71.6k|                .into(),
 1299|  1.32k|            TermPattern::Literal(literal) => literal.clone().into(),
 1300|       |            #[cfg(feature = "rdf-star")]
 1301|      0|            TermPattern::Triple(pattern) => {
 1302|      0|                let (subject, predicate, object) =
 1303|      0|                    Self::triple_pattern_from_algebra(pattern, blank_nodes);
 1304|      0|                GroundTriplePattern {
 1305|      0|                    subject,
 1306|      0|                    predicate,
 1307|      0|                    object,
 1308|      0|                }
 1309|      0|                .into()
 1310|       |            }
 1311|  17.0k|            TermPattern::Variable(variable) => variable.clone().into(),
 1312|       |        }
 1313|  98.9k|    }
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern19from_sparql_algebra0B9_:
 1122|  37.4k|                .map(|p| {
 1123|  37.4k|                    let (subject, predicate, object) =
 1124|  37.4k|                        Self::triple_pattern_from_algebra(p, blank_nodes);
 1125|  37.4k|                    Self::QuadPattern {
 1126|  37.4k|                        subject,
 1127|  37.4k|                        predicate,
 1128|  37.4k|                        object,
 1129|  37.4k|                        graph_name: graph_name.cloned(),
 1130|  37.4k|                    }
 1131|  37.4k|                })
_RINvNtCsaDAmlQ5xRbD_7sparopt7algebra4hashRNtB2_10ExpressionEB4_:
 1641|  2.04k|fn hash(v: impl Hash) -> u64 {
 1642|  2.04k|    let mut hasher = DefaultHasher::new();
 1643|  2.04k|    v.hash(&mut hasher);
 1644|  2.04k|    hasher.finish()
 1645|  2.04k|}
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern18is_empty_singleton0B9_:
  752|    537|            bindings.len() == 1 && bindings.iter().all(|b| b.iter().all(Option::is_none))
_RINvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_12GraphPattern9union_allINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBC_ENCNvMNtB8_9optimizerNtB2Q_9Optimizer12push_filterss_0EEB8_:
  836|     19|    pub fn union_all(args: impl IntoIterator<Item = Self>) -> Self {
  837|     19|        let args = args.into_iter();
  838|     19|        let mut all = Vec::with_capacity(args.size_hint().0);
  839|     57|        for arg in args {
  840|     38|            if arg.is_empty() {
  841|      0|                continue;
  842|     38|            }
  843|     38|            if let Self::Union { inner } = arg {
  844|      0|                all.extend(inner);
  845|     38|            } else {
  846|     38|                all.push(arg);
  847|     38|            }
  848|       |        }
  849|     19|        if all.is_empty() {
  850|      0|            Self::empty()
  851|       |        } else {
  852|     19|            Self::Union {
  853|     19|                inner: order_vec(all),
  854|     19|            }
  855|       |        }
  856|     19|    }
_RINvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_12GraphPattern9union_allINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBC_ENCNvMNtB8_9optimizerNtB2Q_9Optimizer13reorder_joinss7_0EEB8_:
  836|     10|    pub fn union_all(args: impl IntoIterator<Item = Self>) -> Self {
  837|     10|        let args = args.into_iter();
  838|     10|        let mut all = Vec::with_capacity(args.size_hint().0);
  839|     30|        for arg in args {
  840|     20|            if arg.is_empty() {
  841|      0|                continue;
  842|     20|            }
  843|     20|            if let Self::Union { inner } = arg {
  844|      0|                all.extend(inner);
  845|     20|            } else {
  846|     20|                all.push(arg);
  847|     20|            }
  848|       |        }
  849|     10|        if all.is_empty() {
  850|      0|            Self::empty()
  851|       |        } else {
  852|     10|            Self::Union {
  853|     10|                inner: order_vec(all),
  854|     10|            }
  855|       |        }
  856|     10|    }
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB4_10Expression19from_sparql_algebras_0B6_:
  353|     16|                    .map(|e| Self::from_sparql_algebra(e, graph_name))
_RINvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB3_10Expression7and_allINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBz_ENCNvMNtB5_9optimizerNtB2J_9Optimizer20normalize_expressions_0EEB5_:
   97|    135|    pub fn and_all(args: impl IntoIterator<Item = Self>) -> Self {
   98|    135|        let args = args.into_iter();
   99|    135|        let mut all = Vec::with_capacity(args.size_hint().0);
  100|    405|        for arg in args {
  101|    270|            if let Some(ebv) = arg.effective_boolean_value() {
  102|      0|                if !ebv {
  103|      0|                    return false.into();
  104|      0|                }
  105|       |                // We ignore true values
  106|    270|            } else if let Self::And(args) = arg {
  107|     23|                all.extend(args);
  108|    247|            } else {
  109|    247|                all.push(arg);
  110|    247|            }
  111|       |        }
  112|    135|        match all.len() {
  113|      0|            0 => true.into(),
  114|       |            1 => {
  115|      0|                let result = all.pop().unwrap();
  116|      0|                if result.returns_boolean() {
  117|      0|                    result
  118|       |                } else {
  119|      0|                    Self::And(vec![result])
  120|       |                }
  121|       |            }
  122|    135|            _ => Self::And(order_vec(all)),
  123|       |        }
  124|    135|    }
_RINvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_12GraphPattern9union_allINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBC_ENCNvMNtB8_9optimizerNtB2Q_9Optimizer17normalize_pattern0EEB8_:
  836|     19|    pub fn union_all(args: impl IntoIterator<Item = Self>) -> Self {
  837|     19|        let args = args.into_iter();
  838|     19|        let mut all = Vec::with_capacity(args.size_hint().0);
  839|     57|        for arg in args {
  840|     38|            if arg.is_empty() {
  841|      0|                continue;
  842|     38|            }
  843|     38|            if let Self::Union { inner } = arg {
  844|      0|                all.extend(inner);
  845|     38|            } else {
  846|     38|                all.push(arg);
  847|     38|            }
  848|       |        }
  849|     19|        if all.is_empty() {
  850|      0|            Self::empty()
  851|       |        } else {
  852|     19|            Self::Union {
  853|     19|                inner: order_vec(all),
  854|     19|            }
  855|       |        }
  856|     19|    }
_RNCNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB9_12GraphPattern6values00Bb_:
  902|  2.39k|            .filter(|row| !bindings.iter().any(|binding| binding.get(*row).is_some()))
_RINvNtCsaDAmlQ5xRbD_7sparopt7algebra9order_vecNtB2_10ExpressionEB4_:
 1636|    154|fn order_vec<T: Hash>(mut vec: Vec<T>) -> Vec<T> {
 1637|    154|    vec.sort_unstable_by_key(|a| hash(a));
 1638|    154|    vec
 1639|    154|}
_RINvNtCsaDAmlQ5xRbD_7sparopt7algebra9order_vecNtB2_12GraphPatternEB4_:
 1636|     48|fn order_vec<T: Hash>(mut vec: Vec<T>) -> Vec<T> {
 1637|     48|    vec.sort_unstable_by_key(|a| hash(a));
 1638|     48|    vec
 1639|     48|}
_RINvXsM_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_13JoinAlgorithmNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEB8_:
 1497|  1.02k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB3_10Expression7and_allINtNtCsjOdcKtOMjJI_5alloc3vec3VecBz_EEB5_:
   97|  26.3k|    pub fn and_all(args: impl IntoIterator<Item = Self>) -> Self {
   98|  26.3k|        let args = args.into_iter();
   99|  26.3k|        let mut all = Vec::with_capacity(args.size_hint().0);
  100|  26.4k|        for arg in args {
  101|     27|            if let Some(ebv) = arg.effective_boolean_value() {
  102|      0|                if !ebv {
  103|      0|                    return false.into();
  104|      0|                }
  105|       |                // We ignore true values
  106|     27|            } else if let Self::And(args) = arg {
  107|      0|                all.extend(args);
  108|     27|            } else {
  109|     27|                all.push(arg);
  110|     27|            }
  111|       |        }
  112|  26.3k|        match all.len() {
  113|  26.3k|            0 => true.into(),
  114|       |            1 => {
  115|     18|                let result = all.pop().unwrap();
  116|     18|                if result.returns_boolean() {
  117|     16|                    result
  118|       |                } else {
  119|      2|                    Self::And(vec![result])
  120|       |                }
  121|       |            }
  122|      4|            _ => Self::And(order_vec(all)),
  123|       |        }
  124|  26.3k|    }
_RNCNvXs9_NtCsaDAmlQ5xRbD_7sparopt7algebraNtNtCshSv3hUzq9FP_9spargebra7algebra10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromRNtB7_10ExpressionE4from0B9_:
  494|     36|                .reduce(|a, b| Self::Or(Box::new(a), Box::new(b)))
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern6valuess_0B9_:
  909|    819|                .filter_map(|(i, v)| {
  910|    819|                    if empty_rows.contains(&i) {
  911|    819|                        None
  912|       |                    } else {
  913|      0|                        Some(v)
  914|       |                    }
  915|    819|                })
_RNCNvXs9_NtCsaDAmlQ5xRbD_7sparopt7algebraNtNtCshSv3hUzq9FP_9spargebra7algebra10ExpressionINtNtCs9nhK3FOW46N_4core7convert4FromRNtB7_10ExpressionE4froms0_0B9_:
  499|    284|                .reduce(|a, b| Self::And(Box::new(a), Box::new(b)))
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB4_10Expression14used_variables0B6_:
  212|     49|        self.lookup_used_variables(&mut |v| {
  213|     49|            variables.insert(v);
  214|     49|        });
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern6values0B9_:
  902|  3.21k|            .filter(|row| !bindings.iter().any(|binding| binding.get(*row).is_some()))
_RNCINvNtCsaDAmlQ5xRbD_7sparopt7algebra9order_vecNtB4_12GraphPatternE0B6_:
 1637|     96|    vec.sort_unstable_by_key(|a| hash(a));
_RINvXsy_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_10ExpressionNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEB8_:
   22|  25.4k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RINvXsF_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB6_12GraphPatternNtNtCs9nhK3FOW46N_4core4hash4Hash4hashNtNtNtCsc4CYCHgsNRQ_3std4hash6random13DefaultHasherEB8_:
  636|  2.74k|#[derive(Eq, PartialEq, Debug, Clone, Hash)]
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern19from_sparql_algebras_0B9_:
 1132|  28.0k|                .reduce(|a, b| Self::Join {
 1133|  28.0k|                    left: Box::new(a),
 1134|  28.0k|                    right: Box::new(b),
 1135|  28.0k|                    algorithm: JoinAlgorithm::default(),
 1136|  28.0k|                })
_RINvNtCsaDAmlQ5xRbD_7sparopt7algebra4hashRNtB2_12GraphPatternEB4_:
 1641|     96|fn hash(v: impl Hash) -> u64 {
 1642|     96|    let mut hasher = DefaultHasher::new();
 1643|     96|    v.hash(&mut hasher);
 1644|     96|    hasher.finish()
 1645|     96|}
_RINvNtCsaDAmlQ5xRbD_7sparopt7algebra10order_pairNtB2_10ExpressionEB4_:
 1628|    834|fn order_pair<T: Hash>(a: T, b: T) -> (T, T) {
 1629|    834|    if hash(&a) <= hash(&b) {
 1630|    603|        (a, b)
 1631|       |    } else {
 1632|    231|        (b, a)
 1633|       |    }
 1634|    834|}
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB4_10Expression19from_sparql_algebra0B6_:
  306|     16|                            .map(|e| {
  307|     16|                                Self::Equal(
  308|     16|                                    Box::new(left.clone()),
  309|     16|                                    Box::new(Self::from_sparql_algebra(e, graph_name)),
  310|     16|                                )
  311|     16|                            })
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB4_10Expression19from_sparql_algebras0_0B6_:
  359|     60|                    .map(|e| Self::from_sparql_algebra(e, graph_name))
_RINvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB3_10Expression21lookup_used_variablesNCNvB2_14used_variables0EB5_:
  218|  1.25k|    pub fn lookup_used_variables<'a>(&'a self, callback: &mut impl FnMut(&'a Variable)) {
  219|  1.25k|        match self {
  220|    430|            Self::NamedNode(_) | Self::Literal(_) => {}
  221|     49|            Self::Variable(v) | Self::Bound(v) => callback(v),
  222|      0|            Self::Or(inner)
  223|      1|            | Self::And(inner)
  224|      3|            | Self::Coalesce(inner)
  225|      0|            | Self::FunctionCall(_, inner) => {
  226|      6|                for i in inner {
  227|      2|                    i.lookup_used_variables(callback);
  228|      2|                }
  229|       |            }
  230|    108|            Self::Equal(a, b)
  231|      0|            | Self::SameTerm(a, b)
  232|      0|            | Self::Greater(a, b)
  233|      0|            | Self::GreaterOrEqual(a, b)
  234|      0|            | Self::Less(a, b)
  235|      0|            | Self::LessOrEqual(a, b)
  236|     42|            | Self::Add(a, b)
  237|     48|            | Self::Subtract(a, b)
  238|    125|            | Self::Multiply(a, b)
  239|    383|            | Self::Divide(a, b) => {
  240|    383|                a.lookup_used_variables(callback);
  241|    383|                b.lookup_used_variables(callback);
  242|    383|            }
  243|    314|            Self::UnaryPlus(i) | Self::UnaryMinus(i) | Self::Not(i) => {
  244|    386|                i.lookup_used_variables(callback)
  245|       |            }
  246|      0|            Self::Exists(e) => e.lookup_used_variables(callback),
  247|      1|            Self::If(a, b, c) => {
  248|      1|                a.lookup_used_variables(callback);
  249|      1|                b.lookup_used_variables(callback);
  250|      1|                c.lookup_used_variables(callback);
  251|      1|            }
  252|       |        }
  253|  1.25k|    }
_RINvMNtCsaDAmlQ5xRbD_7sparopt7algebraNtB3_10Expression6or_allINtNtNtNtCs9nhK3FOW46N_4core4iter8adapters3map3MapINtNtNtCsjOdcKtOMjJI_5alloc3vec9into_iter8IntoIterBz_ENCNvMNtB5_9optimizerNtB2I_9Optimizer20normalize_expression0EEB5_:
   68|     15|    pub fn or_all(args: impl IntoIterator<Item = Self>) -> Self {
   69|     15|        let args = args.into_iter();
   70|     15|        let mut all = Vec::with_capacity(args.size_hint().0);
   71|     45|        for arg in args {
   72|     30|            if let Some(ebv) = arg.effective_boolean_value() {
   73|      0|                if ebv {
   74|      0|                    return true.into();
   75|      0|                }
   76|       |                // We ignore false values
   77|     30|            } else if let Self::Or(args) = arg {
   78|      0|                all.extend(args);
   79|     30|            } else {
   80|     30|                all.push(arg);
   81|     30|            }
   82|       |        }
   83|     15|        match all.len() {
   84|      0|            0 => false.into(),
   85|       |            1 => {
   86|      0|                let result = all.pop().unwrap();
   87|      0|                if result.returns_boolean() {
   88|      0|                    result // It's already casted to boolean
   89|       |                } else {
   90|      0|                    Self::And(vec![result])
   91|       |                }
   92|       |            }
   93|     15|            _ => Self::Or(order_vec(all)),
   94|       |        }
   95|     15|    }
_RNCINvNtCsaDAmlQ5xRbD_7sparopt7algebra9order_vecNtB4_10ExpressionE0B6_:
 1637|    374|    vec.sort_unstable_by_key(|a| hash(a));
_RNCNvMsi_NtCsaDAmlQ5xRbD_7sparopt7algebraNtB7_12GraphPattern19from_sparql_algebras0_0B9_:
 1161|    442|                    || true.into(),

_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss3_0B6_:
  525|   481k|                        .map(|(i, _)| i)
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss5_0B6_:
  529|   263k|                        .min_by_key(|i| {
  530|   263k|                            // Estimation of the join cost
  531|   263k|                            if cfg!(feature = "sep-0006")
  532|   263k|                                && is_fit_for_for_loop_join(
  533|   263k|                                    &to_reorder[*i],
  534|   263k|                                    input_types,
  535|   263k|                                    &output_types,
  536|   263k|                                )
  537|       |                            {
  538|   263k|                                estimate_lateral_cost(
  539|   263k|                                    &output,
  540|   263k|                                    &output_types,
  541|   263k|                                    &to_reorder[*i],
  542|   263k|                                    input_types,
  543|   263k|                                )
  544|       |                            } else {
  545|     33|                                estimate_join_cost(
  546|     33|                                    &output,
  547|     33|                                    &to_reorder[*i],
  548|     33|                                    &JoinAlgorithm::HashBuildLeftProbeRight {
  549|     33|                                        keys: join_key_variables(
  550|     33|                                            &output_types,
  551|     33|                                            &to_reorder_types[*i],
  552|     33|                                            input_types,
  553|     33|                                        ),
  554|     33|                                    },
  555|     33|                                    input_types,
  556|     33|                                )
  557|       |                            }
  558|   263k|                        })
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer18join_key_variables0B5_:
  886|  2.67k|        .filter(|(variable, left_type)| {
  887|  2.67k|            !left_type.undef && !right.get(variable).undef && input_types.get(variable).undef
  888|  2.67k|        })
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss7_0B6_:
  696|     20|                    .map(|c| Self::reorder_joins(c, input_types)),
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer24is_fit_for_for_loop_join0B5_:
  760|    179|            if right_types.iter().any(|(variable, t)| {
  761|    179|                *t != VariableType::UNDEF
  762|    179|                    && left_types.get(variable).undef
  763|    166|                    && entry_types.get(variable) != VariableType::UNDEF
  764|    179|            }) {
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer17normalize_pattern0B6_:
   93|     38|                    .map(|e| Self::normalize_pattern(e, input_types)),
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss0_0B6_:
  514|  28.3k|                    .map(|(i, _)| i)
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer20normalize_expression0B6_:
  184|     30|                    .map(|e| Self::normalize_expression(e, types)),
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer34are_all_expression_variables_bound0B5_:
  815|     40|        .all(|v| !variable_types.get(v).undef)
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joins0B6_:
  503|  23.7k|                    .map(|p| infer_graph_pattern_types(p, input_types.clone()))
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss4_0B6_:
  526|   481k|                        .filter(|i| {
  527|   481k|                            has_common_variables(&output_types, &to_reorder_types[*i], input_types)
  528|   481k|                        })
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer20normalize_expressions0_0B6_:
  264|      8|                    .map(|e| Self::normalize_expression(e, types))
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss_0B6_:
  513|  56.2k|                    .filter(|(_, v)| **v)
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer24is_fit_for_for_loop_joins_0B5_:
  774|      6|            .all(|i| is_fit_for_for_loop_join(i, global_input_types, entry_types)),
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss1_0B6_:
  515|  28.3k|                    .min_by_key(|i| estimate_graph_pattern_size(&to_reorder[*i], input_types))
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss2_0B6_:
  524|   986k|                        .filter(|(_, v)| **v)
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer20normalize_expressions1_0B6_:
  270|     30|                    .map(|e| Self::normalize_expression(e, types))
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer18join_key_variabless_0B5_:
  889|     59|        .map(|(variable, _)| variable.clone())
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer13reorder_joinss6_0B6_:
  601|    583|                    .reduce(|left, right| {
  602|    583|                        let keys = join_key_variables(
  603|    583|                            &infer_graph_pattern_types(&left, input_types.clone()),
  604|    583|                            &infer_graph_pattern_types(&right, input_types.clone()),
  605|    583|                            input_types,
  606|    583|                        );
  607|    583|                        if estimate_graph_pattern_size(&left, input_types)
  608|    583|                            <= estimate_graph_pattern_size(&right, input_types)
  609|       |                        {
  610|    473|                            GraphPattern::join(
  611|    473|                                left,
  612|    473|                                right,
  613|    473|                                JoinAlgorithm::HashBuildLeftProbeRight { keys },
  614|    473|                            )
  615|       |                        } else {
  616|    110|                            GraphPattern::join(
  617|    110|                                right,
  618|    110|                                left,
  619|    110|                                JoinAlgorithm::HashBuildLeftProbeRight { keys },
  620|    110|                            )
  621|       |                        }
  622|    583|                    })
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer27estimate_graph_pattern_size0B5_:
  949|    108|            .map(|inner| estimate_graph_pattern_size(inner, input_types))
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer12push_filterss_0B6_:
  432|     38|                    .map(|c| Self::push_filters(c, filters.clone(), input_types)),
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB4_9Optimizer20normalize_expressions_0B6_:
  189|    270|                    .map(|e| Self::normalize_expression(e, types)),
_RNCNvNtCsaDAmlQ5xRbD_7sparopt9optimizer20has_common_variables0B5_:
  875|  5.53M|    left.iter().any(|(variable, left_type)| {
  876|  5.53M|        !left_type.undef && !right.get(variable).undef && input_types.get(variable).undef
  877|  5.53M|    })
_RNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB2_9Optimizer17normalize_pattern:
   22|  54.2k|    fn normalize_pattern(pattern: GraphPattern, input_types: &VariableTypes) -> GraphPattern {
   23|  54.2k|        match pattern {
   24|       |            GraphPattern::QuadPattern {
   25|  18.7k|                subject,
   26|  18.7k|                predicate,
   27|  18.7k|                object,
   28|  18.7k|                graph_name,
   29|  18.7k|            } => GraphPattern::QuadPattern {
   30|  18.7k|                subject,
   31|  18.7k|                predicate,
   32|  18.7k|                object,
   33|  18.7k|                graph_name,
   34|  18.7k|            },
   35|       |            GraphPattern::Path {
   36|  5.99k|                subject,
   37|  5.99k|                path,
   38|  5.99k|                object,
   39|  5.99k|                graph_name,
   40|  5.99k|            } => GraphPattern::Path {
   41|  5.99k|                subject,
   42|  5.99k|                path,
   43|  5.99k|                object,
   44|  5.99k|                graph_name,
   45|  5.99k|            },
   46|       |            GraphPattern::Join {
   47|  23.0k|                left,
   48|  23.0k|                right,
   49|  23.0k|                algorithm,
   50|  23.0k|            } => GraphPattern::join(
   51|  23.0k|                Self::normalize_pattern(*left, input_types),
   52|  23.0k|                Self::normalize_pattern(*right, input_types),
   53|  23.0k|                algorithm,
   54|  23.0k|            ),
   55|       |            GraphPattern::LeftJoin {
   56|    221|                left,
   57|    221|                right,
   58|    221|                expression,
   59|    221|                algorithm,
   60|    221|            } => {
   61|    221|                let left = Self::normalize_pattern(*left, input_types);
   62|    221|                let right = Self::normalize_pattern(*right, input_types);
   63|    221|                let mut inner_types = infer_graph_pattern_types(&left, input_types.clone());
   64|    221|                inner_types.intersect_with(infer_graph_pattern_types(&right, input_types.clone()));
   65|    221|                GraphPattern::left_join(
   66|    221|                    left,
   67|    221|                    right,
   68|    221|                    Self::normalize_expression(expression, &inner_types),
   69|    221|                    algorithm,
   70|    221|                )
   71|       |            }
   72|       |            #[cfg(feature = "sep-0006")]
   73|    269|            GraphPattern::Lateral { left, right } => {
   74|    269|                let left = Self::normalize_pattern(*left, input_types);
   75|    269|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
   76|    269|                let right = Self::normalize_pattern(*right, &left_types);
   77|    269|                GraphPattern::lateral(left, right)
   78|       |            }
   79|     22|            GraphPattern::Filter { inner, expression } => {
   80|     22|                let inner = Self::normalize_pattern(*inner, input_types);
   81|     22|                let inner_types = infer_graph_pattern_types(&inner, input_types.clone());
   82|     22|                let expression = Self::normalize_expression(expression, &inner_types);
   83|     22|                let expression_type = infer_expression_type(&expression, &inner_types);
   84|     22|                if expression_type == VariableType::UNDEF {
   85|      0|                    GraphPattern::empty()
   86|       |                } else {
   87|     22|                    GraphPattern::filter(inner, expression)
   88|       |                }
   89|       |            }
   90|     19|            GraphPattern::Union { inner } => GraphPattern::union_all(
   91|     19|                inner
   92|     19|                    .into_iter()
   93|     19|                    .map(|e| Self::normalize_pattern(e, input_types)),
   94|     19|            ),
   95|       |            GraphPattern::Extend {
   96|    294|                inner,
   97|    294|                variable,
   98|    294|                expression,
   99|    294|            } => {
  100|    294|                let inner = Self::normalize_pattern(*inner, input_types);
  101|    294|                let inner_types = infer_graph_pattern_types(&inner, input_types.clone());
  102|    294|                let expression = Self::normalize_expression(expression, &inner_types);
  103|    294|                let expression_type = infer_expression_type(&expression, &inner_types);
  104|    294|                if expression_type == VariableType::UNDEF {
  105|       |                    // TODO: valid?
  106|      1|                    inner
  107|       |                } else {
  108|    293|                    GraphPattern::extend(inner, variable, expression)
  109|       |                }
  110|       |            }
  111|       |            GraphPattern::Minus {
  112|     20|                left,
  113|     20|                right,
  114|     20|                algorithm,
  115|     20|            } => GraphPattern::minus(
  116|     20|                Self::normalize_pattern(*left, input_types),
  117|     20|                Self::normalize_pattern(*right, input_types),
  118|     20|                algorithm,
  119|     20|            ),
  120|       |            GraphPattern::Values {
  121|  1.39k|                variables,
  122|  1.39k|                bindings,
  123|  1.39k|            } => GraphPattern::values(variables, bindings),
  124|      0|            GraphPattern::OrderBy { inner, expression } => {
  125|      0|                let inner = Self::normalize_pattern(*inner, input_types);
  126|      0|                let inner_types = infer_graph_pattern_types(&inner, input_types.clone());
  127|      0|                GraphPattern::order_by(
  128|      0|                    inner,
  129|      0|                    expression
  130|      0|                        .into_iter()
  131|      0|                        .map(|e| match e {
  132|       |                            OrderExpression::Asc(e) => {
  133|       |                                OrderExpression::Asc(Self::normalize_expression(e, &inner_types))
  134|       |                            }
  135|       |                            OrderExpression::Desc(e) => {
  136|       |                                OrderExpression::Desc(Self::normalize_expression(e, &inner_types))
  137|       |                            }
  138|      0|                        })
  139|      0|                        .collect(),
  140|      0|                )
  141|       |            }
  142|  1.00k|            GraphPattern::Project { inner, variables } => {
  143|  1.00k|                GraphPattern::project(Self::normalize_pattern(*inner, input_types), variables)
  144|       |            }
  145|    774|            GraphPattern::Distinct { inner } => {
  146|    774|                GraphPattern::distinct(Self::normalize_pattern(*inner, input_types))
  147|       |            }
  148|  2.44k|            GraphPattern::Reduced { inner } => {
  149|  2.44k|                GraphPattern::reduced(Self::normalize_pattern(*inner, input_types))
  150|       |            }
  151|       |            GraphPattern::Slice {
  152|      0|                inner,
  153|      0|                start,
  154|      0|                length,
  155|      0|            } => GraphPattern::slice(Self::normalize_pattern(*inner, input_types), start, length),
  156|       |            GraphPattern::Group {
  157|      6|                inner,
  158|      6|                variables,
  159|      6|                aggregates,
  160|      6|            } => {
  161|      6|                // TODO: min, max and sample don't care about DISTINCT
  162|      6|                GraphPattern::group(
  163|      6|                    Self::normalize_pattern(*inner, input_types),
  164|      6|                    variables,
  165|      6|                    aggregates,
  166|      6|                )
  167|       |            }
  168|       |            GraphPattern::Service {
  169|      0|                name,
  170|      0|                inner,
  171|      0|                silent,
  172|      0|            } => GraphPattern::service(Self::normalize_pattern(*inner, input_types), name, silent),
  173|       |        }
  174|  54.2k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer21estimate_lateral_cost:
  989|  6.78M|fn estimate_lateral_cost(
  990|  6.78M|    left: &GraphPattern,
  991|  6.78M|    left_types: &VariableTypes,
  992|  6.78M|    right: &GraphPattern,
  993|  6.78M|    input_types: &VariableTypes,
  994|  6.78M|) -> usize {
  995|  6.78M|    estimate_graph_pattern_size(left, input_types)
  996|  6.78M|        .saturating_mul(estimate_graph_pattern_size(right, left_types))
  997|  6.78M|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer35is_expression_fit_for_for_loop_join:
  828|     21|fn is_expression_fit_for_for_loop_join(
  829|     21|    expression: &Expression,
  830|     21|    input_types: &VariableTypes,
  831|     21|    entry_types: &VariableTypes,
  832|     21|) -> bool {
  833|     21|    match expression {
  834|     21|        Expression::NamedNode(_) | Expression::Literal(_) => true,
  835|      0|        Expression::Variable(v) | Expression::Bound(v) => {
  836|      0|            !input_types.get(v).undef || entry_types.get(v) == VariableType::UNDEF
  837|       |        }
  838|      0|        Expression::Or(inner)
  839|      0|        | Expression::And(inner)
  840|      0|        | Expression::Coalesce(inner)
  841|      0|        | Expression::FunctionCall(_, inner) => inner
  842|      0|            .iter()
  843|      0|            .all(|e| is_expression_fit_for_for_loop_join(e, input_types, entry_types)),
  844|      0|        Expression::Equal(a, b)
  845|      0|        | Expression::SameTerm(a, b)
  846|      0|        | Expression::Greater(a, b)
  847|      0|        | Expression::GreaterOrEqual(a, b)
  848|      0|        | Expression::Less(a, b)
  849|      0|        | Expression::LessOrEqual(a, b)
  850|      0|        | Expression::Add(a, b)
  851|      0|        | Expression::Subtract(a, b)
  852|      0|        | Expression::Multiply(a, b)
  853|      0|        | Expression::Divide(a, b) => {
  854|      0|            is_expression_fit_for_for_loop_join(a, input_types, entry_types)
  855|      0|                && is_expression_fit_for_for_loop_join(b, input_types, entry_types)
  856|       |        }
  857|      0|        Expression::UnaryPlus(e) | Expression::UnaryMinus(e) | Expression::Not(e) => {
  858|      0|            is_expression_fit_for_for_loop_join(e, input_types, entry_types)
  859|       |        }
  860|      0|        Expression::If(a, b, c) => {
  861|      0|            is_expression_fit_for_for_loop_join(a, input_types, entry_types)
  862|      0|                && is_expression_fit_for_for_loop_join(b, input_types, entry_types)
  863|      0|                && is_expression_fit_for_for_loop_join(c, input_types, entry_types)
  864|       |        }
  865|      0|        Expression::Exists(inner) => is_fit_for_for_loop_join(inner, input_types, entry_types),
  866|       |    }
  867|     21|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer18estimate_path_size:
 1016|  6.78G|fn estimate_path_size(start_bound: bool, path: &PropertyPathExpression, end_bound: bool) -> usize {
 1017|  6.78G|    match path {
 1018|       |        PropertyPathExpression::NamedNode(_) => {
 1019|  1.70G|            estimate_triple_pattern_size(start_bound, true, end_bound)
 1020|       |        }
 1021|  1.80G|        PropertyPathExpression::Reverse(p) => estimate_path_size(end_bound, p, start_bound),
 1022|   916M|        PropertyPathExpression::Sequence(a, b) => {
 1023|   916M|            // We do a for loop join in the best direction
 1024|   916M|            min(
 1025|   916M|                estimate_path_size(start_bound, a, false)
 1026|   916M|                    .saturating_mul(estimate_path_size(true, b, end_bound)),
 1027|   916M|                estimate_path_size(start_bound, a, true)
 1028|   916M|                    .saturating_mul(estimate_path_size(false, b, end_bound)),
 1029|   916M|            )
 1030|       |        }
 1031|  98.3M|        PropertyPathExpression::Alternative(a, b) => estimate_path_size(start_bound, a, end_bound)
 1032|  98.3M|            .saturating_add(estimate_path_size(start_bound, b, end_bound)),
 1033|  35.6M|        PropertyPathExpression::ZeroOrMore(p) => {
 1034|  35.6M|            if start_bound && end_bound {
 1035|  9.44M|                1
 1036|  26.2M|            } else if start_bound || end_bound {
 1037|  17.8M|                estimate_path_size(start_bound, p, end_bound).saturating_mul(1000)
 1038|       |            } else {
 1039|  8.36M|                1_000_000_000
 1040|       |            }
 1041|       |        }
 1042|   284M|        PropertyPathExpression::OneOrMore(p) => {
 1043|   284M|            if start_bound && end_bound {
 1044|  70.8M|                1
 1045|       |            } else {
 1046|   213M|                estimate_path_size(start_bound, p, end_bound).saturating_mul(1000)
 1047|       |            }
 1048|       |        }
 1049|  1.76G|        PropertyPathExpression::ZeroOrOne(p) => {
 1050|  1.76G|            if start_bound && end_bound {
 1051|   438M|                1
 1052|  1.32G|            } else if start_bound || end_bound {
 1053|   881M|                estimate_path_size(start_bound, p, end_bound)
 1054|       |            } else {
 1055|   440M|                1_000_000_000
 1056|       |            }
 1057|       |        }
 1058|       |        PropertyPathExpression::NegatedPropertySet(_) => {
 1059|   179M|            estimate_triple_pattern_size(start_bound, false, end_bound)
 1060|       |        }
 1061|       |    }
 1062|  6.78G|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB2_9Optimizer20normalize_expression:
  176|  10.9k|    fn normalize_expression(expression: Expression, types: &VariableTypes) -> Expression {
  177|  10.9k|        match expression {
  178|    290|            Expression::NamedNode(node) => node.into(),
  179|  1.90k|            Expression::Literal(literal) => literal.into(),
  180|  2.18k|            Expression::Variable(variable) => variable.into(),
  181|     15|            Expression::Or(inner) => Expression::or_all(
  182|     15|                inner
  183|     15|                    .into_iter()
  184|     15|                    .map(|e| Self::normalize_expression(e, types)),
  185|     15|            ),
  186|    135|            Expression::And(inner) => Expression::and_all(
  187|    135|                inner
  188|    135|                    .into_iter()
  189|    135|                    .map(|e| Self::normalize_expression(e, types)),
  190|    135|            ),
  191|    412|            Expression::Equal(left, right) => {
  192|    412|                let left = Self::normalize_expression(*left, types);
  193|    412|                let left_types = infer_expression_type(&left, types);
  194|    412|                let right = Self::normalize_expression(*right, types);
  195|    412|                let right_types = infer_expression_type(&right, types);
  196|       |                #[allow(unused_mut)]
  197|    412|                let mut must_use_equal = left_types.literal && right_types.literal;
  198|       |                #[cfg(feature = "rdf-star")]
  199|       |                {
  200|    412|                    must_use_equal = must_use_equal || left_types.triple && right_types.triple;
  201|       |                }
  202|    412|                if must_use_equal {
  203|    409|                    Expression::equal(left, right)
  204|       |                } else {
  205|      3|                    Expression::same_term(left, right)
  206|       |                }
  207|       |            }
  208|      0|            Expression::SameTerm(left, right) => Expression::same_term(
  209|      0|                Self::normalize_expression(*left, types),
  210|      0|                Self::normalize_expression(*right, types),
  211|      0|            ),
  212|     18|            Expression::Greater(left, right) => Expression::greater(
  213|     18|                Self::normalize_expression(*left, types),
  214|     18|                Self::normalize_expression(*right, types),
  215|     18|            ),
  216|     74|            Expression::GreaterOrEqual(left, right) => Expression::greater_or_equal(
  217|     74|                Self::normalize_expression(*left, types),
  218|     74|                Self::normalize_expression(*right, types),
  219|     74|            ),
  220|      7|            Expression::Less(left, right) => Expression::less(
  221|      7|                Self::normalize_expression(*left, types),
  222|      7|                Self::normalize_expression(*right, types),
  223|      7|            ),
  224|     13|            Expression::LessOrEqual(left, right) => Expression::less_or_equal(
  225|     13|                Self::normalize_expression(*left, types),
  226|     13|                Self::normalize_expression(*right, types),
  227|     13|            ),
  228|    134|            Expression::Add(left, right) => {
  229|    134|                Self::normalize_expression(*left, types) + Self::normalize_expression(*right, types)
  230|       |            }
  231|    811|            Expression::Subtract(left, right) => {
  232|    811|                Self::normalize_expression(*left, types) - Self::normalize_expression(*right, types)
  233|       |            }
  234|    290|            Expression::Multiply(left, right) => {
  235|    290|                Self::normalize_expression(*left, types) * Self::normalize_expression(*right, types)
  236|       |            }
  237|  1.53k|            Expression::Divide(left, right) => {
  238|  1.53k|                Self::normalize_expression(*left, types) / Self::normalize_expression(*right, types)
  239|       |            }
  240|    155|            Expression::UnaryPlus(inner) => {
  241|    155|                Expression::unary_plus(Self::normalize_expression(*inner, types))
  242|       |            }
  243|  1.07k|            Expression::UnaryMinus(inner) => -Self::normalize_expression(*inner, types),
  244|  1.20k|            Expression::Not(inner) => !Self::normalize_expression(*inner, types),
  245|     64|            Expression::Exists(inner) => Expression::exists(Self::normalize_pattern(*inner, types)),
  246|    188|            Expression::Bound(variable) => {
  247|    188|                let t = types.get(&variable);
  248|    188|                if !t.undef {
  249|     11|                    true.into()
  250|    177|                } else if t == VariableType::UNDEF {
  251|    177|                    false.into()
  252|       |                } else {
  253|      0|                    Expression::Bound(variable)
  254|       |                }
  255|       |            }
  256|    337|            Expression::If(cond, then, els) => Expression::if_cond(
  257|    337|                Self::normalize_expression(*cond, types),
  258|    337|                Self::normalize_expression(*then, types),
  259|    337|                Self::normalize_expression(*els, types),
  260|    337|            ),
  261|     40|            Expression::Coalesce(inners) => Expression::coalesce(
  262|     40|                inners
  263|     40|                    .into_iter()
  264|     40|                    .map(|e| Self::normalize_expression(e, types))
  265|     40|                    .collect(),
  266|     40|            ),
  267|     29|            Expression::FunctionCall(name, args) => Expression::call(
  268|     29|                name,
  269|     29|                args.into_iter()
  270|     29|                    .map(|e| Self::normalize_expression(e, types))
  271|     29|                    .collect(),
  272|     29|            ),
  273|       |        }
  274|  10.9k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer34are_all_expression_variables_bound:
  808|     96|fn are_all_expression_variables_bound(
  809|     96|    expression: &Expression,
  810|     96|    variable_types: &VariableTypes,
  811|     96|) -> bool {
  812|     96|    expression
  813|     96|        .used_variables()
  814|     96|        .into_iter()
  815|     96|        .all(|v| !variable_types.get(v).undef)
  816|     96|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer20has_common_variables:
  869|   481k|fn has_common_variables(
  870|   481k|    left: &VariableTypes,
  871|   481k|    right: &VariableTypes,
  872|   481k|    input_types: &VariableTypes,
  873|   481k|) -> bool {
  874|   481k|    // TODO: we should be smart and count as shared variables FILTER(?a = ?b)
  875|   481k|    left.iter().any(|(variable, left_type)| {
  876|       |        !left_type.undef && !right.get(variable).undef && input_types.get(variable).undef
  877|   481k|    })
  878|   481k|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB2_9Optimizer22optimize_graph_pattern:
   15|  2.44k|    pub fn optimize_graph_pattern(pattern: GraphPattern) -> GraphPattern {
   16|  2.44k|        let pattern = Self::normalize_pattern(pattern, &VariableTypes::default());
   17|  2.44k|        let pattern = Self::reorder_joins(pattern, &VariableTypes::default());
   18|  2.44k|        Self::push_filters(pattern, Vec::new(), &VariableTypes::default())
   19|  2.44k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer18join_key_variables:
  880|    777|fn join_key_variables(
  881|    777|    left: &VariableTypes,
  882|    777|    right: &VariableTypes,
  883|    777|    input_types: &VariableTypes,
  884|    777|) -> Vec<Variable> {
  885|    777|    left.iter()
  886|    777|        .filter(|(variable, left_type)| {
  887|       |            !left_type.undef && !right.get(variable).undef && input_types.get(variable).undef
  888|    777|        })
  889|    777|        .map(|(variable, _)| variable.clone())
  890|    777|        .collect()
  891|    777|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB2_9Optimizer13reorder_joins:
  482|  7.18k|    fn reorder_joins(pattern: GraphPattern, input_types: &VariableTypes) -> GraphPattern {
  483|  7.18k|        match pattern {
  484|       |            GraphPattern::QuadPattern { .. }
  485|       |            | GraphPattern::Path { .. }
  486|  1.24k|            | GraphPattern::Values { .. } => pattern,
  487|  1.41k|            GraphPattern::Join { left, right, .. } => {
  488|  1.41k|                // We flatten the join operation
  489|  1.41k|                let mut to_reorder = Vec::new();
  490|  1.41k|                let mut todo = vec![*right, *left];
  491|  45.9k|                while let Some(e) = todo.pop() {
  492|  44.5k|                    if let GraphPattern::Join { left, right, .. } = e {
  493|  20.8k|                        todo.push(*right);
  494|  20.8k|                        todo.push(*left);
  495|  23.7k|                    } else {
  496|  23.7k|                        to_reorder.push(e);
  497|  23.7k|                    }
  498|       |                }
  499|       |
  500|       |                // We do first type inference
  501|  1.41k|                let to_reorder_types = to_reorder
  502|  1.41k|                    .iter()
  503|  1.41k|                    .map(|p| infer_graph_pattern_types(p, input_types.clone()))
  504|  1.41k|                    .collect::<Vec<_>>();
  505|  1.41k|
  506|  1.41k|                // We do greedy join reordering
  507|  1.41k|                let mut output_cartesian_product_joins = Vec::new();
  508|  1.41k|                let mut not_yet_reordered_ids = vec![true; to_reorder.len()];
  509|       |                // We look for the next connected component to reorder and pick the smallest element
  510|  3.40k|                while let Some(next_entry_id) = not_yet_reordered_ids
  511|  3.40k|                    .iter()
  512|  3.40k|                    .enumerate()
  513|  3.40k|                    .filter(|(_, v)| **v)
  514|  3.40k|                    .map(|(i, _)| i)
  515|  3.40k|                    .min_by_key(|i| estimate_graph_pattern_size(&to_reorder[*i], input_types))
  516|       |                {
  517|  1.99k|                    not_yet_reordered_ids[next_entry_id] = false; // It's now done
  518|  1.99k|                    let mut output = to_reorder[next_entry_id].clone();
  519|  1.99k|                    let mut output_types = to_reorder_types[next_entry_id].clone();
  520|       |                    // We look for an other child to join with that does not blow up the join cost
  521|  23.7k|                    while let Some(next_id) = not_yet_reordered_ids
  522|  23.7k|                        .iter()
  523|  23.7k|                        .enumerate()
  524|  23.7k|                        .filter(|(_, v)| **v)
  525|  23.7k|                        .map(|(i, _)| i)
  526|  23.7k|                        .filter(|i| {
  527|       |                            has_common_variables(&output_types, &to_reorder_types[*i], input_types)
  528|  23.7k|                        })
  529|  23.7k|                        .min_by_key(|i| {
  530|       |                            // Estimation of the join cost
  531|       |                            if cfg!(feature = "sep-0006")
  532|       |                                && is_fit_for_for_loop_join(
  533|       |                                    &to_reorder[*i],
  534|       |                                    input_types,
  535|       |                                    &output_types,
  536|       |                                )
  537|       |                            {
  538|       |                                estimate_lateral_cost(
  539|       |                                    &output,
  540|       |                                    &output_types,
  541|       |                                    &to_reorder[*i],
  542|       |                                    input_types,
  543|       |                                )
  544|       |                            } else {
  545|       |                                estimate_join_cost(
  546|       |                                    &output,
  547|       |                                    &to_reorder[*i],
  548|       |                                    &JoinAlgorithm::HashBuildLeftProbeRight {
  549|       |                                        keys: join_key_variables(
  550|       |                                            &output_types,
  551|       |                                            &to_reorder_types[*i],
  552|       |                                            input_types,
  553|       |                                        ),
  554|       |                                    },
  555|       |                                    input_types,
  556|       |                                )
  557|       |                            }
  558|  23.7k|                        })
  559|       |                    {
  560|  21.7k|                        not_yet_reordered_ids[next_id] = false; // It's now done
  561|  21.7k|                        let next = to_reorder[next_id].clone();
  562|       |                        #[cfg(feature = "sep-0006")]
  563|  21.7k|                        {
  564|  21.7k|                            output = if is_fit_for_for_loop_join(&next, input_types, &output_types)
  565|       |                            {
  566|  21.6k|                                GraphPattern::lateral(output, next)
  567|       |                            } else {
  568|     15|                                GraphPattern::join(
  569|     15|                                    output,
  570|     15|                                    next,
  571|     15|                                    JoinAlgorithm::HashBuildLeftProbeRight {
  572|     15|                                        keys: join_key_variables(
  573|     15|                                            &output_types,
  574|     15|                                            &to_reorder_types[next_id],
  575|     15|                                            input_types,
  576|     15|                                        ),
  577|     15|                                    },
  578|     15|                                )
  579|       |                            };
  580|       |                        }
  581|       |                        #[cfg(not(feature = "sep-0006"))]
  582|       |                        {
  583|       |                            output = GraphPattern::join(
  584|       |                                output,
  585|       |                                next,
  586|       |                                JoinAlgorithm::HashBuildLeftProbeRight {
  587|       |                                    keys: join_key_variables(
  588|       |                                        &output_types,
  589|       |                                        &to_reorder_types[next_id],
  590|       |                                        input_types,
  591|       |                                    ),
  592|       |                                },
  593|       |                            );
  594|       |                        }
  595|  21.7k|                        output_types.intersect_with(to_reorder_types[next_id].clone());
  596|       |                    }
  597|  1.99k|                    output_cartesian_product_joins.push(output);
  598|       |                }
  599|  1.41k|                output_cartesian_product_joins
  600|  1.41k|                    .into_iter()
  601|  1.41k|                    .reduce(|left, right| {
  602|       |                        let keys = join_key_variables(
  603|       |                            &infer_graph_pattern_types(&left, input_types.clone()),
  604|       |                            &infer_graph_pattern_types(&right, input_types.clone()),
  605|       |                            input_types,
  606|       |                        );
  607|       |                        if estimate_graph_pattern_size(&left, input_types)
  608|       |                            <= estimate_graph_pattern_size(&right, input_types)
  609|       |                        {
  610|       |                            GraphPattern::join(
  611|       |                                left,
  612|       |                                right,
  613|       |                                JoinAlgorithm::HashBuildLeftProbeRight { keys },
  614|       |                            )
  615|       |                        } else {
  616|       |                            GraphPattern::join(
  617|       |                                right,
  618|       |                                left,
  619|       |                                JoinAlgorithm::HashBuildLeftProbeRight { keys },
  620|       |                            )
  621|       |                        }
  622|  1.41k|                    })
  623|  1.41k|                    .unwrap()
  624|       |            }
  625|       |            #[cfg(feature = "sep-0006")]
  626|     16|            GraphPattern::Lateral { left, right } => {
  627|     16|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  628|     16|                GraphPattern::lateral(
  629|     16|                    Self::reorder_joins(*left, input_types),
  630|     16|                    Self::reorder_joins(*right, &left_types),
  631|     16|                )
  632|       |            }
  633|       |            GraphPattern::LeftJoin {
  634|    165|                left,
  635|    165|                right,
  636|    165|                expression,
  637|    165|                ..
  638|    165|            } => {
  639|    165|                let left = Self::reorder_joins(*left, input_types);
  640|    165|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  641|    165|                let right = Self::reorder_joins(*right, input_types);
  642|    165|                let right_types = infer_graph_pattern_types(&right, input_types.clone());
  643|    165|                #[cfg(feature = "sep-0006")]
  644|    165|                {
  645|    165|                    if is_fit_for_for_loop_join(&right, input_types, &left_types)
  646|    138|                        && has_common_variables(&left_types, &right_types, input_types)
  647|       |                    {
  648|     36|                        return GraphPattern::lateral(
  649|     36|                            left,
  650|     36|                            GraphPattern::left_join(
  651|     36|                                GraphPattern::empty_singleton(),
  652|     36|                                right,
  653|     36|                                expression,
  654|     36|                                LeftJoinAlgorithm::HashBuildRightProbeLeft { keys: Vec::new() },
  655|     36|                            ),
  656|     36|                        );
  657|    129|                    }
  658|    129|                }
  659|    129|                GraphPattern::left_join(
  660|    129|                    left,
  661|    129|                    right,
  662|    129|                    expression,
  663|    129|                    LeftJoinAlgorithm::HashBuildRightProbeLeft {
  664|    129|                        keys: join_key_variables(&left_types, &right_types, input_types),
  665|    129|                    },
  666|    129|                )
  667|       |            }
  668|     17|            GraphPattern::Minus { left, right, .. } => {
  669|     17|                let left = Self::reorder_joins(*left, input_types);
  670|     17|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  671|     17|                let right = Self::reorder_joins(*right, input_types);
  672|     17|                let right_types = infer_graph_pattern_types(&right, input_types.clone());
  673|     17|                GraphPattern::minus(
  674|     17|                    left,
  675|     17|                    right,
  676|     17|                    MinusAlgorithm::HashBuildRightProbeLeft {
  677|     17|                        keys: join_key_variables(&left_types, &right_types, input_types),
  678|     17|                    },
  679|     17|                )
  680|       |            }
  681|       |            GraphPattern::Extend {
  682|    274|                inner,
  683|    274|                expression,
  684|    274|                variable,
  685|    274|            } => GraphPattern::extend(
  686|    274|                Self::reorder_joins(*inner, input_types),
  687|    274|                variable,
  688|    274|                expression,
  689|    274|            ),
  690|     22|            GraphPattern::Filter { inner, expression } => {
  691|     22|                GraphPattern::filter(Self::reorder_joins(*inner, input_types), expression)
  692|       |            }
  693|     10|            GraphPattern::Union { inner } => GraphPattern::union_all(
  694|     10|                inner
  695|     10|                    .into_iter()
  696|     10|                    .map(|c| Self::reorder_joins(c, input_types)),
  697|     10|            ),
  698|       |            GraphPattern::Slice {
  699|      0|                inner,
  700|      0|                start,
  701|      0|                length,
  702|      0|            } => GraphPattern::slice(Self::reorder_joins(*inner, input_types), start, length),
  703|    687|            GraphPattern::Distinct { inner } => {
  704|    687|                GraphPattern::distinct(Self::reorder_joins(*inner, input_types))
  705|       |            }
  706|  2.42k|            GraphPattern::Reduced { inner } => {
  707|  2.42k|                GraphPattern::reduced(Self::reorder_joins(*inner, input_types))
  708|       |            }
  709|    907|            GraphPattern::Project { inner, variables } => {
  710|    907|                GraphPattern::project(Self::reorder_joins(*inner, input_types), variables)
  711|       |            }
  712|      0|            GraphPattern::OrderBy { inner, expression } => {
  713|      0|                GraphPattern::order_by(Self::reorder_joins(*inner, input_types), expression)
  714|       |            }
  715|      0|            service @ GraphPattern::Service { .. } => {
  716|      0|                // We don't do join reordering inside of SERVICE calls, we don't know about cardinalities
  717|      0|                service
  718|       |            }
  719|       |            GraphPattern::Group {
  720|      6|                inner,
  721|      6|                variables,
  722|      6|                aggregates,
  723|      6|            } => GraphPattern::group(
  724|      6|                Self::reorder_joins(*inner, input_types),
  725|      6|                variables,
  726|      6|                aggregates,
  727|      6|            ),
  728|       |        }
  729|  7.18k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer27is_named_node_pattern_bound:
 1077|  6.16M|fn is_named_node_pattern_bound(pattern: &NamedNodePattern, input_types: &VariableTypes) -> bool {
 1078|  6.16M|    match pattern {
 1079|  2.66M|        NamedNodePattern::NamedNode(_) => true,
 1080|  3.50M|        NamedNodePattern::Variable(v) => !input_types.get(v).undef,
 1081|       |    }
 1082|  6.16M|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer28estimate_triple_pattern_size:
  999|  1.88G|fn estimate_triple_pattern_size(
 1000|  1.88G|    subject_bound: bool,
 1001|  1.88G|    predicate_bound: bool,
 1002|  1.88G|    object_bound: bool,
 1003|  1.88G|) -> usize {
 1004|  1.88G|    match (subject_bound, predicate_bound, object_bound) {
 1005|   172M|        (true, true, true) => 1,
 1006|   651M|        (true, true, false) => 10,
 1007|  30.5M|        (true, false, true) => 2,
 1008|   652M|        (false, true, true) => 10_000,
 1009|  53.2M|        (true, false, false) => 100,
 1010|  42.1M|        (false, false, false) => 1_000_000_000,
 1011|   231M|        (false, true, false) => 1_000_000,
 1012|  54.2M|        (false, false, true) => 100_000,
 1013|       |    }
 1014|  1.88G|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt9optimizerNtB2_9Optimizer12push_filters:
  276|  52.2k|    fn push_filters(
  277|  52.2k|        pattern: GraphPattern,
  278|  52.2k|        mut filters: Vec<Expression>,
  279|  52.2k|        input_types: &VariableTypes,
  280|  52.2k|    ) -> GraphPattern {
  281|  52.2k|        match pattern {
  282|       |            GraphPattern::QuadPattern { .. }
  283|       |            | GraphPattern::Path { .. }
  284|       |            | GraphPattern::Values { .. } => {
  285|  25.1k|                GraphPattern::filter(pattern, Expression::and_all(filters))
  286|       |            }
  287|       |            GraphPattern::Join {
  288|    766|                left,
  289|    766|                right,
  290|    766|                algorithm,
  291|    766|            } => {
  292|    766|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  293|    766|                let right_types = infer_graph_pattern_types(&right, input_types.clone());
  294|    766|                let mut left_filters = Vec::new();
  295|    766|                let mut right_filters = Vec::new();
  296|    766|                let mut final_filters = Vec::new();
  297|    766|                for filter in filters {
  298|      0|                    let push_left = are_all_expression_variables_bound(&filter, &left_types);
  299|      0|                    let push_right = are_all_expression_variables_bound(&filter, &right_types);
  300|      0|                    if push_left {
  301|      0|                        if push_right {
  302|      0|                            left_filters.push(filter.clone());
  303|      0|                            right_filters.push(filter);
  304|      0|                        } else {
  305|      0|                            left_filters.push(filter);
  306|      0|                        }
  307|      0|                    } else if push_right {
  308|      0|                        right_filters.push(filter);
  309|      0|                    } else {
  310|      0|                        final_filters.push(filter);
  311|      0|                    }
  312|       |                }
  313|    766|                GraphPattern::filter(
  314|    766|                    GraphPattern::join(
  315|    766|                        Self::push_filters(*left, left_filters, input_types),
  316|    766|                        Self::push_filters(*right, right_filters, input_types),
  317|    766|                        algorithm,
  318|    766|                    ),
  319|    766|                    Expression::and_all(final_filters),
  320|    766|                )
  321|       |            }
  322|       |            #[cfg(feature = "sep-0006")]
  323|  21.7k|            GraphPattern::Lateral { left, right } => {
  324|  21.7k|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  325|  21.7k|                let mut left_filters = Vec::new();
  326|  21.7k|                let mut right_filters = Vec::new();
  327|  21.8k|                for filter in filters {
  328|     96|                    let push_left = are_all_expression_variables_bound(&filter, &left_types);
  329|     96|                    if push_left {
  330|     86|                        left_filters.push(filter);
  331|     86|                    } else {
  332|     10|                        right_filters.push(filter);
  333|     10|                    }
  334|       |                }
  335|  21.7k|                let left = Self::push_filters(*left, left_filters, input_types);
  336|  21.7k|                let right = Self::push_filters(*right, right_filters, &left_types);
  337|       |                if let GraphPattern::Filter {
  338|      9|                    inner: right,
  339|      9|                    expression,
  340|  21.7k|                } = right
  341|       |                {
  342|       |                    // We prefer to have filter out of the lateral rather than inside the right part
  343|      9|                    GraphPattern::filter(GraphPattern::lateral(left, *right), expression)
  344|       |                } else {
  345|  21.7k|                    GraphPattern::lateral(left, right)
  346|       |                }
  347|       |            }
  348|       |            GraphPattern::LeftJoin {
  349|    177|                left,
  350|    177|                right,
  351|    177|                expression,
  352|    177|                algorithm,
  353|    177|            } => {
  354|    177|                let left_types = infer_graph_pattern_types(&left, input_types.clone());
  355|    177|                let right_types = infer_graph_pattern_types(&right, input_types.clone());
  356|    177|                let mut left_filters = Vec::new();
  357|    177|                let mut right_filters = Vec::new();
  358|    177|                let mut final_filters = Vec::new();
  359|    177|                for filter in filters {
  360|      0|                    let push_left = are_all_expression_variables_bound(&filter, &left_types);
  361|      0|                    if push_left {
  362|      0|                        left_filters.push(filter);
  363|      0|                    } else {
  364|      0|                        final_filters.push(filter);
  365|      0|                    }
  366|       |                }
  367|    177|                let expression = if expression.effective_boolean_value().is_none()
  368|      0|                    && (are_all_expression_variables_bound(&expression, &right_types)
  369|      0|                        || are_no_expression_variables_bound(&expression, &left_types))
  370|       |                {
  371|      0|                    right_filters.push(expression);
  372|      0|                    true.into()
  373|       |                } else {
  374|    177|                    expression
  375|       |                };
  376|    177|                GraphPattern::filter(
  377|    177|                    GraphPattern::left_join(
  378|    177|                        Self::push_filters(*left, left_filters, input_types),
  379|    177|                        Self::push_filters(*right, right_filters, input_types),
  380|    177|                        expression,
  381|    177|                        algorithm,
  382|    177|                    ),
  383|    177|                    Expression::and_all(final_filters),
  384|    177|                )
  385|       |            }
  386|       |            GraphPattern::Minus {
  387|     20|                left,
  388|     20|                right,
  389|     20|                algorithm,
  390|     20|            } => GraphPattern::minus(
  391|     20|                Self::push_filters(*left, filters, input_types),
  392|     20|                Self::push_filters(*right, Vec::new(), input_types),
  393|     20|                algorithm,
  394|     20|            ),
  395|       |            GraphPattern::Extend {
  396|    276|                inner,
  397|    276|                expression,
  398|    276|                variable,
  399|    276|            } => {
  400|    276|                // TODO: handle the case where the filter overrides an expression variable (should not happen in SPARQL but allowed in the algebra)
  401|    276|                let mut inner_filters = Vec::new();
  402|    276|                let mut final_filters = Vec::new();
  403|    276|                for filter in filters {
  404|      0|                    let extend_variable_used =
  405|      0|                        filter.used_variables().into_iter().any(|v| *v == variable);
  406|      0|                    if extend_variable_used {
  407|      0|                        final_filters.push(filter);
  408|      0|                    } else {
  409|      0|                        inner_filters.push(filter);
  410|      0|                    }
  411|       |                }
  412|    276|                GraphPattern::filter(
  413|    276|                    GraphPattern::extend(
  414|    276|                        Self::push_filters(*inner, inner_filters, input_types),
  415|    276|                        variable,
  416|    276|                        expression,
  417|    276|                    ),
  418|    276|                    Expression::and_all(final_filters),
  419|    276|                )
  420|       |            }
  421|     22|            GraphPattern::Filter { inner, expression } => {
  422|     22|                if let Expression::And(expressions) = expression {
  423|      4|                    filters.extend(expressions)
  424|       |                } else {
  425|     18|                    filters.push(expression)
  426|       |                };
  427|     22|                Self::push_filters(*inner, filters, input_types)
  428|       |            }
  429|     19|            GraphPattern::Union { inner } => GraphPattern::union_all(
  430|     19|                inner
  431|     19|                    .into_iter()
  432|     19|                    .map(|c| Self::push_filters(c, filters.clone(), input_types)),
  433|     19|            ),
  434|       |            GraphPattern::Slice {
  435|      0|                inner,
  436|      0|                start,
  437|      0|                length,
  438|      0|            } => GraphPattern::filter(
  439|      0|                GraphPattern::slice(
  440|      0|                    Self::push_filters(*inner, Vec::new(), input_types),
  441|      0|                    start,
  442|      0|                    length,
  443|      0|                ),
  444|      0|                Expression::and_all(filters),
  445|      0|            ),
  446|    719|            GraphPattern::Distinct { inner } => {
  447|    719|                GraphPattern::distinct(Self::push_filters(*inner, filters, input_types))
  448|       |            }
  449|  2.42k|            GraphPattern::Reduced { inner } => {
  450|  2.42k|                GraphPattern::reduced(Self::push_filters(*inner, filters, input_types))
  451|       |            }
  452|    939|            GraphPattern::Project { inner, variables } => {
  453|    939|                GraphPattern::project(Self::push_filters(*inner, filters, input_types), variables)
  454|       |            }
  455|      0|            GraphPattern::OrderBy { inner, expression } => {
  456|      0|                GraphPattern::order_by(Self::push_filters(*inner, filters, input_types), expression)
  457|       |            }
  458|       |            GraphPattern::Service {
  459|      0|                inner,
  460|      0|                name,
  461|      0|                silent,
  462|      0|            } => GraphPattern::service(
  463|      0|                Self::push_filters(*inner, filters, input_types),
  464|      0|                name,
  465|      0|                silent,
  466|      0|            ),
  467|       |            GraphPattern::Group {
  468|      6|                inner,
  469|      6|                variables,
  470|      6|                aggregates,
  471|      6|            } => GraphPattern::filter(
  472|      6|                GraphPattern::group(
  473|      6|                    Self::push_filters(*inner, Vec::new(), input_types),
  474|      6|                    variables,
  475|      6|                    aggregates,
  476|      6|                ),
  477|      6|                Expression::and_all(filters),
  478|      6|            ),
  479|       |        }
  480|  52.2k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer27estimate_graph_pattern_size:
  893|  13.6M|fn estimate_graph_pattern_size(pattern: &GraphPattern, input_types: &VariableTypes) -> usize {
  894|  13.6M|    match pattern {
  895|  1.19k|        GraphPattern::Values { bindings, .. } => bindings.len(),
  896|       |        GraphPattern::QuadPattern {
  897|  6.16M|            subject,
  898|  6.16M|            predicate,
  899|  6.16M|            object,
  900|  6.16M|            ..
  901|  6.16M|        } => estimate_triple_pattern_size(
  902|  6.16M|            is_term_pattern_bound(subject, input_types),
  903|  6.16M|            is_named_node_pattern_bound(predicate, input_types),
  904|  6.16M|            is_term_pattern_bound(object, input_types),
  905|  6.16M|        ),
  906|       |        GraphPattern::Path {
  907|   914k|            subject,
  908|   914k|            path,
  909|   914k|            object,
  910|   914k|            ..
  911|   914k|        } => estimate_path_size(
  912|   914k|            is_term_pattern_bound(subject, input_types),
  913|   914k|            path,
  914|   914k|            is_term_pattern_bound(object, input_types),
  915|   914k|        ),
  916|       |        GraphPattern::Join {
  917|  1.56k|            left,
  918|  1.56k|            right,
  919|  1.56k|            algorithm,
  920|  1.56k|        } => estimate_join_cost(left, right, algorithm, input_types),
  921|       |        GraphPattern::LeftJoin {
  922|     39|            left,
  923|     39|            right,
  924|     39|            algorithm,
  925|     39|            ..
  926|     39|        } => match algorithm {
  927|     39|            LeftJoinAlgorithm::HashBuildRightProbeLeft { keys } => {
  928|     39|                let left_size = estimate_graph_pattern_size(left, input_types);
  929|     39|                max(
  930|     39|                    left_size,
  931|     39|                    left_size
  932|     39|                        .saturating_mul(estimate_graph_pattern_size(
  933|     39|                            right,
  934|     39|                            &infer_graph_pattern_types(right, input_types.clone()),
  935|     39|                        ))
  936|     39|                        .saturating_div(1_000_usize.saturating_pow(keys.len().try_into().unwrap())),
  937|     39|                )
  938|       |            }
  939|       |        },
  940|       |        #[cfg(feature = "sep-0006")]
  941|  6.52M|        GraphPattern::Lateral { left, right } => estimate_lateral_cost(
  942|  6.52M|            left,
  943|  6.52M|            &infer_graph_pattern_types(left, input_types.clone()),
  944|  6.52M|            right,
  945|  6.52M|            input_types,
  946|  6.52M|        ),
  947|     54|        GraphPattern::Union { inner } => inner
  948|     54|            .iter()
  949|     54|            .map(|inner| estimate_graph_pattern_size(inner, input_types))
  950|     54|            .fold(0, usize::saturating_add),
  951|      6|        GraphPattern::Minus { left, .. } => estimate_graph_pattern_size(left, input_types),
  952|      0|        GraphPattern::Filter { inner, .. }
  953|      4|        | GraphPattern::Extend { inner, .. }
  954|      0|        | GraphPattern::OrderBy { inner, .. }
  955|    204|        | GraphPattern::Project { inner, .. }
  956|    204|        | GraphPattern::Distinct { inner, .. }
  957|      0|        | GraphPattern::Reduced { inner, .. }
  958|      0|        | GraphPattern::Group { inner, .. }
  959|    412|        | GraphPattern::Service { inner, .. } => estimate_graph_pattern_size(inner, input_types),
  960|       |        GraphPattern::Slice {
  961|      0|            inner,
  962|      0|            start,
  963|      0|            length,
  964|      0|        } => {
  965|      0|            let inner = estimate_graph_pattern_size(inner, input_types);
  966|      0|            if let Some(length) = length {
  967|      0|                min(inner, *length - *start)
  968|       |            } else {
  969|      0|                inner
  970|       |            }
  971|       |        }
  972|       |    }
  973|  13.6M|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer21is_term_pattern_bound:
 1064|  14.1M|fn is_term_pattern_bound(pattern: &GroundTermPattern, input_types: &VariableTypes) -> bool {
 1065|  14.1M|    match pattern {
 1066|  1.10M|        GroundTermPattern::NamedNode(_) | GroundTermPattern::Literal(_) => true,
 1067|  13.0M|        GroundTermPattern::Variable(v) => !input_types.get(v).undef,
 1068|       |        #[cfg(feature = "rdf-star")]
 1069|      0|        GroundTermPattern::Triple(t) => {
 1070|      0|            is_term_pattern_bound(&t.subject, input_types)
 1071|      0|                && is_named_node_pattern_bound(&t.predicate, input_types)
 1072|      0|                && is_term_pattern_bound(&t.object, input_types)
 1073|       |        }
 1074|       |    }
 1075|  14.1M|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer18estimate_join_cost:
  975|  1.59k|fn estimate_join_cost(
  976|  1.59k|    left: &GraphPattern,
  977|  1.59k|    right: &GraphPattern,
  978|  1.59k|    algorithm: &JoinAlgorithm,
  979|  1.59k|    input_types: &VariableTypes,
  980|  1.59k|) -> usize {
  981|  1.59k|    match algorithm {
  982|  1.59k|        JoinAlgorithm::HashBuildLeftProbeRight { keys } => {
  983|  1.59k|            estimate_graph_pattern_size(left, input_types)
  984|  1.59k|                .saturating_mul(estimate_graph_pattern_size(right, input_types))
  985|  1.59k|                .saturating_div(1_000_usize.saturating_pow(keys.len().try_into().unwrap()))
  986|  1.59k|        }
  987|  1.59k|    }
  988|  1.59k|}
_RNvNtCsaDAmlQ5xRbD_7sparopt9optimizer24is_fit_for_for_loop_join:
  732|   289k|fn is_fit_for_for_loop_join(
  733|   289k|    pattern: &GraphPattern,
  734|   289k|    global_input_types: &VariableTypes,
  735|   289k|    entry_types: &VariableTypes,
  736|   289k|) -> bool {
  737|   289k|    // TODO: think more about it
  738|   289k|    match pattern {
  739|       |        GraphPattern::Values { .. }
  740|       |        | GraphPattern::QuadPattern { .. }
  741|   287k|        | GraphPattern::Path { .. } => true,
  742|       |        #[cfg(feature = "sep-0006")]
  743|  2.08k|        GraphPattern::Lateral { left, right } => {
  744|  2.08k|            is_fit_for_for_loop_join(left, global_input_types, entry_types)
  745|  2.08k|                && is_fit_for_for_loop_join(right, global_input_types, entry_types)
  746|       |        }
  747|       |        GraphPattern::LeftJoin {
  748|     29|            left,
  749|     29|            right,
  750|     29|            expression,
  751|     29|            ..
  752|     29|        } => {
  753|     29|            if !is_fit_for_for_loop_join(left, global_input_types, entry_types) {
  754|      0|                return false;
  755|     29|            }
  756|     29|
  757|     29|            // It is not ok to transform into for loop join if right binds a variable also bound by the entry part of the for loop join
  758|     29|            let mut left_types = infer_graph_pattern_types(left, global_input_types.clone());
  759|     29|            let right_types = infer_graph_pattern_types(right, global_input_types.clone());
  760|     29|            if right_types.iter().any(|(variable, t)| {
  761|       |                *t != VariableType::UNDEF
  762|       |                    && left_types.get(variable).undef
  763|       |                    && entry_types.get(variable) != VariableType::UNDEF
  764|     29|            }) {
  765|      8|                return false;
  766|     21|            }
  767|     21|
  768|     21|            // We don't forget the final expression
  769|     21|            left_types.intersect_with(right_types);
  770|     21|            is_expression_fit_for_for_loop_join(expression, &left_types, entry_types)
  771|       |        }
  772|      3|        GraphPattern::Union { inner } => inner
  773|      3|            .iter()
  774|      3|            .all(|i| is_fit_for_for_loop_join(i, global_input_types, entry_types)),
  775|      0|        GraphPattern::Filter { inner, expression } => {
  776|      0|            is_fit_for_for_loop_join(inner, global_input_types, entry_types)
  777|      0|                && is_expression_fit_for_for_loop_join(
  778|      0|                    expression,
  779|      0|                    &infer_graph_pattern_types(inner, global_input_types.clone()),
  780|      0|                    entry_types,
  781|      0|                )
  782|       |        }
  783|       |        GraphPattern::Extend {
  784|      0|            inner,
  785|      0|            expression,
  786|      0|            variable,
  787|      0|        } => {
  788|      0|            is_fit_for_for_loop_join(inner, global_input_types, entry_types)
  789|      0|                && entry_types.get(variable) == VariableType::UNDEF
  790|      0|                && is_expression_fit_for_for_loop_join(
  791|      0|                    expression,
  792|      0|                    &infer_graph_pattern_types(inner, global_input_types.clone()),
  793|      0|                    entry_types,
  794|      0|                )
  795|       |        }
  796|       |        GraphPattern::Join { .. }
  797|       |        | GraphPattern::Minus { .. }
  798|       |        | GraphPattern::Service { .. }
  799|       |        | GraphPattern::OrderBy { .. }
  800|       |        | GraphPattern::Distinct { .. }
  801|       |        | GraphPattern::Reduced { .. }
  802|       |        | GraphPattern::Slice { .. }
  803|       |        | GraphPattern::Project { .. }
  804|     67|        | GraphPattern::Group { .. } => false,
  805|       |    }
  806|   289k|}

_RNvXs5_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_12VariableTypeNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  344|   167k|#[derive(Clone, Copy, Eq, PartialEq, Debug, Default)]
_RNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB2_13VariableTypes3get:
  301|   346M|    pub fn get(&self, variable: &Variable) -> VariableType {
  302|   346M|        self.inner
  303|   346M|            .get(variable)
  304|   346M|            .copied()
  305|   346M|            .unwrap_or(VariableType::UNDEF)
  306|   346M|    }
_RNvXsa_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_12VariableTypeNtNtCs9nhK3FOW46N_4core3cmp9PartialEq2eqB7_:
  344|   324M|#[derive(Clone, Copy, Eq, PartialEq, Debug, Default)]
_RNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB2_13VariableTypes14intersect_with:
  312|  29.8k|    pub fn intersect_with(&mut self, other: Self) {
  313|   113k|        for (v, t) in other.inner {
  314|  83.9k|            self.intersect_variable_with(v, t);
  315|  83.9k|        }
  316|  29.8k|    }
_RNvNtCsaDAmlQ5xRbD_7sparopt14type_inference21infer_expression_type:
  171|  1.23k|pub fn infer_expression_type(expression: &Expression, types: &VariableTypes) -> VariableType {
  172|      6|    match expression {
  173|      0|        Expression::NamedNode(_) => VariableType::NAMED_NODE,
  174|       |        Expression::Literal(_) | Expression::Exists(_) | Expression::Bound(_) => {
  175|     79|            VariableType::LITERAL
  176|       |        }
  177|      4|        Expression::Variable(v) => types.get(v),
  178|       |        Expression::FunctionCall(Function::Datatype | Function::Iri, _) => {
  179|      0|            VariableType::NAMED_NODE | VariableType::UNDEF
  180|       |        }
  181|       |        #[cfg(feature = "rdf-star")]
  182|       |        Expression::FunctionCall(Function::Predicate, _) => {
  183|      0|            VariableType::NAMED_NODE | VariableType::UNDEF
  184|       |        }
  185|      0|        Expression::FunctionCall(Function::BNode, args) => {
  186|      0|            if args.is_empty() {
  187|      0|                VariableType::BLANK_NODE
  188|       |            } else {
  189|      0|                VariableType::BLANK_NODE | VariableType::UNDEF
  190|       |            }
  191|       |        }
  192|       |        Expression::FunctionCall(
  193|       |            Function::Rand | Function::Now | Function::Uuid | Function::StrUuid,
  194|       |            _,
  195|      0|        ) => VariableType::LITERAL,
  196|       |        Expression::Or(_)
  197|       |        | Expression::And(_)
  198|       |        | Expression::Equal(_, _)
  199|       |        | Expression::Greater(_, _)
  200|       |        | Expression::GreaterOrEqual(_, _)
  201|       |        | Expression::Less(_, _)
  202|       |        | Expression::LessOrEqual(_, _)
  203|       |        | Expression::Add(_, _)
  204|       |        | Expression::Subtract(_, _)
  205|       |        | Expression::Multiply(_, _)
  206|       |        | Expression::Divide(_, _)
  207|       |        | Expression::UnaryPlus(_)
  208|       |        | Expression::UnaryMinus(_)
  209|       |        | Expression::Not(_)
  210|       |        | Expression::FunctionCall(
  211|       |            Function::Str
  212|       |            | Function::Lang
  213|       |            | Function::LangMatches
  214|       |            | Function::Abs
  215|       |            | Function::Ceil
  216|       |            | Function::Floor
  217|       |            | Function::Round
  218|       |            | Function::Concat
  219|       |            | Function::SubStr
  220|       |            | Function::StrLen
  221|       |            | Function::Replace
  222|       |            | Function::UCase
  223|       |            | Function::LCase
  224|       |            | Function::EncodeForUri
  225|       |            | Function::Contains
  226|       |            | Function::StrStarts
  227|       |            | Function::StrEnds
  228|       |            | Function::StrBefore
  229|       |            | Function::StrAfter
  230|       |            | Function::Year
  231|       |            | Function::Month
  232|       |            | Function::Day
  233|       |            | Function::Hours
  234|       |            | Function::Minutes
  235|       |            | Function::Seconds
  236|       |            | Function::Timezone
  237|       |            | Function::Tz
  238|       |            | Function::Md5
  239|       |            | Function::Sha1
  240|       |            | Function::Sha256
  241|       |            | Function::Sha384
  242|       |            | Function::Sha512
  243|       |            | Function::StrLang
  244|       |            | Function::StrDt
  245|       |            | Function::IsIri
  246|       |            | Function::IsBlank
  247|       |            | Function::IsLiteral
  248|       |            | Function::IsNumeric
  249|       |            | Function::Regex,
  250|       |            _,
  251|  1.14k|        ) => VariableType::LITERAL | VariableType::UNDEF,
  252|       |        #[cfg(feature = "sep-0002")]
  253|       |        Expression::FunctionCall(Function::Adjust, _) => {
  254|      0|            VariableType::LITERAL | VariableType::UNDEF
  255|       |        }
  256|       |        #[cfg(feature = "rdf-star")]
  257|       |        Expression::FunctionCall(Function::IsTriple, _) => {
  258|      0|            VariableType::LITERAL | VariableType::UNDEF
  259|       |        }
  260|      1|        Expression::SameTerm(left, right) => {
  261|      1|            if infer_expression_type(left, types).undef || infer_expression_type(right, types).undef
  262|       |            {
  263|      1|                VariableType::LITERAL | VariableType::UNDEF
  264|       |            } else {
  265|      0|                VariableType::LITERAL
  266|       |            }
  267|       |        }
  268|     12|        Expression::If(_, then, els) => {
  269|     12|            infer_expression_type(then, types) | infer_expression_type(els, types)
  270|       |        }
  271|      0|        Expression::Coalesce(inner) => {
  272|      0|            let mut t = VariableType::UNDEF;
  273|      0|            for e in inner {
  274|      0|                let new = infer_expression_type(e, types);
  275|      0|                t = t | new;
  276|      0|                if !new.undef {
  277|      0|                    t.undef = false;
  278|      0|                    return t;
  279|      0|                }
  280|       |            }
  281|      0|            t
  282|       |        }
  283|       |        #[cfg(feature = "rdf-star")]
  284|      0|        Expression::FunctionCall(Function::Triple, _) => VariableType::TRIPLE | VariableType::UNDEF,
  285|       |        #[cfg(feature = "rdf-star")]
  286|       |        Expression::FunctionCall(Function::Subject, _) => {
  287|      0|            VariableType::SUBJECT | VariableType::UNDEF
  288|       |        }
  289|       |        #[cfg(feature = "rdf-star")]
  290|      0|        Expression::FunctionCall(Function::Object, _) => VariableType::TERM | VariableType::UNDEF,
  291|      0|        Expression::FunctionCall(Function::Custom(_), _) => VariableType::ANY,
  292|       |    }
  293|  1.23k|}
_RNvXs1_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_12VariableTypeNtNtNtCs9nhK3FOW46N_4core3ops3bit6BitAnd6bitand:
  440|   324M|    fn bitand(self, other: Self) -> Self {
  441|   324M|        Self {
  442|   324M|            undef: self.undef && other.undef,
  443|   324M|            named_node: self.named_node && other.named_node
  444|   114M|                || (self.undef && other.named_node)
  445|   254k|                || (self.named_node && other.undef),
  446|   324M|            blank_node: self.blank_node && other.blank_node
  447|   191M|                || (self.undef && other.blank_node)
  448|  86.5M|                || (self.blank_node && other.undef),
  449|   324M|            literal: self.literal && other.literal
  450|   315M|                || (self.undef && other.literal)
  451|   256M|                || (self.literal && other.undef),
  452|       |            #[cfg(feature = "rdf-star")]
  453|   324M|            triple: self.triple && other.triple
  454|   191M|                || (self.undef && other.triple)
  455|  86.5M|                || (self.triple && other.undef),
  456|       |        }
  457|   324M|    }
_RNvXsc_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_12VariableTypeNtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
  344|   264k|#[derive(Clone, Copy, Eq, PartialEq, Debug, Default)]
_RNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB2_13VariableTypes23intersect_variable_with:
  335|   324M|    fn intersect_variable_with(&mut self, variable: Variable, t: VariableType) {
  336|   324M|        let t = self.get(&variable) & t;
  337|   324M|        if t != VariableType::UNDEF {
  338|   324M|            self.inner.insert(variable, t);
  339|   324M|        }
  340|   324M|    }
_RNvXs0_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_12VariableTypeNtNtNtCs9nhK3FOW46N_4core3ops3bit5BitOr5bitor:
  424|  1.23k|    fn bitor(self, other: Self) -> Self {
  425|  1.23k|        Self {
  426|  1.23k|            undef: self.undef || other.undef,
  427|  1.23k|            named_node: self.named_node || other.named_node,
  428|  1.23k|            blank_node: self.blank_node || other.blank_node,
  429|  1.23k|            literal: self.literal || other.literal,
  430|       |            #[cfg(feature = "rdf-star")]
  431|  1.23k|            triple: self.triple || other.triple,
  432|       |        }
  433|  1.23k|    }
_RNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB2_13VariableTypes4iter:
  308|   482k|    pub fn iter(&self) -> impl Iterator<Item = (&Variable, &VariableType)> {
  309|   482k|        self.inner.iter()
  310|   482k|    }
_RNvXs3_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_13VariableTypesNtNtCs9nhK3FOW46N_4core5clone5Clone5cloneB7_:
  295|  6.60M|#[derive(Default, Clone, Debug)]
_RNvNtCsaDAmlQ5xRbD_7sparopt14type_inference25infer_graph_pattern_types:
    8|   269M|pub fn infer_graph_pattern_types(
    9|   269M|    pattern: &GraphPattern,
   10|   269M|    mut types: VariableTypes,
   11|   269M|) -> VariableTypes {
   12|   269M|    match pattern {
   13|       |        GraphPattern::QuadPattern {
   14|   120M|            subject,
   15|   120M|            predicate,
   16|   120M|            object,
   17|   120M|            graph_name,
   18|   120M|        } => {
   19|   120M|            add_ground_term_pattern_types(subject, &mut types, false);
   20|   120M|            if let NamedNodePattern::Variable(v) = predicate {
   21|  66.0M|                types.intersect_variable_with(v.clone(), VariableType::NAMED_NODE)
   22|  54.5M|            }
   23|   120M|            add_ground_term_pattern_types(object, &mut types, true);
   24|   120M|            if let Some(NamedNodePattern::Variable(v)) = graph_name {
   25|  3.75M|                types.intersect_variable_with(v.clone(), VariableType::NAMED_NODE)
   26|   116M|            }
   27|   120M|            types
   28|       |        }
   29|       |        GraphPattern::Path {
   30|  17.4M|            subject,
   31|  17.4M|            object,
   32|  17.4M|            graph_name,
   33|  17.4M|            ..
   34|  17.4M|        } => {
   35|  17.4M|            add_ground_term_pattern_types(subject, &mut types, false);
   36|  17.4M|            add_ground_term_pattern_types(object, &mut types, true);
   37|  17.4M|            if let Some(NamedNodePattern::Variable(v)) = graph_name {
   38|   318k|                types.intersect_variable_with(v.clone(), VariableType::NAMED_NODE)
   39|  17.1M|            }
   40|  17.4M|            types
   41|       |        }
   42|  7.75k|        GraphPattern::Join { left, right, .. } => {
   43|  7.75k|            let mut output_types = infer_graph_pattern_types(left, types.clone());
   44|  7.75k|            output_types.intersect_with(infer_graph_pattern_types(right, types));
   45|  7.75k|            output_types
   46|       |        }
   47|       |        #[cfg(feature = "sep-0006")]
   48|   131M|        GraphPattern::Lateral { left, right } => {
   49|   131M|            infer_graph_pattern_types(right, infer_graph_pattern_types(left, types))
   50|       |        }
   51|    158|        GraphPattern::LeftJoin { left, right, .. } => {
   52|    158|            let mut right_types = infer_graph_pattern_types(right, types.clone()); // TODO: expression
   53|  1.18k|            for t in right_types.inner.values_mut() {
   54|  1.18k|                t.undef = true; // Right might be unset
   55|  1.18k|            }
   56|    158|            let mut output_types = infer_graph_pattern_types(left, types);
   57|    158|            output_types.intersect_with(right_types);
   58|    158|            output_types
   59|       |        }
   60|     10|        GraphPattern::Minus { left, .. } => infer_graph_pattern_types(left, types),
   61|     96|        GraphPattern::Union { inner } => inner
   62|     96|            .iter()
   63|     96|            .map(|inner| infer_graph_pattern_types(inner, types.clone()))
   64|     96|            .reduce(|mut a, b| {
   65|       |                a.union_with(b);
   66|       |                a
   67|     96|            })
   68|     96|            .unwrap_or_default(),
   69|       |        GraphPattern::Extend {
   70|     72|            inner,
   71|     72|            variable,
   72|     72|            expression,
   73|     72|        } => {
   74|     72|            let mut types = infer_graph_pattern_types(inner, types);
   75|     72|            types.intersect_variable_with(
   76|     72|                variable.clone(),
   77|     72|                infer_expression_type(expression, &types),
   78|     72|            );
   79|     72|            types
   80|       |        }
   81|      8|        GraphPattern::Filter { inner, .. } => infer_graph_pattern_types(inner, types),
   82|    555|        GraphPattern::Project { inner, variables } => VariableTypes {
   83|    555|            inner: infer_graph_pattern_types(inner, types)
   84|    555|                .inner
   85|    555|                .into_iter()
   86|    555|                .filter(|(v, _)| variables.contains(v))
   87|    555|                .collect(),
   88|    555|        },
   89|    437|        GraphPattern::Distinct { inner }
   90|      0|        | GraphPattern::Reduced { inner }
   91|      0|        | GraphPattern::OrderBy { inner, .. }
   92|    437|        | GraphPattern::Slice { inner, .. } => infer_graph_pattern_types(inner, types),
   93|       |        GraphPattern::Group {
   94|      8|            inner,
   95|      8|            variables,
   96|      8|            aggregates,
   97|      8|        } => {
   98|      8|            let types = infer_graph_pattern_types(inner, types);
   99|      8|            VariableTypes {
  100|      8|                inner: infer_graph_pattern_types(inner, types)
  101|      8|                    .inner
  102|      8|                    .into_iter()
  103|      8|                    .filter(|(v, _)| variables.contains(v))
  104|      8|                    .chain(aggregates.iter().map(|(v, _)| (v.clone(), VariableType::ANY))) //TODO: guess from aggregate
  105|      8|                    .collect(),
  106|      8|            }
  107|       |        }
  108|       |        GraphPattern::Values {
  109|  8.65k|            variables,
  110|  8.65k|            bindings,
  111|       |        } => {
  112|   264k|            for (i, v) in variables.iter().enumerate() {
  113|   264k|                let mut t = VariableType::default();
  114|   553k|                for binding in bindings {
  115|   288k|                    match binding[i] {
  116|  53.4k|                        Some(GroundTerm::NamedNode(_)) => t.named_node = true,
  117|  30.9k|                        Some(GroundTerm::Literal(_)) => t.literal = true,
  118|       |                        #[cfg(feature = "rdf-star")]
  119|      0|                        Some(GroundTerm::Triple(_)) => t.triple = true,
  120|   203k|                        None => t.undef = true,
  121|       |                    }
  122|       |                }
  123|   264k|                types.intersect_variable_with(v.clone(), t)
  124|       |            }
  125|  8.65k|            types
  126|       |        }
  127|       |        GraphPattern::Service {
  128|      0|            name,
  129|      0|            inner,
  130|      0|            silent,
  131|      0|        } => {
  132|      0|            let parent_types = types.clone();
  133|      0|            let mut types = infer_graph_pattern_types(inner, types);
  134|      0|            if let NamedNodePattern::Variable(v) = name {
  135|      0|                types.intersect_variable_with(v.clone(), VariableType::NAMED_NODE)
  136|      0|            }
  137|      0|            if *silent {
  138|      0|                // On failure, single empty solution
  139|      0|                types.union_with(parent_types);
  140|      0|            }
  141|      0|            types
  142|       |        }
  143|       |    }
  144|   269M|}
_RNvNtCsaDAmlQ5xRbD_7sparopt14type_inference29add_ground_term_pattern_types:
  146|   276M|fn add_ground_term_pattern_types(
  147|   276M|    pattern: &GroundTermPattern,
  148|   276M|    types: &mut VariableTypes,
  149|   276M|    is_object: bool,
  150|   276M|) {
  151|   276M|    if let GroundTermPattern::Variable(v) = pattern {
  152|   253M|        types.intersect_variable_with(
  153|   253M|            v.clone(),
  154|   253M|            if is_object {
  155|   116M|                VariableType::TERM
  156|       |            } else {
  157|   136M|                VariableType::SUBJECT
  158|       |            },
  159|       |        )
  160|  22.5M|    }
  161|       |    #[cfg(feature = "rdf-star")]
  162|   276M|    if let GroundTermPattern::Triple(t) = pattern {
  163|      0|        add_ground_term_pattern_types(&t.subject, types, false);
  164|      0|        if let NamedNodePattern::Variable(v) = &t.predicate {
  165|      0|            types.intersect_variable_with(v.clone(), VariableType::NAMED_NODE)
  166|      0|        }
  167|      0|        add_ground_term_pattern_types(&t.object, types, true);
  168|   276M|    }
  169|   276M|}
_RNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB2_13VariableTypes10union_with:
  318|     96|    pub fn union_with(&mut self, other: Self) {
  319|    269|        for (v, t) in &mut self.inner {
  320|    173|            if other.get(v).undef {
  321|     94|                t.undef = true; // Might be undefined
  322|     94|            }
  323|       |        }
  324|    495|        for (v, mut t) in other.inner {
  325|    399|            self.inner
  326|    399|                .entry(v)
  327|    399|                .and_modify(|ex| *ex = *ex | t)
  328|    399|                .or_insert({
  329|    399|                    t.undef = true;
  330|    399|                    t
  331|    399|                });
  332|    399|        }
  333|     96|    }
_RNvXs2_NtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB5_13VariableTypesNtNtCs9nhK3FOW46N_4core7default7Default7defaultB7_:
  295|  7.33k|#[derive(Default, Clone, Debug)]
_RNCNvMNtCsaDAmlQ5xRbD_7sparopt14type_inferenceNtB4_13VariableTypes10union_with0B6_:
  327|     79|                .and_modify(|ex| *ex = *ex | t)
_RNCNvNtCsaDAmlQ5xRbD_7sparopt14type_inference25infer_graph_pattern_types0B5_:
   63|    192|            .map(|inner| infer_graph_pattern_types(inner, types.clone()))
_RNCNvNtCsaDAmlQ5xRbD_7sparopt14type_inference25infer_graph_pattern_typess0_0B5_:
   86|  1.57k|                .filter(|(v, _)| variables.contains(v))
_RNCNvNtCsaDAmlQ5xRbD_7sparopt14type_inference25infer_graph_pattern_typess_0B5_:
   64|     96|            .reduce(|mut a, b| {
   65|     96|                a.union_with(b);
   66|     96|                a
   67|     96|            })
_RNCNvNtCsaDAmlQ5xRbD_7sparopt14type_inference25infer_graph_pattern_typess1_0B5_:
  103|      8|                    .filter(|(v, _)| variables.contains(v))

_RNvXNvCs6Lc7YXa2Vl_12sparql_smithst_1__NtB4_8QuadDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  725|    942|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__NtB4_17PrimaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1794|   142k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsz_1__NtB4_22GraphPatternNotTriplesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  832|  3.23k|#[derive(Arbitrary)]
_RNvXsL_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6FilterNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1058|      3|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1059|      3|        write!(f, "FILTER {}", self.constraint)
 1060|      3|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsr_1__NtB4_11QuadPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  686|  18.6k|#[derive(Arbitrary)]
_RNvXsl_Cs6Lc7YXa2Vl_12sparql_smithNtB5_10DeleteDataNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  595|     71|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  596|     71|        write!(f, "DELETE DATA {}", self.data)
  597|     71|    }
_RNvXs1i_Cs6Lc7YXa2Vl_12sparql_smithNtB6_23ConditionalOrExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1676|  1.70k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1677|  1.70k|        write!(f, "{}", self.start)?;
 1678|  1.74k|        for e in &self.others {
 1679|     37|            write!(f, " || {e}")?;
 1680|       |        }
 1681|  1.70k|        Ok(())
 1682|  1.70k|    }
_RNvXs1t_Cs6Lc7YXa2Vl_12sparql_smithNtB6_13IriOrFunctionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1960|    512|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1961|    512|        write!(f, "{}", self.iri)?;
 1962|       |        // if let Some(args) = &self.args {
 1963|       |        // write!(f, "{args}")?;
 1964|       |        // }
 1965|    512|        Ok(())
 1966|    512|    }
_RNvXsT_Cs6Lc7YXa2Vl_12sparql_smithNtB5_22TriplesSameSubjectPathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1215|  1.55k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1216|  1.55k|        match self {
 1217|       |            Self::Atomic {
 1218|    969|                subject,
 1219|    969|                predicate_object,
 1220|    969|            } => {
 1221|    969|                write!(f, "{subject}{predicate_object}")
 1222|       |            }
 1223|       |            Self::Other {
 1224|    589|                subject,
 1225|    589|                predicate_object,
 1226|    589|            } => {
 1227|    589|                write!(f, "{subject} {predicate_object}")
 1228|       |            }
 1229|       |        }
 1230|  1.55k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__NtB4_23ConditionalOrExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1668|  42.7k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsp_1__NtB4_8GraphRefNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  654|  3.87k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths11_1__NtB4_7PathEltNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1353|   108k|#[derive(Arbitrary)]
_RNvXse_Cs6Lc7YXa2Vl_12sparql_smithNtB5_5ClearNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  479|  1.28k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  480|  1.28k|        write!(f, "CLEAR ")?;
  481|  1.28k|        if self.silent {
  482|    978|            write!(f, "SILENT ")?;
  483|    306|        }
  484|  1.28k|        write!(f, "{}", self.target)
  485|  1.28k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsC_1__NtB4_17GraphGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  886|    285|#[derive(Arbitrary)]
_RNvXsA_Cs6Lc7YXa2Vl_12sparql_smithNtB5_19LateralGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  881|    292|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  882|    292|        write!(f, " LATERAL {}", self.inner)
  883|    292|    }
_RNvXsJ_Cs6Lc7YXa2Vl_12sparql_smithNtB5_17MinusGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1029|     22|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1030|     22|        write!(f, " MINUS {}", self.inner)
 1031|     22|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsa_1__NtB4_12HavingClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  262|    170|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1r_1__NtB4_10ExistsFuncNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1928|  1.14k|#[derive(Arbitrary)]
_RNvXs3_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12SelectClauseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  149|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  150|  1.48k|        f.write_str("SELECT")?;
  151|  1.48k|        if let Some(option) = &self.option {
  152|    993|            match option {
  153|    292|                SelectOption::Distinct => f.write_str(" DISTINCT"),
  154|    701|                SelectOption::Reduced => f.write_str(" REDUCED"),
  155|      0|            }?;
  156|    496|        }
  157|  1.48k|        match &self.values {
  158|    727|            SelectValues::Star => f.write_str(" *"),
  159|    762|            SelectValues::Projection { start, others } => {
  160|    973|                for e in once(start).chain(others) {
  161|    973|                    match e {
  162|    383|                        SelectProjection::Variable(v) => write!(f, " {v}"),
  163|    590|                        SelectProjection::Projection(e, v) => write!(f, " ({e} AS {v})"),
  164|      0|                    }?;
  165|       |                }
  166|    762|                Ok(())
  167|       |            }
  168|       |        }
  169|  1.48k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsA_1__NtB4_20OptionalGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  862|    789|#[derive(Arbitrary)]
_RNvXsy_Cs6Lc7YXa2Vl_12sparql_smithNtB5_22GraphPatternNotTriplesNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  847|    922|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  848|    922|        match self {
  849|    125|            Self::GroupOrUnion(p) => write!(f, "{p}"),
  850|    235|            Self::Optional(p) => write!(f, "{p}"),
  851|     22|            Self::Minus(p) => write!(f, "{p}"),
  852|     80|            Self::Graph(p) => write!(f, "{p}"),
  853|      3|            Self::Filter(p) => write!(f, "{p}"),
  854|      2|            Self::Bind(p) => write!(f, "{p}"),
  855|    163|            Self::InlineData(p) => write!(f, "{p}"),
  856|       |            #[cfg(feature = "sep-0006")]
  857|    292|            Self::Lateral(p) => write!(f, "{p}"),
  858|       |        }
  859|    922|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsX_1__NtB4_23PropertyListPathElementNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1263|  1.16k|#[derive(Arbitrary)]
_RNvXsH_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14InlineDataFullNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  987|    185|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  988|    185|        f.write_str("( ")?;
  989|  3.49k|        for v in &self.vars {
  990|  3.31k|            write!(f, " {v}")?;
  991|       |        }
  992|    185|        f.write_str(" ) {")?;
  993|    449|        for vs in &self.values {
  994|    264|            f.write_str(" (")?;
  995|  4.79k|            for v in vs {
  996|  4.53k|                write!(f, " {v}")?;
  997|       |            }
  998|    264|            f.write_str(" )")?;
  999|       |        }
 1000|    185|        f.write_str(" }")
 1001|    185|    }
_RNvXs8_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12HavingClauseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  270|     21|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  271|     21|        write!(f, "HAVING {}", self.start)?;
  272|     21|        for o in &self.others {
  273|      0|            write!(f, " {o}")?;
  274|       |        }
  275|     21|        Ok(())
  276|     21|    }
_RNvXs14_Cs6Lc7YXa2Vl_12sparql_smithNtB6_20PathOneInPropertySetNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1459|  7.56k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1460|  7.56k|        match self {
 1461|  1.31k|            Self::Iri(iri) => write!(f, "{iri}"),
 1462|    440|            Self::A => f.write_str(" a "),
 1463|  2.60k|            Self::NegatedIri(iri) => write!(f, "^{iri}"),
 1464|  3.19k|            Self::NegatedA => f.write_str(" ^a "),
 1465|       |        }
 1466|  7.56k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsw_1__NtB4_20GroupGraphPatternSubNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  780|  9.48k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__NtB4_25BlankNodePropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1513|  29.6k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths4_1__NtB4_12SelectValuesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  133|  9.35k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths12_1__NtB4_16PathEltOrInverseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1370|   108k|#[derive(Arbitrary)]
_RNvXs1u_Cs6Lc7YXa2Vl_12sparql_smithNtB6_7LiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1980|  10.8k|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 1981|  10.8k|        Ok(Self {
 1982|  10.8k|            value: u.choose(LITERALS.as_slice())?,
 1983|       |        })
 1984|  10.8k|    }
_RNvXsX_Cs6Lc7YXa2Vl_12sparql_smithNtB5_15PathAlternativeNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1327|  22.4k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1328|  22.4k|        write!(f, "{}", self.start)?;
 1329|  23.9k|        for other in &self.others {
 1330|  1.49k|            write!(f, " | {other}")?;
 1331|       |        }
 1332|  22.4k|        Ok(())
 1333|  22.4k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths16_1__NtB4_20PathOneInPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1449|  26.4k|#[derive(Arbitrary)]
_RNvXsk_Cs6Lc7YXa2Vl_12sparql_smithNtB5_10InsertDataNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  583|    239|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  584|    239|        write!(f, "INSERT DATA {}", self.data)
  585|    239|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsh_1__NtB4_3AddNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  522|    981|#[derive(Arbitrary)]
_RNvXsw_Cs6Lc7YXa2Vl_12sparql_smithNtB5_20GroupGraphPatternSubNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  795|  3.01k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  796|  3.01k|        if let Some(start) = &self.start {
  797|  1.29k|            write!(f, "{start}")?;
  798|  1.71k|        }
  799|  3.93k|        for other in &self.others {
  800|    922|            write!(f, "{}", other.start)?;
  801|    922|            if other.with_dot {
  802|    189|                f.write_str(" . ")?;
  803|    733|            }
  804|    922|            if let Some(end) = &other.end {
  805|    216|                write!(f, "{end}")?;
  806|    706|            }
  807|       |        }
  808|  3.01k|        Ok(())
  809|  3.01k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithss_1__NtB4_17VarOrIriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  694|  47.5k|#[derive(Arbitrary)]
_RNvXs1s_Cs6Lc7YXa2Vl_12sparql_smithNtB6_13NotExistsFuncNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1947|     40|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1948|     40|        write!(f, "NOT EXISTS {}", self.pattern)
 1949|     40|    }
_RNvXs12_Cs6Lc7YXa2Vl_12sparql_smithNtB6_11PathPrimaryNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1414|  32.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1415|  32.5k|        match self {
 1416|  8.31k|            Self::Iri(iri) => write!(f, "{iri}"),
 1417|  2.17k|            Self::A => f.write_str(" a "),
 1418|  1.49k|            Self::Negated(n) => write!(f, "!{n}"),
 1419|  20.5k|            Self::Child(c) => write!(f, "({c})"),
 1420|       |        }
 1421|  32.5k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsq_1__NtB4_11GraphRefAllNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  666|  4.94k|#[derive(Arbitrary)]
_RNvXs1w_Cs6Lc7YXa2Vl_12sparql_smithNtB6_3IriNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 2003|  63.4k|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 2004|  63.4k|        Ok(Self {
 2005|  63.4k|            value: u.int_in_range(1..=NUMBER_OF_NAMED_NODES)?,
 2006|       |        })
 2007|  63.4k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithso_1__NtB4_14GraphOrDefaultNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  636|  6.82k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsT_1__NtB4_22TriplesSameSubjectPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1201|  5.27k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__NtB4_24MultiplicativeExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1756|  85.8k|#[derive(Arbitrary)]
_RNvXsI_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14DataBlockValueNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1013|  4.86k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1014|  4.86k|        match self {
 1015|  3.08k|            Self::Iri(i) => write!(f, "{i}"),
 1016|    401|            Self::Literal(l) => write!(f, "{l}"),
 1017|  1.38k|            Self::Undef => f.write_str("UNDEF"),
 1018|       |        }
 1019|  4.86k|    }
_RNvXsi_Cs6Lc7YXa2Vl_12sparql_smithNtB5_4MoveNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  549|    611|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  550|    611|        write!(f, "MOVE ")?;
  551|    611|        if self.silent {
  552|    562|            write!(f, "SILENT ")?;
  553|     49|        }
  554|    611|        write!(f, "{} TO {}", self.from, self.to)
  555|    611|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths7_1__NtB4_16SolutionModifierNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  188|  2.92k|#[derive(Arbitrary)]
_RNvXs1q_Cs6Lc7YXa2Vl_12sparql_smithNtB6_11BuiltInCallNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1905|    722|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1906|    722|        match self {
 1907|     12|            Self::Str(v) => write!(f, "STR({v})"),
 1908|      5|            Self::Lang(v) => write!(f, "LANG({v})"),
 1909|      1|            Self::Datatype(v) => write!(f, "DATATYPE({v})"),
 1910|    462|            Self::Bound(v) => write!(f, "BOUND({v})"),
 1911|      4|            Self::Iri(v) => write!(f, "IRI({v})"),
 1912|     10|            Self::Bnode(v) => write!(f, "BNODE({v})"),
 1913|    110|            Self::Coalesce(vs) => write!(f, "COALESCE{vs}"),
 1914|      0|            Self::If(a, b, c) => write!(f, "IF({a}, {b}, {c})"),
 1915|      0|            Self::StrLang(a, b) => write!(f, "STRLANG({a}, {b})"),
 1916|      3|            Self::StrDt(a, b) => write!(f, "STRDT({a}, {b})"),
 1917|      1|            Self::SameTerm(a, b) => write!(f, "sameTerm({a}, {b})"),
 1918|      5|            Self::IsIri(e) => write!(f, "isIRI({e})"),
 1919|     17|            Self::IsBlank(e) => write!(f, "isBlank({e})"),
 1920|      1|            Self::IsLiteral(e) => write!(f, "isLiteral({e})"),
 1921|      3|            Self::IsNumeric(e) => write!(f, "isNumeric({e})"),
 1922|     48|            Self::Exists(e) => write!(f, "{e}"),
 1923|     40|            Self::NotExists(e) => write!(f, "{e}"),
 1924|       |        }
 1925|    722|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsB_1__NtB4_19LateralGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  874|  1.03k|#[derive(Arbitrary)]
_RNvXsb_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6UpdateNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  424|  2.71k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  425|  8.29k|        for variant in &self.inner.variants {
  426|  5.57k|            write!(f, "{variant} ; ")?;
  427|       |        }
  428|  2.71k|        Ok(())
  429|  2.71k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths13_1__NtB4_7PathModNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1386|  29.9k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__NtB4_11BuiltInCallNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1828|  13.0k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsf_1__NtB4_4DropNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  488|    773|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths9_1__NtB4_14GroupConditionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  236|  1.05k|#[derive(Arbitrary)]
_RNvXsx_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12TriplesBlockNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  820|  1.55k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  821|  1.55k|        write!(f, "{}", self.start)?;
  822|  1.55k|        if let Some(end) = &self.end {
  823|     74|            f.write_str(" . ")?;
  824|     74|            if let Some(end) = end {
  825|     47|                write!(f, "{end}")?;
  826|     27|            }
  827|  1.48k|        }
  828|  1.55k|        Ok(())
  829|  1.55k|    }
_RNvXs1h_Cs6Lc7YXa2Vl_12sparql_smithNtB6_9GraphTermNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1656|  1.38k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1657|  1.38k|        match self {
 1658|    250|            Self::Iri(iri) => write!(f, "{iri}"),
 1659|    114|            Self::Literal(l) => write!(f, "{l}"),
 1660|  1.01k|            Self::Nil => f.write_str(" () "),
 1661|       |        }
 1662|  1.38k|    }
_RNvXs7_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14GroupConditionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  246|    196|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  247|    196|        match self {
  248|     34|            Self::BuiltInCall(c) => write!(f, "{c}"),
  249|       |            // Self::FunctionCall(c) => write!(f, "{c}"),
  250|      3|            Self::Projection(e, v) => {
  251|      3|                if let Some(v) = v {
  252|      0|                    write!(f, "({e} AS {v})")
  253|       |                } else {
  254|      3|                    write!(f, "({e})")
  255|       |                }
  256|       |            }
  257|    159|            Self::Var(v) => write!(f, "{v}"),
  258|       |        }
  259|    196|    }
_RNvXsg_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6CreateNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  513|    274|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  514|    274|        write!(f, "CREATE ")?;
  515|    274|        if self.silent {
  516|    264|            write!(f, "SILENT ")?;
  517|     10|        }
  518|    274|        write!(f, "{}", self.target)
  519|    274|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths3_1__NtB4_12SelectOptionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  127|  6.57k|#[derive(Arbitrary)]
_RNvXs1o_Cs6Lc7YXa2Vl_12sparql_smithNtB6_17PrimaryExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1805|  7.86k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1806|  7.86k|        match self {
 1807|    494|            Self::Bracketted(e) => write!(f, "{e}"),
 1808|    683|            Self::BuiltInCall(e) => write!(f, "{e}"),
 1809|    512|            Self::IriOrFunction(e) => write!(f, "{e}"),
 1810|  2.16k|            Self::Literal(e) => write!(f, "{e}"),
 1811|  4.00k|            Self::Var(e) => write!(f, "{e}"),
 1812|       |        }
 1813|  7.86k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsW_1__NtB4_28PropertyListPathNotEmptyVerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1257|  34.1k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsi_1__NtB4_4MoveNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  540|  2.05k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsU_1__NtB4_16PropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1233|  1.04k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths19_1__NtB4_15TriplesNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1497|  34.1k|#[derive(Arbitrary)]
_RNvXs18_Cs6Lc7YXa2Vl_12sparql_smithNtB6_25BlankNodePropertyListPathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1520|  9.29k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1521|  9.29k|        write!(f, "[ {} ]", self.inner)
 1522|  9.29k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__NtB4_13IriOrFunctionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1952|  9.62k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsE_1__NtB4_10InlineDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  912|    525|#[derive(Arbitrary)]
_RNvXsv_Cs6Lc7YXa2Vl_12sparql_smithNtB5_17GroupGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  770|  4.50k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  771|  4.50k|        f.write_str(" { ")?;
  772|  4.50k|        match self {
  773|  3.01k|            Self::GroupGraphPatternSub(p) => write!(f, "{p}"),
  774|  1.48k|            Self::SubSelect(s) => write!(f, "{s}"),
  775|      0|        }?;
  776|  4.50k|        f.write_str(" } ")
  777|  4.50k|    }
_RNvXs5_Cs6Lc7YXa2Vl_12sparql_smithNtB5_16SolutionModifierNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  200|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  201|  1.48k|        if let Some(group) = &self.group {
  202|     46|            write!(f, " {group}")?;
  203|  1.44k|        }
  204|  1.48k|        if let Some(having) = &self.having {
  205|     21|            write!(f, " {having}")?;
  206|  1.46k|        }
  207|       |        #[cfg(feature = "order")]
  208|       |        if let Some(order) = &self.order {
  209|       |            write!(f, " {order}")?;
  210|       |        }
  211|       |        #[cfg(feature = "limit-offset")]
  212|       |        if let Some(limit_offset) = &self.limit_offset {
  213|       |            write!(f, " {limit_offset}")?;
  214|       |        }
  215|  1.48k|        Ok(())
  216|  1.48k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__NtB4_8VarOrIriNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1607|   101k|#[derive(Arbitrary)]
_RNvXs1r_Cs6Lc7YXa2Vl_12sparql_smithNtB6_10ExistsFuncNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1935|     48|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1936|     48|        write!(f, "EXISTS {}", self.pattern)
 1937|     48|    }
_RNvXs11_Cs6Lc7YXa2Vl_12sparql_smithNtB6_7PathModNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1395|  8.06k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1396|  8.06k|        match self {
 1397|  4.60k|            Self::ZeroOrOne => f.write_str(" ? "),
 1398|  1.08k|            Self::ZeroOrMore => f.write_str(" * "),
 1399|  2.37k|            Self::OneOrMore => f.write_str(" + "),
 1400|       |        }
 1401|  8.06k|    }
_RNvXs1d_Cs6Lc7YXa2Vl_12sparql_smithNtB6_9VarOrTermNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1599|  7.53k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1600|  7.53k|        match self {
 1601|  6.14k|            Self::Var(v) => write!(f, "{v}"),
 1602|  1.38k|            Self::GraphTerm(t) => write!(f, "{t}"),
 1603|       |        }
 1604|  7.53k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__NtB4_24GroupOrUnionGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1034|    455|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithse_1__NtB4_5ClearNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  471|  4.19k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__NtB4_18AdditiveExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1738|  57.0k|#[derive(Arbitrary)]
_RNvXsh_Cs6Lc7YXa2Vl_12sparql_smithNtB5_3AddNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  531|    264|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  532|    264|        write!(f, "ADD ")?;
  533|    264|        if self.silent {
  534|    226|            write!(f, "SILENT ")?;
  535|     38|        }
  536|    264|        write!(f, "{} TO {}", self.from, self.to)
  537|    264|    }
_RNvXst_Cs6Lc7YXa2Vl_12sparql_smithNtB5_8QuadDataNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  740|    310|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  741|    310|        f.write_str(" { ")?;
  742|  3.87k|        for (s, p, o, g) in &self.quads {
  743|  3.56k|            if let Some(g) = g {
  744|  3.26k|                write!(f, "GRAPH {g} {{ {s} {p} {o} }} ")?;
  745|       |            } else {
  746|    294|                write!(f, "{s} {p} {o} . ")?;
  747|       |            }
  748|       |        }
  749|    310|        f.write_str("}")
  750|    310|    }
_RNvXs1p_Cs6Lc7YXa2Vl_12sparql_smithNtB6_20BrackettedExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1823|    513|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1824|    513|        write!(f, "({})", self.inner)
 1825|    513|    }
_RNvXsZ_Cs6Lc7YXa2Vl_12sparql_smithNtB5_7PathEltNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1361|  32.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1362|  32.5k|        write!(f, "{}", self.path)?;
 1363|  32.5k|        if let Some(mode) = &self.mode {
 1364|  8.06k|            write!(f, "{mode}")?;
 1365|  24.4k|        }
 1366|  32.5k|        Ok(())
 1367|  32.5k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsu_1__NtB4_12IriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  733|  10.6k|#[derive(Arbitrary)]
_RNvXsm_Cs6Lc7YXa2Vl_12sparql_smithNtB5_11DeleteWhereNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  607|    364|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  608|    364|        write!(f, "DELETE WHERE {}", self.data)
  609|    364|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__NtB4_15UnaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1774|   143k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths2_1__NtB4_12SelectClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  120|  9.37k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths6_1__NtB4_11WhereClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  172|  5.78k|#[derive(Arbitrary)]
_RNvXsU_Cs6Lc7YXa2Vl_12sparql_smithNtB5_16PropertyListPathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1240|    589|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1241|    589|        if let Some(p) = &self.inner {
 1242|     25|            write!(f, "{p}")
 1243|       |        } else {
 1244|    564|            Ok(())
 1245|       |        }
 1246|    589|    }
_RNvXs1g_Cs6Lc7YXa2Vl_12sparql_smithNtB6_3VarNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1641|  41.1k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1642|  41.1k|        write!(f, " ?{} ", self.value)
 1643|  41.1k|    }
_RNvXsR_Cs6Lc7YXa2Vl_12sparql_smithNtB5_4VerbNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1172|  12.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1173|  12.5k|        match self {
 1174|  3.45k|            Self::VarOrIri(iri) => write!(f, "{iri}"),
 1175|  9.13k|            Self::A => f.write_str(" a "),
 1176|       |        }
 1177|  12.5k|    }
_RNvXsf_Cs6Lc7YXa2Vl_12sparql_smithNtB5_4DropNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  496|    204|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  497|    204|        write!(f, "DROP ")?;
  498|    204|        if self.silent {
  499|    119|            write!(f, "SILENT ")?;
  500|     85|        }
  501|    204|        write!(f, "{}", self.target)
  502|    204|    }
_RNvXsr_Cs6Lc7YXa2Vl_12sparql_smithNtB5_11QuadPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  702|  4.66k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  703|  4.66k|        f.write_str(" { ")?;
  704|  17.2k|        for (s, p, o, g) in &self.quads {
  705|  12.5k|            if let Some(g) = g {
  706|  10.7k|                write!(f, "GRAPH {g} {{ {s} {p} {o} }} ")?;
  707|       |            } else {
  708|  1.82k|                write!(f, "{s} {p} {o} . ")?;
  709|       |            }
  710|       |        }
  711|  4.66k|        f.write_str("}")
  712|  4.66k|    }
_RNvXs1e_Cs6Lc7YXa2Vl_12sparql_smithNtB6_8VarOrIriNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1615|  26.8k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1616|  26.8k|        match self {
 1617|  8.74k|            Self::Var(v) => write!(f, "{v}"),
 1618|  18.1k|            Self::Iri(t) => write!(f, "{t}"),
 1619|       |        }
 1620|  26.8k|    }
_RNvXs1n_Cs6Lc7YXa2Vl_12sparql_smithNtB6_15UnaryExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1784|  7.86k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1785|  7.86k|        match self {
 1786|  1.06k|            Self::Not(e) => write!(f, "!{e}"),
 1787|    300|            Self::Plus(e) => write!(f, "+{e}"),
 1788|  2.31k|            Self::Minus(e) => write!(f, "-{e}"),
 1789|  4.18k|            Self::Base(e) => write!(f, "{e}"),
 1790|       |        }
 1791|  7.86k|    }
_RNvXs1k_Cs6Lc7YXa2Vl_12sparql_smithNtB6_20RelationalExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1720|  2.00k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1721|  2.00k|        match self {
 1722|    400|            Self::Base(e) => write!(f, "{e}"),
 1723|    132|            Self::Equal(a, b) => write!(f, "{a} = {b}"),
 1724|     19|            Self::NotEqual(a, b) => write!(f, "{a} != {b}"),
 1725|     21|            Self::Less(a, b) => write!(f, "{a} < {b}"),
 1726|     28|            Self::LessOrEqual(a, b) => write!(f, "{a} <= {b}"),
 1727|     47|            Self::Greater(a, b) => write!(f, "{a} > {b}"),
 1728|    232|            Self::GreaterOrEqual(a, b) => write!(f, "{a} >= {b}"),
 1729|     86|            Self::In(a, b) => write!(f, "{a} IN {b}"),
 1730|  1.04k|            Self::NotIn(a, b) => write!(f, "{a} NOT IN {b}"),
 1731|       |        }
 1732|  2.00k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsK_1__NtB4_6FilterNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1051|     27|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__NtB4_20RelationalExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1705|  50.1k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsR_1__NtB4_4VerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1164|  47.7k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths14_1__NtB4_11PathPrimaryNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1404|   108k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__NtB4_9GraphTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1646|  4.62k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1s_1__NtB4_13NotExistsFuncNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1940|    828|#[derive(Arbitrary)]
_RNvXs4_Cs6Lc7YXa2Vl_12sparql_smithNtB5_11WhereClauseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  180|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  181|  1.48k|        if self.with_where {
  182|    463|            f.write_str(" WHERE ")?;
  183|  1.02k|        }
  184|  1.48k|        write!(f, "{}", self.group_graph_pattern)
  185|  1.48k|    }
_RNvXsP_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14ExpressionListNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1125|  1.24k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1126|  1.24k|        f.write_str("(")?;
 1127|  1.24k|        for (i, e) in self.inner.iter().enumerate() {
 1128|    529|            if i > 0 {
 1129|      5|                f.write_str(", ")?;
 1130|    524|            }
 1131|    529|            write!(f, "{e}")?;
 1132|       |        }
 1133|  1.24k|        f.write_str(")")
 1134|  1.24k|    }
_RNvXsd_Cs6Lc7YXa2Vl_12sparql_smithNtB5_13UpdateVariantNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  455|  5.57k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  456|  5.57k|        match self {
  457|  1.28k|            UpdateVariant::Load(a) => a.fmt(f),
  458|    204|            UpdateVariant::Drop(a) => a.fmt(f),
  459|    264|            UpdateVariant::Add(a) => a.fmt(f),
  460|    611|            UpdateVariant::Move(a) => a.fmt(f),
  461|    114|            UpdateVariant::Copy(a) => a.fmt(f),
  462|    274|            UpdateVariant::Crate(a) => a.fmt(f),
  463|    239|            UpdateVariant::InsertData(a) => a.fmt(f),
  464|     71|            UpdateVariant::DeleteData(a) => a.fmt(f),
  465|    364|            UpdateVariant::DeleteWhere(a) => a.fmt(f),
  466|  2.15k|            UpdateVariant::Modify(a) => a.fmt(f),
  467|       |        }
  468|  5.57k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsD_1__NtB4_4BindNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  899|     18|#[derive(Arbitrary)]
_RNvXs1c_Cs6Lc7YXa2Vl_12sparql_smithNtB6_13GraphNodePathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1583|  16.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1584|  16.5k|        match self {
 1585|  6.56k|            Self::VarOrTerm(t) => write!(f, "{t}"),
 1586|  10.0k|            Self::TriplesNodePath(p) => write!(f, "{p}"),
 1587|       |        }
 1588|  16.5k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsx_1__NtB4_30GroupGraphPatternSubOtherBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  787|  3.23k|#[derive(Arbitrary)]
_RNvXs1l_Cs6Lc7YXa2Vl_12sparql_smithNtB6_18AdditiveExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1747|  2.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1748|  2.48k|        match self {
 1749|    648|            Self::Base(e) => write!(f, "{e}"),
 1750|    232|            Self::Plus(a, b) => write!(f, "{a} + {b}"),
 1751|  1.60k|            Self::Minus(a, b) => write!(f, "{a} - {b}"),
 1752|       |        }
 1753|  2.48k|    }
_RNvXsa_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6UpdateNtCs9EteCURj6Wn_9arbitrary9Arbitrary9size_hint:
  418|  3.51k|    fn size_hint(_depth: usize) -> (usize, Option<usize>) {
  419|  3.51k|        (20, None) // TODO: is it good?
  420|  3.51k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsv_1__NtB4_17GroupGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  762|  18.9k|#[derive(Arbitrary)]
_RNvXss_Cs6Lc7YXa2Vl_12sparql_smithNtB5_17VarOrIriOrLiteralNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  716|  12.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  717|  12.5k|        match self {
  718|  2.57k|            VarOrIriOrLiteral::Iri(i) => i.fmt(f),
  719|  1.42k|            VarOrIriOrLiteral::Literal(l) => l.fmt(f),
  720|  8.58k|            VarOrIriOrLiteral::Var(v) => v.fmt(f),
  721|       |        }
  722|  12.5k|    }
_RNvXsE_Cs6Lc7YXa2Vl_12sparql_smithNtB5_9DataBlockNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  932|    224|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  933|    224|        match self {
  934|     39|            Self::OneVar(e) => write!(f, "{e}"),
  935|    185|            Self::Full(c) => write!(f, "{c}"),
  936|       |        }
  937|    224|    }
_RNvXs2_Cs6Lc7YXa2Vl_12sparql_smithNtB5_9SubSelectNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  111|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  112|  1.48k|        write!(
  113|  1.48k|            f,
  114|  1.48k|            "{}{}{}{}",
  115|  1.48k|            self.select_clause, self.where_clause, self.solution_modifier, self.values_clause
  116|  1.48k|        )
  117|  1.48k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsI_1__NtB4_17MinusGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1022|     99|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsG_1__NtB4_16InlineDataOneVarNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  940|    140|#[derive(Arbitrary)]
_RNvXs1x_Cs6Lc7YXa2Vl_12sparql_smithNtB6_3IriNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 2015|  52.6k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 2016|  52.6k|        write!(f, " <http://example.org/{}> ", self.value)
 2017|  52.6k|    }
_RNvXsY_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12PathSequenceNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1344|  23.9k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1345|  23.9k|        write!(f, "{}", self.start)?;
 1346|  32.5k|        for other in &self.others {
 1347|  8.57k|            write!(f, " / {other}")?;
 1348|       |        }
 1349|  23.9k|        Ok(())
 1350|  23.9k|    }
_RNvXs1a_Cs6Lc7YXa2Vl_12sparql_smithNtB6_14CollectionPathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1550|  1.32k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1551|  1.32k|        write!(f, "( {}", self.start)?;
 1552|  2.82k|        for e in &self.others {
 1553|  1.50k|            write!(f, " {e}")?;
 1554|       |        }
 1555|  1.32k|        f.write_str(" )")
 1556|  1.32k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsd_1__NtB4_13UpdateVariantNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  438|  20.3k|#[derive(Arbitrary)]
_RNvXs1v_Cs6Lc7YXa2Vl_12sparql_smithNtB6_7LiteralNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1992|  6.45k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1993|  6.45k|        write!(f, "{}", self.value)
 1994|  6.45k|    }
_RNvXs13_Cs6Lc7YXa2Vl_12sparql_smithNtB6_22PathNegatedPropertySetNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1435|  1.49k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1436|  1.49k|        match self {
 1437|    297|            Self::Single(p) => write!(f, "{p}"),
 1438|  1.19k|            Self::Multiple { start, others } => {
 1439|  1.19k|                write!(f, " ( {start}")?;
 1440|  7.26k|                for other in others {
 1441|  6.07k|                    write!(f, " | {other}")?;
 1442|       |                }
 1443|  1.19k|                f.write_str(" ) ")
 1444|       |            }
 1445|       |        }
 1446|  1.49k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths15_1__NtB4_22PathNegatedPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1424|  5.17k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsy_1__NtB4_12TriplesBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  812|  5.27k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__NtB4_15PathAlternativeNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1319|  71.9k|#[derive(Arbitrary)]
_RNvXsq_Cs6Lc7YXa2Vl_12sparql_smithNtB5_11GraphRefAllNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  676|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  677|  1.48k|        match self {
  678|    927|            GraphRefAll::GraphRef(g) => g.fmt(f),
  679|    236|            GraphRefAll::Default => write!(f, "DEFAULT"),
  680|     46|            GraphRefAll::Named => write!(f, "NAMED"),
  681|    279|            GraphRefAll::All => write!(f, "ALL"),
  682|       |        }
  683|  1.48k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsL_1__NtB4_10ConstraintNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1063|    203|#[derive(Arbitrary)]
_RNvXsC_Cs6Lc7YXa2Vl_12sparql_smithNtB5_4BindNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  907|      2|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  908|      2|        write!(f, " BIND({} AS {})", self.expression, self.var)
  909|      2|    }
_RNvXs1m_Cs6Lc7YXa2Vl_12sparql_smithNtB6_24MultiplicativeExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1765|  4.32k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1766|  4.32k|        match self {
 1767|    796|            Self::Base(e) => write!(f, "{e}"),
 1768|    489|            Self::Mul(a, b) => write!(f, "{a} * {b}"),
 1769|  3.04k|            Self::Div(a, b) => write!(f, "{a} / {b}"),
 1770|       |        }
 1771|  4.32k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsn_1__NtB4_6ModifyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  612|  8.89k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1_1__NtB4_9SubSelectNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  101|  9.37k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths5_1__NtB4_16SelectProjectionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  142|  7.88k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__NtB4_14CollectionPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1542|  4.38k|#[derive(Arbitrary)]
_RNvXsG_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14InlineDataFullNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  964|    198|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  965|    198|        let vars = u.arbitrary_iter()?.collect::<Result<Vec<_>>>()?;
  966|       |
  967|    198|        let mut values = Vec::new();
  968|    198|        u.arbitrary_loop(Some(0), Some(3), |u| {
  969|       |            let mut row = Vec::with_capacity(vars.len());
  970|       |            u.arbitrary_loop(
  971|       |                Some(vars.len().try_into().unwrap()),
  972|       |                Some(vars.len().try_into().unwrap()),
  973|       |                |u| {
  974|       |                    row.push(u.arbitrary()?);
  975|       |                    Ok(ControlFlow::Continue(()))
  976|       |                },
  977|       |            )?;
  978|       |            values.push(row);
  979|       |            Ok(ControlFlow::Continue(()))
  980|    198|        })?;
  981|       |
  982|    198|        Ok(Self { vars, values })
  983|    198|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths8_1__NtB4_11GroupClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  219|    300|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsc_1__NtB4_13UpdateContentNtCs9EteCURj6Wn_9arbitrary9Arbitrary19arbitrary_take_rest:
  398|  10.5k|#[derive(Arbitrary)]
_RNvXsj_Cs6Lc7YXa2Vl_12sparql_smithNtB5_4CopyNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  567|    114|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  568|    114|        write!(f, "MOVE ")?;
  569|    114|        if self.silent {
  570|     88|            write!(f, "SILENT ")?;
  571|     26|        }
  572|    114|        write!(f, "{} TO {}", self.from, self.to)
  573|    114|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsl_1__NtB4_10DeleteDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  588|    225|#[derive(Arbitrary)]
_RNvXsF_Cs6Lc7YXa2Vl_12sparql_smithNtB5_16InlineDataOneVarNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  948|     39|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  949|     39|        write!(f, "{} {{", self.var)?;
  950|    372|        for v in &self.values {
  951|    333|            write!(f, " {v}")?;
  952|       |        }
  953|     39|        write!(f, " }}")
  954|     39|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsg_1__NtB4_6CreateNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  505|    919|#[derive(Arbitrary)]
_RNvXso_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14GraphOrDefaultNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  645|  1.97k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  646|  1.97k|        match self {
  647|    875|            GraphOrDefault::Default => write!(f, "DEFAULT"),
  648|    870|            GraphOrDefault::Graph(g) => write!(f, "GRAPH {g}"),
  649|    233|            GraphOrDefault::Iri(g) => g.fmt(f),
  650|       |        }
  651|  1.97k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__NtB4_13GraphNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1575|  52.7k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__NtB4_20BrackettedExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1816|  20.6k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsj_1__NtB4_4CopyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  558|    390|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsV_1__NtB4_24PropertyListPathNotEmptyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1249|  32.9k|#[derive(Arbitrary)]
_RNvXsD_Cs6Lc7YXa2Vl_12sparql_smithNtB5_10InlineDataNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  919|    163|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  920|    163|        write!(f, "VALUES {}", self.inner)
  921|    163|    }
_RNvXsM_Cs6Lc7YXa2Vl_12sparql_smithNtB5_10ConstraintNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1072|     24|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1073|     24|        match self {
 1074|     19|            Self::BrackettedExpression(e) => write!(f, "{e}"),
 1075|      5|            Self::BuiltInCall(c) => write!(f, "{c}"),
 1076|       |            // Self::FunctionCall(c) => write!(f, "{c}"),
 1077|       |        }
 1078|     24|    }
_RNvXs1j_Cs6Lc7YXa2Vl_12sparql_smithNtB6_24ConditionalAndExpressionNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1693|  1.74k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1694|  1.74k|        write!(f, "{}", self.start)?;
 1695|  2.00k|        for e in &self.others {
 1696|    269|            write!(f, " && {e}")?;
 1697|       |        }
 1698|  1.74k|        Ok(())
 1699|  1.74k|    }
_RNvXs9_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12ValuesClauseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  385|  1.48k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  386|  1.48k|        if let Some(value) = &self.value {
  387|     61|            write!(f, " VALUES {value}")
  388|       |        } else {
  389|  1.42k|            Ok(())
  390|       |        }
  391|  1.48k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsH_1__NtB4_14DataBlockValueNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1004|  11.3k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsO_1__NtB4_14ExpressionListNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1118|  19.9k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsm_1__NtB4_11DeleteWhereNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  600|  1.12k|#[derive(Arbitrary)]
_RNvXs6_Cs6Lc7YXa2Vl_12sparql_smithNtB5_11GroupClauseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  227|     46|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  228|     46|        write!(f, "GROUP BY {}", self.start)?;
  229|    196|        for o in &self.others {
  230|    150|            write!(f, " {o}")?;
  231|       |        }
  232|     46|        Ok(())
  233|     46|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsF_1__NtB4_9DataBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  924|    738|#[derive(Arbitrary)]
_RNvXsp_Cs6Lc7YXa2Vl_12sparql_smithNtB5_8GraphRefNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  661|  1.20k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  662|  1.20k|        write!(f, "GRAPH {}", self.iri)
  663|  1.20k|    }
_RNvXsB_Cs6Lc7YXa2Vl_12sparql_smithNtB5_17GraphGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  894|     80|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  895|     80|        write!(f, " GRAPH {} {}", self.graph, self.inner)
  896|     80|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsb_1__NtB4_12ValuesClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  378|  2.68k|#[derive(Arbitrary)]
_RNvXsK_Cs6Lc7YXa2Vl_12sparql_smithNtB5_24GroupOrUnionGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1042|    125|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1043|    125|        write!(f, "{}", self.start)?;
 1044|    144|        for other in &self.others {
 1045|     19|            write!(f, " UNION {other}")?;
 1046|       |        }
 1047|    125|        Ok(())
 1048|    125|    }
_RNvXsW_Cs6Lc7YXa2Vl_12sparql_smithNtB5_14ObjectListPathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1304|  10.6k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1305|  10.6k|        write!(f, "{}", self.start)?;
 1306|  13.7k|        for other in &self.others {
 1307|  3.14k|            write!(f, " , {other}")?;
 1308|       |        }
 1309|  10.6k|        Ok(())
 1310|  10.6k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths10_1__NtB4_12PathSequenceNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1336|  77.1k|#[derive(Arbitrary)]
_RNvXs17_Cs6Lc7YXa2Vl_12sparql_smithNtB6_15TriplesNodePathNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1505|  10.6k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1506|  10.6k|        match self {
 1507|  1.32k|            Self::CollectionPath(p) => write!(f, "{p}"),
 1508|  9.29k|            Self::BlankNodePropertyListPath(p) => write!(f, "{p}"),
 1509|       |        }
 1510|  10.6k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__NtB4_9VarOrTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1591|  23.6k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__NtB4_24ConditionalAndExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1685|  43.3k|#[derive(Arbitrary)]
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsY_1__NtB4_14ObjectListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1296|  32.2k|#[derive(Arbitrary)]
_RNvXsu_Cs6Lc7YXa2Vl_12sparql_smithNtB5_12IriOrLiteralNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  754|  3.56k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  755|  3.56k|        match self {
  756|  1.21k|            IriOrLiteral::Iri(i) => i.fmt(f),
  757|  2.35k|            IriOrLiteral::Literal(l) => l.fmt(f),
  758|       |        }
  759|  3.56k|    }
_RNvXs10_Cs6Lc7YXa2Vl_12sparql_smithNtB6_16PathEltOrInverseNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1378|  32.5k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1379|  32.5k|        match self {
 1380|  9.93k|            Self::PathElt(e) => write!(f, "{e}"),
 1381|  22.5k|            Self::Inverse(e) => write!(f, " ^{e}"),
 1382|       |        }
 1383|  32.5k|    }
_RNvXs1f_Cs6Lc7YXa2Vl_12sparql_smithNtB6_3VarNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
 1629|  71.8k|    fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
 1630|  71.8k|        Ok(Self {
 1631|  71.8k|            value: u.int_in_range(1..=NUMBER_OF_VARIABLES)?,
 1632|       |        })
 1633|  71.8k|    }
_RNvXNvCs6Lc7YXa2Vl_12sparql_smithsk_1__NtB4_10InsertDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary:
  576|    717|#[derive(Arbitrary)]
_RNvXsn_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6ModifyNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  624|  2.15k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  625|  2.15k|        if let Some(with) = &self.with {
  626|  1.94k|            write!(f, "WITH {with} ")?;
  627|    205|        }
  628|  2.15k|        write!(
  629|  2.15k|            f,
  630|  2.15k|            "DELETE {} INSERT {} WHERE {}",
  631|  2.15k|            self.delete, self.insert, self.where_
  632|  2.15k|        )
  633|  2.15k|    }
_RNvXsz_Cs6Lc7YXa2Vl_12sparql_smithNtB5_20OptionalGraphPatternNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
  869|    235|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  870|    235|        write!(f, " OPTIONAL {}", self.inner)
  871|    235|    }
_RNvXsa_Cs6Lc7YXa2Vl_12sparql_smithNtB5_6UpdateNtCs9EteCURj6Wn_9arbitrary9Arbitrary19arbitrary_take_rest:
  412|  3.51k|    fn arbitrary_take_rest(u: Unstructured<'a>) -> Result<Self> {
  413|  3.51k|        Ok(Self {
  414|  3.51k|            inner: UpdateContent::arbitrary_take_rest(u)?,
  415|       |        })
  416|  3.51k|    }
_RNvXsV_Cs6Lc7YXa2Vl_12sparql_smithNtB5_24PropertyListPathNotEmptyNtNtCs9nhK3FOW46N_4core3fmt7Display3fmt:
 1270|  10.2k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1271|  10.2k|        match &self.start_predicate {
 1272|  1.72k|            PropertyListPathNotEmptyVerb::VerbPath(p) => write!(f, "{p}"),
 1273|  8.56k|            PropertyListPathNotEmptyVerb::VerbSimple(s) => write!(f, "{s}"),
 1274|      0|        }?;
 1275|  10.2k|        write!(f, "{}", self.start_object)?;
 1276|  10.8k|        for other in &self.others {
 1277|    532|            f.write_str(" ; ")?;
 1278|    532|            if let Some(e) = other {
 1279|    335|                match &e.predicate {
 1280|    189|                    PropertyListPathNotEmptyVerb::VerbPath(p) => write!(f, "{p}"),
 1281|    146|                    PropertyListPathNotEmptyVerb::VerbSimple(s) => write!(f, "{s}"),
 1282|      0|                }?;
 1283|    335|                write!(f, "{}", e.object)?;
 1284|    197|            }
 1285|       |        }
 1286|  10.2k|        Ok(())
 1287|  10.2k|    }
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsW_1__NtB6_28PropertyListPathNotEmptyVerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1257|  11.4k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths9_1__NtB6_14GroupConditionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  236|    353|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithse_1__21RECURSIVE_COUNT_Clear7___getit0B7_:
  471|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths16_1__36RECURSIVE_COUNT_PathOneInPropertySet7___getit0B7_:
 1449|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithso_1__NtB6_14GraphOrDefaultNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  636|     15|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsR_1__20RECURSIVE_COUNT_Verb7___getit0B7_:
 1164|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsT_1__NtB6_22TriplesSameSubjectPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1201|      4|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsw_1__NtB6_20GroupGraphPatternSubNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  780|  3.48k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths19_1__NtB6_15TriplesNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1497|  11.3k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsa_1__NtB6_12HavingClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  262|     58|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__NtB6_9GraphTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1646|  1.54k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1_1__NtB6_9SubSelectNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  101|      9|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsG_1__NtB6_16InlineDataOneVarNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  940|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__NtB6_11BuiltInCallNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1828|  4.36k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsL_1__NtB6_10ConstraintNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1063|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths10_1__NtB6_12PathSequenceNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1336|  25.7k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsa_1__28RECURSIVE_COUNT_HavingClause7___getit0B7_:
  262|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths6_1__NtB6_11WhereClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  172|  2.07k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithse_1__NtB6_5ClearNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  471|     35|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsW_1__NtB6_28PropertyListPathNotEmptyVerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1257|     41|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__NtB6_18AdditiveExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1738|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__NtB6_8VarOrIriNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1607|    164|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsr_1__27RECURSIVE_COUNT_QuadPattern7___getit0B7_:
  686|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsp_1__NtB6_8GraphRefNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  654|     59|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__NtB6_17PrimaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1794|  48.0k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1_1__NtB6_9SubSelectNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  101|      9|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsb_1__NtB6_12ValuesClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  378|  1.67k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsx_1__NtB6_30GroupGraphPatternSubOtherBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  787|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__25RECURSIVE_COUNT_VarOrTerm7___getit0B7_:
 1591|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__30RECURSIVE_COUNT_CollectionPath7___getit0B7_:
 1542|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsX_1__NtB6_23PropertyListPathElementNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1263|    389|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsi_1__NtB6_4MoveNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  540|    686|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsn_1__NtB6_6ModifyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  612|  2.96k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__33RECURSIVE_COUNT_PrimaryExpression7___getit0B7_:
 1794|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsI_1__NtB6_17MinusGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1022|     33|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__NtB6_23ConditionalOrExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1668|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__NtB6_15UnaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1774|  48.1k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsn_1__NtB6_6ModifyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  612|      5|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsL_1__NtB6_10ConstraintNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1063|     69|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsv_1__33RECURSIVE_COUNT_GroupGraphPattern7___getit0B7_:
  762|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__NtB6_20BrackettedExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1816|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1r_1__NtB6_10ExistsFuncNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1928|    383|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsz_1__NtB6_22GraphPatternNotTriplesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  832|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsT_1__NtB6_22TriplesSameSubjectPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1201|  1.76k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__27RECURSIVE_COUNT_BuiltInCall7___getit0B7_:
 1828|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__NtB6_25BlankNodePropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1513|     11|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths8_1__NtB6_11GroupClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  219|    100|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths6_1__NtB6_11WhereClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  172|    226|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsV_1__NtB6_24PropertyListPathNotEmptyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1249|     38|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths11_1__NtB6_7PathEltNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1353|    332|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsT_1__38RECURSIVE_COUNT_TriplesSameSubjectPath7___getit0B7_:
 1201|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsE_1__NtB6_10InlineDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  912|    175|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsY_1__30RECURSIVE_COUNT_ObjectListPath7___getit0B7_:
 1296|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths15_1__NtB6_22PathNegatedPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1424|  1.72k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsb_1__NtB6_12ValuesClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  378|  1.16k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths2_1__28RECURSIVE_COUNT_SelectClause7___getit0B7_:
  120|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsk_1__NtB6_10InsertDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  576|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsq_1__NtB6_11GraphRefAllNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  666|  1.67k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__NtB6_9VarOrTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1591|  1.19k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__NtB6_9VarOrTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1591|  8.66k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsL_1__26RECURSIVE_COUNT_Constraint7___getit0B7_:
 1063|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsH_1__NtB6_14DataBlockValueNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1004|  5.06k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__NtB6_15UnaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1774|  1.00k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__NtB6_24ConditionalAndExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1685|    798|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__40RECURSIVE_COUNT_ConditionalAndExpression7___getit0B7_:
 1685|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__NtB6_24MultiplicativeExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1756|    938|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsf_1__NtB6_4DropNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  488|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsf_1__20RECURSIVE_COUNT_Drop7___getit0B7_:
  488|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__NtB6_15UnaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1774|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsX_1__NtB6_23PropertyListPathElementNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1263|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsK_1__NtB6_6FilterNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1051|      9|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths19_1__NtB6_15TriplesNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1497|      6|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsm_1__27RECURSIVE_COUNT_DeleteWhere7___getit0B7_:
  600|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths10_1__NtB6_12PathSequenceNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1336|    106|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsu_1__NtB6_12IriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  733|  3.58k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsB_1__NtB6_19LateralGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  874|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths7_1__32RECURSIVE_COUNT_SolutionModifier7___getit0B7_:
  188|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsB_1__NtB6_19LateralGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  874|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsH_1__30RECURSIVE_COUNT_DataBlockValue7___getit0B7_:
 1004|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsL_1__NtB6_10ConstraintNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1063|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths16_1__NtB6_20PathOneInPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1449|     40|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsW_1__NtB6_28PropertyListPathNotEmptyVerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1257|     41|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__NtB6_11BuiltInCallNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1828|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithso_1__NtB6_14GraphOrDefaultNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  636|  2.28k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithss_1__NtB6_17VarOrIriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  694|    186|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__39RECURSIVE_COUNT_ConditionalOrExpression7___getit0B7_:
 1668|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__NtB6_13IriOrFunctionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1952|  3.20k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsk_1__NtB6_10InsertDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  576|    241|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsf_1__NtB6_4DropNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  488|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__NtB6_13GraphNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1575|  1.04k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsq_1__27RECURSIVE_COUNT_GraphRefAll7___getit0B7_:
  666|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths13_1__NtB6_7PathModNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1386|     22|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsd_1__NtB6_13UpdateVariantNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  438|      7|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsd_1__29RECURSIVE_COUNT_UpdateVariant7___getit0B7_:
  438|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsG_1__NtB6_16InlineDataOneVarNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  940|     48|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsi_1__NtB6_4MoveNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  540|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsU_1__NtB6_16PropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1233|    474|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths6_1__27RECURSIVE_COUNT_WhereClause7___getit0B7_:
  172|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__NtB6_24ConditionalAndExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1685|  14.9k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsU_1__NtB6_16PropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1233|    474|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithst_1__24RECURSIVE_COUNT_QuadData7___getit0B7_:
  725|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsr_1__NtB6_11QuadPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  686|    142|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__NtB6_23ConditionalOrExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1668|  14.7k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsX_1__NtB6_23PropertyListPathElementNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1263|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsu_1__NtB6_12IriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  733|     38|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsd_1__NtB6_13UpdateVariantNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  438|  6.79k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsr_1__NtB6_11QuadPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  686|  6.31k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsY_1__NtB6_14ObjectListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1296|  11.4k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__NtB6_20RelationalExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1705|  17.2k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths11_1__23RECURSIVE_COUNT_PathElt7___getit0B7_:
 1353|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsy_1__NtB6_12TriplesBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  812|      4|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsG_1__NtB6_16InlineDataOneVarNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  940|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths3_1__NtB6_12SelectOptionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  127|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths11_1__NtB6_7PathEltNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1353|  36.2k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths4_1__NtB6_12SelectValuesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  133|     20|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__NtB6_24GroupOrUnionGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1034|      5|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths12_1__NtB6_16PathEltOrInverseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1370|    132|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths12_1__NtB6_16PathEltOrInverseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1370|  36.2k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsU_1__NtB6_16PropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1233|    663|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsR_1__NtB6_4VerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1164|     90|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__NtB6_14CollectionPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1542|     61|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__NtB6_24GroupOrUnionGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1034|      5|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__NtB6_20RelationalExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1705|    804|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__NtB6_13IriOrFunctionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1952|      3|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1n_1__31RECURSIVE_COUNT_UnaryExpression7___getit0B7_:
 1774|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__NtB6_17PrimaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1794|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithss_1__NtB6_17VarOrIriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  694|    186|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths3_1__NtB6_12SelectOptionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  127|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsn_1__NtB6_6ModifyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  612|      5|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__40RECURSIVE_COUNT_MultiplicativeExpression7___getit0B7_:
 1756|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsq_1__NtB6_11GraphRefAllNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  666|     44|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsd_1__NtB6_13UpdateVariantNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  438|      7|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__NtB6_13IriOrFunctionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1952|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__NtB6_8VarOrIriNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1607|    164|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsx_1__NtB6_30GroupGraphPatternSubOtherBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  787|  1.08k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithso_1__NtB6_14GraphOrDefaultNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  636|     15|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths6_1__NtB6_11WhereClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  172|    226|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithss_1__NtB6_17VarOrIriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  694|  15.9k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths19_1__31RECURSIVE_COUNT_TriplesNodePath7___getit0B7_:
 1497|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsy_1__NtB6_12TriplesBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  812|  1.76k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__31RECURSIVE_COUNT_PathAlternative7___getit0B7_:
 1319|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithst_1__NtB6_8QuadDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  725|    316|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsr_1__NtB6_11QuadPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  686|    142|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsw_1__NtB6_20GroupGraphPatternSubNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  780|    489|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__NtB6_15PathAlternativeNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1319|  24.0k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1o_1__NtB6_17PrimaryExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1794|    942|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsR_1__NtB6_4VerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1164|  15.9k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsp_1__NtB6_8GraphRefNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  654|     59|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths2_1__NtB6_12SelectClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  120|      9|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths13_1__23RECURSIVE_COUNT_PathMod7___getit0B7_:
 1386|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__NtB6_8VarOrIriNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1607|  33.7k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsg_1__22RECURSIVE_COUNT_Create7___getit0B7_:
  505|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__29RECURSIVE_COUNT_GraphNodePath7___getit0B7_:
 1575|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsB_1__NtB6_19LateralGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  874|    344|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__NtB6_24MultiplicativeExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1756|  29.1k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsU_1__32RECURSIVE_COUNT_PropertyListPath7___getit0B7_:
 1233|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsV_1__NtB6_24PropertyListPathNotEmptyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1249|     38|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1s_1__NtB6_13NotExistsFuncNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1940|    276|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__NtB6_15PathAlternativeNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1319|    105|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsm_1__NtB6_11DeleteWhereNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  600|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsu_1__NtB6_12IriOrLiteralNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  733|     38|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsu_1__28RECURSIVE_COUNT_IriOrLiteral7___getit0B7_:
  733|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1_1__25RECURSIVE_COUNT_SubSelect7___getit0B7_:
  101|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsb_1__NtB6_12ValuesClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  378|  1.16k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths14_1__27RECURSIVE_COUNT_PathPrimary7___getit0B7_:
 1404|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__NtB6_20BrackettedExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1816|    939|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsy_1__28RECURSIVE_COUNT_TriplesBlock7___getit0B7_:
  812|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths15_1__NtB6_22PathNegatedPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1424|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1f_1__NtB6_9VarOrTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1591|  1.19k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsx_1__NtB6_30GroupGraphPatternSubOtherBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  787|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsx_1__46RECURSIVE_COUNT_GroupGraphPatternSubOtherBlock7___getit0B7_:
  787|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths4_1__NtB6_12SelectValuesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  133|     20|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths4_1__28RECURSIVE_COUNT_SelectValues7___getit0B7_:
  133|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths12_1__NtB6_16PathEltOrInverseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1370|    132|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths12_1__32RECURSIVE_COUNT_PathEltOrInverse7___getit0B7_:
 1370|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsH_1__NtB6_14DataBlockValueNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1004|  1.90k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths2_1__NtB6_12SelectClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  120|      9|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1_1__NtB6_9SubSelectNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  101|  3.13k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__NtB6_14CollectionPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1542|  1.50k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsc_1__NtB6_13UpdateContentNtCs9EteCURj6Wn_9arbitrary9Arbitrary19arbitrary_take_rests_0B6_:
  398|  3.51k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsk_1__NtB6_10InsertDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  576|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsT_1__NtB6_22TriplesSameSubjectPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1201|      4|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths7_1__NtB6_16SolutionModifierNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  188|  1.15k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsp_1__NtB6_8GraphRefNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  654|  1.33k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsn_1__22RECURSIVE_COUNT_Modify7___getit0B7_:
  612|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsl_1__NtB6_10DeleteDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  588|     75|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__NtB6_20RelationalExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1705|    798|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1k_1__36RECURSIVE_COUNT_RelationalExpression7___getit0B7_:
 1705|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithss_1__33RECURSIVE_COUNT_VarOrIriOrLiteral7___getit0B7_:
  694|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsq_1__NtB6_11GraphRefAllNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  666|     44|#[derive(Arbitrary)]
_RNCNCNvXsG_Cs6Lc7YXa2Vl_12sparql_smithNtB9_14InlineDataFullNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary00B9_:
  973|  4.65k|                |u| {
  974|  4.65k|                    row.push(u.arbitrary()?);
  975|  4.65k|                    Ok(ControlFlow::Continue(()))
  976|  4.65k|                },
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsY_1__NtB6_14ObjectListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1296|    978|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1q_1__NtB6_11BuiltInCallNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1828|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsR_1__NtB6_4VerbNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1164|     90|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1g_1__24RECURSIVE_COUNT_VarOrIri7___getit0B7_:
 1607|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1j_1__NtB6_24ConditionalAndExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1685|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__NtB6_9GraphTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1646|      4|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithso_1__30RECURSIVE_COUNT_GraphOrDefault7___getit0B7_:
  636|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithst_1__NtB6_8QuadDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  725|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsO_1__NtB6_14ExpressionListNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1118|  6.70k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__25RECURSIVE_COUNT_GraphTerm7___getit0B7_:
 1646|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsm_1__NtB6_11DeleteWhereNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  600|    377|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths13_1__NtB6_7PathModNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1386|  10.0k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsz_1__NtB6_22GraphPatternNotTriplesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  832|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsz_1__38RECURSIVE_COUNT_GraphPatternNotTriples7___getit0B7_:
  832|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__34RECURSIVE_COUNT_AdditiveExpression7___getit0B7_:
 1738|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths2_1__NtB6_12SelectClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  120|  3.13k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsY_1__NtB6_14ObjectListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1296|    978|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths5_1__NtB6_16SelectProjectionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  142|  2.62k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths14_1__NtB6_11PathPrimaryNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1404|    332|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths16_1__NtB6_20PathOneInPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1449|     40|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths11_1__NtB6_7PathEltNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1353|    332|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1i_1__NtB6_23ConditionalOrExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1668|    805|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths5_1__NtB6_16SelectProjectionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  142|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths5_1__32RECURSIVE_COUNT_SelectProjection7___getit0B7_:
  142|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__NtB6_18AdditiveExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1738|  19.4k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsi_1__NtB6_4MoveNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  540|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsH_1__NtB6_14DataBlockValueNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1004|  1.90k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__NtB6_20BrackettedExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1816|  7.35k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths14_1__NtB6_11PathPrimaryNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1404|  36.2k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsV_1__40RECURSIVE_COUNT_PropertyListPathNotEmpty7___getit0B7_:
 1249|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsp_1__24RECURSIVE_COUNT_GraphRef7___getit0B7_:
  654|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsh_1__NtB6_3AddNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  522|    327|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__NtB6_13GraphNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1575|  18.2k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths10_1__28RECURSIVE_COUNT_PathSequence7___getit0B7_:
 1336|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths7_1__NtB6_16SolutionModifierNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  188|  1.15k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsw_1__NtB6_20GroupGraphPatternSubNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  780|    489|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsw_1__36RECURSIVE_COUNT_GroupGraphPatternSub7___getit0B7_:
  780|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsb_1__28RECURSIVE_COUNT_ValuesClause7___getit0B7_:
  378|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths15_1__NtB6_22PathNegatedPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1424|      2|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsB_1__35RECURSIVE_COUNT_LateralGraphPattern7___getit0B7_:
  874|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths15_1__38RECURSIVE_COUNT_PathNegatedPropertySet7___getit0B7_:
 1424|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithse_1__NtB6_5ClearNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  471|     35|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__NtB6_25BlankNodePropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1513|  9.88k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsz_1__NtB6_22GraphPatternNotTriplesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  832|  1.08k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths19_1__NtB6_15TriplesNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1497|      6|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsV_1__NtB6_24PropertyListPathNotEmptyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1249|  11.0k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__NtB6_24GroupOrUnionGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1034|    155|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1l_1__NtB6_18AdditiveExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1738|    954|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1h_1__NtB6_9GraphTermNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1646|      4|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsZ_1__NtB6_15PathAlternativeNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1319|    105|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths16_1__NtB6_20PathOneInPropertySetNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
 1449|  8.84k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithst_1__NtB6_8QuadDataNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  725|      3|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsA_1__NtB6_20OptionalGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  862|    263|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsk_1__26RECURSIVE_COUNT_InsertData7___getit0B7_:
  576|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths5_1__NtB6_16SelectProjectionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  142|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1c_1__NtB6_14CollectionPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1542|     61|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsa_1__NtB6_12HavingClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  262|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsj_1__NtB6_4CopyNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  558|    130|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths10_1__NtB6_12PathSequenceNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1336|    106|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths4_1__NtB6_12SelectValuesNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  133|  3.13k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsg_1__NtB6_6CreateNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  505|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__41RECURSIVE_COUNT_BlankNodePropertyListPath7___getit0B7_:
 1513|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsa_1__NtB6_12HavingClauseNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  262|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1e_1__NtB6_13GraphNodePathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1575|  1.04k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsg_1__NtB6_6CreateNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  505|    307|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1p_1__36RECURSIVE_COUNT_BrackettedExpression7___getit0B7_:
 1816|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsO_1__NtB6_14ExpressionListNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1118|     75|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsO_1__30RECURSIVE_COUNT_ExpressionList7___getit0B7_:
 1118|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsv_1__NtB6_17GroupGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  762|    462|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths14_1__NtB6_11PathPrimaryNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1404|    332|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths7_1__NtB6_16SolutionModifierNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  188|  1.74k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsD_1__NtB6_4BindNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  899|      6|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsv_1__NtB6_17GroupGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  762|  6.61k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsG_1__32RECURSIVE_COUNT_InlineDataOneVar7___getit0B7_:
  940|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsi_1__20RECURSIVE_COUNT_Move7___getit0B7_:
  540|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths13_1__NtB6_7PathModNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1386|     22|#[derive(Arbitrary)]
_RNCNvXsG_Cs6Lc7YXa2Vl_12sparql_smithNtB7_14InlineDataFullNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B7_:
  968|    278|        u.arbitrary_loop(Some(0), Some(3), |u| {
  969|    278|            let mut row = Vec::with_capacity(vars.len());
  970|    278|            u.arbitrary_loop(
  971|    278|                Some(vars.len().try_into().unwrap()),
  972|    278|                Some(vars.len().try_into().unwrap()),
  973|    278|                |u| {
  974|       |                    row.push(u.arbitrary()?);
  975|       |                    Ok(ControlFlow::Continue(()))
  976|    278|                },
  977|    278|            )?;
  978|    278|            values.push(row);
  979|    278|            Ok(ControlFlow::Continue(()))
  980|    278|        })?;
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsJ_1__40RECURSIVE_COUNT_GroupOrUnionGraphPattern7___getit0B7_:
 1034|      1|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsX_1__39RECURSIVE_COUNT_PropertyListPathElement7___getit0B7_:
 1263|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithse_1__NtB6_5ClearNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  471|  1.42k|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smithsW_1__44RECURSIVE_COUNT_PropertyListPathNotEmptyVerb7___getit0B7_:
 1257|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths3_1__NtB6_12SelectOptionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  127|  2.19k|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsO_1__NtB6_14ExpressionListNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1118|     75|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths3_1__28RECURSIVE_COUNT_SelectOption7___getit0B7_:
  127|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1m_1__NtB6_24MultiplicativeExpressionNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
 1756|    798|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsv_1__NtB6_17GroupGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys0_0B6_:
  762|    462|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsF_1__NtB6_9DataBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  924|    246|#[derive(Arbitrary)]
_RNCNvNvNvCs6Lc7YXa2Vl_12sparql_smiths1t_1__29RECURSIVE_COUNT_IriOrFunction7___getit0B7_:
 1952|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smiths1a_1__NtB6_25BlankNodePropertyListPathNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
 1513|     11|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsm_1__NtB6_11DeleteWhereNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  600|      2|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsg_1__NtB6_6CreateNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  505|      1|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsC_1__NtB6_17GraphGraphPatternNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  886|     95|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsy_1__NtB6_12TriplesBlockNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrary0B6_:
  812|      4|#[derive(Arbitrary)]
_RNCNvXNvCs6Lc7YXa2Vl_12sparql_smithsf_1__NtB6_4DropNtCs9EteCURj6Wn_9arbitrary9Arbitrary9arbitrarys_0B6_:
  488|    259|#[derive(Arbitrary)]

