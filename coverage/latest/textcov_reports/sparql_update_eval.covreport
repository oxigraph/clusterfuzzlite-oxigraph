LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_ZN7rocksdb8CacheKeyC2Ev:
   37|      2|  inline CacheKey() : file_num_etc64_(), offset_etc64_() {}
_ZN7rocksdb18OffsetableCacheKeyC2Ev:
   86|      2|  inline OffsetableCacheKey() : CacheKey() {}

_ZN7rocksdb20FullTypedCacheHelperINS_21ParsedFullFilterBlockENS_18BlockCreateContextELNS_14CacheEntryRoleE1EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_21ParsedFullFilterBlockELNS_14CacheEntryRoleE1EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_17UncompressionDictENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_17UncompressionDictELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_11Block_kDataENS_18BlockCreateContextELNS_14CacheEntryRoleE0EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_11Block_kDataELNS_14CacheEntryRoleE0EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_12Block_kIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE4EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_12Block_kIndexELNS_14CacheEntryRoleE4EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_27Block_kFilterPartitionIndexENS_18BlockCreateContextELNS_14CacheEntryRoleE2EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_27Block_kFilterPartitionIndexELNS_14CacheEntryRoleE2EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }
_ZN7rocksdb20FullTypedCacheHelperINS_20Block_kRangeDeletionENS_18BlockCreateContextELNS_14CacheEntryRoleE5EE13GetFullHelperEv:
  261|      2|  static const Cache::CacheItemHelper* GetFullHelper() {
  262|      2|    static const Cache::CacheItemHelper kHelper{
  263|      2|        kRole,
  264|      2|        &FullTypedCacheHelper::Delete,
  265|      2|        &FullTypedCacheHelper::Size,
  266|      2|        &FullTypedCacheHelper::SaveTo,
  267|      2|        &FullTypedCacheHelper::Create,
  268|      2|        BasicTypedCacheHelper<TValue, kRole>::GetBasicHelper()};
  269|      2|    return &kHelper;
  270|      2|  }
_ZN7rocksdb21BasicTypedCacheHelperINS_20Block_kRangeDeletionELNS_14CacheEntryRoleE5EE14GetBasicHelperEv:
  134|      4|  static const Cache::CacheItemHelper* GetBasicHelper() {
  135|      4|    static const Cache::CacheItemHelper kHelper{kRole,
  136|      4|                                                &BasicTypedCacheHelper::Delete};
  137|      4|    return &kHelper;
  138|      4|  }

_ZN7rocksdb19PackSequenceAndTypeEmNS_9ValueTypeE:
  179|    310|inline uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  180|    310|  assert(seq <= kMaxSequenceNumber);
  181|       |  // kTypeMaxValid is used in TruncatedRangeDelIterator, see its constructor.
  182|    310|  assert(IsExtendedValueType(t) || t == kTypeMaxValid);
  183|    310|  return (seq << 8) | t;
  184|    310|}

_ZN7rocksdb29WriteStallCauseToHyphenStringENS_15WriteStallCauseE:
   14|      2|const std::string& WriteStallCauseToHyphenString(WriteStallCause cause) {
   15|      2|  static const std::string kMemtableLimit = "memtable-limit";
   16|      2|  static const std::string kL0FileCountLimit = "l0-file-count-limit";
   17|      2|  static const std::string kPendingCompactionBytes = "pending-compaction-bytes";
   18|      2|  static const std::string kWriteBufferManagerLimit =
   19|      2|      "write-buffer-manager-limit";
   20|      2|  switch (cause) {
   21|      0|    case WriteStallCause::kMemtableLimit:
  ------------------
  |  Branch (21:5): [True: 0, False: 2]
  ------------------
   22|      0|      return kMemtableLimit;
   23|      0|    case WriteStallCause::kL0FileCountLimit:
  ------------------
  |  Branch (23:5): [True: 0, False: 2]
  ------------------
   24|      0|      return kL0FileCountLimit;
   25|      0|    case WriteStallCause::kPendingCompactionBytes:
  ------------------
  |  Branch (25:5): [True: 0, False: 2]
  ------------------
   26|      0|      return kPendingCompactionBytes;
   27|      2|    case WriteStallCause::kWriteBufferManagerLimit:
  ------------------
  |  Branch (27:5): [True: 2, False: 0]
  ------------------
   28|      2|      return kWriteBufferManagerLimit;
   29|      0|    default:
  ------------------
  |  Branch (29:5): [True: 0, False: 2]
  ------------------
   30|      0|      break;
   31|      2|  }
   32|      0|  return InvalidWriteStallHyphenString();
   33|      2|}
_ZN7rocksdb33WriteStallConditionToHyphenStringENS_19WriteStallConditionE:
   36|      2|    WriteStallCondition condition) {
   37|      2|  static const std::string kDelayed = "delays";
   38|      2|  static const std::string kStopped = "stops";
   39|      2|  switch (condition) {
   40|      0|    case WriteStallCondition::kDelayed:
  ------------------
  |  Branch (40:5): [True: 0, False: 2]
  ------------------
   41|      0|      return kDelayed;
   42|      2|    case WriteStallCondition::kStopped:
  ------------------
  |  Branch (42:5): [True: 2, False: 0]
  ------------------
   43|      2|      return kStopped;
   44|      0|    default:
  ------------------
  |  Branch (44:5): [True: 0, False: 2]
  ------------------
   45|      0|      break;
   46|      2|  }
   47|      0|  return InvalidWriteStallHyphenString();
   48|      2|}
_ZN7rocksdb24isCFScopeWriteStallCauseENS_15WriteStallCauseE:
  110|      2|bool isCFScopeWriteStallCause(WriteStallCause cause) {
  111|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  112|      2|  uint32_t lower_bound =
  113|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  114|      2|      kNumCFScopeWriteStallCauses;
  115|      2|  uint32_t upper_bound =
  116|      2|      static_cast<uint32_t>(WriteStallCause::kCFScopeWriteStallCauseEnumMax) -
  117|      2|      1;
  118|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (118:10): [True: 2, False: 0]
  |  Branch (118:38): [True: 0, False: 2]
  ------------------
  119|      2|}
_ZN7rocksdb24isDBScopeWriteStallCauseENS_15WriteStallCauseE:
  121|      2|bool isDBScopeWriteStallCause(WriteStallCause cause) {
  122|      2|  uint32_t int_cause = static_cast<uint32_t>(cause);
  123|      2|  uint32_t lower_bound =
  124|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  125|      2|      kNumDBScopeWriteStallCauses;
  126|      2|  uint32_t upper_bound =
  127|      2|      static_cast<uint32_t>(WriteStallCause::kDBScopeWriteStallCauseEnumMax) -
  128|      2|      1;
  129|      2|  return lower_bound <= int_cause && int_cause <= upper_bound;
  ------------------
  |  Branch (129:10): [True: 2, False: 0]
  |  Branch (129:38): [True: 2, False: 0]
  ------------------
  130|      2|}
_ZN7rocksdb22WriteStallStatsMapKeys19CauseConditionCountENS_15WriteStallCauseENS_19WriteStallConditionE:
  157|      2|    WriteStallCause cause, WriteStallCondition condition) {
  158|      2|  std::string cause_condition_count_name;
  159|       |
  160|      2|  std::string cause_name;
  161|      2|  if (isCFScopeWriteStallCause(cause) || isDBScopeWriteStallCause(cause)) {
  ------------------
  |  Branch (161:7): [True: 0, False: 2]
  |  Branch (161:42): [True: 2, False: 0]
  ------------------
  162|      2|    cause_name = WriteStallCauseToHyphenString(cause);
  163|      2|  } else {
  164|      0|    assert(false);
  165|      0|    return "";
  166|      0|  }
  167|       |
  168|      2|  const std::string& condition_name =
  169|      2|      WriteStallConditionToHyphenString(condition);
  170|       |
  171|      2|  cause_condition_count_name.reserve(cause_name.size() + 1 +
  172|      2|                                     condition_name.size());
  173|      2|  cause_condition_count_name.append(cause_name);
  174|      2|  cause_condition_count_name.append("-");
  175|      2|  cause_condition_count_name.append(condition_name);
  176|       |
  177|      2|  return cause_condition_count_name;
  178|      2|}

_ZN7rocksdb11WriteThread17AdaptationContextC2EPKc:
  290|     10|    explicit AdaptationContext(const char* name0) : name(name0), value(0) {}

_ZN7rocksdb21LogicalBlockSizeCacheC2ENSt3__18functionIFmiEEENS2_IFNS_6StatusERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPmEEE:
  177|      2|      : get_logical_block_size_of_fd_(get_logical_block_size_of_fd),
  178|      2|        get_logical_block_size_of_directory_(
  179|      2|            get_logical_block_size_of_directory) {}

_ZN7rocksdb5Cache15CacheItemHelperC2Ev:
  151|      2|    CacheItemHelper() : CacheItemHelper(CacheEntryRole::kMisc) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEE:
  155|     16|        : CacheItemHelper(_role, _del_cb, nullptr, nullptr, nullptr, this) {}
_ZN7rocksdb5Cache15CacheItemHelperC2ENS_14CacheEntryRoleEPFvPvPNS_15MemoryAllocatorEEPFmS3_EPFNS_6StatusES3_mmPcEPFSA_RKNS_5SliceENS_15CompressionTypeENS_9CacheTierEPNS0_13CreateContextES5_PS3_PmEPKS1_:
  162|     30|        : del_cb(_del_cb),
  163|     30|          size_cb(_size_cb),
  164|     30|          saveto_cb(_saveto_cb),
  165|     30|          create_cb(_create_cb),
  166|     30|          role(_role),
  167|     30|          without_secondary_compat(_without_secondary_compat) {
  168|       |      // Either all three secondary cache callbacks are non-nullptr or
  169|       |      // all three are nullptr
  170|     30|      assert((size_cb != nullptr) == (saveto_cb != nullptr));
  171|     30|      assert((size_cb != nullptr) == (create_cb != nullptr));
  172|       |      // without_secondary_compat points to equivalent but without
  173|       |      // secondary support
  174|     30|      assert(role == without_secondary_compat->role);
  175|     30|      assert(del_cb == without_secondary_compat->del_cb);
  176|     30|      assert(!without_secondary_compat->IsSecondaryCacheCompatible());
  177|     30|    }

_ZN7rocksdb10FileSystem4TypeEv:
  301|      2|  static const char* Type() { return "FileSystem"; }

_ZN7rocksdb5SliceC2Ev:
   35|      2|  Slice() : data_(""), size_(0) {}

_ZN7rocksdb13ObjectLibrary5EntryD2Ev:
   48|      2|    virtual ~Entry() {}
_ZN7rocksdb13ObjectLibrary12PatternEntryC2ERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
   95|      2|        : name_(name), optional_(optional), slength_(0) {
   96|      2|      nlength_ = name_.size();
   97|      2|    }
_ZN7rocksdb13ObjectLibrary12PatternEntry12AddSeparatorERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb:
  114|      2|                               bool at_least_one = true) {
  115|      2|      slength_ += separator.size();
  116|      2|      if (at_least_one) {
  ------------------
  |  Branch (116:11): [True: 0, False: 2]
  ------------------
  117|      0|        separators_.emplace_back(separator, kMatchAtLeastOne);
  118|      0|        ++slength_;
  119|      2|      } else {
  120|      2|        separators_.emplace_back(separator, kMatchZeroOrMore);
  121|      2|      }
  122|      2|      return *this;
  123|      2|    }
_ZN7rocksdb13ObjectLibraryC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  192|      2|  explicit ObjectLibrary(const std::string& id) { id_ = id; }
_ZN7rocksdb13ObjectLibrary15AddFactoryEntryEPKcONSt3__110unique_ptrINS0_5EntryENS3_14default_deleteIS5_EEEE:
  268|      2|  void AddFactoryEntry(const char* type, std::unique_ptr<Entry>&& entry) {
  269|      2|    std::unique_lock<std::mutex> lock(mu_);
  270|      2|    auto& factories = factories_[type];
  271|      2|    factories.emplace_back(std::move(entry));
  272|      2|  }
_ZN7rocksdb13ObjectLibrary12FactoryEntryINS_10FileSystemEEC2EPNS0_5EntryENSt3__18functionIFPS2_RKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEPNS6_10unique_ptrIS2_NS6_14default_deleteIS2_EEEEPSE_EEE:
  174|      2|        : entry_(e), factory_(std::move(f)) {}
_ZN7rocksdb13ObjectLibrary10AddFactoryINS_10FileSystemEEERKNSt3__18functionIFPT_RKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPNS3_10unique_ptrIS5_NS3_14default_deleteIS5_EEEEPSC_EEERKNS0_12PatternEntryESO_:
  252|      2|                                   const FactoryFunc<T>& func) {
  253|      2|    std::unique_ptr<Entry> factory(
  254|      2|        new FactoryEntry<T>(new PatternEntry(entry), func));
  255|      2|    AddFactoryEntry(T::Type(), std::move(factory));
  256|      2|    return func;
  257|      2|  }

_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11SystemClockEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdborERKNS_15OptionTypeFlagsES2_:
  116|     88|                                 const OptionTypeFlags& b) {
  117|     88|  return static_cast<OptionTypeFlags>(static_cast<uint32_t>(a) |
  118|     88|                                      static_cast<uint32_t>(b));
  119|     88|}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  256|    772|      : offset_(offset),
  257|    772|        parse_func_(nullptr),
  258|    772|        serialize_func_(nullptr),
  259|    772|        equals_func_(nullptr),
  260|    772|        type_(type),
  261|    772|        verification_(verification),
  262|    772|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo12SetParseFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEESE_PvEEE:
  591|    116|  OptionTypeInfo& SetParseFunc(const ParseFunc& f) {
  592|    116|    parse_func_ = f;
  593|    116|    return *this;
  594|    116|  }
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeE:
  246|     16|      : offset_(offset),
  247|     16|        parse_func_(nullptr),
  248|     16|        serialize_func_(nullptr),
  249|     16|        equals_func_(nullptr),
  250|     16|        type_(type),
  251|     16|        verification_(OptionVerificationType::kNormal),
  252|     16|        flags_(OptionTypeFlags::kNone) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEE:
  267|     20|      : offset_(offset),
  268|     20|        parse_func_(parse_func),
  269|     20|        serialize_func_(nullptr),
  270|     20|        equals_func_(nullptr),
  271|     20|        type_(type),
  272|     20|        verification_(verification),
  273|     20|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfoC2EiNS_10OptionTypeENS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESH_PvEEERKNS5_IFS6_S9_SH_PKvPSF_EEERKNS5_IFbS9_SH_SO_SO_SP_EEE:
  280|     20|      : offset_(offset),
  281|     20|        parse_func_(parse_func),
  282|     20|        serialize_func_(serialize_func),
  283|     20|        equals_func_(equals_func),
  284|     20|        type_(type),
  285|     20|        verification_(verification),
  286|     20|        flags_(flags) {}
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  374|     18|      int offset, OptionVerificationType verification, OptionTypeFlags flags) {
  375|     18|    OptionTypeInfo info(offset, OptionType::kStruct, verification, flags);
  376|     18|    info.SetParseFunc(
  377|       |        // Parses the struct and updates the fields at addr
  378|     18|        [struct_name, struct_map](const ConfigOptions& opts,
  379|     18|                                  const std::string& name,
  380|     18|                                  const std::string& value, void* addr) {
  381|     18|          return ParseStruct(opts, struct_name, struct_map, name, value, addr);
  382|     18|        });
  383|     18|    info.SetSerializeFunc(
  384|       |        // Serializes the struct options into value
  385|     18|        [struct_name, struct_map](const ConfigOptions& opts,
  386|     18|                                  const std::string& name, const void* addr,
  387|     18|                                  std::string* value) {
  388|     18|          return SerializeStruct(opts, struct_name, struct_map, name, addr,
  389|     18|                                 value);
  390|     18|        });
  391|     18|    info.SetEqualsFunc(
  392|       |        // Compares the struct fields of addr1 and addr2 for equality
  393|     18|        [struct_name, struct_map](const ConfigOptions& opts,
  394|     18|                                  const std::string& name, const void* addr1,
  395|     18|                                  const void* addr2, std::string* mismatch) {
  396|     18|          return StructsAreEqual(opts, struct_name, struct_map, name, addr1,
  397|     18|                                 addr2, mismatch);
  398|     18|        });
  399|     18|    return info;
  400|     18|  }
_ZN7rocksdb14OptionTypeInfo6StructERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKNS1_13unordered_mapIS7_S0_NS1_4hashIS7_EENS1_8equal_toIS7_EENS5_INS1_4pairIS8_S0_EEEEEEiNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKNS1_8functionIFNS_6StatusERKNS_13ConfigOptionsES9_S9_PvEEE:
  405|      4|      const ParseFunc& parse_func) {
  406|      4|    OptionTypeInfo info(
  407|      4|        Struct(struct_name, struct_map, offset, verification, flags));
  408|      4|    return info.SetParseFunc(parse_func);
  409|      4|  }
_ZN7rocksdb14OptionTypeInfo16SetSerializeFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvPSC_EEE:
  596|     60|  OptionTypeInfo& SetSerializeFunc(const SerializeFunc& f) {
  597|     60|    serialize_func_ = f;
  598|     60|    return *this;
  599|     60|  }
_ZN7rocksdb14OptionTypeInfo13SetEqualsFuncERKNSt3__18functionIFbRKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvSF_PSB_EEE:
  600|     60|  OptionTypeInfo& SetEqualsFunc(const EqualsFunc& f) {
  601|     60|    equals_func_ = f;
  602|     60|    return *this;
  603|     60|  }
_ZN7rocksdb14OptionTypeInfo14SetPrepareFuncERKNSt3__18functionIFNS_6StatusERKNS_13ConfigOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPvEEE:
  605|      4|  OptionTypeInfo& SetPrepareFunc(const PrepareFunc& f) {
  606|      4|    prepare_func_ = f;
  607|      4|    return *this;
  608|      4|  }
_ZN7rocksdb14OptionTypeInfo15SetValidateFuncERKNSt3__18functionIFNS_6StatusERKNS_9DBOptionsERKNS_19ColumnFamilyOptionsERKNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPKvEEE:
  610|      4|  OptionTypeInfo& SetValidateFunc(const ValidateFunc& f) {
  611|      4|    validate_func_ = f;
  612|      4|    return *this;
  613|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10FileSystemEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_10StatisticsEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdb14OptionTypeInfo6VectorINS_18FileTemperatureAgeEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorIiEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_14SliceTransformEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_20PrepopulateBlobCacheEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorINS_15CompressionTypeEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_10ComparatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  564|      2|                                       OptionTypeFlags flags) {
  565|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  566|      2|                        flags | OptionTypeFlags::kRawPointer);
  567|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  568|      2|                                const std::string& name,
  569|      2|                                const std::string& value, void* addr) {
  570|      2|      auto** pointer = static_cast<T**>(addr);
  571|      2|      if (name == kIdPropName() && value.empty()) {
  572|      2|        *pointer = nullptr;
  573|      2|        return Status::OK();
  574|      2|      } else {
  575|      2|        return T::CreateFromString(opts, value, pointer);
  576|      2|      }
  577|      2|    });
  578|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_12TableFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_31TablePropertiesCollectorFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__110shared_ptrINS_31TablePropertiesCollectorFactoryEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrIKNS_16CompactionFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  564|      4|                                       OptionTypeFlags flags) {
  565|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  566|      4|                        flags | OptionTypeFlags::kRawPointer);
  567|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  568|      4|                                const std::string& name,
  569|      4|                                const std::string& value, void* addr) {
  570|      4|      auto** pointer = static_cast<T**>(addr);
  571|      4|      if (name == kIdPropName() && value.empty()) {
  572|      4|        *pointer = nullptr;
  573|      4|        return Status::OK();
  574|      4|      } else {
  575|      4|        return T::CreateFromString(opts, value, pointer);
  576|      4|      }
  577|      4|    });
  578|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23CompactionFilterFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_13MergeOperatorEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      4|                                          OptionTypeFlags flags) {
  486|      4|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      4|                        flags | OptionTypeFlags::kShared);
  488|      4|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      4|                                const std::string& name,
  490|      4|                                const std::string& value, void* addr) {
  491|      4|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      4|      if (name == kIdPropName() && value.empty()) {
  493|      4|        shared->reset();
  494|      4|        return Status::OK();
  495|      4|      } else {
  496|      4|        return T::CreateFromString(opts, value, shared);
  497|      4|      }
  498|      4|    });
  499|      4|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_21SstPartitionerFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo14AsCustomRawPtrINS_9WalFilterEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  564|      2|                                       OptionTypeFlags flags) {
  565|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  566|      2|                        flags | OptionTypeFlags::kRawPointer);
  567|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  568|      2|                                const std::string& name,
  569|      2|                                const std::string& value, void* addr) {
  570|      2|      auto** pointer = static_cast<T**>(addr);
  571|      2|      if (name == kIdPropName() && value.empty()) {
  572|      2|        *pointer = nullptr;
  573|      2|        return Status::OK();
  574|      2|      } else {
  575|      2|        return T::CreateFromString(opts, value, pointer);
  576|      2|      }
  577|      2|    });
  578|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_15WALRecoveryModeEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumIbEES0_iPKNSt3__113unordered_mapINS2_12basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEET_NS2_4hashIS9_EENS2_8equal_toIS9_EENS7_INS2_4pairIKS9_SA_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_12InfoLogLevelEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_22FileChecksumGenFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_9CacheTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_11PinningTierEEES0_iPKNSt3__113unordered_mapINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEET_NS3_4hashISA_EENS3_8equal_toISA_EENS8_INS3_4pairIKSA_SB_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      6|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      6|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      6|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      6|        [map](const ConfigOptions&, const std::string& name,
  312|      6|              const std::string& value, void* addr) {
  313|      6|          if (map == nullptr) {
  314|      6|            return Status::NotSupported("No enum mapping ", name);
  315|      6|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      6|            return Status::OK();
  317|      6|          } else {
  318|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      6|          }
  320|      6|        });
  321|      6|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      6|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      6|              std::string* value) {
  329|      6|          if (map == nullptr) {
  330|      6|            return Status::NotSupported("No enum mapping ", name);
  331|      6|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      6|                                      value)) {
  333|      6|            return Status::OK();
  334|      6|          } else {
  335|      6|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      6|          }
  337|      6|        });
  338|      6|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      6|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      6|           const void* addr2, std::string*) {
  343|      6|          return (*static_cast<const T*>(addr1) ==
  344|      6|                  *static_cast<const T*>(addr2));
  345|      6|        });
  346|      6|    return info;
  347|      6|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_23FlushBlockPolicyFactoryEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions9IndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions18DataBlockIndexTypeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions19IndexShorteningModeEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrIKNS_12FilterPolicyEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo4EnumINS_22BlockBasedTableOptions21PrepopulateBlockCacheEEES0_iPKNSt3__113unordered_mapINS4_12basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEET_NS4_4hashISB_EENS4_8equal_toISB_EENS9_INS4_4pairIKSB_SC_EEEEEENS_15OptionTypeFlagsENS_22OptionVerificationTypeE:
  303|      2|      OptionVerificationType verification = OptionVerificationType::kNormal) {
  304|      2|    OptionTypeInfo info(offset, OptionType::kEnum, verification, flags);
  305|      2|    info.SetParseFunc(
  306|       |        // Uses the map argument to convert the input string into
  307|       |        // its corresponding enum value.  If value is found in the map,
  308|       |        // addr is updated to the corresponding map entry.
  309|       |        // @return OK if the value is found in the map
  310|       |        // @return InvalidArgument if the value is not found in the map
  311|      2|        [map](const ConfigOptions&, const std::string& name,
  312|      2|              const std::string& value, void* addr) {
  313|      2|          if (map == nullptr) {
  314|      2|            return Status::NotSupported("No enum mapping ", name);
  315|      2|          } else if (ParseEnum<T>(*map, value, static_cast<T*>(addr))) {
  316|      2|            return Status::OK();
  317|      2|          } else {
  318|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  319|      2|          }
  320|      2|        });
  321|      2|    info.SetSerializeFunc(
  322|       |        // Uses the map argument to convert the input enum into
  323|       |        // its corresponding string value.  If enum value is found in the map,
  324|       |        // value is updated to the corresponding string value in the map.
  325|       |        // @return OK if the enum is found in the map
  326|       |        // @return InvalidArgument if the enum is not found in the map
  327|      2|        [map](const ConfigOptions&, const std::string& name, const void* addr,
  328|      2|              std::string* value) {
  329|      2|          if (map == nullptr) {
  330|      2|            return Status::NotSupported("No enum mapping ", name);
  331|      2|          } else if (SerializeEnum<T>(*map, (*static_cast<const T*>(addr)),
  332|      2|                                      value)) {
  333|      2|            return Status::OK();
  334|      2|          } else {
  335|      2|            return Status::InvalidArgument("No mapping for enum ", name);
  336|      2|          }
  337|      2|        });
  338|      2|    info.SetEqualsFunc(
  339|       |        // Casts addr1 and addr2 to the enum type and returns true if
  340|       |        // they are equal, false otherwise.
  341|      2|        [](const ConfigOptions&, const std::string&, const void* addr1,
  342|      2|           const void* addr2, std::string*) {
  343|      2|          return (*static_cast<const T*>(addr1) ==
  344|      2|                  *static_cast<const T*>(addr2));
  345|      2|        });
  346|      2|    return info;
  347|      2|  }  // End OptionTypeInfo::Enum
_ZN7rocksdb14OptionTypeInfo6VectorImEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo5ArrayImLm2EEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  415|      2|                              char separator = ':') {
  416|      2|    OptionTypeInfo info(_offset, OptionType::kArray, _verification, _flags);
  417|      2|    info.SetParseFunc([elem_info, separator](
  418|      2|                          const ConfigOptions& opts, const std::string& name,
  419|      2|                          const std::string& value, void* addr) {
  420|      2|      auto result = static_cast<std::array<T, kSize>*>(addr);
  421|      2|      return ParseArray<T, kSize>(opts, elem_info, separator, name, value,
  422|      2|                                  result);
  423|      2|    });
  424|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  425|      2|                                                 const std::string& name,
  426|      2|                                                 const void* addr,
  427|      2|                                                 std::string* value) {
  428|      2|      const auto& array = *(static_cast<const std::array<T, kSize>*>(addr));
  429|      2|      return SerializeArray<T, kSize>(opts, elem_info, separator, name, array,
  430|      2|                                      value);
  431|      2|    });
  432|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  433|      2|                                   const std::string& name, const void* addr1,
  434|      2|                                   const void* addr2, std::string* mismatch) {
  435|      2|      const auto& array1 = *(static_cast<const std::array<T, kSize>*>(addr1));
  436|      2|      const auto& array2 = *(static_cast<const std::array<T, kSize>*>(addr2));
  437|      2|      return ArraysAreEqual<T, kSize>(opts, elem_info, name, array1, array2,
  438|      2|                                      mismatch);
  439|      2|    });
  440|      2|    return info;
  441|      2|  }
_ZN7rocksdb14OptionTypeInfo6VectorINS_27CompactionServiceOutputFileEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsERKS0_c:
  448|      2|                               char separator = ':') {
  449|      2|    OptionTypeInfo info(_offset, OptionType::kVector, _verification, _flags);
  450|      2|    info.SetParseFunc([elem_info, separator](
  451|      2|                          const ConfigOptions& opts, const std::string& name,
  452|      2|                          const std::string& value, void* addr) {
  453|      2|      auto result = static_cast<std::vector<T>*>(addr);
  454|      2|      return ParseVector<T>(opts, elem_info, separator, name, value, result);
  455|      2|    });
  456|      2|    info.SetSerializeFunc([elem_info, separator](const ConfigOptions& opts,
  457|      2|                                                 const std::string& name,
  458|      2|                                                 const void* addr,
  459|      2|                                                 std::string* value) {
  460|      2|      const auto& vec = *(static_cast<const std::vector<T>*>(addr));
  461|      2|      return SerializeVector<T>(opts, elem_info, separator, name, vec, value);
  462|      2|    });
  463|      2|    info.SetEqualsFunc([elem_info](const ConfigOptions& opts,
  464|      2|                                   const std::string& name, const void* addr1,
  465|      2|                                   const void* addr2, std::string* mismatch) {
  466|      2|      const auto& vec1 = *(static_cast<const std::vector<T>*>(addr1));
  467|      2|      const auto& vec2 = *(static_cast<const std::vector<T>*>(addr2));
  468|      2|      return VectorsAreEqual<T>(opts, elem_info, name, vec1, vec2, mismatch);
  469|      2|    });
  470|      2|    return info;
  471|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_18EncryptionProviderEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }
_ZN7rocksdb14OptionTypeInfo17AsCustomSharedPtrINS_11BlockCipherEEES0_iNS_22OptionVerificationTypeENS_15OptionTypeFlagsE:
  485|      2|                                          OptionTypeFlags flags) {
  486|      2|    OptionTypeInfo info(offset, OptionType::kCustomizable, ovt,
  487|      2|                        flags | OptionTypeFlags::kShared);
  488|      2|    return info.SetParseFunc([](const ConfigOptions& opts,
  489|      2|                                const std::string& name,
  490|      2|                                const std::string& value, void* addr) {
  491|      2|      auto* shared = static_cast<std::shared_ptr<T>*>(addr);
  492|      2|      if (name == kIdPropName() && value.empty()) {
  493|      2|        shared->reset();
  494|      2|        return Status::OK();
  495|      2|      } else {
  496|      2|        return T::CreateFromString(opts, value, shared);
  497|      2|      }
  498|      2|    });
  499|      2|  }

_ZN7rocksdb21HistogramBucketMapperC2Ev:
   23|      2|HistogramBucketMapper::HistogramBucketMapper() {
   24|       |  // If you change this, you also need to change
   25|       |  // size of array buckets_ in HistogramImpl
   26|      2|  bucketValues_ = {1, 2};
   27|      2|  double bucket_val = static_cast<double>(bucketValues_.back());
   28|    216|  while ((bucket_val = 1.5 * bucket_val) <=
  ------------------
  |  Branch (28:10): [True: 214, False: 2]
  ------------------
   29|    216|         static_cast<double>(std::numeric_limits<uint64_t>::max())) {
   30|    214|    bucketValues_.push_back(static_cast<uint64_t>(bucket_val));
   31|       |    // Extracts two most significant digits to make histogram buckets more
   32|       |    // human-readable. E.g., 172 becomes 170.
   33|    214|    uint64_t pow_of_ten = 1;
   34|  1.99k|    while (bucketValues_.back() / 10 > 10) {
  ------------------
  |  Branch (34:12): [True: 1.77k, False: 214]
  ------------------
   35|  1.77k|      bucketValues_.back() /= 10;
   36|  1.77k|      pow_of_ten *= 10;
   37|  1.77k|    }
   38|    214|    bucketValues_.back() *= pow_of_ten;
   39|    214|  }
   40|      2|  maxBucketValue_ = bucketValues_.back();
   41|      2|  minBucketValue_ = bucketValues_.front();
   42|      2|}

_ZN7rocksdb4port5MutexC2Eb:
   59|      4|Mutex::Mutex(bool adaptive) {
   60|      4|  (void)adaptive;
   61|       |#ifdef ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   62|       |  if (!adaptive) {
   63|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   64|       |  } else {
   65|       |    pthread_mutexattr_t mutex_attr;
   66|       |    PthreadCall("init mutex attr", pthread_mutexattr_init(&mutex_attr));
   67|       |    PthreadCall("set mutex attr", pthread_mutexattr_settype(
   68|       |                                      &mutex_attr, PTHREAD_MUTEX_ADAPTIVE_NP));
   69|       |    PthreadCall("init mutex", pthread_mutex_init(&mu_, &mutex_attr));
   70|       |    PthreadCall("destroy mutex attr", pthread_mutexattr_destroy(&mutex_attr));
   71|       |  }
   72|       |#else
   73|      4|  PthreadCall("init mutex", pthread_mutex_init(&mu_, nullptr));
   74|      4|#endif  // ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
   75|      4|}
_ZN7rocksdb4port7RWMutexC2Ev:
  152|      2|RWMutex::RWMutex() {
  153|      2|  PthreadCall("init mutex", pthread_rwlock_init(&mu_, nullptr));
  154|      2|}
port_posix.cc:_ZN7rocksdb4portL11PthreadCallEPKci:
   51|      6|static int PthreadCall(const char* label, int result) {
   52|      6|  if (result != 0 && result != ETIMEDOUT && result != EBUSY) {
  ------------------
  |  Branch (52:7): [True: 0, False: 6]
  |  Branch (52:22): [True: 0, False: 0]
  |  Branch (52:45): [True: 0, False: 0]
  ------------------
   53|      0|    fprintf(stderr, "pthread %s: %s\n", label, errnoStr(result).c_str());
   54|      0|    abort();
   55|      0|  }
   56|      6|  return result;
   57|      6|}
port_posix.cc:_ZN7rocksdb4portL11GetPageSizeEv:
  241|      2|static size_t GetPageSize() {
  242|      2|#if defined(OS_LINUX) || defined(_SC_PAGESIZE)
  243|      2|  long v = sysconf(_SC_PAGESIZE);
  244|      2|  if (v >= 1024) {
  ------------------
  |  Branch (244:7): [True: 2, False: 0]
  ------------------
  245|      2|    return static_cast<size_t>(v);
  246|      2|  }
  247|      0|#endif
  248|       |  // Default assume 4KB
  249|      0|  return 4U * 1024U;
  250|      2|}

_ZN7rocksdb11BlockHandleC2Emm:
  437|      2|    : offset_(_offset), size_(_size) {}

_ZN7rocksdb22PersistentCacheOptionsC2Ev:
   20|      2|  PersistentCacheOptions() {}

_ZN7rocksdb13ObjectLibrary7DefaultEv:
  208|      2|std::shared_ptr<ObjectLibrary> &ObjectLibrary::Default() {
  209|       |  // Use avoid destruction here so the default ObjectLibrary will not be
  210|       |  // statically destroyed and long-lived.
  211|      2|  STATIC_AVOID_DESTRUCTION(std::shared_ptr<ObjectLibrary>, instance)
  ------------------
  |  |   53|      2|#define STATIC_AVOID_DESTRUCTION(Type, name) static Type& name = *new Type
  ------------------
  212|      2|  (std::make_shared<ObjectLibrary>("default"));
  213|      2|  return instance;
  214|      2|}

