_RNvNvCsaUGX8A231Yw_18sparql_results_xml1__19___libfuzzer_sys_run:
  241|    649|            fn __libfuzzer_sys_run($bytes: &[u8]) {
  242|    649|                $body
  243|    649|            }
rust_fuzzer_test_input:
  215|    649|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    649|                }
  223|    649|
  224|    649|                __libfuzzer_sys_run(bytes);
  225|    649|                0
  226|    649|            }
LLVMFuzzerTestOneInput:
   58|    649|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    649|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    649|    });
   63|    649|
   64|    649|    match test_input {
   65|    649|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    649|}
_RNCNvCs5rGtGqFKXa_13libfuzzer_sys15test_input_wrap0B3_:
   59|    649|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    649|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    649|        rust_fuzzer_test_input(data_slice)
   62|    649|    });
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_RNvMNtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB2_6Memchr3newCslt04TQWGvnL_13oxigraph_fuzz:
   45|    707|    pub fn new(needle: u8, haystack: &[u8]) -> Memchr<'_> {
   46|    707|        Memchr { needle: needle, haystack: haystack, position: 0 }
   47|    707|    }
_RNvMs1_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB5_7Memchr23newCslt04TQWGvnL_13oxigraph_fuzz:
   84|  2.47k|    pub fn new(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   85|  2.47k|        Memchr2 {
   86|  2.47k|            needle1: needle1,
   87|  2.47k|            needle2: needle2,
   88|  2.47k|            haystack: haystack,
   89|  2.47k|            position: 0,
   90|  2.47k|        }
   91|  2.47k|    }
_RNvXs5_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB5_7Memchr3NtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4nextCslt04TQWGvnL_13oxigraph_fuzz:
  152|  1.82k|    fn next(&mut self) -> Option<usize> {
  153|       |        iter_next!(
  154|       |            self,
  155|       |            memchr3(self.needle1, self.needle2, self.needle3, self.haystack)
  156|       |        )
  157|  1.82k|    }
_RNvMs4_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB5_7Memchr33newCslt04TQWGvnL_13oxigraph_fuzz:
  132|    101|    pub fn new(
  133|    101|        needle1: u8,
  134|    101|        needle2: u8,
  135|    101|        needle3: u8,
  136|    101|        haystack: &[u8],
  137|    101|    ) -> Memchr3<'_> {
  138|    101|        Memchr3 {
  139|    101|            needle1: needle1,
  140|    101|            needle2: needle2,
  141|    101|            needle3: needle3,
  142|    101|            haystack: haystack,
  143|    101|            position: 0,
  144|    101|        }
  145|    101|    }
_RNvXs_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB4_6MemchrNtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4nextCslt04TQWGvnL_13oxigraph_fuzz:
   54|  4.80k|    fn next(&mut self) -> Option<usize> {
   55|       |        iter_next!(self, memchr(self.needle, self.haystack))
   56|  4.80k|    }
_RNCNvXs5_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB7_7Memchr3NtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4next0CsiptRIqLjvkg_9quick_xml:
  153|  1.72k|        iter_next!(
  154|  1.72k|            self,
  155|  1.72k|            memchr3(self.needle1, self.needle2, self.needle3, self.haystack)
  156|  1.72k|        )
_RNvXs2_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB5_7Memchr2NtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4nextCsiptRIqLjvkg_9quick_xml:
   98|   560k|    fn next(&mut self) -> Option<usize> {
   99|       |        iter_next!(self, memchr2(self.needle1, self.needle2, self.haystack))
  100|   560k|    }
_RNvMs1_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB5_7Memchr23newCsiptRIqLjvkg_9quick_xml:
   84|    251|    pub fn new(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   85|    251|        Memchr2 {
   86|    251|            needle1: needle1,
   87|    251|            needle2: needle2,
   88|    251|            haystack: haystack,
   89|    251|            position: 0,
   90|    251|        }
   91|    251|    }
_RNCNvXs2_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB7_7Memchr2NtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4next0CsiptRIqLjvkg_9quick_xml:
   99|   558k|        iter_next!(self, memchr2(self.needle1, self.needle2, self.haystack))
_RNCNvXs_NtNtCs1B8jV3ef48P_6memchr6memchr4iterNtB6_6MemchrNtNtNtNtCs9jyDXsa31Er_4core4iter6traits8iterator8Iterator4next0CsiptRIqLjvkg_9quick_xml:
   55|  4.69k|        iter_next!(self, memchr(self.needle, self.haystack))

_RNvNtCs1B8jV3ef48P_6memchr6memchr6memchrCslt04TQWGvnL_13oxigraph_fuzz:
   87|  5.75k|pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {
   88|  5.75k|    #[cfg(miri)]
   89|  5.75k|    #[inline(always)]
   90|  5.75k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   91|  5.75k|        naive::memchr(n1, haystack)
   92|  5.75k|    }
   93|  5.75k|
   94|  5.75k|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
   95|  5.75k|    #[inline(always)]
   96|  5.75k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   97|  5.75k|        x86::memchr(n1, haystack)
   98|  5.75k|    }
   99|  5.75k|
  100|  5.75k|    #[cfg(all(
  101|  5.75k|        memchr_libc,
  102|  5.75k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  103|  5.75k|        not(miri),
  104|  5.75k|    ))]
  105|  5.75k|    #[inline(always)]
  106|  5.75k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
  107|  5.75k|        c::memchr(n1, haystack)
  108|  5.75k|    }
  109|  5.75k|
  110|  5.75k|    #[cfg(all(
  111|  5.75k|        not(memchr_libc),
  112|  5.75k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  113|  5.75k|        not(miri),
  114|  5.75k|    ))]
  115|  5.75k|    #[inline(always)]
  116|  5.75k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
  117|  5.75k|        fallback::memchr(n1, haystack)
  118|  5.75k|    }
  119|  5.75k|
  120|  5.75k|    if haystack.is_empty() {
  121|     52|        None
  122|       |    } else {
  123|  5.70k|        imp(needle, haystack)
  124|       |    }
  125|  5.75k|}
_RNvNvNtCs1B8jV3ef48P_6memchr6memchr7memchr33imp:
  218|  1.80k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  219|  1.80k|        x86::memchr3(n1, n2, n3, haystack)
  220|  1.80k|    }
_RNvNtCs1B8jV3ef48P_6memchr6memchr12memchr2_iterCslt04TQWGvnL_13oxigraph_fuzz:
   23|  2.47k|pub fn memchr2_iter(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   24|  2.47k|    Memchr2::new(needle1, needle2, haystack)
   25|  2.47k|}
_RNvNtCs1B8jV3ef48P_6memchr6memchr12memchr3_iterCslt04TQWGvnL_13oxigraph_fuzz:
   29|    101|pub fn memchr3_iter(
   30|    101|    needle1: u8,
   31|    101|    needle2: u8,
   32|    101|    needle3: u8,
   33|    101|    haystack: &[u8],
   34|    101|) -> Memchr3<'_> {
   35|    101|    Memchr3::new(needle1, needle2, needle3, haystack)
   36|    101|}
_RNvNvNtCs1B8jV3ef48P_6memchr6memchr6memchr3imp:
   96|  5.70k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   97|  5.70k|        x86::memchr(n1, haystack)
   98|  5.70k|    }
_RNvNvNtCs1B8jV3ef48P_6memchr6memchr7memchr23imp:
  160|   559k|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  161|   559k|        x86::memchr2(n1, n2, haystack)
  162|   559k|    }
_RNvNtCs1B8jV3ef48P_6memchr6memchr7memchr3Cslt04TQWGvnL_13oxigraph_fuzz:
  204|  1.82k|pub fn memchr3(
  205|  1.82k|    needle1: u8,
  206|  1.82k|    needle2: u8,
  207|  1.82k|    needle3: u8,
  208|  1.82k|    haystack: &[u8],
  209|  1.82k|) -> Option<usize> {
  210|  1.82k|    #[cfg(miri)]
  211|  1.82k|    #[inline(always)]
  212|  1.82k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  213|  1.82k|        naive::memchr3(n1, n2, n3, haystack)
  214|  1.82k|    }
  215|  1.82k|
  216|  1.82k|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
  217|  1.82k|    #[inline(always)]
  218|  1.82k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  219|  1.82k|        x86::memchr3(n1, n2, n3, haystack)
  220|  1.82k|    }
  221|  1.82k|
  222|  1.82k|    #[cfg(all(
  223|  1.82k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  224|  1.82k|        not(miri),
  225|  1.82k|    ))]
  226|  1.82k|    #[inline(always)]
  227|  1.82k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  228|  1.82k|        fallback::memchr3(n1, n2, n3, haystack)
  229|  1.82k|    }
  230|  1.82k|
  231|  1.82k|    if haystack.is_empty() {
  232|     18|        None
  233|       |    } else {
  234|  1.80k|        imp(needle1, needle2, needle3, haystack)
  235|       |    }
  236|  1.82k|}
_RNvNtCs1B8jV3ef48P_6memchr6memchr11memchr_iterCslt04TQWGvnL_13oxigraph_fuzz:
   17|    707|pub fn memchr_iter(needle: u8, haystack: &[u8]) -> Memchr<'_> {
   18|    707|    Memchr::new(needle, haystack)
   19|    707|}
_RNvNtCs1B8jV3ef48P_6memchr6memchr7memchr2CsiptRIqLjvkg_9quick_xml:
  151|   560k|pub fn memchr2(needle1: u8, needle2: u8, haystack: &[u8]) -> Option<usize> {
  152|   560k|    #[cfg(miri)]
  153|   560k|    #[inline(always)]
  154|   560k|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  155|   560k|        naive::memchr2(n1, n2, haystack)
  156|   560k|    }
  157|   560k|
  158|   560k|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
  159|   560k|    #[inline(always)]
  160|   560k|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  161|   560k|        x86::memchr2(n1, n2, haystack)
  162|   560k|    }
  163|   560k|
  164|   560k|    #[cfg(all(
  165|   560k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  166|   560k|        not(miri),
  167|   560k|    ))]
  168|   560k|    #[inline(always)]
  169|   560k|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  170|   560k|        fallback::memchr2(n1, n2, haystack)
  171|   560k|    }
  172|   560k|
  173|   560k|    if haystack.is_empty() {
  174|  1.77k|        None
  175|       |    } else {
  176|   559k|        imp(needle1, needle2, haystack)
  177|       |    }
  178|   560k|}
_RNvNtCs1B8jV3ef48P_6memchr6memchr12memchr2_iterCsiptRIqLjvkg_9quick_xml:
   23|    251|pub fn memchr2_iter(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   24|    251|    Memchr2::new(needle1, needle2, haystack)
   25|    251|}

_RNvNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx7memchr27matched:
  126|  14.3k|    unsafe fn matched(
  127|  14.3k|        start_ptr: *const u8,
  128|  14.3k|        ptr: *const u8,
  129|  14.3k|        eqa1: __m256i,
  130|  14.3k|        eqa2: __m256i,
  131|  14.3k|        eqb1: __m256i,
  132|  14.3k|        eqb2: __m256i,
  133|  14.3k|    ) -> usize {
  134|  14.3k|        let mut at = sub(ptr, start_ptr);
  135|  14.3k|        let mask1 = _mm256_movemask_epi8(eqa1);
  136|  14.3k|        let mask2 = _mm256_movemask_epi8(eqa2);
  137|  14.3k|        if mask1 != 0 || mask2 != 0 {
  138|  9.44k|            return at + forward_pos2(mask1, mask2);
  139|  4.85k|        }
  140|  4.85k|
  141|  4.85k|        at += VECTOR_SIZE;
  142|  4.85k|        let mask1 = _mm256_movemask_epi8(eqb1);
  143|  4.85k|        let mask2 = _mm256_movemask_epi8(eqb2);
  144|  4.85k|        at + forward_pos2(mask1, mask2)
  145|  14.3k|    }
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx15forward_search1:
  533|  5.04k|unsafe fn forward_search1(
  534|  5.04k|    start_ptr: *const u8,
  535|  5.04k|    end_ptr: *const u8,
  536|  5.04k|    ptr: *const u8,
  537|  5.04k|    vn1: __m256i,
  538|  5.04k|) -> Option<usize> {
  539|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  540|      0|    debug_assert!(start_ptr <= ptr);
  541|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  542|       |
  543|  5.04k|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  544|  5.04k|    let mask = _mm256_movemask_epi8(_mm256_cmpeq_epi8(chunk, vn1));
  545|  5.04k|    if mask != 0 {
  546|  3.88k|        Some(sub(ptr, start_ptr) + forward_pos(mask))
  547|       |    } else {
  548|  1.16k|        None
  549|       |    }
  550|  5.04k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx11forward_pos:
  680|   532k|fn forward_pos(mask: i32) -> usize {
  681|   532k|    // We are dealing with little endian here, where the most significant byte
  682|   532k|    // is at a higher address. That means the least significant bit that is set
  683|   532k|    // corresponds to the position of our first matching byte. That position
  684|   532k|    // corresponds to the number of zeros after the least significant bit.
  685|   532k|    mask.trailing_zeros() as usize
  686|   532k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx15forward_search2:
  553|   528k|unsafe fn forward_search2(
  554|   528k|    start_ptr: *const u8,
  555|   528k|    end_ptr: *const u8,
  556|   528k|    ptr: *const u8,
  557|   528k|    vn1: __m256i,
  558|   528k|    vn2: __m256i,
  559|   528k|) -> Option<usize> {
  560|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  561|      0|    debug_assert!(start_ptr <= ptr);
  562|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  563|       |
  564|   528k|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  565|   528k|    let eq1 = _mm256_cmpeq_epi8(chunk, vn1);
  566|   528k|    let eq2 = _mm256_cmpeq_epi8(chunk, vn2);
  567|   528k|    if _mm256_movemask_epi8(_mm256_or_si256(eq1, eq2)) != 0 {
  568|   512k|        let mask1 = _mm256_movemask_epi8(eq1);
  569|   512k|        let mask2 = _mm256_movemask_epi8(eq2);
  570|   512k|        Some(sub(ptr, start_ptr) + forward_pos2(mask1, mask2))
  571|       |    } else {
  572|  16.4k|        None
  573|       |    }
  574|   528k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx12forward_pos2:
  694|   526k|fn forward_pos2(mask1: i32, mask2: i32) -> usize {
  695|      0|    debug_assert!(mask1 != 0 || mask2 != 0);
  696|       |
  697|   526k|    forward_pos(mask1 | mask2)
  698|   526k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx6memchr:
   18|  5.70k|pub unsafe fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   19|  5.70k|    // For a high level explanation for how this algorithm works, see the
   20|  5.70k|    // sse2 implementation. The avx implementation here is the same, but with
   21|  5.70k|    // 256-bit vectors instead of 128-bit vectors.
   22|  5.70k|
   23|  5.70k|    // This routine is called whenever a match is detected. It is specifically
   24|  5.70k|    // marked as unlineable because it improves the codegen of the unrolled
   25|  5.70k|    // loop below. Inlining this seems to cause codegen with some extra adds
   26|  5.70k|    // and a load that aren't necessary. This seems to result in about a 10%
   27|  5.70k|    // improvement for the memchr1/crate/huge/never benchmark.
   28|  5.70k|    //
   29|  5.70k|    // Interestingly, I couldn't observe a similar improvement for memrchr.
   30|  5.70k|    #[cold]
   31|  5.70k|    #[inline(never)]
   32|  5.70k|    #[target_feature(enable = "avx2")]
   33|  5.70k|    unsafe fn matched(
   34|  5.70k|        start_ptr: *const u8,
   35|  5.70k|        ptr: *const u8,
   36|  5.70k|        eqa: __m256i,
   37|  5.70k|        eqb: __m256i,
   38|  5.70k|        eqc: __m256i,
   39|  5.70k|        eqd: __m256i,
   40|  5.70k|    ) -> usize {
   41|  5.70k|        let mut at = sub(ptr, start_ptr);
   42|  5.70k|        let mask = _mm256_movemask_epi8(eqa);
   43|  5.70k|        if mask != 0 {
   44|  5.70k|            return at + forward_pos(mask);
   45|  5.70k|        }
   46|  5.70k|
   47|  5.70k|        at += VECTOR_SIZE;
   48|  5.70k|        let mask = _mm256_movemask_epi8(eqb);
   49|  5.70k|        if mask != 0 {
   50|  5.70k|            return at + forward_pos(mask);
   51|  5.70k|        }
   52|  5.70k|
   53|  5.70k|        at += VECTOR_SIZE;
   54|  5.70k|        let mask = _mm256_movemask_epi8(eqc);
   55|  5.70k|        if mask != 0 {
   56|  5.70k|            return at + forward_pos(mask);
   57|  5.70k|        }
   58|  5.70k|
   59|  5.70k|        at += VECTOR_SIZE;
   60|  5.70k|        let mask = _mm256_movemask_epi8(eqd);
   61|  5.70k|        debug_assert!(mask != 0);
   62|  5.70k|        at + forward_pos(mask)
   63|  5.70k|    }
   64|  5.70k|
   65|  5.70k|    let start_ptr = haystack.as_ptr();
   66|  5.70k|    let end_ptr = start_ptr.add(haystack.len());
   67|  5.70k|    let mut ptr = start_ptr;
   68|  5.70k|
   69|  5.70k|    if haystack.len() < VECTOR_SIZE {
   70|       |        // For small haystacks, defer to the SSE2 implementation. Codegen
   71|       |        // suggests this completely avoids touching the AVX vectors.
   72|  1.07k|        return sse2::memchr(n1, haystack);
   73|  4.62k|    }
   74|  4.62k|
   75|  4.62k|    let vn1 = _mm256_set1_epi8(n1 as i8);
   76|  4.62k|    let loop_size = cmp::min(LOOP_SIZE, haystack.len());
   77|  4.62k|    if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
   78|  3.80k|        return Some(i);
   79|    828|    }
   80|    828|
   81|    828|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
   82|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
   83|  1.05k|    while loop_size == LOOP_SIZE && ptr <= end_ptr.sub(loop_size) {
   84|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
   85|       |
   86|    819|        let a = _mm256_load_si256(ptr as *const __m256i);
   87|    819|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
   88|    819|        let c = _mm256_load_si256(ptr.add(2 * VECTOR_SIZE) as *const __m256i);
   89|    819|        let d = _mm256_load_si256(ptr.add(3 * VECTOR_SIZE) as *const __m256i);
   90|    819|        let eqa = _mm256_cmpeq_epi8(vn1, a);
   91|    819|        let eqb = _mm256_cmpeq_epi8(vn1, b);
   92|    819|        let eqc = _mm256_cmpeq_epi8(vn1, c);
   93|    819|        let eqd = _mm256_cmpeq_epi8(vn1, d);
   94|    819|        let or1 = _mm256_or_si256(eqa, eqb);
   95|    819|        let or2 = _mm256_or_si256(eqc, eqd);
   96|    819|        let or3 = _mm256_or_si256(or1, or2);
   97|    819|
   98|    819|        if _mm256_movemask_epi8(or3) != 0 {
   99|    593|            return Some(matched(start_ptr, ptr, eqa, eqb, eqc, eqd));
  100|    226|        }
  101|    226|        ptr = ptr.add(loop_size);
  102|       |    }
  103|    437|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  104|      0|        debug_assert!(sub(end_ptr, ptr) >= VECTOR_SIZE);
  105|       |
  106|    260|        if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  107|     58|            return Some(i);
  108|    202|        }
  109|    202|        ptr = ptr.add(VECTOR_SIZE);
  110|       |    }
  111|    177|    if ptr < end_ptr {
  112|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  113|    157|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  114|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  115|       |
  116|    157|        return forward_search1(start_ptr, end_ptr, ptr, vn1);
  117|     20|    }
  118|     20|    None
  119|  5.70k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx7memchr2:
  122|   559k|pub unsafe fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  123|   559k|    #[cold]
  124|   559k|    #[inline(never)]
  125|   559k|    #[target_feature(enable = "avx2")]
  126|   559k|    unsafe fn matched(
  127|   559k|        start_ptr: *const u8,
  128|   559k|        ptr: *const u8,
  129|   559k|        eqa1: __m256i,
  130|   559k|        eqa2: __m256i,
  131|   559k|        eqb1: __m256i,
  132|   559k|        eqb2: __m256i,
  133|   559k|    ) -> usize {
  134|   559k|        let mut at = sub(ptr, start_ptr);
  135|   559k|        let mask1 = _mm256_movemask_epi8(eqa1);
  136|   559k|        let mask2 = _mm256_movemask_epi8(eqa2);
  137|   559k|        if mask1 != 0 || mask2 != 0 {
  138|   559k|            return at + forward_pos2(mask1, mask2);
  139|   559k|        }
  140|   559k|
  141|   559k|        at += VECTOR_SIZE;
  142|   559k|        let mask1 = _mm256_movemask_epi8(eqb1);
  143|   559k|        let mask2 = _mm256_movemask_epi8(eqb2);
  144|   559k|        at + forward_pos2(mask1, mask2)
  145|   559k|    }
  146|   559k|
  147|   559k|    let vn1 = _mm256_set1_epi8(n1 as i8);
  148|   559k|    let vn2 = _mm256_set1_epi8(n2 as i8);
  149|   559k|    let len = haystack.len();
  150|   559k|    let loop_size = cmp::min(LOOP_SIZE2, len);
  151|   559k|    let start_ptr = haystack.as_ptr();
  152|   559k|    let end_ptr = start_ptr.add(haystack.len());
  153|   559k|    let mut ptr = start_ptr;
  154|   559k|
  155|   559k|    if haystack.len() < VECTOR_SIZE {
  156|  49.2k|        while ptr < end_ptr {
  157|  48.5k|            if *ptr == n1 || *ptr == n2 {
  158|  31.4k|                return Some(sub(ptr, start_ptr));
  159|  17.1k|            }
  160|  17.1k|            ptr = ptr.offset(1);
  161|       |        }
  162|    706|        return None;
  163|   526k|    }
  164|       |
  165|   526k|    if let Some(i) = forward_search2(start_ptr, end_ptr, ptr, vn1, vn2) {
  166|   511k|        return Some(i);
  167|  15.8k|    }
  168|  15.8k|
  169|  15.8k|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  170|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  171|  17.1k|    while loop_size == LOOP_SIZE2 && ptr <= end_ptr.sub(loop_size) {
  172|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  173|       |
  174|  15.5k|        let a = _mm256_load_si256(ptr as *const __m256i);
  175|  15.5k|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
  176|  15.5k|        let eqa1 = _mm256_cmpeq_epi8(vn1, a);
  177|  15.5k|        let eqb1 = _mm256_cmpeq_epi8(vn1, b);
  178|  15.5k|        let eqa2 = _mm256_cmpeq_epi8(vn2, a);
  179|  15.5k|        let eqb2 = _mm256_cmpeq_epi8(vn2, b);
  180|  15.5k|        let or1 = _mm256_or_si256(eqa1, eqb1);
  181|  15.5k|        let or2 = _mm256_or_si256(eqa2, eqb2);
  182|  15.5k|        let or3 = _mm256_or_si256(or1, or2);
  183|  15.5k|        if _mm256_movemask_epi8(or3) != 0 {
  184|  14.3k|            return Some(matched(start_ptr, ptr, eqa1, eqa2, eqb1, eqb2));
  185|  1.27k|        }
  186|  1.27k|        ptr = ptr.add(loop_size);
  187|       |    }
  188|  2.03k|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  189|  1.04k|        if let Some(i) = forward_search2(start_ptr, end_ptr, ptr, vn1, vn2) {
  190|    550|            return Some(i);
  191|    497|        }
  192|    497|        ptr = ptr.add(VECTOR_SIZE);
  193|       |    }
  194|    986|    if ptr < end_ptr {
  195|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  196|    967|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  197|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  198|       |
  199|    967|        return forward_search2(start_ptr, end_ptr, ptr, vn1, vn2);
  200|     19|    }
  201|     19|    None
  202|   559k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx7memchr3:
  205|  1.80k|pub unsafe fn memchr3(
  206|  1.80k|    n1: u8,
  207|  1.80k|    n2: u8,
  208|  1.80k|    n3: u8,
  209|  1.80k|    haystack: &[u8],
  210|  1.80k|) -> Option<usize> {
  211|  1.80k|    #[cold]
  212|  1.80k|    #[inline(never)]
  213|  1.80k|    #[target_feature(enable = "avx2")]
  214|  1.80k|    unsafe fn matched(
  215|  1.80k|        start_ptr: *const u8,
  216|  1.80k|        ptr: *const u8,
  217|  1.80k|        eqa1: __m256i,
  218|  1.80k|        eqa2: __m256i,
  219|  1.80k|        eqa3: __m256i,
  220|  1.80k|        eqb1: __m256i,
  221|  1.80k|        eqb2: __m256i,
  222|  1.80k|        eqb3: __m256i,
  223|  1.80k|    ) -> usize {
  224|  1.80k|        let mut at = sub(ptr, start_ptr);
  225|  1.80k|        let mask1 = _mm256_movemask_epi8(eqa1);
  226|  1.80k|        let mask2 = _mm256_movemask_epi8(eqa2);
  227|  1.80k|        let mask3 = _mm256_movemask_epi8(eqa3);
  228|  1.80k|        if mask1 != 0 || mask2 != 0 || mask3 != 0 {
  229|  1.80k|            return at + forward_pos3(mask1, mask2, mask3);
  230|  1.80k|        }
  231|  1.80k|
  232|  1.80k|        at += VECTOR_SIZE;
  233|  1.80k|        let mask1 = _mm256_movemask_epi8(eqb1);
  234|  1.80k|        let mask2 = _mm256_movemask_epi8(eqb2);
  235|  1.80k|        let mask3 = _mm256_movemask_epi8(eqb3);
  236|  1.80k|        at + forward_pos3(mask1, mask2, mask3)
  237|  1.80k|    }
  238|  1.80k|
  239|  1.80k|    let vn1 = _mm256_set1_epi8(n1 as i8);
  240|  1.80k|    let vn2 = _mm256_set1_epi8(n2 as i8);
  241|  1.80k|    let vn3 = _mm256_set1_epi8(n3 as i8);
  242|  1.80k|    let len = haystack.len();
  243|  1.80k|    let loop_size = cmp::min(LOOP_SIZE2, len);
  244|  1.80k|    let start_ptr = haystack.as_ptr();
  245|  1.80k|    let end_ptr = start_ptr.add(haystack.len());
  246|  1.80k|    let mut ptr = start_ptr;
  247|  1.80k|
  248|  1.80k|    if haystack.len() < VECTOR_SIZE {
  249|    978|        while ptr < end_ptr {
  250|    928|            if *ptr == n1 || *ptr == n2 || *ptr == n3 {
  251|    430|                return Some(sub(ptr, start_ptr));
  252|    498|            }
  253|    498|            ptr = ptr.offset(1);
  254|       |        }
  255|     50|        return None;
  256|  1.32k|    }
  257|       |
  258|  1.32k|    if let Some(i) = forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3) {
  259|  1.09k|        return Some(i);
  260|    224|    }
  261|    224|
  262|    224|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  263|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  264|    341|    while loop_size == LOOP_SIZE2 && ptr <= end_ptr.sub(loop_size) {
  265|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  266|       |
  267|    304|        let a = _mm256_load_si256(ptr as *const __m256i);
  268|    304|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
  269|    304|        let eqa1 = _mm256_cmpeq_epi8(vn1, a);
  270|    304|        let eqb1 = _mm256_cmpeq_epi8(vn1, b);
  271|    304|        let eqa2 = _mm256_cmpeq_epi8(vn2, a);
  272|    304|        let eqb2 = _mm256_cmpeq_epi8(vn2, b);
  273|    304|        let eqa3 = _mm256_cmpeq_epi8(vn3, a);
  274|    304|        let eqb3 = _mm256_cmpeq_epi8(vn3, b);
  275|    304|        let or1 = _mm256_or_si256(eqa1, eqb1);
  276|    304|        let or2 = _mm256_or_si256(eqa2, eqb2);
  277|    304|        let or3 = _mm256_or_si256(eqa3, eqb3);
  278|    304|        let or4 = _mm256_or_si256(or1, or2);
  279|    304|        let or5 = _mm256_or_si256(or3, or4);
  280|    304|        if _mm256_movemask_epi8(or5) != 0 {
  281|    187|            return Some(matched(
  282|    187|                start_ptr, ptr, eqa1, eqa2, eqa3, eqb1, eqb2, eqb3,
  283|    187|            ));
  284|    117|        }
  285|    117|        ptr = ptr.add(loop_size);
  286|       |    }
  287|     45|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  288|      8|        if let Some(i) =
  289|     16|            forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3)
  290|       |        {
  291|      8|            return Some(i);
  292|      8|        }
  293|      8|        ptr = ptr.add(VECTOR_SIZE);
  294|       |    }
  295|     29|    if ptr < end_ptr {
  296|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  297|     23|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  298|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  299|       |
  300|     23|        return forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3);
  301|      6|    }
  302|      6|    None
  303|  1.80k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx3sub:
  752|   565k|fn sub(a: *const u8, b: *const u8) -> usize {
  753|      0|    debug_assert!(a >= b);
  754|   565k|    (a as usize) - (b as usize)
  755|   565k|}
_RNvNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx7memchr37matched:
  214|    187|    unsafe fn matched(
  215|    187|        start_ptr: *const u8,
  216|    187|        ptr: *const u8,
  217|    187|        eqa1: __m256i,
  218|    187|        eqa2: __m256i,
  219|    187|        eqa3: __m256i,
  220|    187|        eqb1: __m256i,
  221|    187|        eqb2: __m256i,
  222|    187|        eqb3: __m256i,
  223|    187|    ) -> usize {
  224|    187|        let mut at = sub(ptr, start_ptr);
  225|    187|        let mask1 = _mm256_movemask_epi8(eqa1);
  226|    187|        let mask2 = _mm256_movemask_epi8(eqa2);
  227|    187|        let mask3 = _mm256_movemask_epi8(eqa3);
  228|    187|        if mask1 != 0 || mask2 != 0 || mask3 != 0 {
  229|    106|            return at + forward_pos3(mask1, mask2, mask3);
  230|     81|        }
  231|     81|
  232|     81|        at += VECTOR_SIZE;
  233|     81|        let mask1 = _mm256_movemask_epi8(eqb1);
  234|     81|        let mask2 = _mm256_movemask_epi8(eqb2);
  235|     81|        let mask3 = _mm256_movemask_epi8(eqb3);
  236|     81|        at + forward_pos3(mask1, mask2, mask3)
  237|    187|    }
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx15forward_search3:
  577|  1.36k|unsafe fn forward_search3(
  578|  1.36k|    start_ptr: *const u8,
  579|  1.36k|    end_ptr: *const u8,
  580|  1.36k|    ptr: *const u8,
  581|  1.36k|    vn1: __m256i,
  582|  1.36k|    vn2: __m256i,
  583|  1.36k|    vn3: __m256i,
  584|  1.36k|) -> Option<usize> {
  585|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  586|      0|    debug_assert!(start_ptr <= ptr);
  587|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  588|       |
  589|  1.36k|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  590|  1.36k|    let eq1 = _mm256_cmpeq_epi8(chunk, vn1);
  591|  1.36k|    let eq2 = _mm256_cmpeq_epi8(chunk, vn2);
  592|  1.36k|    let eq3 = _mm256_cmpeq_epi8(chunk, vn3);
  593|  1.36k|    let or = _mm256_or_si256(eq1, eq2);
  594|  1.36k|    if _mm256_movemask_epi8(_mm256_or_si256(or, eq3)) != 0 {
  595|  1.10k|        let mask1 = _mm256_movemask_epi8(eq1);
  596|  1.10k|        let mask2 = _mm256_movemask_epi8(eq2);
  597|  1.10k|        let mask3 = _mm256_movemask_epi8(eq3);
  598|  1.10k|        Some(sub(ptr, start_ptr) + forward_pos3(mask1, mask2, mask3))
  599|       |    } else {
  600|    253|        None
  601|       |    }
  602|  1.36k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx12forward_pos3:
  706|  1.29k|fn forward_pos3(mask1: i32, mask2: i32, mask3: i32) -> usize {
  707|      0|    debug_assert!(mask1 != 0 || mask2 != 0 || mask3 != 0);
  708|       |
  709|  1.29k|    forward_pos(mask1 | mask2 | mask3)
  710|  1.29k|}
_RNvNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x863avx6memchr7matched:
   33|    593|    unsafe fn matched(
   34|    593|        start_ptr: *const u8,
   35|    593|        ptr: *const u8,
   36|    593|        eqa: __m256i,
   37|    593|        eqb: __m256i,
   38|    593|        eqc: __m256i,
   39|    593|        eqd: __m256i,
   40|    593|    ) -> usize {
   41|    593|        let mut at = sub(ptr, start_ptr);
   42|    593|        let mask = _mm256_movemask_epi8(eqa);
   43|    593|        if mask != 0 {
   44|    244|            return at + forward_pos(mask);
   45|    349|        }
   46|    349|
   47|    349|        at += VECTOR_SIZE;
   48|    349|        let mask = _mm256_movemask_epi8(eqb);
   49|    349|        if mask != 0 {
   50|    195|            return at + forward_pos(mask);
   51|    154|        }
   52|    154|
   53|    154|        at += VECTOR_SIZE;
   54|    154|        let mask = _mm256_movemask_epi8(eqc);
   55|    154|        if mask != 0 {
   56|     98|            return at + forward_pos(mask);
   57|     56|        }
   58|     56|
   59|     56|        at += VECTOR_SIZE;
   60|     56|        let mask = _mm256_movemask_epi8(eqd);
   61|      0|        debug_assert!(mask != 0);
   62|     56|        at + forward_pos(mask)
   63|    593|    }

_RNvNtNtCs1B8jV3ef48P_6memchr6memchr3x867memchr2:
  100|   559k|pub fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  101|   559k|    unsafe_ifunc!(
  102|   559k|        fn(u8, u8, &[u8]) -> Option<usize>,
  103|   559k|        memchr2,
  104|   559k|        haystack,
  105|   559k|        n1,
  106|   559k|        n2
  107|   559k|    )
  108|   559k|}
_RNvNtNtCs1B8jV3ef48P_6memchr6memchr3x867memchr3:
  111|  1.80k|pub fn memchr3(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  112|  1.80k|    unsafe_ifunc!(
  113|  1.80k|        fn(u8, u8, u8, &[u8]) -> Option<usize>,
  114|  1.80k|        memchr3,
  115|  1.80k|        haystack,
  116|  1.80k|        n1,
  117|  1.80k|        n2,
  118|  1.80k|        n3
  119|  1.80k|    )
  120|  1.80k|}
_RNvNtNtCs1B8jV3ef48P_6memchr6memchr3x866memchr:
   95|  5.70k|pub fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   96|  5.70k|    unsafe_ifunc!(fn(u8, &[u8]) -> Option<usize>, memchr, haystack, n1)
   97|  5.70k|}
_RNvNvNtNtCs1B8jV3ef48P_6memchr6memchr3x867memchr36detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }
_RNvNvNtNtCs1B8jV3ef48P_6memchr6memchr3x866memchr6detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }
_RNvNvNtNtCs1B8jV3ef48P_6memchr6memchr3x867memchr26detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }

_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x864sse26memchr:
   16|  1.07k|pub unsafe fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   17|  1.07k|    // What follows is a fast SSE2-only algorithm to detect the position of
   18|  1.07k|    // `n1` in `haystack` if it exists. From what I know, this is the "classic"
   19|  1.07k|    // algorithm. I believe it can be found in places like glibc and Go's
   20|  1.07k|    // standard library. It appears to be well known and is elaborated on in
   21|  1.07k|    // more detail here: https://gms.tf/stdfind-and-memchr-optimizations.html
   22|  1.07k|    //
   23|  1.07k|    // While this routine is very long, the basic idea is actually very simple
   24|  1.07k|    // and can be expressed straight-forwardly in pseudo code:
   25|  1.07k|    //
   26|  1.07k|    //     needle = (n1 << 15) | (n1 << 14) | ... | (n1 << 1) | n1
   27|  1.07k|    //     // Note: shift amount in bytes
   28|  1.07k|    //
   29|  1.07k|    //     while i <= haystack.len() - 16:
   30|  1.07k|    //       // A 16 byte vector. Each byte in chunk corresponds to a byte in
   31|  1.07k|    //       // the haystack.
   32|  1.07k|    //       chunk = haystack[i:i+16]
   33|  1.07k|    //       // Compare bytes in needle with bytes in chunk. The result is a 16
   34|  1.07k|    //       // byte chunk where each byte is 0xFF if the corresponding bytes
   35|  1.07k|    //       // in needle and chunk were equal, or 0x00 otherwise.
   36|  1.07k|    //       eqs = cmpeq(needle, chunk)
   37|  1.07k|    //       // Return a 32 bit integer where the most significant 16 bits
   38|  1.07k|    //       // are always 0 and the lower 16 bits correspond to whether the
   39|  1.07k|    //       // most significant bit in the correspond byte in `eqs` is set.
   40|  1.07k|    //       // In other words, `mask as u16` has bit i set if and only if
   41|  1.07k|    //       // needle[i] == chunk[i].
   42|  1.07k|    //       mask = movemask(eqs)
   43|  1.07k|    //
   44|  1.07k|    //       // Mask is 0 if there is no match, and non-zero otherwise.
   45|  1.07k|    //       if mask != 0:
   46|  1.07k|    //         // trailing_zeros tells us the position of the least significant
   47|  1.07k|    //         // bit that is set.
   48|  1.07k|    //         return i + trailing_zeros(mask)
   49|  1.07k|    //
   50|  1.07k|    //     // haystack length may not be a multiple of 16, so search the rest.
   51|  1.07k|    //     while i < haystack.len():
   52|  1.07k|    //       if haystack[i] == n1:
   53|  1.07k|    //         return i
   54|  1.07k|    //
   55|  1.07k|    //     // No match found.
   56|  1.07k|    //     return NULL
   57|  1.07k|    //
   58|  1.07k|    // In fact, we could loosely translate the above code to Rust line-for-line
   59|  1.07k|    // and it would be a pretty fast algorithm. But, we pull out all the stops
   60|  1.07k|    // to go as fast as possible:
   61|  1.07k|    //
   62|  1.07k|    // 1. We use aligned loads. That is, we do some finagling to make sure our
   63|  1.07k|    //    primary loop not only proceeds in increments of 16 bytes, but that
   64|  1.07k|    //    the address of haystack's pointer that we dereference is aligned to
   65|  1.07k|    //    16 bytes. 16 is a magic number here because it is the size of SSE2
   66|  1.07k|    //    128-bit vector. (For the AVX2 algorithm, 32 is the magic number.)
   67|  1.07k|    //    Therefore, to get aligned loads, our pointer's address must be evenly
   68|  1.07k|    //    divisible by 16.
   69|  1.07k|    // 2. Our primary loop proceeds 64 bytes at a time instead of 16. It's
   70|  1.07k|    //    kind of like loop unrolling, but we combine the equality comparisons
   71|  1.07k|    //    using a vector OR such that we only need to extract a single mask to
   72|  1.07k|    //    determine whether a match exists or not. If so, then we do some
   73|  1.07k|    //    book-keeping to determine the precise location but otherwise mush on.
   74|  1.07k|    // 3. We use our "chunk" comparison routine in as many places as possible,
   75|  1.07k|    //    even if it means using unaligned loads. In particular, if haystack
   76|  1.07k|    //    starts with an unaligned address, then we do an unaligned load to
   77|  1.07k|    //    search the first 16 bytes. We then start our primary loop at the
   78|  1.07k|    //    smallest subsequent aligned address, which will actually overlap with
   79|  1.07k|    //    previously searched bytes. But we're OK with that. We do a similar
   80|  1.07k|    //    dance at the end of our primary loop. Finally, to avoid a
   81|  1.07k|    //    byte-at-a-time loop at the end, we do a final 16 byte unaligned load
   82|  1.07k|    //    that may overlap with a previous load. This is OK because it converts
   83|  1.07k|    //    a loop into a small number of very fast vector instructions.
   84|  1.07k|    //
   85|  1.07k|    // The primary downside of this algorithm is that it's effectively
   86|  1.07k|    // completely unsafe. Therefore, we have to be super careful to avoid
   87|  1.07k|    // undefined behavior:
   88|  1.07k|    //
   89|  1.07k|    // 1. We use raw pointers everywhere. Not only does dereferencing a pointer
   90|  1.07k|    //    require the pointer to be valid, but we actually can't even store the
   91|  1.07k|    //    address of an invalid pointer (unless it's 1 past the end of
   92|  1.07k|    //    haystack) without sacrificing performance.
   93|  1.07k|    // 2. _mm_loadu_si128 is used when you don't care about alignment, and
   94|  1.07k|    //    _mm_load_si128 is used when you do care. You cannot use the latter
   95|  1.07k|    //    on unaligned pointers.
   96|  1.07k|    // 3. We make liberal use of debug_assert! to check assumptions.
   97|  1.07k|    // 4. We make a concerted effort to stick with pointers instead of indices.
   98|  1.07k|    //    Indices are nicer because there's less to worry about with them (see
   99|  1.07k|    //    above about pointer offsets), but I could not get the compiler to
  100|  1.07k|    //    produce as good of code as what the below produces. In any case,
  101|  1.07k|    //    pointers are what we really care about here, and alignment is
  102|  1.07k|    //    expressed a bit more naturally with them.
  103|  1.07k|    //
  104|  1.07k|    // In general, most of the algorithms in this crate have a similar
  105|  1.07k|    // structure to what you see below, so this comment applies fairly well to
  106|  1.07k|    // all of them.
  107|  1.07k|
  108|  1.07k|    let vn1 = _mm_set1_epi8(n1 as i8);
  109|  1.07k|    let len = haystack.len();
  110|  1.07k|    let loop_size = cmp::min(LOOP_SIZE, len);
  111|  1.07k|    let start_ptr = haystack.as_ptr();
  112|  1.07k|    let end_ptr = start_ptr.add(haystack.len());
  113|  1.07k|    let mut ptr = start_ptr;
  114|  1.07k|
  115|  1.07k|    if haystack.len() < VECTOR_SIZE {
  116|  2.83k|        while ptr < end_ptr {
  117|  2.56k|            if *ptr == n1 {
  118|    413|                return Some(sub(ptr, start_ptr));
  119|  2.14k|            }
  120|  2.14k|            ptr = ptr.offset(1);
  121|       |        }
  122|    273|        return None;
  123|    390|    }
  124|       |
  125|    390|    if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  126|    309|        return Some(i);
  127|     81|    }
  128|     81|
  129|     81|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  130|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  131|     81|    while loop_size == LOOP_SIZE && ptr <= end_ptr.sub(loop_size) {
  132|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  133|       |
  134|      0|        let a = _mm_load_si128(ptr as *const __m128i);
  135|      0|        let b = _mm_load_si128(ptr.add(VECTOR_SIZE) as *const __m128i);
  136|      0|        let c = _mm_load_si128(ptr.add(2 * VECTOR_SIZE) as *const __m128i);
  137|      0|        let d = _mm_load_si128(ptr.add(3 * VECTOR_SIZE) as *const __m128i);
  138|      0|        let eqa = _mm_cmpeq_epi8(vn1, a);
  139|      0|        let eqb = _mm_cmpeq_epi8(vn1, b);
  140|      0|        let eqc = _mm_cmpeq_epi8(vn1, c);
  141|      0|        let eqd = _mm_cmpeq_epi8(vn1, d);
  142|      0|        let or1 = _mm_or_si128(eqa, eqb);
  143|      0|        let or2 = _mm_or_si128(eqc, eqd);
  144|      0|        let or3 = _mm_or_si128(or1, or2);
  145|      0|        if _mm_movemask_epi8(or3) != 0 {
  146|      0|            let mut at = sub(ptr, start_ptr);
  147|      0|            let mask = _mm_movemask_epi8(eqa);
  148|      0|            if mask != 0 {
  149|      0|                return Some(at + forward_pos(mask));
  150|      0|            }
  151|      0|
  152|      0|            at += VECTOR_SIZE;
  153|      0|            let mask = _mm_movemask_epi8(eqb);
  154|      0|            if mask != 0 {
  155|      0|                return Some(at + forward_pos(mask));
  156|      0|            }
  157|      0|
  158|      0|            at += VECTOR_SIZE;
  159|      0|            let mask = _mm_movemask_epi8(eqc);
  160|      0|            if mask != 0 {
  161|      0|                return Some(at + forward_pos(mask));
  162|      0|            }
  163|      0|
  164|      0|            at += VECTOR_SIZE;
  165|      0|            let mask = _mm_movemask_epi8(eqd);
  166|      0|            debug_assert!(mask != 0);
  167|      0|            return Some(at + forward_pos(mask));
  168|      0|        }
  169|      0|        ptr = ptr.add(loop_size);
  170|       |    }
  171|     92|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  172|      0|        debug_assert!(sub(end_ptr, ptr) >= VECTOR_SIZE);
  173|       |
  174|     15|        if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  175|      4|            return Some(i);
  176|     11|        }
  177|     11|        ptr = ptr.add(VECTOR_SIZE);
  178|       |    }
  179|     77|    if ptr < end_ptr {
  180|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  181|     63|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  182|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  183|       |
  184|     63|        return forward_search1(start_ptr, end_ptr, ptr, vn1);
  185|     14|    }
  186|     14|    None
  187|  1.07k|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x864sse215forward_search1:
  569|    468|pub unsafe fn forward_search1(
  570|    468|    start_ptr: *const u8,
  571|    468|    end_ptr: *const u8,
  572|    468|    ptr: *const u8,
  573|    468|    vn1: __m128i,
  574|    468|) -> Option<usize> {
  575|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  576|      0|    debug_assert!(start_ptr <= ptr);
  577|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  578|       |
  579|    468|    let chunk = _mm_loadu_si128(ptr as *const __m128i);
  580|    468|    let mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, vn1));
  581|    468|    if mask != 0 {
  582|    322|        Some(sub(ptr, start_ptr) + forward_pos(mask))
  583|       |    } else {
  584|    146|        None
  585|       |    }
  586|    468|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x864sse211forward_pos:
  716|    322|fn forward_pos(mask: i32) -> usize {
  717|    322|    // We are dealing with little endian here, where the most significant byte
  718|    322|    // is at a higher address. That means the least significant bit that is set
  719|    322|    // corresponds to the position of our first matching byte. That position
  720|    322|    // corresponds to the number of zeros after the least significant bit.
  721|    322|    mask.trailing_zeros() as usize
  722|    322|}
_RNvNtNtNtCs1B8jV3ef48P_6memchr6memchr3x864sse23sub:
  788|    798|fn sub(a: *const u8, b: *const u8) -> usize {
  789|      0|    debug_assert!(a >= b);
  790|    798|    (a as usize) - (b as usize)
  791|    798|}

_RNvMs2_NtCs1ZGo2WHpFn6_9once_cell3impINtB5_8OnceCellNtNtCs9lXrf61Tc6r_5alloc6string6StringE14is_initializedCs5rGtGqFKXa_13libfuzzer_sys:
   59|    649|    pub(crate) fn is_initialized(&self) -> bool {
   60|    649|        // An `Acquire` load is enough because that makes all the initialization
   61|    649|        // operations visible to us, and, this being a fast path, weaker
   62|    649|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    649|        // `SeqCst` operations on the slow path.
   64|    649|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    649|    }

_RNvMs4_NtCs1ZGo2WHpFn6_9once_cell4syncINtB5_8OnceCellNtNtCs9lXrf61Tc6r_5alloc6string6StringE3getCs5rGtGqFKXa_13libfuzzer_sys:
  967|    649|        pub fn get(&self) -> Option<&T> {
  968|    649|            if self.0.is_initialized() {
  969|       |                // Safe b/c value is initialized.
  970|      0|                Some(unsafe { self.get_unchecked() })
  971|       |            } else {
  972|    649|                None
  973|       |            }
  974|    649|        }

_RNvMs_NtCsiptRIqLjvkg_9quick_xml8encodingNtB4_7Decoder6decode:
   81|    441|    pub fn decode<'b>(&self, bytes: &'b [u8]) -> Result<Cow<'b, str>> {
   82|       |        #[cfg(not(feature = "encoding"))]
   83|    441|        let decoded = Ok(Cow::Borrowed(std::str::from_utf8(bytes)?));
   84|       |
   85|       |        #[cfg(feature = "encoding")]
   86|       |        let decoded = decode(bytes, self.encoding);
   87|       |
   88|    330|        decoded
   89|    441|    }

_RNvXs1_NtCsiptRIqLjvkg_9quick_xml6errorsNtB5_5ErrorINtNtCs9jyDXsa31Er_4core7convert4FromNtNtB7_7escapei11EscapeErrorE4fromB7_:
   75|     81|    fn from(error: EscapeError) -> Error {
   76|     81|        Error::EscapeError(error)
   77|     81|    }
_RNvXs_NtCsiptRIqLjvkg_9quick_xml6errorsNtB4_5ErrorINtNtCs9jyDXsa31Er_4core7convert4FromNtNtNtBR_3str5error9Utf8ErrorE4fromB6_:
   59|    111|    fn from(error: Utf8Error) -> Error {
   60|    111|        Error::NonDecodable(Some(error))
   61|    111|    }

_RNvNtCsiptRIqLjvkg_9quick_xml7escapei13parse_decimal:
 1725|  1.06k|fn parse_decimal(bytes: &str) -> Result<u32, EscapeError> {
 1726|  1.06k|    // maximum code is 0x10FFFF = 1114111 => 7 characters
 1727|  1.06k|    if bytes.len() > 7 {
 1728|      2|        return Err(EscapeError::TooLongDecimal);
 1729|  1.06k|    }
 1730|  1.06k|    let mut code = 0;
 1731|  5.18k|    for b in bytes.bytes() {
 1732|  5.18k|        code *= 10;
 1733|  5.18k|        code += match b {
 1734|  5.17k|            b'0'..=b'9' => b - b'0',
 1735|     10|            b => return Err(EscapeError::InvalidDecimal(b as char)),
 1736|       |        } as u32;
 1737|       |    }
 1738|  1.05k|    Ok(code)
 1739|  1.06k|}
_RNCINvNtCsiptRIqLjvkg_9quick_xml7escapei13unescape_withNCNvMs7_NtB6_6eventsNtBZ_9BytesText8unescape0E0B6_:
  172|  3.17k|    while let Some(start) = iter.by_ref().find(|p| bytes[*p] == b'&') {
_RINvNtCsiptRIqLjvkg_9quick_xml7escapei13unescape_withNCNvMs7_NtB4_6eventsNtBX_9BytesText8unescape0EB4_:
  160|    251|pub fn unescape_with<'input, 'entity, F>(
  161|    251|    raw: &'input str,
  162|    251|    mut resolve_entity: F,
  163|    251|) -> Result<Cow<'input, str>, EscapeError>
  164|    251|where
  165|    251|    // the lifetime of the output comes from a capture or is `'static`
  166|    251|    F: FnMut(&str) -> Option<&'entity str>,
  167|    251|{
  168|    251|    let bytes = raw.as_bytes();
  169|    251|    let mut unescaped = None;
  170|    251|    let mut last_end = 0;
  171|    251|    let mut iter = memchr2_iter(b'&', b';', bytes);
  172|  1.72k|    while let Some(start) = iter.by_ref().find(|p| bytes[*p] == b'&') {
  173|  1.55k|        match iter.next() {
  174|  1.53k|            Some(end) if bytes[end] == b';' => {
  175|  1.53k|                // append valid data
  176|  1.53k|                if unescaped.is_none() {
  177|    170|                    unescaped = Some(String::with_capacity(raw.len()));
  178|  1.36k|                }
  179|  1.53k|                let unescaped = unescaped.as_mut().expect("initialized");
  180|  1.53k|                unescaped.push_str(&raw[last_end..start]);
  181|  1.53k|
  182|  1.53k|                // search for character correctness
  183|  1.53k|                let pat = &raw[start + 1..end];
  184|  1.53k|                if let Some(entity) = pat.strip_prefix('#') {
  185|  1.28k|                    let codepoint = parse_number(entity, start..end)?;
  186|  1.25k|                    unescaped.push_str(codepoint.encode_utf8(&mut [0u8; 4]));
  187|    250|                } else if let Some(value) = named_entity(pat) {
  188|    217|                    unescaped.push_str(value);
  189|    217|                } else if let Some(value) = resolve_entity(pat) {
  190|      0|                    unescaped.push_str(value);
  191|      0|                } else {
  192|     33|                    return Err(EscapeError::UnrecognizedSymbol(
  193|     33|                        start + 1..end,
  194|     33|                        pat.to_string(),
  195|     33|                    ));
  196|       |                }
  197|       |
  198|  1.46k|                last_end = end + 1;
  199|       |            }
  200|     19|            _ => return Err(EscapeError::UnterminatedEntity(start..raw.len())),
  201|       |        }
  202|       |    }
  203|       |
  204|    170|    if let Some(mut unescaped) = unescaped {
  205|     98|        if let Some(raw) = raw.get(last_end..) {
  206|     98|            unescaped.push_str(raw);
  207|     98|        }
  208|     98|        Ok(Cow::Owned(unescaped))
  209|       |    } else {
  210|     72|        Ok(Cow::Borrowed(raw))
  211|       |    }
  212|    251|}
_RNvNtCsiptRIqLjvkg_9quick_xml7escapei17parse_hexadecimal:
 1707|    212|fn parse_hexadecimal(bytes: &str) -> Result<u32, EscapeError> {
 1708|    212|    // maximum code is 0x10FFFF => 6 characters
 1709|    212|    if bytes.len() > 6 {
 1710|      1|        return Err(EscapeError::TooLongHexadecimal);
 1711|    211|    }
 1712|    211|    let mut code = 0;
 1713|    684|    for b in bytes.bytes() {
 1714|    684|        code <<= 4;
 1715|    684|        code += match b {
 1716|    680|            b'0'..=b'9' => b - b'0',
 1717|     66|            b'a'..=b'f' => b - b'a' + 10,
 1718|     71|            b'A'..=b'F' => b - b'A' + 10,
 1719|      7|            b => return Err(EscapeError::InvalidHexadecimal(b as char)),
 1720|       |        } as u32;
 1721|       |    }
 1722|    204|    Ok(code)
 1723|    212|}
_RNvNtCsiptRIqLjvkg_9quick_xml7escapei12named_entity:
  215|    250|fn named_entity(name: &str) -> Option<&str> {
  216|       |    // match over strings are not allowed in const functions
  217|    250|    let s = match name.as_bytes() {
  218|    250|        b"lt" => "<",
  219|     78|        b"gt" => ">",
  220|     95|        b"amp" => "&",
  221|     19|        b"apos" => "'",
  222|      0|        b"quot" => "\"",
  223|     33|        _ => return None,
  224|       |    };
  225|    217|    Some(s)
  226|    250|}
_RNvNtCsiptRIqLjvkg_9quick_xml7escapei12parse_number:
 1692|  1.28k|fn parse_number(bytes: &str, range: Range<usize>) -> Result<char, EscapeError> {
 1693|  1.28k|    let code = if let Some(hex_digits) = bytes.strip_prefix('x') {
 1694|    212|        parse_hexadecimal(hex_digits)
 1695|       |    } else {
 1696|  1.06k|        parse_decimal(bytes)
 1697|     20|    }?;
 1698|  1.26k|    if code == 0 {
 1699|      5|        return Err(EscapeError::EntityWithNull(range));
 1700|  1.25k|    }
 1701|  1.25k|    match std::char::from_u32(code) {
 1702|  1.25k|        Some(c) => Ok(c),
 1703|      4|        None => Err(EscapeError::InvalidCodepoint(code)),
 1704|       |    }
 1705|  1.28k|}

_RNvMNtCsiptRIqLjvkg_9quick_xml6eventsNtB2_10BytesStart4nameCslt04TQWGvnL_13oxigraph_fuzz:
  170|    202|    pub fn name(&self) -> QName {
  171|    202|        QName(&self.buf[..self.name_len])
  172|    202|    }
_RNvMNtCsiptRIqLjvkg_9quick_xml6eventsNtB2_10BytesStart10local_nameCslt04TQWGvnL_13oxigraph_fuzz:
  179|    101|    pub fn local_name(&self) -> LocalName {
  180|    101|        self.name().into()
  181|    101|    }
_RINvMs7_NtCsiptRIqLjvkg_9quick_xml6eventsNtB6_9BytesText4wrapRShEB8_:
  684|  1.34k|    pub(crate) fn wrap<C: Into<Cow<'a, [u8]>>>(content: C, decoder: Decoder) -> Self {
  685|  1.34k|        Self {
  686|  1.34k|            content: content.into(),
  687|  1.34k|            decoder,
  688|  1.34k|        }
  689|  1.34k|    }
_RNCNvMs7_NtCsiptRIqLjvkg_9quick_xml6eventsNtB7_9BytesText8unescape0B9_:
  734|     33|        self.unescape_with(|_| None)
_RNvMNtCsiptRIqLjvkg_9quick_xml6eventsNtB2_10BytesStart4wrapB4_:
   79|    101|    pub(crate) fn wrap(content: &'a [u8], name_len: usize) -> Self {
   80|    101|        BytesStart {
   81|    101|            buf: Cow::Borrowed(content),
   82|    101|            name_len,
   83|    101|        }
   84|    101|    }
_RINvMs7_NtCsiptRIqLjvkg_9quick_xml6eventsNtB6_9BytesText13unescape_withNCNvB2_8unescape0EB8_:
  741|    294|    pub fn unescape_with<'entity>(
  742|    294|        &self,
  743|    294|        resolve_entity: impl FnMut(&str) -> Option<&'entity str>,
  744|    294|    ) -> Result<Cow<'a, str>> {
  745|    294|        let decoded = match &self.content {
  746|    294|            Cow::Borrowed(bytes) => self.decoder.decode(bytes)?,
  747|       |            // Convert to owned, because otherwise Cow will be bound with wrong lifetime
  748|      0|            Cow::Owned(bytes) => self.decoder.decode(bytes)?.into_owned().into(),
  749|       |        };
  750|       |
  751|    251|        match unescape_with(&decoded, resolve_entity)? {
  752|       |            // Because result is borrowed, no replacements was done and we can use original string
  753|     72|            Cow::Borrowed(_) => Ok(decoded),
  754|     98|            Cow::Owned(s) => Ok(s.into()),
  755|       |        }
  756|    294|    }
_RNvMs7_NtCsiptRIqLjvkg_9quick_xml6eventsNtB5_9BytesText8unescape:
  733|    294|    pub fn unescape(&self) -> Result<Cow<'a, str>> {
  734|    294|        self.unescape_with(|_| None)
  735|    294|    }

_RNCNvXs4_NtCsiptRIqLjvkg_9quick_xml4nameNtB7_9LocalNameINtNtCs9jyDXsa31Er_4core7convert4FromNtB7_5QNameE4from0Cslt04TQWGvnL_13oxigraph_fuzz:
  174|      3|        Self(name.index().map_or(name.0, |i| &name.0[i + 1..]))
_RNvXs3_NtCsiptRIqLjvkg_9quick_xml4nameNtB5_9LocalNameINtNtCs9jyDXsa31Er_4core7convert5AsRefShE6as_refCslt04TQWGvnL_13oxigraph_fuzz:
  154|    101|    fn as_ref(&self) -> &[u8] {
  155|    101|        self.0
  156|    101|    }
_RNvMNtCsiptRIqLjvkg_9quick_xml4nameNtB2_5QName5index:
  111|    101|    fn index(&self) -> Option<usize> {
  112|    101|        memchr(b':', self.0)
  113|    101|    }
_RNvXs0_NtCsiptRIqLjvkg_9quick_xml4nameNtB5_5QNameINtNtCs9jyDXsa31Er_4core7convert5AsRefShE6as_refCslt04TQWGvnL_13oxigraph_fuzz:
  124|    101|    fn as_ref(&self) -> &[u8] {
  125|    101|        self.0
  126|    101|    }
_RNvXs4_NtCsiptRIqLjvkg_9quick_xml4nameNtB5_9LocalNameINtNtCs9jyDXsa31Er_4core7convert4FromNtB5_5QNameE4fromCslt04TQWGvnL_13oxigraph_fuzz:
  173|    101|    fn from(name: QName<'a>) -> Self {
  174|    101|        Self(name.index().map_or(name.0, |i| &name.0[i + 1..]))
  175|    101|    }

_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE15remove_utf8_bomCslt04TQWGvnL_13oxigraph_fuzz:
   18|    649|        $($async)? fn remove_utf8_bom(&mut self) -> Result<()> {
   19|       |            use crate::encoding::UTF8_BOM;
   20|       |
   21|    649|            loop {
   22|    649|                break match self $(.$reader)? .fill_buf() $(.$await)? {
   23|    649|                    Ok(n) => {
   24|    649|                        if n.starts_with(UTF8_BOM) {
   25|      1|                            self $(.$reader)? .consume(UTF8_BOM.len());
   26|    648|                        }
   27|    649|                        Ok(())
   28|       |                    },
   29|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
   30|      0|                    Err(e) => Err(Error::Io(e.into())),
   31|       |                };
   32|       |            }
   33|    649|        }
_RNCNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB6_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE15skip_whitespace0Cslt04TQWGvnL_13oxigraph_fuzz:
  250|  2.70k|    impl_buffered_source!();
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE16read_bytes_untilCslt04TQWGvnL_13oxigraph_fuzz:
   52|    885|        $($async)? fn read_bytes_until $(<$lf>)? (
   53|    885|            &mut self,
   54|    885|            byte: u8,
   55|    885|            buf: &'b mut Vec<u8>,
   56|    885|            position: &mut usize,
   57|    885|        ) -> Result<Option<&'b [u8]>> {
   58|       |            // search byte must be within the ascii range
   59|      0|            debug_assert!(byte.is_ascii());
   60|       |
   61|    885|            let mut read = 0;
   62|    885|            let mut done = false;
   63|    885|            let start = buf.len();
   64|  1.73k|            while !done {
   65|    849|                let used = {
   66|  1.22k|                    let available = match self $(.$reader)? .fill_buf() $(.$await)? {
   67|  1.22k|                        Ok(n) if n.is_empty() => break,
   68|    849|                        Ok(n) => n,
   69|      0|                        Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
   70|      0|                        Err(e) => {
   71|      0|                            *position += read;
   72|      0|                            return Err(Error::Io(e.into()));
   73|       |                        }
   74|       |                    };
   75|       |
   76|    849|                    match memchr::memchr(byte, available) {
   77|    513|                        Some(i) => {
   78|    513|                            buf.extend_from_slice(&available[..i]);
   79|    513|                            done = true;
   80|    513|                            i + 1
   81|       |                        }
   82|       |                        None => {
   83|    336|                            buf.extend_from_slice(available);
   84|    336|                            available.len()
   85|       |                        }
   86|       |                    }
   87|       |                };
   88|    849|                self $(.$reader)? .consume(used);
   89|    849|                read += used;
   90|       |            }
   91|    885|            *position += read;
   92|    885|
   93|    885|            if read == 0 {
   94|     36|                Ok(None)
   95|       |            } else {
   96|    849|                Ok(Some(&buf[start..]))
   97|       |            }
   98|    885|        }
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE8peek_oneCslt04TQWGvnL_13oxigraph_fuzz:
  231|  3.77k|        $($async)? fn peek_one(&mut self) -> Result<Option<u8>> {
  232|  3.77k|            loop {
  233|  3.77k|                break match self $(.$reader)? .fill_buf() $(.$await)? {
  234|  3.77k|                    Ok(n) if n.is_empty() => Ok(None),
  235|  3.73k|                    Ok(n) => Ok(Some(n[0])),
  236|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  237|      0|                    Err(e) => Err(Error::Io(e.into())),
  238|       |                };
  239|       |            }
  240|  3.77k|        }
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE17read_bang_elementCslt04TQWGvnL_13oxigraph_fuzz:
  100|    711|        $($async)? fn read_bang_element $(<$lf>)? (
  101|    711|            &mut self,
  102|    711|            buf: &'b mut Vec<u8>,
  103|    711|            position: &mut usize,
  104|    711|        ) -> Result<Option<(BangType, &'b [u8])>> {
  105|    711|            // Peeked one bang ('!') before being called, so it's guaranteed to
  106|    711|            // start with it.
  107|    711|            let start = buf.len();
  108|    711|            let mut read = 1;
  109|    711|            buf.push(b'!');
  110|    711|            self $(.$reader)? .consume(1);
  111|       |
  112|    711|            let bang_type = BangType::new(self.peek_one() $(.$await)? ?)?;
  113|       |
  114|    818|            loop {
  115|    818|                match self $(.$reader)? .fill_buf() $(.$await)? {
  116|       |                    // Note: Do not update position, so the error points to
  117|       |                    // somewhere sane rather than at the EOF
  118|    818|                    Ok(n) if n.is_empty() => return Err(bang_type.to_err()),
  119|    707|                    Ok(available) => {
  120|    707|                        if let Some((consumed, used)) = bang_type.parse(buf, available) {
  121|    596|                            buf.extend_from_slice(consumed);
  122|    596|
  123|    596|                            self $(.$reader)? .consume(used);
  124|    596|                            read += used;
  125|    596|
  126|    596|                            *position += read;
  127|    596|                            break;
  128|    111|                        } else {
  129|    111|                            buf.extend_from_slice(available);
  130|    111|
  131|    111|                            let used = available.len();
  132|    111|                            self $(.$reader)? .consume(used);
  133|    111|                            read += used;
  134|    111|                        }
  135|       |                    }
  136|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  137|      0|                    Err(e) => {
  138|      0|                        *position += read;
  139|      0|                        return Err(Error::Io(e.into()));
  140|       |                    }
  141|       |                }
  142|       |            }
  143|       |
  144|    596|            if read == 0 {
  145|      0|                Ok(None)
  146|       |            } else {
  147|    596|                Ok(Some((bang_type, &buf[start..])))
  148|       |            }
  149|    711|        }
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE8skip_oneCslt04TQWGvnL_13oxigraph_fuzz:
  217|  1.69k|        $($async)? fn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool> {
  218|       |            // search byte must be within the ascii range
  219|      0|            debug_assert!(byte.is_ascii());
  220|       |
  221|  1.69k|            match self.peek_one() $(.$await)? ? {
  222|  1.66k|                Some(b) if b == byte => {
  223|  1.36k|                    *position += 1;
  224|  1.36k|                    self $(.$reader)? .consume(1);
  225|  1.36k|                    Ok(true)
  226|       |                }
  227|    330|                _ => Ok(false),
  228|       |            }
  229|  1.69k|        }
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE12read_elementCslt04TQWGvnL_13oxigraph_fuzz:
  152|    101|        $($async)? fn read_element $(<$lf>)? (
  153|    101|            &mut self,
  154|    101|            buf: &'b mut Vec<u8>,
  155|    101|            position: &mut usize,
  156|    101|        ) -> Result<Option<&'b [u8]>> {
  157|    101|            let mut state = ReadElementState::Elem;
  158|    101|            let mut read = 0;
  159|    101|
  160|    101|            let start = buf.len();
  161|       |            loop {
  162|    196|                match self $(.$reader)? .fill_buf() $(.$await)? {
  163|    196|                    Ok(n) if n.is_empty() => break,
  164|    101|                    Ok(available) => {
  165|    101|                        if let Some((consumed, used)) = state.change(available) {
  166|      6|                            buf.extend_from_slice(consumed);
  167|      6|
  168|      6|                            self $(.$reader)? .consume(used);
  169|      6|                            read += used;
  170|      6|
  171|      6|                            // Position now just after the `>` symbol
  172|      6|                            *position += read;
  173|      6|                            break;
  174|     95|                        } else {
  175|     95|                            // The `>` symbol not yet found, continue reading
  176|     95|                            buf.extend_from_slice(available);
  177|     95|
  178|     95|                            let used = available.len();
  179|     95|                            self $(.$reader)? .consume(used);
  180|     95|                            read += used;
  181|     95|                        }
  182|       |                    }
  183|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  184|      0|                    Err(e) => {
  185|      0|                        *position += read;
  186|      0|                        return Err(Error::Io(e.into()));
  187|       |                    }
  188|       |                };
  189|       |            }
  190|       |
  191|    101|            if read == 0 {
  192|      0|                Ok(None)
  193|       |            } else {
  194|    101|                Ok(Some(&buf[start..]))
  195|       |            }
  196|    101|        }
_RNvXNtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEE15skip_whitespaceCslt04TQWGvnL_13oxigraph_fuzz:
  198|  1.69k|        $($async)? fn skip_whitespace(&mut self, position: &mut usize) -> Result<()> {
  199|  1.77k|            loop {
  200|  1.77k|                break match self $(.$reader)? .fill_buf() $(.$await)? {
  201|  1.77k|                    Ok(n) => {
  202|  1.77k|                        let count = n.iter().position(|b| !is_whitespace(*b)).unwrap_or(n.len());
  203|  1.77k|                        if count > 0 {
  204|     75|                            self $(.$reader)? .consume(count);
  205|     75|                            *position += count;
  206|     75|                            continue;
  207|       |                        } else {
  208|  1.69k|                            Ok(())
  209|       |                        }
  210|       |                    }
  211|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  212|      0|                    Err(e) => Err(Error::Io(e.into())),
  213|       |                };
  214|       |            }
  215|  1.69k|        }
_RNvMs_NtNtCsiptRIqLjvkg_9quick_xml6reader15buffered_readerINtB6_6ReaderRShE15read_event_intoCslt04TQWGvnL_13oxigraph_fuzz:
  301|  1.69k|    pub fn read_event_into<'b>(&mut self, buf: &'b mut Vec<u8>) -> Result<Event<'b>> {
  302|  1.69k|        self.read_event_impl(buf)
  303|  1.69k|    }

_RNvMs2_NtCsiptRIqLjvkg_9quick_xml6readerNtB5_16ReadElementState6change:
  902|    101|    fn change<'b>(&mut self, chunk: &'b [u8]) -> Option<(&'b [u8], usize)> {
  903|  1.72k|        for i in memchr::memchr3_iter(b'>', b'\'', b'"', chunk) {
  904|  1.72k|            *self = match (*self, chunk[i]) {
  905|       |                // only allowed to match `>` while we are in state `Elem`
  906|      6|                (Self::Elem, b'>') => return Some((&chunk[..i], i + 1)),
  907|    434|                (Self::Elem, b'\'') => Self::SingleQ,
  908|    241|                (Self::Elem, b'\"') => Self::DoubleQ,
  909|       |
  910|       |                // the only end_byte that gets us out if the same character
  911|    643|                (Self::SingleQ, b'\'') | (Self::DoubleQ, b'"') => Self::Elem,
  912|       |
  913|       |                // all other bytes: no state change
  914|    402|                _ => *self,
  915|       |            };
  916|       |        }
  917|     95|        None
  918|    101|    }
_RNvMs1_NtCsiptRIqLjvkg_9quick_xml6readerNtB5_8BangType5parse:
  822|    707|    fn parse<'b>(&self, buf: &[u8], chunk: &'b [u8]) -> Option<(&'b [u8], usize)> {
  823|  4.69k|        for i in memchr::memchr_iter(b'>', chunk) {
  824|    919|            match self {
  825|    919|                // Need to read at least 6 symbols (`!---->`) for properly finished comment
  826|    919|                // <!----> - XML comment
  827|    919|                //  012345 - i
  828|    919|                Self::Comment if buf.len() + i > 4 => {
  829|    793|                    if chunk[..i].ends_with(b"--") {
  830|       |                        // We cannot strip last `--` from the buffer because we need it in case of
  831|       |                        // check_comments enabled option. XML standard requires that comment
  832|       |                        // will not end with `--->` sequence because this is a special case of
  833|       |                        // `--` in the comment (https://www.w3.org/TR/xml11/#sec-comments)
  834|    561|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  835|    232|                    }
  836|    232|                    // End sequence `-|->` was splitted at |
  837|    232|                    //        buf --/   \-- chunk
  838|    232|                    if i == 1 && buf.ends_with(b"-") && chunk[0] == b'-' {
  839|      0|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  840|    232|                    }
  841|    232|                    // End sequence `--|>` was splitted at |
  842|    232|                    //         buf --/   \-- chunk
  843|    232|                    if i == 0 && buf.ends_with(b"--") {
  844|      0|                        return Some((&[], i + 1)); // +1 for `>`
  845|    232|                    }
  846|       |                }
  847|    126|                Self::Comment => {}
  848|       |                Self::CData => {
  849|  1.30k|                    if chunk[..i].ends_with(b"]]") {
  850|      4|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  851|  1.29k|                    }
  852|  1.29k|                    // End sequence `]|]>` was splitted at |
  853|  1.29k|                    //        buf --/   \-- chunk
  854|  1.29k|                    if i == 1 && buf.ends_with(b"]") && chunk[0] == b']' {
  855|      0|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  856|  1.29k|                    }
  857|  1.29k|                    // End sequence `]]|>` was splitted at |
  858|  1.29k|                    //         buf --/   \-- chunk
  859|  1.29k|                    if i == 0 && buf.ends_with(b"]]") {
  860|      0|                        return Some((&[], i + 1)); // +1 for `>`
  861|  1.29k|                    }
  862|       |                }
  863|       |                Self::DocType => {
  864|  2.47k|                    let content = &chunk[..i];
  865|  2.47k|                    let balance = memchr::memchr2_iter(b'<', b'>', content)
  866|  2.47k|                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })
  867|  2.47k|                        .sum::<i32>();
  868|  2.47k|                    if balance == 0 {
  869|     31|                        return Some((content, i + 1)); // +1 for `>`
  870|  2.44k|                    }
  871|       |                }
  872|       |            }
  873|       |        }
  874|    111|        None
  875|    707|    }
_RNvMs1_NtCsiptRIqLjvkg_9quick_xml6readerNtB5_8BangType3new:
  805|    711|    fn new(byte: Option<u8>) -> Result<Self> {
  806|    711|        Ok(match byte {
  807|     59|            Some(b'[') => Self::CData,
  808|    586|            Some(b'-') => Self::Comment,
  809|     62|            Some(b'D') | Some(b'd') => Self::DocType,
  810|      3|            Some(b) => return Err(Error::UnexpectedBang(b)),
  811|      1|            None => return Err(Error::UnexpectedEof("Bang".to_string())),
  812|       |        })
  813|    711|    }
_RNvMs1_NtCsiptRIqLjvkg_9quick_xml6readerNtB5_8BangType6to_errCslt04TQWGvnL_13oxigraph_fuzz:
  877|    111|    fn to_err(&self) -> Error {
  878|    111|        let bang_str = match self {
  879|     55|            Self::CData => "CData",
  880|     25|            Self::Comment => "Comment",
  881|     31|            Self::DocType => "DOCTYPE",
  882|       |        };
  883|    111|        Error::UnexpectedEof(bang_str.to_string())
  884|    111|    }
_RNvNtCsiptRIqLjvkg_9quick_xml6reader13is_whitespaceCslt04TQWGvnL_13oxigraph_fuzz:
  923|  2.70k|pub(crate) const fn is_whitespace(b: u8) -> bool {
  924|  2.70k|    matches!(b, b' ' | b'\r' | b'\n' | b'\t')
  925|  2.70k|}
_RINvMs0_NtCsiptRIqLjvkg_9quick_xml6readerINtB6_6ReaderRShE15read_event_implQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEECslt04TQWGvnL_13oxigraph_fuzz:
  643|  1.69k|    fn read_event_impl<'i, B>(&mut self, mut buf: B) -> Result<Event<'i>>
  644|  1.69k|    where
  645|  1.69k|        R: XmlSource<'i, B>,
  646|  1.69k|    {
  647|  3.06k|        read_event_impl!(self, buf, self.reader, read_until_open, read_until_close)
  648|  1.69k|    }
_RINvMs0_NtCsiptRIqLjvkg_9quick_xml6readerINtB6_6ReaderRShE16read_until_closeQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEECslt04TQWGvnL_13oxigraph_fuzz:
  663|  1.36k|    fn read_until_close<'i, B>(&mut self, buf: B) -> Result<Event<'i>>
  664|  1.36k|    where
  665|  1.36k|        R: XmlSource<'i, B>,
  666|  1.36k|    {
  667|  1.36k|        read_until_close!(self, buf, self.reader)
  668|  1.36k|    }
_RINvMs0_NtCsiptRIqLjvkg_9quick_xml6readerINtB6_6ReaderRShE15read_until_openQINtNtCs9lXrf61Tc6r_5alloc3vec3VechEECslt04TQWGvnL_13oxigraph_fuzz:
  654|  1.69k|    fn read_until_open<'i, B>(&mut self, buf: B) -> Result<std::result::Result<Event<'i>, B>>
  655|  1.69k|    where
  656|  1.69k|        R: XmlSource<'i, B>,
  657|  1.69k|    {
  658|  1.69k|        read_until_open!(self, buf, self.reader, read_event_impl)
  659|  1.69k|    }
_RNvMNtCsiptRIqLjvkg_9quick_xml6readerINtB2_6ReaderRShE21expand_empty_elementsCslt04TQWGvnL_13oxigraph_fuzz:
   33|    649|        pub fn expand_empty_elements(&mut self, val: bool) -> &mut Self {
   34|    649|            self $(.$holder)? .parser.expand_empty_elements = val;
   35|    649|            self
   36|    649|        }
_RNvMNtCsiptRIqLjvkg_9quick_xml6readerINtB2_6ReaderRShE9trim_textCslt04TQWGvnL_13oxigraph_fuzz:
   60|    649|        pub fn trim_text(&mut self, val: bool) -> &mut Self {
   61|    649|            self $(.$holder)? .parser.trim_text_start = val;
   62|    649|            self $(.$holder)? .parser.trim_text_end = val;
   63|    649|            self
   64|    649|        }
_RNvNtCsiptRIqLjvkg_9quick_xml6reader13is_whitespaceB3_:
  923|  5.43k|pub(crate) const fn is_whitespace(b: u8) -> bool {
  924|  5.43k|    matches!(b, b' ' | b'\r' | b'\n' | b'\t')
  925|  5.43k|}
_RNvMs1_NtCsiptRIqLjvkg_9quick_xml6readerNtB5_8BangType6to_errB7_:
  877|     37|    fn to_err(&self) -> Error {
  878|     37|        let bang_str = match self {
  879|      4|            Self::CData => "CData",
  880|      2|            Self::Comment => "Comment",
  881|     31|            Self::DocType => "DOCTYPE",
  882|       |        };
  883|     37|        Error::UnexpectedEof(bang_str.to_string())
  884|     37|    }
_RNCNvMs1_NtCsiptRIqLjvkg_9quick_xml6readerNtB7_8BangType5parse0B9_:
  866|   553k|                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })
_RNvMs_NtCsiptRIqLjvkg_9quick_xml6readerINtB4_6ReaderRShE7decoderB6_:
  633|    101|    pub fn decoder(&self) -> Decoder {
  634|    101|        self.parser.decoder()
  635|    101|    }
_RNvMNtCsiptRIqLjvkg_9quick_xml6readerINtB2_6ReaderRShE11from_readerB4_:
  533|    649|    pub fn from_reader(reader: R) -> Self {
  534|    649|        Self {
  535|    649|            reader,
  536|    649|            parser: Parser::default(),
  537|    649|        }
  538|    649|    }

_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser9read_bang0B8_:
   86|     35|        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {
   87|     35|            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)
   88|     35|        };
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser18read_question_mark:
  183|    509|    pub fn read_question_mark<'b>(&mut self, buf: &'b [u8]) -> Result<Event<'b>> {
  184|    509|        let len = buf.len();
  185|    509|        if len > 2 && buf[len - 1] == b'?' {
  186|    490|            if len > 5 && &buf[1..4] == b"xml" && is_whitespace(buf[4]) {
  187|      0|                let event = BytesDecl::from_start(BytesStart::wrap(&buf[1..len - 1], 3));
  188|      0|
  189|      0|                // Try getting encoding from the declaration event
  190|      0|                #[cfg(feature = "encoding")]
  191|      0|                if self.encoding.can_be_refined() {
  192|      0|                    if let Some(encoding) = event.encoder() {
  193|      0|                        self.encoding = EncodingRef::XmlDetected(encoding);
  194|      0|                    }
  195|      0|                }
  196|      0|
  197|      0|                Ok(Event::Decl(event))
  198|       |            } else {
  199|    490|                Ok(Event::PI(BytesText::wrap(&buf[1..len - 1], self.decoder())))
  200|       |            }
  201|       |        } else {
  202|     19|            self.offset -= len;
  203|     19|            Err(Error::UnexpectedEof("XmlDecl".to_string()))
  204|       |        }
  205|    509|    }
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser7decoder:
  256|  1.49k|    pub fn decoder(&self) -> Decoder {
  257|  1.49k|        Decoder {
  258|  1.49k|            #[cfg(feature = "encoding")]
  259|  1.49k|            encoding: self.encoding.encoding(),
  260|  1.49k|        }
  261|  1.49k|    }
_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser9read_texts0_0B8_:
   76|    294|                .map_or_else(|| bytes.len(), |p| p + 1);
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser8read_end:
  132|     46|    pub fn read_end<'b>(&mut self, buf: &'b [u8]) -> Result<Event<'b>> {
  133|       |        // XML standard permits whitespaces after the markup name in closing tags.
  134|       |        // Let's strip them from the buffer before comparing tag names.
  135|     46|        let name = if self.trim_markup_names_in_closing_tags {
  136|     46|            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {
  137|     13|                let (name, _) = buf[1..].split_at(pos_end_name + 1);
  138|     13|                name
  139|       |            } else {
  140|     33|                &buf[1..]
  141|       |            }
  142|       |        } else {
  143|      0|            &buf[1..]
  144|       |        };
  145|       |
  146|     46|        let decoder = self.decoder();
  147|     46|        let mismatch_err = |expected: String, found: &[u8], offset: &mut usize| {
  148|       |            *offset -= buf.len();
  149|       |            Err(Error::EndEventMismatch {
  150|       |                expected,
  151|       |                found: decoder.decode(found).unwrap_or_default().into_owned(),
  152|       |            })
  153|       |        };
  154|       |
  155|       |        // Get the index in self.opened_buffer of the name of the last opened tag
  156|     46|        match self.opened_starts.pop() {
  157|      0|            Some(start) => {
  158|      0|                if self.check_end_names {
  159|      0|                    let expected = &self.opened_buffer[start..];
  160|      0|                    if name != expected {
  161|      0|                        let expected = decoder.decode(expected).unwrap_or_default().into_owned();
  162|      0|                        // #513: In order to allow error recovery we should drop content of the buffer
  163|      0|                        self.opened_buffer.truncate(start);
  164|      0|
  165|      0|                        return mismatch_err(expected, name, &mut self.offset);
  166|      0|                    }
  167|      0|                }
  168|       |
  169|      0|                self.opened_buffer.truncate(start);
  170|       |            }
  171|       |            None => {
  172|     46|                if self.check_end_names {
  173|     46|                    return mismatch_err("".to_string(), &buf[1..], &mut self.offset);
  174|      0|                }
  175|       |            }
  176|       |        }
  177|       |
  178|      0|        Ok(Event::End(BytesEnd::wrap(name.into())))
  179|     46|    }
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser10read_start:
  211|    101|    pub fn read_start<'b>(&mut self, content: &'b [u8]) -> Result<Event<'b>> {
  212|    101|        let len = content.len();
  213|    101|        let name_end = content
  214|    101|            .iter()
  215|    101|            .position(|&b| is_whitespace(b))
  216|    101|            .unwrap_or(len);
  217|    101|        if let Some(&b'/') = content.last() {
  218|       |            // This is self-closed tag `<something/>`
  219|      2|            let name_len = if name_end < len { name_end } else { len - 1 };
  220|      2|            let event = BytesStart::wrap(&content[..len - 1], name_len);
  221|      2|
  222|      2|            if self.expand_empty_elements {
  223|      2|                self.state = ParseState::Empty;
  224|      2|                self.opened_starts.push(self.opened_buffer.len());
  225|      2|                self.opened_buffer.extend(&content[..name_len]);
  226|      2|                Ok(Event::Start(event))
  227|       |            } else {
  228|      0|                Ok(Event::Empty(event))
  229|       |            }
  230|       |        } else {
  231|       |            // #514: Always store names event when .check_end_names == false,
  232|       |            // because checks can be temporary disabled and when they would be
  233|       |            // enabled, we should have that information
  234|     99|            self.opened_starts.push(self.opened_buffer.len());
  235|     99|            self.opened_buffer.extend(&content[..name_end]);
  236|     99|            Ok(Event::Start(BytesStart::wrap(content, name_end)))
  237|       |        }
  238|    101|    }
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser9read_text:
   68|    294|    pub fn read_text<'b>(&mut self, bytes: &'b [u8]) -> Result<Event<'b>> {
   69|    294|        let mut content = bytes;
   70|    294|
   71|    294|        if self.trim_text_end {
   72|    294|            // Skip the ending '<'
   73|    294|            let len = bytes
   74|    294|                .iter()
   75|    294|                .rposition(|&b| !is_whitespace(b))
   76|    294|                .map_or_else(|| bytes.len(), |p| p + 1);
   77|    294|            content = &bytes[..len];
   78|    294|        }
   79|       |
   80|    294|        Ok(Event::Text(BytesText::wrap(content, self.decoder())))
   81|    294|    }
_RNvXs_NtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6ParserNtNtCs9jyDXsa31Er_4core7default7Default7default:
  265|    649|    fn default() -> Self {
  266|    649|        Self {
  267|    649|            offset: 0,
  268|    649|            state: ParseState::Init,
  269|    649|            expand_empty_elements: false,
  270|    649|            trim_text_start: false,
  271|    649|            trim_text_end: false,
  272|    649|            trim_markup_names_in_closing_tags: true,
  273|    649|            check_end_names: true,
  274|    649|            check_comments: false,
  275|    649|            opened_buffer: Vec::new(),
  276|    649|            opened_starts: Vec::new(),
  277|    649|
  278|    649|            #[cfg(feature = "encoding")]
  279|    649|            encoding: EncodingRef::Implicit(UTF_8),
  280|    649|        }
  281|    649|    }
_RNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB2_6Parser9read_bang:
   85|    596|    pub fn read_bang<'b>(&mut self, bang_type: BangType, buf: &'b [u8]) -> Result<Event<'b>> {
   86|    596|        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {
   87|       |            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)
   88|       |        };
   89|       |
   90|    596|        let len = buf.len();
   91|     35|        match bang_type {
   92|    561|            BangType::Comment if buf.starts_with(b"!--") => {
   93|      0|                debug_assert!(buf.ends_with(b"--"));
   94|    559|                if self.check_comments {
   95|       |                    // search if '--' not in comments
   96|      0|                    if let Some(p) = memchr::memchr_iter(b'-', &buf[3..len - 2])
   97|      0|                        .position(|p| buf[3 + p + 1] == b'-')
   98|       |                    {
   99|      0|                        self.offset += len - p;
  100|      0|                        return Err(Error::UnexpectedToken("--".to_string()));
  101|      0|                    }
  102|    559|                }
  103|    559|                Ok(Event::Comment(BytesText::wrap(
  104|    559|                    &buf[3..len - 2],
  105|    559|                    self.decoder(),
  106|    559|                )))
  107|       |            }
  108|      4|            BangType::CData if uncased_starts_with(buf, b"![CDATA[") => {
  109|      0|                debug_assert!(buf.ends_with(b"]]"));
  110|      0|                Ok(Event::CData(BytesCData::wrap(
  111|      0|                    &buf[8..len - 2],
  112|      0|                    self.decoder(),
  113|      0|                )))
  114|       |            }
  115|     31|            BangType::DocType if uncased_starts_with(buf, b"!DOCTYPE") => {
  116|      0|                let start = buf[8..]
  117|      0|                    .iter()
  118|      0|                    .position(|b| !is_whitespace(*b))
  119|      0|                    .unwrap_or(len - 8);
  120|      0|                debug_assert!(start < len - 8, "DocType must have a name");
  121|      0|                Ok(Event::DocType(BytesText::wrap(
  122|      0|                    &buf[8 + start..],
  123|      0|                    self.decoder(),
  124|      0|                )))
  125|       |            }
  126|     37|            _ => Err(bang_type.to_err()),
  127|       |        }
  128|    596|    }
_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser8read_ends_0B8_:
  147|     46|        let mismatch_err = |expected: String, found: &[u8], offset: &mut usize| {
  148|     46|            *offset -= buf.len();
  149|     46|            Err(Error::EndEventMismatch {
  150|     46|                expected,
  151|     46|                found: decoder.decode(found).unwrap_or_default().into_owned(),
  152|     46|            })
  153|     46|        };
_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser8read_end0B8_:
  136|    778|            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {
_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser10read_start0B8_:
  215|  4.29k|            .position(|&b| is_whitespace(b))
_RNCNvMNtNtCsiptRIqLjvkg_9quick_xml6reader6parserNtB4_6Parser9read_text0B8_:
   75|  1.13k|                .rposition(|&b| !is_whitespace(b))

_RNvNtCslt04TQWGvnL_13oxigraph_fuzz13result_format18fuzz_result_format:
    6|    649|pub fn fuzz_result_format(format: QueryResultsFormat, data: &[u8]) {
    7|    649|    let parser = QueryResultsParser::from_format(format);
    8|    649|    let serializer = QueryResultsSerializer::from_format(format);
    9|       |
   10|    649|    let Ok(reader) = parser.read_results(data) else {
   11|    649|        return;
   12|       |    };
   13|      0|    match reader {
   14|      0|        QueryResultsReader::Solutions(solutions) => {
   15|      0|            let Ok(solutions) = solutions.collect::<Result<Vec<_>, _>>() else {
   16|      0|                return;
   17|       |            };
   18|       |
   19|       |            // We try to write again
   20|      0|            let mut writer = serializer
   21|      0|                .solutions_writer(
   22|      0|                    Vec::new(),
   23|      0|                    solutions
   24|      0|                        .get(0)
   25|      0|                        .map_or_else(Vec::new, |s| s.variables().to_vec()),
   26|      0|                )
   27|      0|                .unwrap();
   28|      0|            for solution in &solutions {
   29|      0|                writer.write(solution).unwrap();
   30|      0|            }
   31|      0|            let serialized = String::from_utf8(writer.finish().unwrap()).unwrap();
   32|       |
   33|       |            // And to parse again
   34|      0|            if let QueryResultsReader::Solutions(roundtrip_solutions) = parser
   35|      0|                .read_results(serialized.as_bytes())
   36|      0|                .with_context(|| format!("Parsing {:?}", &serialized))
   37|      0|                .unwrap()
   38|       |            {
   39|      0|                assert_eq!(
   40|      0|                    roundtrip_solutions
   41|      0|                        .collect::<Result<Vec<_>, _>>()
   42|      0|                        .with_context(|| format!("Parsing {:?}", &serialized))
   43|      0|                        .unwrap(),
   44|      0|                    solutions
   45|      0|                )
   46|      0|            }
   47|       |        }
   48|      0|        QueryResultsReader::Boolean(value) => {
   49|      0|            // We try to write again
   50|      0|            let mut serialized = Vec::new();
   51|      0|            serializer
   52|      0|                .write_boolean_result(&mut serialized, value)
   53|      0|                .unwrap();
   54|       |
   55|       |            // And to parse again
   56|      0|            if let QueryResultsReader::Boolean(roundtrip_value) =
   57|      0|                parser.read_results(serialized.as_slice()).unwrap()
   58|       |            {
   59|      0|                assert_eq!(roundtrip_value, value)
   60|      0|            }
   61|       |        }
   62|       |    }
   63|    649|}

_RINvMs4_NtCsdUl1VstNg53_10sparesults5errorNtB6_11SyntaxError3msgNtNtCs9lXrf61Tc6r_5alloc6string6StringECslt04TQWGvnL_13oxigraph_fuzz:
   86|    209|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|    209|        Self {
   88|    209|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|    209|        }
   90|    209|    }
_RINvMs4_NtCsdUl1VstNg53_10sparesults5errorNtB6_11SyntaxError3msgReECslt04TQWGvnL_13oxigraph_fuzz:
   86|     37|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|     37|        Self {
   88|     37|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|     37|        }
   90|     37|    }
_RNvXs1_NtCsdUl1VstNg53_10sparesults5errorNtB5_10ParseErrorINtNtCs9jyDXsa31Er_4core7convert4FromNtB5_11SyntaxErrorE4fromCslt04TQWGvnL_13oxigraph_fuzz:
   43|    246|    fn from(error: SyntaxError) -> Self {
   44|    246|        Self::Syntax(error)
   45|    246|    }
_RNvXs3_NtCsdUl1VstNg53_10sparesults5errorNtB5_10ParseErrorINtNtCs9jyDXsa31Er_4core7convert4FromNtNtCsiptRIqLjvkg_9quick_xml6errors5ErrorE4fromCslt04TQWGvnL_13oxigraph_fuzz:
   60|    403|    fn from(error: quick_xml::Error) -> Self {
   61|    403|        match error {
   62|      0|            quick_xml::Error::Io(error) => Self::Io(io::Error::new(error.kind(), error)),
   63|    403|            error => Self::Syntax(SyntaxError {
   64|    403|                inner: SyntaxErrorKind::Xml(error),
   65|    403|            }),
   66|       |        }
   67|    403|    }

_RINvMs_CsdUl1VstNg53_10sparesultsNtB5_18QueryResultsParser12read_resultsRShECslt04TQWGvnL_13oxigraph_fuzz:
  193|    649|    pub fn read_results<R: BufRead>(&self, reader: R) -> Result<QueryResultsReader<R>, ParseError> {
  194|    649|        Ok(match self.format {
  195|    649|            QueryResultsFormat::Xml => match XmlQueryResultsReader::read(reader)? {
  196|      0|                XmlQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  197|       |                XmlQueryResultsReader::Solutions {
  198|      0|                    solutions,
  199|      0|                    variables,
  200|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  201|      0|                    variables: Rc::new(variables),
  202|      0|                    solutions: SolutionsReaderKind::Xml(solutions),
  203|      0|                }),
  204|       |            },
  205|      0|            QueryResultsFormat::Json => match JsonQueryResultsReader::read(reader)? {
  206|      0|                JsonQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  207|       |                JsonQueryResultsReader::Solutions {
  208|      0|                    solutions,
  209|      0|                    variables,
  210|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  211|      0|                    variables: Rc::new(variables),
  212|      0|                    solutions: SolutionsReaderKind::Json(solutions),
  213|      0|                }),
  214|       |            },
  215|      0|            QueryResultsFormat::Csv => return Err(SyntaxError::msg("CSV SPARQL results syntax is lossy and can't be parsed to a proper RDF representation").into()),
  216|      0|            QueryResultsFormat::Tsv => match TsvQueryResultsReader::read(reader)? {
  217|      0|                TsvQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  218|       |                TsvQueryResultsReader::Solutions {
  219|      0|                    solutions,
  220|      0|                    variables,
  221|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  222|      0|                    variables: Rc::new(variables),
  223|      0|                    solutions: SolutionsReaderKind::Tsv(solutions),
  224|      0|                }),
  225|       |            },
  226|       |        })
  227|    649|    }
_RNvMs_CsdUl1VstNg53_10sparesultsNtB4_18QueryResultsParser11from_formatCslt04TQWGvnL_13oxigraph_fuzz:
  166|    649|    pub fn from_format(format: QueryResultsFormat) -> Self {
  167|    649|        Self { format }
  168|    649|    }
_RNvMs2_CsdUl1VstNg53_10sparesultsNtB5_22QueryResultsSerializer11from_formatCslt04TQWGvnL_13oxigraph_fuzz:
  362|    649|    pub fn from_format(format: QueryResultsFormat) -> Self {
  363|    649|        Self { format }
  364|    649|    }

_RNvMs_NtCsdUl1VstNg53_10sparesults3xmlINtB4_21XmlQueryResultsReaderRShE4readCslt04TQWGvnL_13oxigraph_fuzz:
  170|    649|    pub fn read(source: R) -> Result<Self, ParseError> {
  171|    649|        enum State {
  172|    649|            Start,
  173|    649|            Sparql,
  174|    649|            Head,
  175|    649|            AfterHead,
  176|    649|            Boolean,
  177|    649|        }
  178|    649|
  179|    649|        let mut reader = Reader::from_reader(source);
  180|    649|        reader.trim_text(true);
  181|    649|        reader.expand_empty_elements(true);
  182|    649|
  183|    649|        let mut buffer = Vec::default();
  184|    649|        let mut variables = Vec::default();
  185|    649|        let mut state = State::Start;
  186|       |
  187|       |        //Read header
  188|  1.69k|        loop {
  189|  1.69k|            buffer.clear();
  190|  1.69k|            let event = reader.read_event_into(&mut buffer)?;
  191|  1.48k|            match event {
  192|    101|                Event::Start(event) => match state {
  193|       |                    State::Start => {
  194|    101|                        if event.local_name().as_ref() == b"sparql" {
  195|      0|                            state = State::Sparql;
  196|      0|                        } else {
  197|    101|                            return Err(SyntaxError::msg(format!("Expecting <sparql> tag, found <{}>", decode(&reader, &event.name())?)).into());
  198|       |                        }
  199|       |                    }
  200|       |                    State::Sparql => {
  201|      0|                        if event.local_name().as_ref() == b"head" {
  202|      0|                            state = State::Head;
  203|      0|                        } else {
  204|      0|                            return Err(SyntaxError::msg(format!("Expecting <head> tag, found <{}>",decode(&reader, &event.name())?)).into());
  205|       |                        }
  206|       |                    }
  207|       |                    State::Head => {
  208|      0|                        if event.local_name().as_ref() == b"variable" {
  209|      0|                            let name = event.attributes()
  210|      0|                                .filter_map(Result::ok)
  211|      0|                                .find(|attr| attr.key.local_name().as_ref() == b"name")
  212|      0|                                .ok_or_else(|| SyntaxError::msg("No name attribute found for the <variable> tag"))?
  213|      0|                                .decode_and_unescape_value(&reader)?;
  214|      0|                            let variable = Variable::new(name).map_err(|e| SyntaxError::msg(format!("Invalid variable name: {e}")))?;
  215|      0|                            if variables.contains(&variable) {
  216|      0|                                return Err(SyntaxError::msg(format!(
  217|      0|                                    "The variable {variable} is declared twice"
  218|      0|                                ))
  219|      0|                                    .into());
  220|      0|                            }
  221|      0|                            variables.push(variable);
  222|      0|                        } else if event.local_name().as_ref() == b"link" {
  223|      0|                            // no op
  224|      0|                        } else {
  225|      0|                            return Err(SyntaxError::msg(format!("Expecting <variable> or <link> tag, found <{}>", decode(&reader, &event.name())?)).into());
  226|       |                        }
  227|       |                    }
  228|       |                    State::AfterHead => {
  229|      0|                        if event.local_name().as_ref() == b"boolean" {
  230|      0|                            state = State::Boolean
  231|      0|                        } else if event.local_name().as_ref() == b"results" {
  232|      0|                            let mut mapping = BTreeMap::default();
  233|      0|                            for (i, var) in variables.iter().enumerate() {
  234|      0|                                mapping.insert(var.clone().into_string(), i);
  235|      0|                            }
  236|      0|                            return Ok(Self::Solutions { variables,
  237|      0|                                solutions: XmlSolutionsReader {
  238|      0|                                    reader,
  239|      0|                                    buffer,
  240|      0|                                    mapping,
  241|      0|                                    stack: Vec::new(),
  242|      0|                                    subject_stack: Vec::new(),
  243|      0|                                    predicate_stack: Vec::new(),
  244|      0|                                    object_stack: Vec::new(),
  245|      0|                                }});
  246|      0|                        } else if event.local_name().as_ref() != b"link" && event.local_name().as_ref() != b"results" && event.local_name().as_ref() != b"boolean" {
  247|      0|                            return Err(SyntaxError::msg(format!("Expecting sparql tag, found <{}>", decode(&reader, &event.name())?)).into());
  248|      0|                        }
  249|       |                    }
  250|      0|                    State::Boolean => return Err(SyntaxError::msg(format!("Unexpected tag inside of <boolean> tag: <{}>", decode(&reader, &event.name())?)).into())
  251|       |                },
  252|    294|                Event::Text(event) => {
  253|    294|                    let value = event.unescape()?;
  254|    170|                    return match state {
  255|       |                        State::Boolean => {
  256|      0|                            return if value == "true" {
  257|      0|                                Ok(Self::Boolean(true))
  258|      0|                            } else if value == "false" {
  259|      0|                                Ok(Self::Boolean(false))
  260|       |                            } else {
  261|      0|                                Err(SyntaxError::msg(format!("Unexpected boolean value. Found '{value}'")).into())
  262|       |                            };
  263|       |                        }
  264|    170|                        _ => Err(SyntaxError::msg(format!("Unexpected textual value found: '{value}'")).into())
  265|       |                    };
  266|       |                },
  267|      0|                Event::End(event) => {
  268|      0|                    if let State::Head = state {
  269|      0|                        if event.local_name().as_ref() == b"head" {
  270|      0|                            state = State::AfterHead
  271|      0|                        }
  272|       |                    } else {
  273|      0|                        return Err(SyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into());
  274|       |                    }
  275|       |                },
  276|     37|                Event::Eof => return Err(SyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into()),
  277|  1.04k|                _ => (),
  278|       |            }
  279|       |        }
  280|    649|    }
_RINvNtCsdUl1VstNg53_10sparesults3xml6decodeRShNtNtCsiptRIqLjvkg_9quick_xml4name5QNameECslt04TQWGvnL_13oxigraph_fuzz:
  598|    101|fn decode<'a, T>(
  599|    101|    reader: &Reader<T>,
  600|    101|    data: &'a impl AsRef<[u8]>,
  601|    101|) -> Result<Cow<'a, str>, ParseError> {
  602|    101|    Ok(reader.decoder().decode(data.as_ref())?)
  603|    101|}

