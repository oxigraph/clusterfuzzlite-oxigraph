_RNvNvCsftNTZF1VNPo_18sparql_results_xml1__19___libfuzzer_sys_run:
  241|  1.91k|            fn __libfuzzer_sys_run($bytes: &[u8]) {
  242|  1.91k|                $body
  243|  1.91k|            }
rust_fuzzer_test_input:
  215|  1.91k|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|  1.91k|                }
  223|  1.91k|
  224|  1.91k|                __libfuzzer_sys_run(bytes);
  225|  1.91k|                0
  226|  1.91k|            }
LLVMFuzzerTestOneInput:
   58|  1.91k|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|  1.91k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|  1.91k|    });
   63|  1.91k|
   64|  1.91k|    match test_input {
   65|  1.91k|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|  1.91k|}
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}
_RNCNvCsjiqEitFvUQw_13libfuzzer_sys15test_input_wrap0B3_:
   59|  1.91k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|  1.91k|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|  1.91k|        rust_fuzzer_test_input(data_slice)
   62|  1.91k|    });

_RNvMNtNtCseb519bkMcGB_6memchr6memchr4iterNtB2_6Memchr3newCs19LGvG89wkE_13oxigraph_fuzz:
   45|  5.69k|    pub fn new(needle: u8, haystack: &[u8]) -> Memchr<'_> {
   46|  5.69k|        Memchr { needle: needle, haystack: haystack, position: 0 }
   47|  5.69k|    }
_RNvMs1_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB5_7Memchr23newCs19LGvG89wkE_13oxigraph_fuzz:
   84|  18.0k|    pub fn new(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   85|  18.0k|        Memchr2 {
   86|  18.0k|            needle1: needle1,
   87|  18.0k|            needle2: needle2,
   88|  18.0k|            haystack: haystack,
   89|  18.0k|            position: 0,
   90|  18.0k|        }
   91|  18.0k|    }
_RNvXs5_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB5_7Memchr3NtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4nextCs19LGvG89wkE_13oxigraph_fuzz:
  152|  6.73k|    fn next(&mut self) -> Option<usize> {
  153|       |        iter_next!(
  154|       |            self,
  155|       |            memchr3(self.needle1, self.needle2, self.needle3, self.haystack)
  156|       |        )
  157|  6.73k|    }
_RNvMs4_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB5_7Memchr33newCs19LGvG89wkE_13oxigraph_fuzz:
  132|    256|    pub fn new(
  133|    256|        needle1: u8,
  134|    256|        needle2: u8,
  135|    256|        needle3: u8,
  136|    256|        haystack: &[u8],
  137|    256|    ) -> Memchr3<'_> {
  138|    256|        Memchr3 {
  139|    256|            needle1: needle1,
  140|    256|            needle2: needle2,
  141|    256|            needle3: needle3,
  142|    256|            haystack: haystack,
  143|    256|            position: 0,
  144|    256|        }
  145|    256|    }
_RNvXs_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB4_6MemchrNtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4nextCs19LGvG89wkE_13oxigraph_fuzz:
   54|  30.7k|    fn next(&mut self) -> Option<usize> {
   55|       |        iter_next!(self, memchr(self.needle, self.haystack))
   56|  30.7k|    }
_RNvXs2_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB5_7Memchr2NtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4nextCscrcAsbrazo7_9quick_xml:
   98|  3.92M|    fn next(&mut self) -> Option<usize> {
   99|       |        iter_next!(self, memchr2(self.needle1, self.needle2, self.haystack))
  100|  3.92M|    }
_RNCNvXs_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB6_6MemchrNtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4next0CscrcAsbrazo7_9quick_xml:
   55|  30.2k|        iter_next!(self, memchr(self.needle, self.haystack))
_RNCNvXs2_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB7_7Memchr2NtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4next0CscrcAsbrazo7_9quick_xml:
   99|  3.90M|        iter_next!(self, memchr2(self.needle1, self.needle2, self.haystack))
_RNvMs1_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB5_7Memchr23newCscrcAsbrazo7_9quick_xml:
   84|    697|    pub fn new(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   85|    697|        Memchr2 {
   86|    697|            needle1: needle1,
   87|    697|            needle2: needle2,
   88|    697|            haystack: haystack,
   89|    697|            position: 0,
   90|    697|        }
   91|    697|    }
_RNCNvXs5_NtNtCseb519bkMcGB_6memchr6memchr4iterNtB7_7Memchr3NtNtNtNtCsewp07EQjaMZ_4core4iter6traits8iterator8Iterator4next0CscrcAsbrazo7_9quick_xml:
  153|  6.49k|        iter_next!(
  154|  6.49k|            self,
  155|  6.49k|            memchr3(self.needle1, self.needle2, self.needle3, self.haystack)
  156|  6.49k|        )

_RNvNtCseb519bkMcGB_6memchr6memchr6memchrCs19LGvG89wkE_13oxigraph_fuzz:
   87|  34.8k|pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {
   88|  34.8k|    #[cfg(miri)]
   89|  34.8k|    #[inline(always)]
   90|  34.8k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   91|  34.8k|        naive::memchr(n1, haystack)
   92|  34.8k|    }
   93|  34.8k|
   94|  34.8k|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
   95|  34.8k|    #[inline(always)]
   96|  34.8k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   97|  34.8k|        x86::memchr(n1, haystack)
   98|  34.8k|    }
   99|  34.8k|
  100|  34.8k|    #[cfg(all(
  101|  34.8k|        memchr_libc,
  102|  34.8k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  103|  34.8k|        not(miri),
  104|  34.8k|    ))]
  105|  34.8k|    #[inline(always)]
  106|  34.8k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
  107|  34.8k|        c::memchr(n1, haystack)
  108|  34.8k|    }
  109|  34.8k|
  110|  34.8k|    #[cfg(all(
  111|  34.8k|        not(memchr_libc),
  112|  34.8k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  113|  34.8k|        not(miri),
  114|  34.8k|    ))]
  115|  34.8k|    #[inline(always)]
  116|  34.8k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
  117|  34.8k|        fallback::memchr(n1, haystack)
  118|  34.8k|    }
  119|  34.8k|
  120|  34.8k|    if haystack.is_empty() {
  121|    143|        None
  122|       |    } else {
  123|  34.6k|        imp(needle, haystack)
  124|       |    }
  125|  34.8k|}
_RNvNvNtCseb519bkMcGB_6memchr6memchr7memchr33imp:
  218|  6.68k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  219|  6.68k|        x86::memchr3(n1, n2, n3, haystack)
  220|  6.68k|    }
_RNvNtCseb519bkMcGB_6memchr6memchr12memchr2_iterCs19LGvG89wkE_13oxigraph_fuzz:
   23|  18.0k|pub fn memchr2_iter(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   24|  18.0k|    Memchr2::new(needle1, needle2, haystack)
   25|  18.0k|}
_RNvNtCseb519bkMcGB_6memchr6memchr12memchr3_iterCs19LGvG89wkE_13oxigraph_fuzz:
   29|    256|pub fn memchr3_iter(
   30|    256|    needle1: u8,
   31|    256|    needle2: u8,
   32|    256|    needle3: u8,
   33|    256|    haystack: &[u8],
   34|    256|) -> Memchr3<'_> {
   35|    256|    Memchr3::new(needle1, needle2, needle3, haystack)
   36|    256|}
_RNvNvNtCseb519bkMcGB_6memchr6memchr6memchr3imp:
   96|  34.6k|    fn imp(n1: u8, haystack: &[u8]) -> Option<usize> {
   97|  34.6k|        x86::memchr(n1, haystack)
   98|  34.6k|    }
_RNvNvNtCseb519bkMcGB_6memchr6memchr7memchr23imp:
  160|  3.91M|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  161|  3.91M|        x86::memchr2(n1, n2, haystack)
  162|  3.91M|    }
_RNvNtCseb519bkMcGB_6memchr6memchr7memchr3Cs19LGvG89wkE_13oxigraph_fuzz:
  204|  6.73k|pub fn memchr3(
  205|  6.73k|    needle1: u8,
  206|  6.73k|    needle2: u8,
  207|  6.73k|    needle3: u8,
  208|  6.73k|    haystack: &[u8],
  209|  6.73k|) -> Option<usize> {
  210|  6.73k|    #[cfg(miri)]
  211|  6.73k|    #[inline(always)]
  212|  6.73k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  213|  6.73k|        naive::memchr3(n1, n2, n3, haystack)
  214|  6.73k|    }
  215|  6.73k|
  216|  6.73k|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
  217|  6.73k|    #[inline(always)]
  218|  6.73k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  219|  6.73k|        x86::memchr3(n1, n2, n3, haystack)
  220|  6.73k|    }
  221|  6.73k|
  222|  6.73k|    #[cfg(all(
  223|  6.73k|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  224|  6.73k|        not(miri),
  225|  6.73k|    ))]
  226|  6.73k|    #[inline(always)]
  227|  6.73k|    fn imp(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  228|  6.73k|        fallback::memchr3(n1, n2, n3, haystack)
  229|  6.73k|    }
  230|  6.73k|
  231|  6.73k|    if haystack.is_empty() {
  232|     47|        None
  233|       |    } else {
  234|  6.68k|        imp(needle1, needle2, needle3, haystack)
  235|       |    }
  236|  6.73k|}
_RNvNtCseb519bkMcGB_6memchr6memchr11memchr_iterCs19LGvG89wkE_13oxigraph_fuzz:
   17|  5.69k|pub fn memchr_iter(needle: u8, haystack: &[u8]) -> Memchr<'_> {
   18|  5.69k|    Memchr::new(needle, haystack)
   19|  5.69k|}
_RNvNtCseb519bkMcGB_6memchr6memchr7memchr2CscrcAsbrazo7_9quick_xml:
  151|  3.92M|pub fn memchr2(needle1: u8, needle2: u8, haystack: &[u8]) -> Option<usize> {
  152|  3.92M|    #[cfg(miri)]
  153|  3.92M|    #[inline(always)]
  154|  3.92M|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  155|  3.92M|        naive::memchr2(n1, n2, haystack)
  156|  3.92M|    }
  157|  3.92M|
  158|  3.92M|    #[cfg(all(target_arch = "x86_64", memchr_runtime_simd, not(miri)))]
  159|  3.92M|    #[inline(always)]
  160|  3.92M|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  161|  3.92M|        x86::memchr2(n1, n2, haystack)
  162|  3.92M|    }
  163|  3.92M|
  164|  3.92M|    #[cfg(all(
  165|  3.92M|        not(all(target_arch = "x86_64", memchr_runtime_simd)),
  166|  3.92M|        not(miri),
  167|  3.92M|    ))]
  168|  3.92M|    #[inline(always)]
  169|  3.92M|    fn imp(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  170|  3.92M|        fallback::memchr2(n1, n2, haystack)
  171|  3.92M|    }
  172|  3.92M|
  173|  3.92M|    if haystack.is_empty() {
  174|  10.7k|        None
  175|       |    } else {
  176|  3.91M|        imp(needle1, needle2, haystack)
  177|       |    }
  178|  3.92M|}
_RNvNtCseb519bkMcGB_6memchr6memchr12memchr2_iterCscrcAsbrazo7_9quick_xml:
   23|    697|pub fn memchr2_iter(needle1: u8, needle2: u8, haystack: &[u8]) -> Memchr2<'_> {
   24|    697|    Memchr2::new(needle1, needle2, haystack)
   25|    697|}

_RNvNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx7memchr27matched:
  126|  86.6k|    unsafe fn matched(
  127|  86.6k|        start_ptr: *const u8,
  128|  86.6k|        ptr: *const u8,
  129|  86.6k|        eqa1: __m256i,
  130|  86.6k|        eqa2: __m256i,
  131|  86.6k|        eqb1: __m256i,
  132|  86.6k|        eqb2: __m256i,
  133|  86.6k|    ) -> usize {
  134|  86.6k|        let mut at = sub(ptr, start_ptr);
  135|  86.6k|        let mask1 = _mm256_movemask_epi8(eqa1);
  136|  86.6k|        let mask2 = _mm256_movemask_epi8(eqa2);
  137|  86.6k|        if mask1 != 0 || mask2 != 0 {
  138|  60.4k|            return at + forward_pos2(mask1, mask2);
  139|  26.2k|        }
  140|  26.2k|
  141|  26.2k|        at += VECTOR_SIZE;
  142|  26.2k|        let mask1 = _mm256_movemask_epi8(eqb1);
  143|  26.2k|        let mask2 = _mm256_movemask_epi8(eqb2);
  144|  26.2k|        at + forward_pos2(mask1, mask2)
  145|  86.6k|    }
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx15forward_search1:
  533|  33.1k|unsafe fn forward_search1(
  534|  33.1k|    start_ptr: *const u8,
  535|  33.1k|    end_ptr: *const u8,
  536|  33.1k|    ptr: *const u8,
  537|  33.1k|    vn1: __m256i,
  538|  33.1k|) -> Option<usize> {
  539|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  540|      0|    debug_assert!(start_ptr <= ptr);
  541|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  542|       |
  543|  33.1k|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  544|  33.1k|    let mask = _mm256_movemask_epi8(_mm256_cmpeq_epi8(chunk, vn1));
  545|  33.1k|    if mask != 0 {
  546|  27.2k|        Some(sub(ptr, start_ptr) + forward_pos(mask))
  547|       |    } else {
  548|  5.90k|        None
  549|       |    }
  550|  33.1k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx11forward_pos:
  680|  3.72M|fn forward_pos(mask: i32) -> usize {
  681|  3.72M|    // We are dealing with little endian here, where the most significant byte
  682|  3.72M|    // is at a higher address. That means the least significant bit that is set
  683|  3.72M|    // corresponds to the position of our first matching byte. That position
  684|  3.72M|    // corresponds to the number of zeros after the least significant bit.
  685|  3.72M|    mask.trailing_zeros() as usize
  686|  3.72M|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx15forward_search2:
  553|  3.70M|unsafe fn forward_search2(
  554|  3.70M|    start_ptr: *const u8,
  555|  3.70M|    end_ptr: *const u8,
  556|  3.70M|    ptr: *const u8,
  557|  3.70M|    vn1: __m256i,
  558|  3.70M|    vn2: __m256i,
  559|  3.70M|) -> Option<usize> {
  560|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  561|      0|    debug_assert!(start_ptr <= ptr);
  562|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  563|       |
  564|  3.70M|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  565|  3.70M|    let eq1 = _mm256_cmpeq_epi8(chunk, vn1);
  566|  3.70M|    let eq2 = _mm256_cmpeq_epi8(chunk, vn2);
  567|  3.70M|    if _mm256_movemask_epi8(_mm256_or_si256(eq1, eq2)) != 0 {
  568|  3.60M|        let mask1 = _mm256_movemask_epi8(eq1);
  569|  3.60M|        let mask2 = _mm256_movemask_epi8(eq2);
  570|  3.60M|        Some(sub(ptr, start_ptr) + forward_pos2(mask1, mask2))
  571|       |    } else {
  572|  98.9k|        None
  573|       |    }
  574|  3.70M|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx12forward_pos2:
  694|  3.68M|fn forward_pos2(mask1: i32, mask2: i32) -> usize {
  695|      0|    debug_assert!(mask1 != 0 || mask2 != 0);
  696|       |
  697|  3.68M|    forward_pos(mask1 | mask2)
  698|  3.68M|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx6memchr:
   18|  34.6k|pub unsafe fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   19|  34.6k|    // For a high level explanation for how this algorithm works, see the
   20|  34.6k|    // sse2 implementation. The avx implementation here is the same, but with
   21|  34.6k|    // 256-bit vectors instead of 128-bit vectors.
   22|  34.6k|
   23|  34.6k|    // This routine is called whenever a match is detected. It is specifically
   24|  34.6k|    // marked as unlineable because it improves the codegen of the unrolled
   25|  34.6k|    // loop below. Inlining this seems to cause codegen with some extra adds
   26|  34.6k|    // and a load that aren't necessary. This seems to result in about a 10%
   27|  34.6k|    // improvement for the memchr1/crate/huge/never benchmark.
   28|  34.6k|    //
   29|  34.6k|    // Interestingly, I couldn't observe a similar improvement for memrchr.
   30|  34.6k|    #[cold]
   31|  34.6k|    #[inline(never)]
   32|  34.6k|    #[target_feature(enable = "avx2")]
   33|  34.6k|    unsafe fn matched(
   34|  34.6k|        start_ptr: *const u8,
   35|  34.6k|        ptr: *const u8,
   36|  34.6k|        eqa: __m256i,
   37|  34.6k|        eqb: __m256i,
   38|  34.6k|        eqc: __m256i,
   39|  34.6k|        eqd: __m256i,
   40|  34.6k|    ) -> usize {
   41|  34.6k|        let mut at = sub(ptr, start_ptr);
   42|  34.6k|        let mask = _mm256_movemask_epi8(eqa);
   43|  34.6k|        if mask != 0 {
   44|  34.6k|            return at + forward_pos(mask);
   45|  34.6k|        }
   46|  34.6k|
   47|  34.6k|        at += VECTOR_SIZE;
   48|  34.6k|        let mask = _mm256_movemask_epi8(eqb);
   49|  34.6k|        if mask != 0 {
   50|  34.6k|            return at + forward_pos(mask);
   51|  34.6k|        }
   52|  34.6k|
   53|  34.6k|        at += VECTOR_SIZE;
   54|  34.6k|        let mask = _mm256_movemask_epi8(eqc);
   55|  34.6k|        if mask != 0 {
   56|  34.6k|            return at + forward_pos(mask);
   57|  34.6k|        }
   58|  34.6k|
   59|  34.6k|        at += VECTOR_SIZE;
   60|  34.6k|        let mask = _mm256_movemask_epi8(eqd);
   61|  34.6k|        debug_assert!(mask != 0);
   62|  34.6k|        at + forward_pos(mask)
   63|  34.6k|    }
   64|  34.6k|
   65|  34.6k|    let start_ptr = haystack.as_ptr();
   66|  34.6k|    let end_ptr = start_ptr.add(haystack.len());
   67|  34.6k|    let mut ptr = start_ptr;
   68|  34.6k|
   69|  34.6k|    if haystack.len() < VECTOR_SIZE {
   70|       |        // For small haystacks, defer to the SSE2 implementation. Codegen
   71|       |        // suggests this completely avoids touching the AVX vectors.
   72|  3.73k|        return sse2::memchr(n1, haystack);
   73|  30.9k|    }
   74|  30.9k|
   75|  30.9k|    let vn1 = _mm256_set1_epi8(n1 as i8);
   76|  30.9k|    let loop_size = cmp::min(LOOP_SIZE, haystack.len());
   77|  30.9k|    if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
   78|  26.7k|        return Some(i);
   79|  4.17k|    }
   80|  4.17k|
   81|  4.17k|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
   82|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
   83|  5.68k|    while loop_size == LOOP_SIZE && ptr <= end_ptr.sub(loop_size) {
   84|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
   85|       |
   86|  4.55k|        let a = _mm256_load_si256(ptr as *const __m256i);
   87|  4.55k|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
   88|  4.55k|        let c = _mm256_load_si256(ptr.add(2 * VECTOR_SIZE) as *const __m256i);
   89|  4.55k|        let d = _mm256_load_si256(ptr.add(3 * VECTOR_SIZE) as *const __m256i);
   90|  4.55k|        let eqa = _mm256_cmpeq_epi8(vn1, a);
   91|  4.55k|        let eqb = _mm256_cmpeq_epi8(vn1, b);
   92|  4.55k|        let eqc = _mm256_cmpeq_epi8(vn1, c);
   93|  4.55k|        let eqd = _mm256_cmpeq_epi8(vn1, d);
   94|  4.55k|        let or1 = _mm256_or_si256(eqa, eqb);
   95|  4.55k|        let or2 = _mm256_or_si256(eqc, eqd);
   96|  4.55k|        let or3 = _mm256_or_si256(or1, or2);
   97|  4.55k|
   98|  4.55k|        if _mm256_movemask_epi8(or3) != 0 {
   99|  3.04k|            return Some(matched(start_ptr, ptr, eqa, eqb, eqc, eqd));
  100|  1.50k|        }
  101|  1.50k|        ptr = ptr.add(loop_size);
  102|       |    }
  103|  2.23k|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  104|      0|        debug_assert!(sub(end_ptr, ptr) >= VECTOR_SIZE);
  105|       |
  106|  1.42k|        if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  107|    315|            return Some(i);
  108|  1.10k|        }
  109|  1.10k|        ptr = ptr.add(VECTOR_SIZE);
  110|       |    }
  111|    813|    if ptr < end_ptr {
  112|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  113|    782|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  114|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  115|       |
  116|    782|        return forward_search1(start_ptr, end_ptr, ptr, vn1);
  117|     31|    }
  118|     31|    None
  119|  34.6k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx7memchr2:
  122|  3.91M|pub unsafe fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  123|  3.91M|    #[cold]
  124|  3.91M|    #[inline(never)]
  125|  3.91M|    #[target_feature(enable = "avx2")]
  126|  3.91M|    unsafe fn matched(
  127|  3.91M|        start_ptr: *const u8,
  128|  3.91M|        ptr: *const u8,
  129|  3.91M|        eqa1: __m256i,
  130|  3.91M|        eqa2: __m256i,
  131|  3.91M|        eqb1: __m256i,
  132|  3.91M|        eqb2: __m256i,
  133|  3.91M|    ) -> usize {
  134|  3.91M|        let mut at = sub(ptr, start_ptr);
  135|  3.91M|        let mask1 = _mm256_movemask_epi8(eqa1);
  136|  3.91M|        let mask2 = _mm256_movemask_epi8(eqa2);
  137|  3.91M|        if mask1 != 0 || mask2 != 0 {
  138|  3.91M|            return at + forward_pos2(mask1, mask2);
  139|  3.91M|        }
  140|  3.91M|
  141|  3.91M|        at += VECTOR_SIZE;
  142|  3.91M|        let mask1 = _mm256_movemask_epi8(eqb1);
  143|  3.91M|        let mask2 = _mm256_movemask_epi8(eqb2);
  144|  3.91M|        at + forward_pos2(mask1, mask2)
  145|  3.91M|    }
  146|  3.91M|
  147|  3.91M|    let vn1 = _mm256_set1_epi8(n1 as i8);
  148|  3.91M|    let vn2 = _mm256_set1_epi8(n2 as i8);
  149|  3.91M|    let len = haystack.len();
  150|  3.91M|    let loop_size = cmp::min(LOOP_SIZE2, len);
  151|  3.91M|    let start_ptr = haystack.as_ptr();
  152|  3.91M|    let end_ptr = start_ptr.add(haystack.len());
  153|  3.91M|    let mut ptr = start_ptr;
  154|  3.91M|
  155|  3.91M|    if haystack.len() < VECTOR_SIZE {
  156|   384k|        while ptr < end_ptr {
  157|   378k|            if *ptr == n1 || *ptr == n2 {
  158|   216k|                return Some(sub(ptr, start_ptr));
  159|   161k|            }
  160|   161k|            ptr = ptr.offset(1);
  161|       |        }
  162|  6.74k|        return None;
  163|  3.69M|    }
  164|       |
  165|  3.69M|    if let Some(i) = forward_search2(start_ptr, end_ptr, ptr, vn1, vn2) {
  166|  3.59M|        return Some(i);
  167|  95.2k|    }
  168|  95.2k|
  169|  95.2k|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  170|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  171|   107k|    while loop_size == LOOP_SIZE2 && ptr <= end_ptr.sub(loop_size) {
  172|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  173|       |
  174|  99.1k|        let a = _mm256_load_si256(ptr as *const __m256i);
  175|  99.1k|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
  176|  99.1k|        let eqa1 = _mm256_cmpeq_epi8(vn1, a);
  177|  99.1k|        let eqb1 = _mm256_cmpeq_epi8(vn1, b);
  178|  99.1k|        let eqa2 = _mm256_cmpeq_epi8(vn2, a);
  179|  99.1k|        let eqb2 = _mm256_cmpeq_epi8(vn2, b);
  180|  99.1k|        let or1 = _mm256_or_si256(eqa1, eqb1);
  181|  99.1k|        let or2 = _mm256_or_si256(eqa2, eqb2);
  182|  99.1k|        let or3 = _mm256_or_si256(or1, or2);
  183|  99.1k|        if _mm256_movemask_epi8(or3) != 0 {
  184|  86.6k|            return Some(matched(start_ptr, ptr, eqa1, eqa2, eqb1, eqb2));
  185|  12.5k|        }
  186|  12.5k|        ptr = ptr.add(loop_size);
  187|       |    }
  188|  11.2k|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  189|  5.82k|        if let Some(i) = forward_search2(start_ptr, end_ptr, ptr, vn1, vn2) {
  190|  3.15k|            return Some(i);
  191|  2.67k|        }
  192|  2.67k|        ptr = ptr.add(VECTOR_SIZE);
  193|       |    }
  194|  5.45k|    if ptr < end_ptr {
  195|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  196|  5.37k|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  197|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  198|       |
  199|  5.37k|        return forward_search2(start_ptr, end_ptr, ptr, vn1, vn2);
  200|     79|    }
  201|     79|    None
  202|  3.91M|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx7memchr3:
  205|  6.68k|pub unsafe fn memchr3(
  206|  6.68k|    n1: u8,
  207|  6.68k|    n2: u8,
  208|  6.68k|    n3: u8,
  209|  6.68k|    haystack: &[u8],
  210|  6.68k|) -> Option<usize> {
  211|  6.68k|    #[cold]
  212|  6.68k|    #[inline(never)]
  213|  6.68k|    #[target_feature(enable = "avx2")]
  214|  6.68k|    unsafe fn matched(
  215|  6.68k|        start_ptr: *const u8,
  216|  6.68k|        ptr: *const u8,
  217|  6.68k|        eqa1: __m256i,
  218|  6.68k|        eqa2: __m256i,
  219|  6.68k|        eqa3: __m256i,
  220|  6.68k|        eqb1: __m256i,
  221|  6.68k|        eqb2: __m256i,
  222|  6.68k|        eqb3: __m256i,
  223|  6.68k|    ) -> usize {
  224|  6.68k|        let mut at = sub(ptr, start_ptr);
  225|  6.68k|        let mask1 = _mm256_movemask_epi8(eqa1);
  226|  6.68k|        let mask2 = _mm256_movemask_epi8(eqa2);
  227|  6.68k|        let mask3 = _mm256_movemask_epi8(eqa3);
  228|  6.68k|        if mask1 != 0 || mask2 != 0 || mask3 != 0 {
  229|  6.68k|            return at + forward_pos3(mask1, mask2, mask3);
  230|  6.68k|        }
  231|  6.68k|
  232|  6.68k|        at += VECTOR_SIZE;
  233|  6.68k|        let mask1 = _mm256_movemask_epi8(eqb1);
  234|  6.68k|        let mask2 = _mm256_movemask_epi8(eqb2);
  235|  6.68k|        let mask3 = _mm256_movemask_epi8(eqb3);
  236|  6.68k|        at + forward_pos3(mask1, mask2, mask3)
  237|  6.68k|    }
  238|  6.68k|
  239|  6.68k|    let vn1 = _mm256_set1_epi8(n1 as i8);
  240|  6.68k|    let vn2 = _mm256_set1_epi8(n2 as i8);
  241|  6.68k|    let vn3 = _mm256_set1_epi8(n3 as i8);
  242|  6.68k|    let len = haystack.len();
  243|  6.68k|    let loop_size = cmp::min(LOOP_SIZE2, len);
  244|  6.68k|    let start_ptr = haystack.as_ptr();
  245|  6.68k|    let end_ptr = start_ptr.add(haystack.len());
  246|  6.68k|    let mut ptr = start_ptr;
  247|  6.68k|
  248|  6.68k|    if haystack.len() < VECTOR_SIZE {
  249|  2.98k|        while ptr < end_ptr {
  250|  2.85k|            if *ptr == n1 || *ptr == n2 || *ptr == n3 {
  251|  1.39k|                return Some(sub(ptr, start_ptr));
  252|  1.46k|            }
  253|  1.46k|            ptr = ptr.offset(1);
  254|       |        }
  255|    123|        return None;
  256|  5.17k|    }
  257|       |
  258|  5.17k|    if let Some(i) = forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3) {
  259|  4.23k|        return Some(i);
  260|    942|    }
  261|    942|
  262|    942|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  263|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  264|  1.18k|    while loop_size == LOOP_SIZE2 && ptr <= end_ptr.sub(loop_size) {
  265|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  266|       |
  267|  1.10k|        let a = _mm256_load_si256(ptr as *const __m256i);
  268|  1.10k|        let b = _mm256_load_si256(ptr.add(VECTOR_SIZE) as *const __m256i);
  269|  1.10k|        let eqa1 = _mm256_cmpeq_epi8(vn1, a);
  270|  1.10k|        let eqb1 = _mm256_cmpeq_epi8(vn1, b);
  271|  1.10k|        let eqa2 = _mm256_cmpeq_epi8(vn2, a);
  272|  1.10k|        let eqb2 = _mm256_cmpeq_epi8(vn2, b);
  273|  1.10k|        let eqa3 = _mm256_cmpeq_epi8(vn3, a);
  274|  1.10k|        let eqb3 = _mm256_cmpeq_epi8(vn3, b);
  275|  1.10k|        let or1 = _mm256_or_si256(eqa1, eqb1);
  276|  1.10k|        let or2 = _mm256_or_si256(eqa2, eqb2);
  277|  1.10k|        let or3 = _mm256_or_si256(eqa3, eqb3);
  278|  1.10k|        let or4 = _mm256_or_si256(or1, or2);
  279|  1.10k|        let or5 = _mm256_or_si256(or3, or4);
  280|  1.10k|        if _mm256_movemask_epi8(or5) != 0 {
  281|    858|            return Some(matched(
  282|    858|                start_ptr, ptr, eqa1, eqa2, eqa3, eqb1, eqb2, eqb3,
  283|    858|            ));
  284|    246|        }
  285|    246|        ptr = ptr.add(loop_size);
  286|       |    }
  287|    112|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  288|     10|        if let Some(i) =
  289|     38|            forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3)
  290|       |        {
  291|     10|            return Some(i);
  292|     28|        }
  293|     28|        ptr = ptr.add(VECTOR_SIZE);
  294|       |    }
  295|     74|    if ptr < end_ptr {
  296|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  297|     65|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  298|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  299|       |
  300|     65|        return forward_search3(start_ptr, end_ptr, ptr, vn1, vn2, vn3);
  301|      9|    }
  302|      9|    None
  303|  6.68k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx3sub:
  752|  3.94M|fn sub(a: *const u8, b: *const u8) -> usize {
  753|      0|    debug_assert!(a >= b);
  754|  3.94M|    (a as usize) - (b as usize)
  755|  3.94M|}
_RNvNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx7memchr37matched:
  214|    858|    unsafe fn matched(
  215|    858|        start_ptr: *const u8,
  216|    858|        ptr: *const u8,
  217|    858|        eqa1: __m256i,
  218|    858|        eqa2: __m256i,
  219|    858|        eqa3: __m256i,
  220|    858|        eqb1: __m256i,
  221|    858|        eqb2: __m256i,
  222|    858|        eqb3: __m256i,
  223|    858|    ) -> usize {
  224|    858|        let mut at = sub(ptr, start_ptr);
  225|    858|        let mask1 = _mm256_movemask_epi8(eqa1);
  226|    858|        let mask2 = _mm256_movemask_epi8(eqa2);
  227|    858|        let mask3 = _mm256_movemask_epi8(eqa3);
  228|    858|        if mask1 != 0 || mask2 != 0 || mask3 != 0 {
  229|    478|            return at + forward_pos3(mask1, mask2, mask3);
  230|    380|        }
  231|    380|
  232|    380|        at += VECTOR_SIZE;
  233|    380|        let mask1 = _mm256_movemask_epi8(eqb1);
  234|    380|        let mask2 = _mm256_movemask_epi8(eqb2);
  235|    380|        let mask3 = _mm256_movemask_epi8(eqb3);
  236|    380|        at + forward_pos3(mask1, mask2, mask3)
  237|    858|    }
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx15forward_search3:
  577|  5.27k|unsafe fn forward_search3(
  578|  5.27k|    start_ptr: *const u8,
  579|  5.27k|    end_ptr: *const u8,
  580|  5.27k|    ptr: *const u8,
  581|  5.27k|    vn1: __m256i,
  582|  5.27k|    vn2: __m256i,
  583|  5.27k|    vn3: __m256i,
  584|  5.27k|) -> Option<usize> {
  585|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  586|      0|    debug_assert!(start_ptr <= ptr);
  587|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  588|       |
  589|  5.27k|    let chunk = _mm256_loadu_si256(ptr as *const __m256i);
  590|  5.27k|    let eq1 = _mm256_cmpeq_epi8(chunk, vn1);
  591|  5.27k|    let eq2 = _mm256_cmpeq_epi8(chunk, vn2);
  592|  5.27k|    let eq3 = _mm256_cmpeq_epi8(chunk, vn3);
  593|  5.27k|    let or = _mm256_or_si256(eq1, eq2);
  594|  5.27k|    if _mm256_movemask_epi8(_mm256_or_si256(or, eq3)) != 0 {
  595|  4.24k|        let mask1 = _mm256_movemask_epi8(eq1);
  596|  4.24k|        let mask2 = _mm256_movemask_epi8(eq2);
  597|  4.24k|        let mask3 = _mm256_movemask_epi8(eq3);
  598|  4.24k|        Some(sub(ptr, start_ptr) + forward_pos3(mask1, mask2, mask3))
  599|       |    } else {
  600|  1.03k|        None
  601|       |    }
  602|  5.27k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx12forward_pos3:
  706|  5.10k|fn forward_pos3(mask1: i32, mask2: i32, mask3: i32) -> usize {
  707|      0|    debug_assert!(mask1 != 0 || mask2 != 0 || mask3 != 0);
  708|       |
  709|  5.10k|    forward_pos(mask1 | mask2 | mask3)
  710|  5.10k|}
_RNvNvNtNtNtCseb519bkMcGB_6memchr6memchr3x863avx6memchr7matched:
   33|  3.04k|    unsafe fn matched(
   34|  3.04k|        start_ptr: *const u8,
   35|  3.04k|        ptr: *const u8,
   36|  3.04k|        eqa: __m256i,
   37|  3.04k|        eqb: __m256i,
   38|  3.04k|        eqc: __m256i,
   39|  3.04k|        eqd: __m256i,
   40|  3.04k|    ) -> usize {
   41|  3.04k|        let mut at = sub(ptr, start_ptr);
   42|  3.04k|        let mask = _mm256_movemask_epi8(eqa);
   43|  3.04k|        if mask != 0 {
   44|  1.32k|            return at + forward_pos(mask);
   45|  1.72k|        }
   46|  1.72k|
   47|  1.72k|        at += VECTOR_SIZE;
   48|  1.72k|        let mask = _mm256_movemask_epi8(eqb);
   49|  1.72k|        if mask != 0 {
   50|  1.01k|            return at + forward_pos(mask);
   51|    710|        }
   52|    710|
   53|    710|        at += VECTOR_SIZE;
   54|    710|        let mask = _mm256_movemask_epi8(eqc);
   55|    710|        if mask != 0 {
   56|    439|            return at + forward_pos(mask);
   57|    271|        }
   58|    271|
   59|    271|        at += VECTOR_SIZE;
   60|    271|        let mask = _mm256_movemask_epi8(eqd);
   61|      0|        debug_assert!(mask != 0);
   62|    271|        at + forward_pos(mask)
   63|  3.04k|    }

_RNvNtNtCseb519bkMcGB_6memchr6memchr3x867memchr2:
  100|  3.91M|pub fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
  101|  3.91M|    unsafe_ifunc!(
  102|  3.91M|        fn(u8, u8, &[u8]) -> Option<usize>,
  103|  3.91M|        memchr2,
  104|  3.91M|        haystack,
  105|  3.91M|        n1,
  106|  3.91M|        n2
  107|  3.91M|    )
  108|  3.91M|}
_RNvNtNtCseb519bkMcGB_6memchr6memchr3x867memchr3:
  111|  6.68k|pub fn memchr3(n1: u8, n2: u8, n3: u8, haystack: &[u8]) -> Option<usize> {
  112|  6.68k|    unsafe_ifunc!(
  113|  6.68k|        fn(u8, u8, u8, &[u8]) -> Option<usize>,
  114|  6.68k|        memchr3,
  115|  6.68k|        haystack,
  116|  6.68k|        n1,
  117|  6.68k|        n2,
  118|  6.68k|        n3
  119|  6.68k|    )
  120|  6.68k|}
_RNvNtNtCseb519bkMcGB_6memchr6memchr3x866memchr:
   95|  34.6k|pub fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   96|  34.6k|    unsafe_ifunc!(fn(u8, &[u8]) -> Option<usize>, memchr, haystack, n1)
   97|  34.6k|}
_RNvNvNtNtCseb519bkMcGB_6memchr6memchr3x867memchr36detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }
_RNvNvNtNtCseb519bkMcGB_6memchr6memchr3x866memchr6detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }
_RNvNvNtNtCseb519bkMcGB_6memchr6memchr3x867memchr26detect:
   43|      1|        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
   44|      1|            let fun =
   45|      0|                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
   46|      1|                    avx::$name as FnRaw
   47|      0|                } else if cfg!(memchr_runtime_sse2) {
   48|      0|                    sse2::$name as FnRaw
   49|       |                } else {
   50|      0|                    fallback::$name as FnRaw
   51|       |                };
   52|      1|            FN.store(fun as FnRaw, Ordering::Relaxed);
   53|      1|            // SAFETY: By virtue of the caller contract, $fnty is a function
   54|      1|            // pointer, which is always safe to transmute with a *mut ().
   55|      1|            // Also, if 'fun is the AVX routine, then it is guaranteed to be
   56|      1|            // supported since we checked the avx2 feature.
   57|      1|            unsafe {
   58|      1|                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
   59|      1|            }
   60|      1|        }

_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x864sse26memchr:
   16|  3.73k|pub unsafe fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
   17|  3.73k|    // What follows is a fast SSE2-only algorithm to detect the position of
   18|  3.73k|    // `n1` in `haystack` if it exists. From what I know, this is the "classic"
   19|  3.73k|    // algorithm. I believe it can be found in places like glibc and Go's
   20|  3.73k|    // standard library. It appears to be well known and is elaborated on in
   21|  3.73k|    // more detail here: https://gms.tf/stdfind-and-memchr-optimizations.html
   22|  3.73k|    //
   23|  3.73k|    // While this routine is very long, the basic idea is actually very simple
   24|  3.73k|    // and can be expressed straight-forwardly in pseudo code:
   25|  3.73k|    //
   26|  3.73k|    //     needle = (n1 << 15) | (n1 << 14) | ... | (n1 << 1) | n1
   27|  3.73k|    //     // Note: shift amount in bytes
   28|  3.73k|    //
   29|  3.73k|    //     while i <= haystack.len() - 16:
   30|  3.73k|    //       // A 16 byte vector. Each byte in chunk corresponds to a byte in
   31|  3.73k|    //       // the haystack.
   32|  3.73k|    //       chunk = haystack[i:i+16]
   33|  3.73k|    //       // Compare bytes in needle with bytes in chunk. The result is a 16
   34|  3.73k|    //       // byte chunk where each byte is 0xFF if the corresponding bytes
   35|  3.73k|    //       // in needle and chunk were equal, or 0x00 otherwise.
   36|  3.73k|    //       eqs = cmpeq(needle, chunk)
   37|  3.73k|    //       // Return a 32 bit integer where the most significant 16 bits
   38|  3.73k|    //       // are always 0 and the lower 16 bits correspond to whether the
   39|  3.73k|    //       // most significant bit in the correspond byte in `eqs` is set.
   40|  3.73k|    //       // In other words, `mask as u16` has bit i set if and only if
   41|  3.73k|    //       // needle[i] == chunk[i].
   42|  3.73k|    //       mask = movemask(eqs)
   43|  3.73k|    //
   44|  3.73k|    //       // Mask is 0 if there is no match, and non-zero otherwise.
   45|  3.73k|    //       if mask != 0:
   46|  3.73k|    //         // trailing_zeros tells us the position of the least significant
   47|  3.73k|    //         // bit that is set.
   48|  3.73k|    //         return i + trailing_zeros(mask)
   49|  3.73k|    //
   50|  3.73k|    //     // haystack length may not be a multiple of 16, so search the rest.
   51|  3.73k|    //     while i < haystack.len():
   52|  3.73k|    //       if haystack[i] == n1:
   53|  3.73k|    //         return i
   54|  3.73k|    //
   55|  3.73k|    //     // No match found.
   56|  3.73k|    //     return NULL
   57|  3.73k|    //
   58|  3.73k|    // In fact, we could loosely translate the above code to Rust line-for-line
   59|  3.73k|    // and it would be a pretty fast algorithm. But, we pull out all the stops
   60|  3.73k|    // to go as fast as possible:
   61|  3.73k|    //
   62|  3.73k|    // 1. We use aligned loads. That is, we do some finagling to make sure our
   63|  3.73k|    //    primary loop not only proceeds in increments of 16 bytes, but that
   64|  3.73k|    //    the address of haystack's pointer that we dereference is aligned to
   65|  3.73k|    //    16 bytes. 16 is a magic number here because it is the size of SSE2
   66|  3.73k|    //    128-bit vector. (For the AVX2 algorithm, 32 is the magic number.)
   67|  3.73k|    //    Therefore, to get aligned loads, our pointer's address must be evenly
   68|  3.73k|    //    divisible by 16.
   69|  3.73k|    // 2. Our primary loop proceeds 64 bytes at a time instead of 16. It's
   70|  3.73k|    //    kind of like loop unrolling, but we combine the equality comparisons
   71|  3.73k|    //    using a vector OR such that we only need to extract a single mask to
   72|  3.73k|    //    determine whether a match exists or not. If so, then we do some
   73|  3.73k|    //    book-keeping to determine the precise location but otherwise mush on.
   74|  3.73k|    // 3. We use our "chunk" comparison routine in as many places as possible,
   75|  3.73k|    //    even if it means using unaligned loads. In particular, if haystack
   76|  3.73k|    //    starts with an unaligned address, then we do an unaligned load to
   77|  3.73k|    //    search the first 16 bytes. We then start our primary loop at the
   78|  3.73k|    //    smallest subsequent aligned address, which will actually overlap with
   79|  3.73k|    //    previously searched bytes. But we're OK with that. We do a similar
   80|  3.73k|    //    dance at the end of our primary loop. Finally, to avoid a
   81|  3.73k|    //    byte-at-a-time loop at the end, we do a final 16 byte unaligned load
   82|  3.73k|    //    that may overlap with a previous load. This is OK because it converts
   83|  3.73k|    //    a loop into a small number of very fast vector instructions.
   84|  3.73k|    //
   85|  3.73k|    // The primary downside of this algorithm is that it's effectively
   86|  3.73k|    // completely unsafe. Therefore, we have to be super careful to avoid
   87|  3.73k|    // undefined behavior:
   88|  3.73k|    //
   89|  3.73k|    // 1. We use raw pointers everywhere. Not only does dereferencing a pointer
   90|  3.73k|    //    require the pointer to be valid, but we actually can't even store the
   91|  3.73k|    //    address of an invalid pointer (unless it's 1 past the end of
   92|  3.73k|    //    haystack) without sacrificing performance.
   93|  3.73k|    // 2. _mm_loadu_si128 is used when you don't care about alignment, and
   94|  3.73k|    //    _mm_load_si128 is used when you do care. You cannot use the latter
   95|  3.73k|    //    on unaligned pointers.
   96|  3.73k|    // 3. We make liberal use of debug_assert! to check assumptions.
   97|  3.73k|    // 4. We make a concerted effort to stick with pointers instead of indices.
   98|  3.73k|    //    Indices are nicer because there's less to worry about with them (see
   99|  3.73k|    //    above about pointer offsets), but I could not get the compiler to
  100|  3.73k|    //    produce as good of code as what the below produces. In any case,
  101|  3.73k|    //    pointers are what we really care about here, and alignment is
  102|  3.73k|    //    expressed a bit more naturally with them.
  103|  3.73k|    //
  104|  3.73k|    // In general, most of the algorithms in this crate have a similar
  105|  3.73k|    // structure to what you see below, so this comment applies fairly well to
  106|  3.73k|    // all of them.
  107|  3.73k|
  108|  3.73k|    let vn1 = _mm_set1_epi8(n1 as i8);
  109|  3.73k|    let len = haystack.len();
  110|  3.73k|    let loop_size = cmp::min(LOOP_SIZE, len);
  111|  3.73k|    let start_ptr = haystack.as_ptr();
  112|  3.73k|    let end_ptr = start_ptr.add(haystack.len());
  113|  3.73k|    let mut ptr = start_ptr;
  114|  3.73k|
  115|  3.73k|    if haystack.len() < VECTOR_SIZE {
  116|  7.01k|        while ptr < end_ptr {
  117|  6.47k|            if *ptr == n1 {
  118|  1.43k|                return Some(sub(ptr, start_ptr));
  119|  5.04k|            }
  120|  5.04k|            ptr = ptr.offset(1);
  121|       |        }
  122|    537|        return None;
  123|  1.75k|    }
  124|       |
  125|  1.75k|    if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  126|  1.49k|        return Some(i);
  127|    265|    }
  128|    265|
  129|    265|    ptr = ptr.add(VECTOR_SIZE - (start_ptr as usize & VECTOR_ALIGN));
  130|      0|    debug_assert!(ptr > start_ptr && end_ptr.sub(VECTOR_SIZE) >= start_ptr);
  131|    265|    while loop_size == LOOP_SIZE && ptr <= end_ptr.sub(loop_size) {
  132|      0|        debug_assert_eq!(0, (ptr as usize) % VECTOR_SIZE);
  133|       |
  134|      0|        let a = _mm_load_si128(ptr as *const __m128i);
  135|      0|        let b = _mm_load_si128(ptr.add(VECTOR_SIZE) as *const __m128i);
  136|      0|        let c = _mm_load_si128(ptr.add(2 * VECTOR_SIZE) as *const __m128i);
  137|      0|        let d = _mm_load_si128(ptr.add(3 * VECTOR_SIZE) as *const __m128i);
  138|      0|        let eqa = _mm_cmpeq_epi8(vn1, a);
  139|      0|        let eqb = _mm_cmpeq_epi8(vn1, b);
  140|      0|        let eqc = _mm_cmpeq_epi8(vn1, c);
  141|      0|        let eqd = _mm_cmpeq_epi8(vn1, d);
  142|      0|        let or1 = _mm_or_si128(eqa, eqb);
  143|      0|        let or2 = _mm_or_si128(eqc, eqd);
  144|      0|        let or3 = _mm_or_si128(or1, or2);
  145|      0|        if _mm_movemask_epi8(or3) != 0 {
  146|      0|            let mut at = sub(ptr, start_ptr);
  147|      0|            let mask = _mm_movemask_epi8(eqa);
  148|      0|            if mask != 0 {
  149|      0|                return Some(at + forward_pos(mask));
  150|      0|            }
  151|      0|
  152|      0|            at += VECTOR_SIZE;
  153|      0|            let mask = _mm_movemask_epi8(eqb);
  154|      0|            if mask != 0 {
  155|      0|                return Some(at + forward_pos(mask));
  156|      0|            }
  157|      0|
  158|      0|            at += VECTOR_SIZE;
  159|      0|            let mask = _mm_movemask_epi8(eqc);
  160|      0|            if mask != 0 {
  161|      0|                return Some(at + forward_pos(mask));
  162|      0|            }
  163|      0|
  164|      0|            at += VECTOR_SIZE;
  165|      0|            let mask = _mm_movemask_epi8(eqd);
  166|      0|            debug_assert!(mask != 0);
  167|      0|            return Some(at + forward_pos(mask));
  168|      0|        }
  169|      0|        ptr = ptr.add(loop_size);
  170|       |    }
  171|    317|    while ptr <= end_ptr.sub(VECTOR_SIZE) {
  172|      0|        debug_assert!(sub(end_ptr, ptr) >= VECTOR_SIZE);
  173|       |
  174|     79|        if let Some(i) = forward_search1(start_ptr, end_ptr, ptr, vn1) {
  175|     27|            return Some(i);
  176|     52|        }
  177|     52|        ptr = ptr.add(VECTOR_SIZE);
  178|       |    }
  179|    238|    if ptr < end_ptr {
  180|      0|        debug_assert!(sub(end_ptr, ptr) < VECTOR_SIZE);
  181|    212|        ptr = ptr.sub(VECTOR_SIZE - sub(end_ptr, ptr));
  182|      0|        debug_assert_eq!(sub(end_ptr, ptr), VECTOR_SIZE);
  183|       |
  184|    212|        return forward_search1(start_ptr, end_ptr, ptr, vn1);
  185|     26|    }
  186|     26|    None
  187|  3.73k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x864sse215forward_search1:
  569|  2.04k|pub unsafe fn forward_search1(
  570|  2.04k|    start_ptr: *const u8,
  571|  2.04k|    end_ptr: *const u8,
  572|  2.04k|    ptr: *const u8,
  573|  2.04k|    vn1: __m128i,
  574|  2.04k|) -> Option<usize> {
  575|      0|    debug_assert!(sub(end_ptr, start_ptr) >= VECTOR_SIZE);
  576|      0|    debug_assert!(start_ptr <= ptr);
  577|      0|    debug_assert!(ptr <= end_ptr.sub(VECTOR_SIZE));
  578|       |
  579|  2.04k|    let chunk = _mm_loadu_si128(ptr as *const __m128i);
  580|  2.04k|    let mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, vn1));
  581|  2.04k|    if mask != 0 {
  582|  1.56k|        Some(sub(ptr, start_ptr) + forward_pos(mask))
  583|       |    } else {
  584|    482|        None
  585|       |    }
  586|  2.04k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x864sse211forward_pos:
  716|  1.56k|fn forward_pos(mask: i32) -> usize {
  717|  1.56k|    // We are dealing with little endian here, where the most significant byte
  718|  1.56k|    // is at a higher address. That means the least significant bit that is set
  719|  1.56k|    // corresponds to the position of our first matching byte. That position
  720|  1.56k|    // corresponds to the number of zeros after the least significant bit.
  721|  1.56k|    mask.trailing_zeros() as usize
  722|  1.56k|}
_RNvNtNtNtCseb519bkMcGB_6memchr6memchr3x864sse23sub:
  788|  3.21k|fn sub(a: *const u8, b: *const u8) -> usize {
  789|      0|    debug_assert!(a >= b);
  790|  3.21k|    (a as usize) - (b as usize)
  791|  3.21k|}

_RNvMs2_NtCsihGzv2ZnbOq_9once_cell3impINtB5_8OnceCellNtNtCsgGlVtr8vkIt_5alloc6string6StringE14is_initializedCsjiqEitFvUQw_13libfuzzer_sys:
   49|  1.91k|    pub(crate) fn is_initialized(&self) -> bool {
   50|  1.91k|        // An `Acquire` load is enough because that makes all the initialization
   51|  1.91k|        // operations visible to us, and, this being a fast path, weaker
   52|  1.91k|        // ordering helps with performance. This `Acquire` synchronizes with
   53|  1.91k|        // `SeqCst` operations on the slow path.
   54|  1.91k|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   55|  1.91k|    }

_RNvMs4_NtCsihGzv2ZnbOq_9once_cell4syncINtB5_8OnceCellNtNtCsgGlVtr8vkIt_5alloc6string6StringE3getCsjiqEitFvUQw_13libfuzzer_sys:
  965|  1.91k|        pub fn get(&self) -> Option<&T> {
  966|  1.91k|            if self.0.is_initialized() {
  967|       |                // Safe b/c value is initialized.
  968|      0|                Some(unsafe { self.get_unchecked() })
  969|       |            } else {
  970|  1.91k|                None
  971|       |            }
  972|  1.91k|        }

_RNvMs_NtCscrcAsbrazo7_9quick_xml8encodingNtB4_7Decoder6decode:
   81|  1.09k|    pub fn decode<'b>(&self, bytes: &'b [u8]) -> Result<Cow<'b, str>> {
   82|       |        #[cfg(not(feature = "encoding"))]
   83|  1.09k|        let decoded = Ok(Cow::Borrowed(std::str::from_utf8(bytes)?));
   84|       |
   85|       |        #[cfg(feature = "encoding")]
   86|       |        let decoded = decode(bytes, self.encoding);
   87|       |
   88|    824|        decoded
   89|  1.09k|    }

_RNvXs1_NtCscrcAsbrazo7_9quick_xml6errorsNtB5_5ErrorINtNtCsewp07EQjaMZ_4core7convert4FromNtNtB7_7escapei11EscapeErrorE4fromB7_:
   75|    190|    fn from(error: EscapeError) -> Error {
   76|    190|        Error::EscapeError(error)
   77|    190|    }
_RNvXs_NtCscrcAsbrazo7_9quick_xml6errorsNtB4_5ErrorINtNtCsewp07EQjaMZ_4core7convert4FromNtNtNtBR_3str5error9Utf8ErrorE4fromB6_:
   59|    268|    fn from(error: Utf8Error) -> Error {
   60|    268|        Error::NonDecodable(Some(error))
   61|    268|    }

_RNCINvNtCscrcAsbrazo7_9quick_xml7escapei13unescape_withNCNvMs7_NtB6_6eventsNtBZ_9BytesText8unescape0E0B6_:
  172|  24.1k|    while let Some(start) = iter.by_ref().find(|p| bytes[*p] == b'&') {
_RNvNtCscrcAsbrazo7_9quick_xml7escapei13parse_decimal:
 1725|  9.04k|fn parse_decimal(bytes: &str) -> Result<u32, EscapeError> {
 1726|  9.04k|    // maximum code is 0x10FFFF = 1114111 => 7 characters
 1727|  9.04k|    if bytes.len() > 7 {
 1728|      2|        return Err(EscapeError::TooLongDecimal);
 1729|  9.03k|    }
 1730|  9.03k|    let mut code = 0;
 1731|  38.9k|    for b in bytes.bytes() {
 1732|  38.9k|        code *= 10;
 1733|  38.9k|        code += match b {
 1734|  38.9k|            b'0'..=b'9' => b - b'0',
 1735|     13|            b => return Err(EscapeError::InvalidDecimal(b as char)),
 1736|       |        } as u32;
 1737|       |    }
 1738|  9.02k|    Ok(code)
 1739|  9.04k|}
_RNvNtCscrcAsbrazo7_9quick_xml7escapei17parse_hexadecimal:
 1707|    938|fn parse_hexadecimal(bytes: &str) -> Result<u32, EscapeError> {
 1708|    938|    // maximum code is 0x10FFFF => 6 characters
 1709|    938|    if bytes.len() > 6 {
 1710|      2|        return Err(EscapeError::TooLongHexadecimal);
 1711|    936|    }
 1712|    936|    let mut code = 0;
 1713|  2.98k|    for b in bytes.bytes() {
 1714|  2.98k|        code <<= 4;
 1715|  2.98k|        code += match b {
 1716|  2.98k|            b'0'..=b'9' => b - b'0',
 1717|     66|            b'a'..=b'f' => b - b'a' + 10,
 1718|    371|            b'A'..=b'F' => b - b'A' + 10,
 1719|     10|            b => return Err(EscapeError::InvalidHexadecimal(b as char)),
 1720|       |        } as u32;
 1721|       |    }
 1722|    926|    Ok(code)
 1723|    938|}
_RINvNtCscrcAsbrazo7_9quick_xml7escapei13unescape_withNCNvMs7_NtB4_6eventsNtBX_9BytesText8unescape0EB4_:
  160|    697|pub fn unescape_with<'input, 'entity, F>(
  161|    697|    raw: &'input str,
  162|    697|    mut resolve_entity: F,
  163|    697|) -> Result<Cow<'input, str>, EscapeError>
  164|    697|where
  165|    697|    // the lifetime of the output comes from a capture or is `'static`
  166|    697|    F: FnMut(&str) -> Option<&'entity str>,
  167|    697|{
  168|    697|    let bytes = raw.as_bytes();
  169|    697|    let mut unescaped = None;
  170|    697|    let mut last_end = 0;
  171|    697|    let mut iter = memchr2_iter(b'&', b';', bytes);
  172|  12.1k|    while let Some(start) = iter.by_ref().find(|p| bytes[*p] == b'&') {
  173|  11.6k|        match iter.next() {
  174|  11.5k|            Some(end) if bytes[end] == b';' => {
  175|  11.5k|                // append valid data
  176|  11.5k|                if unescaped.is_none() {
  177|    543|                    unescaped = Some(String::with_capacity(raw.len()));
  178|  11.0k|                }
  179|  11.5k|                let unescaped = unescaped.as_mut().expect("initialized");
  180|  11.5k|                unescaped.push_str(&raw[last_end..start]);
  181|  11.5k|
  182|  11.5k|                // search for character correctness
  183|  11.5k|                let pat = &raw[start + 1..end];
  184|  11.5k|                if let Some(entity) = pat.strip_prefix('#') {
  185|  9.97k|                    let codepoint = parse_number(entity, start..end)?;
  186|  9.92k|                    unescaped.push_str(codepoint.encode_utf8(&mut [0u8; 4]));
  187|  1.58k|                } else if let Some(value) = named_entity(pat) {
  188|  1.53k|                    unescaped.push_str(value);
  189|  1.53k|                } else if let Some(value) = resolve_entity(pat) {
  190|      0|                    unescaped.push_str(value);
  191|      0|                } else {
  192|     52|                    return Err(EscapeError::UnrecognizedSymbol(
  193|     52|                        start + 1..end,
  194|     52|                        pat.to_string(),
  195|     52|                    ));
  196|       |                }
  197|       |
  198|  11.4k|                last_end = end + 1;
  199|       |            }
  200|     83|            _ => return Err(EscapeError::UnterminatedEntity(start..raw.len())),
  201|       |        }
  202|       |    }
  203|       |
  204|    507|    if let Some(mut unescaped) = unescaped {
  205|    369|        if let Some(raw) = raw.get(last_end..) {
  206|    369|            unescaped.push_str(raw);
  207|    369|        }
  208|    369|        Ok(Cow::Owned(unescaped))
  209|       |    } else {
  210|    138|        Ok(Cow::Borrowed(raw))
  211|       |    }
  212|    697|}
_RNvNtCscrcAsbrazo7_9quick_xml7escapei12named_entity:
  215|  1.58k|fn named_entity(name: &str) -> Option<&str> {
  216|       |    // match over strings are not allowed in const functions
  217|  1.58k|    let s = match name.as_bytes() {
  218|  1.58k|        b"lt" => "<",
  219|     80|        b"gt" => ">",
  220|    775|        b"amp" => "&",
  221|    137|        b"apos" => "'",
  222|      0|        b"quot" => "\"",
  223|     52|        _ => return None,
  224|       |    };
  225|  1.53k|    Some(s)
  226|  1.58k|}
_RNvNtCscrcAsbrazo7_9quick_xml7escapei12parse_number:
 1692|  9.97k|fn parse_number(bytes: &str, range: Range<usize>) -> Result<char, EscapeError> {
 1693|  9.97k|    let code = if let Some(hex_digits) = bytes.strip_prefix('x') {
 1694|    938|        parse_hexadecimal(hex_digits)
 1695|       |    } else {
 1696|  9.04k|        parse_decimal(bytes)
 1697|     27|    }?;
 1698|  9.95k|    if code == 0 {
 1699|     10|        return Err(EscapeError::EntityWithNull(range));
 1700|  9.94k|    }
 1701|  9.94k|    match std::char::from_u32(code) {
 1702|  9.92k|        Some(c) => Ok(c),
 1703|     18|        None => Err(EscapeError::InvalidCodepoint(code)),
 1704|       |    }
 1705|  9.97k|}

_RNvMNtCscrcAsbrazo7_9quick_xml6eventsNtB2_10BytesStart4nameCs19LGvG89wkE_13oxigraph_fuzz:
  170|    512|    pub fn name(&self) -> QName {
  171|    512|        QName(&self.buf[..self.name_len])
  172|    512|    }
_RNvMNtCscrcAsbrazo7_9quick_xml6eventsNtB2_10BytesStart10local_nameCs19LGvG89wkE_13oxigraph_fuzz:
  179|    256|    pub fn local_name(&self) -> LocalName {
  180|    256|        self.name().into()
  181|    256|    }
_RNvMNtCscrcAsbrazo7_9quick_xml6eventsNtB2_10BytesStart4wrapB4_:
   79|    256|    pub(crate) fn wrap(content: &'a [u8], name_len: usize) -> Self {
   80|    256|        BytesStart {
   81|    256|            buf: Cow::Borrowed(content),
   82|    256|            name_len,
   83|    256|        }
   84|    256|    }
_RNvMs7_NtCscrcAsbrazo7_9quick_xml6eventsNtB5_9BytesText8unescape:
  733|    779|    pub fn unescape(&self) -> Result<Cow<'a, str>> {
  734|    779|        self.unescape_with(|_| None)
  735|    779|    }
_RINvMs7_NtCscrcAsbrazo7_9quick_xml6eventsNtB6_9BytesText4wrapRShEB8_:
  684|  8.76k|    pub(crate) fn wrap<C: Into<Cow<'a, [u8]>>>(content: C, decoder: Decoder) -> Self {
  685|  8.76k|        Self {
  686|  8.76k|            content: content.into(),
  687|  8.76k|            decoder,
  688|  8.76k|        }
  689|  8.76k|    }
_RNCNvMs7_NtCscrcAsbrazo7_9quick_xml6eventsNtB7_9BytesText8unescape0B9_:
  734|     52|        self.unescape_with(|_| None)
_RINvMs7_NtCscrcAsbrazo7_9quick_xml6eventsNtB6_9BytesText13unescape_withNCNvB2_8unescape0EB8_:
  741|    779|    pub fn unescape_with<'entity>(
  742|    779|        &self,
  743|    779|        resolve_entity: impl FnMut(&str) -> Option<&'entity str>,
  744|    779|    ) -> Result<Cow<'a, str>> {
  745|    779|        let decoded = match &self.content {
  746|    779|            Cow::Borrowed(bytes) => self.decoder.decode(bytes)?,
  747|       |            // Convert to owned, because otherwise Cow will be bound with wrong lifetime
  748|      0|            Cow::Owned(bytes) => self.decoder.decode(bytes)?.into_owned().into(),
  749|       |        };
  750|       |
  751|    697|        match unescape_with(&decoded, resolve_entity)? {
  752|       |            // Because result is borrowed, no replacements was done and we can use original string
  753|    138|            Cow::Borrowed(_) => Ok(decoded),
  754|    369|            Cow::Owned(s) => Ok(s.into()),
  755|       |        }
  756|    779|    }

_RNCNvXs4_NtCscrcAsbrazo7_9quick_xml4nameNtB7_9LocalNameINtNtCsewp07EQjaMZ_4core7convert4FromNtB7_5QNameE4from0Cs19LGvG89wkE_13oxigraph_fuzz:
  174|      3|        Self(name.index().map_or(name.0, |i| &name.0[i + 1..]))
_RNvXs3_NtCscrcAsbrazo7_9quick_xml4nameNtB5_9LocalNameINtNtCsewp07EQjaMZ_4core7convert5AsRefShE6as_refCs19LGvG89wkE_13oxigraph_fuzz:
  154|    256|    fn as_ref(&self) -> &[u8] {
  155|    256|        self.0
  156|    256|    }
_RNvMNtCscrcAsbrazo7_9quick_xml4nameNtB2_5QName5index:
  111|    256|    fn index(&self) -> Option<usize> {
  112|    256|        memchr(b':', self.0)
  113|    256|    }
_RNvXs0_NtCscrcAsbrazo7_9quick_xml4nameNtB5_5QNameINtNtCsewp07EQjaMZ_4core7convert5AsRefShE6as_refCs19LGvG89wkE_13oxigraph_fuzz:
  124|    256|    fn as_ref(&self) -> &[u8] {
  125|    256|        self.0
  126|    256|    }
_RNvXs4_NtCscrcAsbrazo7_9quick_xml4nameNtB5_9LocalNameINtNtCsewp07EQjaMZ_4core7convert4FromNtB5_5QNameE4fromCs19LGvG89wkE_13oxigraph_fuzz:
  173|    256|    fn from(name: QName<'a>) -> Self {
  174|    256|        Self(name.index().map_or(name.0, |i| &name.0[i + 1..]))
  175|    256|    }

_RNvMs_NtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerINtB6_6ReaderRShE15read_event_intoCs19LGvG89wkE_13oxigraph_fuzz:
  301|  9.89k|    pub fn read_event_into<'b>(&mut self, buf: &'b mut Vec<u8>) -> Result<Event<'b>> {
  302|  9.89k|        self.read_event_impl(buf)
  303|  9.89k|    }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE17read_bang_elementCs19LGvG89wkE_13oxigraph_fuzz:
  100|  5.70k|        $($async)? fn read_bang_element $(<$lf>)? (
  101|  5.70k|            &mut self,
  102|  5.70k|            buf: &'b mut Vec<u8>,
  103|  5.70k|            position: &mut usize,
  104|  5.70k|        ) -> Result<Option<(BangType, &'b [u8])>> {
  105|  5.70k|            // Peeked one bang ('!') before being called, so it's guaranteed to
  106|  5.70k|            // start with it.
  107|  5.70k|            let start = buf.len();
  108|  5.70k|            let mut read = 1;
  109|  5.70k|            buf.push(b'!');
  110|  5.70k|            self $(.$reader)? .consume(1);
  111|       |
  112|  5.70k|            let bang_type = BangType::new(self.peek_one() $(.$await)? ?)?;
  113|       |
  114|  6.15k|            loop {
  115|  6.15k|                match self $(.$reader)? .fill_buf() $(.$await)? {
  116|       |                    // Note: Do not update position, so the error points to
  117|       |                    // somewhere sane rather than at the EOF
  118|  6.15k|                    Ok(n) if n.is_empty() => return Err(bang_type.to_err()),
  119|  5.69k|                    Ok(available) => {
  120|  5.69k|                        if let Some((consumed, used)) = bang_type.parse(buf, available) {
  121|  5.22k|                            buf.extend_from_slice(consumed);
  122|  5.22k|
  123|  5.22k|                            self $(.$reader)? .consume(used);
  124|  5.22k|                            read += used;
  125|  5.22k|
  126|  5.22k|                            *position += read;
  127|  5.22k|                            break;
  128|    466|                        } else {
  129|    466|                            buf.extend_from_slice(available);
  130|    466|
  131|    466|                            let used = available.len();
  132|    466|                            self $(.$reader)? .consume(used);
  133|    466|                            read += used;
  134|    466|                        }
  135|       |                    }
  136|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  137|      0|                    Err(e) => {
  138|      0|                        *position += read;
  139|      0|                        return Err(Error::Io(e.into()));
  140|       |                    }
  141|       |                }
  142|       |            }
  143|       |
  144|  5.22k|            if read == 0 {
  145|      0|                Ok(None)
  146|       |            } else {
  147|  5.22k|                Ok(Some((bang_type, &buf[start..])))
  148|       |            }
  149|  5.70k|        }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE8peek_oneCs19LGvG89wkE_13oxigraph_fuzz:
  231|  24.6k|        $($async)? fn peek_one(&mut self) -> Result<Option<u8>> {
  232|  24.6k|            loop {
  233|  24.6k|                break match self $(.$reader)? .fill_buf() $(.$await)? {
  234|  24.6k|                    Ok(n) if n.is_empty() => Ok(None),
  235|  24.5k|                    Ok(n) => Ok(Some(n[0])),
  236|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  237|      0|                    Err(e) => Err(Error::Io(e.into())),
  238|       |                };
  239|       |            }
  240|  24.6k|        }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE12read_elementCs19LGvG89wkE_13oxigraph_fuzz:
  152|    256|        $($async)? fn read_element $(<$lf>)? (
  153|    256|            &mut self,
  154|    256|            buf: &'b mut Vec<u8>,
  155|    256|            position: &mut usize,
  156|    256|        ) -> Result<Option<&'b [u8]>> {
  157|    256|            let mut state = ReadElementState::Elem;
  158|    256|            let mut read = 0;
  159|    256|
  160|    256|            let start = buf.len();
  161|       |            loop {
  162|    499|                match self $(.$reader)? .fill_buf() $(.$await)? {
  163|    499|                    Ok(n) if n.is_empty() => break,
  164|    256|                    Ok(available) => {
  165|    256|                        if let Some((consumed, used)) = state.change(available) {
  166|     13|                            buf.extend_from_slice(consumed);
  167|     13|
  168|     13|                            self $(.$reader)? .consume(used);
  169|     13|                            read += used;
  170|     13|
  171|     13|                            // Position now just after the `>` symbol
  172|     13|                            *position += read;
  173|     13|                            break;
  174|    243|                        } else {
  175|    243|                            // The `>` symbol not yet found, continue reading
  176|    243|                            buf.extend_from_slice(available);
  177|    243|
  178|    243|                            let used = available.len();
  179|    243|                            self $(.$reader)? .consume(used);
  180|    243|                            read += used;
  181|    243|                        }
  182|       |                    }
  183|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  184|      0|                    Err(e) => {
  185|      0|                        *position += read;
  186|      0|                        return Err(Error::Io(e.into()));
  187|       |                    }
  188|       |                };
  189|       |            }
  190|       |
  191|    256|            if read == 0 {
  192|      0|                Ok(None)
  193|       |            } else {
  194|    256|                Ok(Some(&buf[start..]))
  195|       |            }
  196|    256|        }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE15skip_whitespaceCs19LGvG89wkE_13oxigraph_fuzz:
  198|  9.89k|        $($async)? fn skip_whitespace(&mut self, position: &mut usize) -> Result<()> {
  199|  10.0k|            loop {
  200|  10.0k|                break match self $(.$reader)? .fill_buf() $(.$await)? {
  201|  10.0k|                    Ok(n) => {
  202|  10.0k|                        let count = n.iter().position(|b| !is_whitespace(*b)).unwrap_or(n.len());
  203|  10.0k|                        if count > 0 {
  204|    176|                            self $(.$reader)? .consume(count);
  205|    176|                            *position += count;
  206|    176|                            continue;
  207|       |                        } else {
  208|  9.89k|                            Ok(())
  209|       |                        }
  210|       |                    }
  211|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
  212|      0|                    Err(e) => Err(Error::Io(e.into())),
  213|       |                };
  214|       |            }
  215|  9.89k|        }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE15remove_utf8_bomCs19LGvG89wkE_13oxigraph_fuzz:
   18|  1.91k|        $($async)? fn remove_utf8_bom(&mut self) -> Result<()> {
   19|       |            use crate::encoding::UTF8_BOM;
   20|       |
   21|  1.91k|            loop {
   22|  1.91k|                break match self $(.$reader)? .fill_buf() $(.$await)? {
   23|  1.91k|                    Ok(n) => {
   24|  1.91k|                        if n.starts_with(UTF8_BOM) {
   25|      2|                            self $(.$reader)? .consume(UTF8_BOM.len());
   26|  1.90k|                        }
   27|  1.91k|                        Ok(())
   28|       |                    },
   29|      0|                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
   30|      0|                    Err(e) => Err(Error::Io(e.into())),
   31|       |                };
   32|       |            }
   33|  1.91k|        }
_RNCNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB6_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE15skip_whitespace0Cs19LGvG89wkE_13oxigraph_fuzz:
  250|  12.5k|    impl_buffered_source!();
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE8skip_oneCs19LGvG89wkE_13oxigraph_fuzz:
  217|  9.89k|        $($async)? fn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool> {
  218|       |            // search byte must be within the ascii range
  219|      0|            debug_assert!(byte.is_ascii());
  220|       |
  221|  9.89k|            match self.peek_one() $(.$await)? ? {
  222|  9.79k|                Some(b) if b == byte => {
  223|  9.02k|                    *position += 1;
  224|  9.02k|                    self $(.$reader)? .consume(1);
  225|  9.02k|                    Ok(true)
  226|       |                }
  227|    872|                _ => Ok(false),
  228|       |            }
  229|  9.89k|        }
_RNvXNtNtCscrcAsbrazo7_9quick_xml6reader15buffered_readerRShINtB4_9XmlSourceQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEE16read_bytes_untilCs19LGvG89wkE_13oxigraph_fuzz:
   52|  3.92k|        $($async)? fn read_bytes_until $(<$lf>)? (
   53|  3.92k|            &mut self,
   54|  3.92k|            byte: u8,
   55|  3.92k|            buf: &'b mut Vec<u8>,
   56|  3.92k|            position: &mut usize,
   57|  3.92k|        ) -> Result<Option<&'b [u8]>> {
   58|       |            // search byte must be within the ascii range
   59|      0|            debug_assert!(byte.is_ascii());
   60|       |
   61|  3.92k|            let mut read = 0;
   62|  3.92k|            let mut done = false;
   63|  3.92k|            let start = buf.len();
   64|  7.76k|            while !done {
   65|  3.83k|                let used = {
   66|  4.73k|                    let available = match self $(.$reader)? .fill_buf() $(.$await)? {
   67|  4.73k|                        Ok(n) if n.is_empty() => break,
   68|  3.83k|                        Ok(n) => n,
   69|      0|                        Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
   70|      0|                        Err(e) => {
   71|      0|                            *position += read;
   72|      0|                            return Err(Error::Io(e.into()));
   73|       |                        }
   74|       |                    };
   75|       |
   76|  3.83k|                    match memchr::memchr(byte, available) {
   77|  3.03k|                        Some(i) => {
   78|  3.03k|                            buf.extend_from_slice(&available[..i]);
   79|  3.03k|                            done = true;
   80|  3.03k|                            i + 1
   81|       |                        }
   82|       |                        None => {
   83|    801|                            buf.extend_from_slice(available);
   84|    801|                            available.len()
   85|       |                        }
   86|       |                    }
   87|       |                };
   88|  3.83k|                self $(.$reader)? .consume(used);
   89|  3.83k|                read += used;
   90|       |            }
   91|  3.92k|            *position += read;
   92|  3.92k|
   93|  3.92k|            if read == 0 {
   94|     93|                Ok(None)
   95|       |            } else {
   96|  3.83k|                Ok(Some(&buf[start..]))
   97|       |            }
   98|  3.92k|        }

_RINvMs0_NtCscrcAsbrazo7_9quick_xml6readerINtB6_6ReaderRShE15read_event_implQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEECs19LGvG89wkE_13oxigraph_fuzz:
  643|  9.89k|    fn read_event_impl<'i, B>(&mut self, mut buf: B) -> Result<Event<'i>>
  644|  9.89k|    where
  645|  9.89k|        R: XmlSource<'i, B>,
  646|  9.89k|    {
  647|  18.9k|        read_event_impl!(self, buf, self.reader, read_until_open, read_until_close)
  648|  9.89k|    }
_RINvMs0_NtCscrcAsbrazo7_9quick_xml6readerINtB6_6ReaderRShE16read_until_closeQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEECs19LGvG89wkE_13oxigraph_fuzz:
  663|  9.02k|    fn read_until_close<'i, B>(&mut self, buf: B) -> Result<Event<'i>>
  664|  9.02k|    where
  665|  9.02k|        R: XmlSource<'i, B>,
  666|  9.02k|    {
  667|  9.02k|        read_until_close!(self, buf, self.reader)
  668|  9.02k|    }
_RINvMs0_NtCscrcAsbrazo7_9quick_xml6readerINtB6_6ReaderRShE15read_until_openQINtNtCsgGlVtr8vkIt_5alloc3vec3VechEECs19LGvG89wkE_13oxigraph_fuzz:
  654|  9.89k|    fn read_until_open<'i, B>(&mut self, buf: B) -> Result<std::result::Result<Event<'i>, B>>
  655|  9.89k|    where
  656|  9.89k|        R: XmlSource<'i, B>,
  657|  9.89k|    {
  658|  9.89k|        read_until_open!(self, buf, self.reader, read_event_impl)
  659|  9.89k|    }
_RNvMNtCscrcAsbrazo7_9quick_xml6readerINtB2_6ReaderRShE21expand_empty_elementsCs19LGvG89wkE_13oxigraph_fuzz:
   33|  1.91k|        pub fn expand_empty_elements(&mut self, val: bool) -> &mut Self {
   34|  1.91k|            self $(.$holder)? .parser.expand_empty_elements = val;
   35|  1.91k|            self
   36|  1.91k|        }
_RNvMNtCscrcAsbrazo7_9quick_xml6readerINtB2_6ReaderRShE9trim_textCs19LGvG89wkE_13oxigraph_fuzz:
   60|  1.91k|        pub fn trim_text(&mut self, val: bool) -> &mut Self {
   61|  1.91k|            self $(.$holder)? .parser.trim_text_start = val;
   62|  1.91k|            self $(.$holder)? .parser.trim_text_end = val;
   63|  1.91k|            self
   64|  1.91k|        }
_RNvMs1_NtCscrcAsbrazo7_9quick_xml6readerNtB5_8BangType3new:
  805|  5.70k|    fn new(byte: Option<u8>) -> Result<Self> {
  806|  5.70k|        Ok(match byte {
  807|    140|            Some(b'[') => Self::CData,
  808|  5.10k|            Some(b'-') => Self::Comment,
  809|    448|            Some(b'D') | Some(b'd') => Self::DocType,
  810|      7|            Some(b) => return Err(Error::UnexpectedBang(b)),
  811|      7|            None => return Err(Error::UnexpectedEof("Bang".to_string())),
  812|       |        })
  813|  5.70k|    }
_RNvMs2_NtCscrcAsbrazo7_9quick_xml6readerNtB5_16ReadElementState6change:
  902|    256|    fn change<'b>(&mut self, chunk: &'b [u8]) -> Option<(&'b [u8], usize)> {
  903|  6.49k|        for i in memchr::memchr3_iter(b'>', b'\'', b'"', chunk) {
  904|  6.49k|            *self = match (*self, chunk[i]) {
  905|       |                // only allowed to match `>` while we are in state `Elem`
  906|     13|                (Self::Elem, b'>') => return Some((&chunk[..i], i + 1)),
  907|  1.94k|                (Self::Elem, b'\'') => Self::SingleQ,
  908|    571|                (Self::Elem, b'\"') => Self::DoubleQ,
  909|       |
  910|       |                // the only end_byte that gets us out if the same character
  911|  2.42k|                (Self::SingleQ, b'\'') | (Self::DoubleQ, b'"') => Self::Elem,
  912|       |
  913|       |                // all other bytes: no state change
  914|  1.54k|                _ => *self,
  915|       |            };
  916|       |        }
  917|    243|        None
  918|    256|    }
_RNvMs1_NtCscrcAsbrazo7_9quick_xml6readerNtB5_8BangType5parse:
  822|  5.69k|    fn parse<'b>(&self, buf: &[u8], chunk: &'b [u8]) -> Option<(&'b [u8], usize)> {
  823|  30.2k|        for i in memchr::memchr_iter(b'>', chunk) {
  824|  7.20k|            match self {
  825|  7.20k|                // Need to read at least 6 symbols (`!---->`) for properly finished comment
  826|  7.20k|                // <!----> - XML comment
  827|  7.20k|                //  012345 - i
  828|  7.20k|                Self::Comment if buf.len() + i > 4 => {
  829|  5.97k|                    if chunk[..i].ends_with(b"--") {
  830|       |                        // We cannot strip last `--` from the buffer because we need it in case of
  831|       |                        // check_comments enabled option. XML standard requires that comment
  832|       |                        // will not end with `--->` sequence because this is a special case of
  833|       |                        // `--` in the comment (https://www.w3.org/TR/xml11/#sec-comments)
  834|  4.98k|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  835|    984|                    }
  836|    984|                    // End sequence `-|->` was splitted at |
  837|    984|                    //        buf --/   \-- chunk
  838|    984|                    if i == 1 && buf.ends_with(b"-") && chunk[0] == b'-' {
  839|      0|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  840|    984|                    }
  841|    984|                    // End sequence `--|>` was splitted at |
  842|    984|                    //         buf --/   \-- chunk
  843|    984|                    if i == 0 && buf.ends_with(b"--") {
  844|      0|                        return Some((&[], i + 1)); // +1 for `>`
  845|    984|                    }
  846|       |                }
  847|  1.23k|                Self::Comment => {}
  848|       |                Self::CData => {
  849|  4.97k|                    if chunk[..i].ends_with(b"]]") {
  850|      5|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  851|  4.96k|                    }
  852|  4.96k|                    // End sequence `]|]>` was splitted at |
  853|  4.96k|                    //        buf --/   \-- chunk
  854|  4.96k|                    if i == 1 && buf.ends_with(b"]") && chunk[0] == b']' {
  855|      0|                        return Some((&chunk[..i], i + 1)); // +1 for `>`
  856|  4.96k|                    }
  857|  4.96k|                    // End sequence `]]|>` was splitted at |
  858|  4.96k|                    //         buf --/   \-- chunk
  859|  4.96k|                    if i == 0 && buf.ends_with(b"]]") {
  860|      0|                        return Some((&[], i + 1)); // +1 for `>`
  861|  4.96k|                    }
  862|       |                }
  863|       |                Self::DocType => {
  864|  18.0k|                    let content = &chunk[..i];
  865|  18.0k|                    let balance = memchr::memchr2_iter(b'<', b'>', content)
  866|  18.0k|                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })
  867|  18.0k|                        .sum::<i32>();
  868|  18.0k|                    if balance == 0 {
  869|    233|                        return Some((content, i + 1)); // +1 for `>`
  870|  17.8k|                    }
  871|       |                }
  872|       |            }
  873|       |        }
  874|    466|        None
  875|  5.69k|    }
_RNvMs1_NtCscrcAsbrazo7_9quick_xml6readerNtB5_8BangType6to_errCs19LGvG89wkE_13oxigraph_fuzz:
  877|    466|    fn to_err(&self) -> Error {
  878|    466|        let bang_str = match self {
  879|    135|            Self::CData => "CData",
  880|    116|            Self::Comment => "Comment",
  881|    215|            Self::DocType => "DOCTYPE",
  882|       |        };
  883|    466|        Error::UnexpectedEof(bang_str.to_string())
  884|    466|    }
_RNvNtCscrcAsbrazo7_9quick_xml6reader13is_whitespaceCs19LGvG89wkE_13oxigraph_fuzz:
  923|  12.5k|pub(crate) const fn is_whitespace(b: u8) -> bool {
  924|  12.5k|    matches!(b, b' ' | b'\r' | b'\n' | b'\t')
  925|  12.5k|}
_RNvNtCscrcAsbrazo7_9quick_xml6reader13is_whitespaceB3_:
  923|  14.1k|pub(crate) const fn is_whitespace(b: u8) -> bool {
  924|  14.1k|    matches!(b, b' ' | b'\r' | b'\n' | b'\t')
  925|  14.1k|}
_RNvMs1_NtCscrcAsbrazo7_9quick_xml6readerNtB5_8BangType6to_errB7_:
  877|    185|    fn to_err(&self) -> Error {
  878|    185|        let bang_str = match self {
  879|      5|            Self::CData => "CData",
  880|     14|            Self::Comment => "Comment",
  881|    166|            Self::DocType => "DOCTYPE",
  882|       |        };
  883|    185|        Error::UnexpectedEof(bang_str.to_string())
  884|    185|    }
_RNvMs_NtCscrcAsbrazo7_9quick_xml6readerINtB4_6ReaderRShE7decoderB6_:
  633|    256|    pub fn decoder(&self) -> Decoder {
  634|    256|        self.parser.decoder()
  635|    256|    }
_RNCNvMs1_NtCscrcAsbrazo7_9quick_xml6readerNtB7_8BangType5parse0B9_:
  866|  3.87M|                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })
_RNvMNtCscrcAsbrazo7_9quick_xml6readerINtB2_6ReaderRShE11from_readerB4_:
  533|  1.91k|    pub fn from_reader(reader: R) -> Self {
  534|  1.91k|        Self {
  535|  1.91k|            reader,
  536|  1.91k|            parser: Parser::default(),
  537|  1.91k|        }
  538|  1.91k|    }

_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser8read_end0B8_:
  136|  1.57k|            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser18read_question_mark:
  183|  3.00k|    pub fn read_question_mark<'b>(&mut self, buf: &'b [u8]) -> Result<Event<'b>> {
  184|  3.00k|        let len = buf.len();
  185|  3.00k|        if len > 2 && buf[len - 1] == b'?' {
  186|  2.94k|            if len > 5 && &buf[1..4] == b"xml" && is_whitespace(buf[4]) {
  187|      0|                let event = BytesDecl::from_start(BytesStart::wrap(&buf[1..len - 1], 3));
  188|      0|
  189|      0|                // Try getting encoding from the declaration event
  190|      0|                #[cfg(feature = "encoding")]
  191|      0|                if self.encoding.can_be_refined() {
  192|      0|                    if let Some(encoding) = event.encoder() {
  193|      0|                        self.encoding = EncodingRef::XmlDetected(encoding);
  194|      0|                    }
  195|      0|                }
  196|      0|
  197|      0|                Ok(Event::Decl(event))
  198|       |            } else {
  199|  2.94k|                Ok(Event::PI(BytesText::wrap(&buf[1..len - 1], self.decoder())))
  200|       |            }
  201|       |        } else {
  202|     60|            self.offset -= len;
  203|     60|            Err(Error::UnexpectedEof("XmlDecl".to_string()))
  204|       |        }
  205|  3.00k|    }
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser7decoder:
  256|  9.07k|    pub fn decoder(&self) -> Decoder {
  257|  9.07k|        Decoder {
  258|  9.07k|            #[cfg(feature = "encoding")]
  259|  9.07k|            encoding: self.encoding.encoding(),
  260|  9.07k|        }
  261|  9.07k|    }
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser8read_end:
  132|     57|    pub fn read_end<'b>(&mut self, buf: &'b [u8]) -> Result<Event<'b>> {
  133|       |        // XML standard permits whitespaces after the markup name in closing tags.
  134|       |        // Let's strip them from the buffer before comparing tag names.
  135|     57|        let name = if self.trim_markup_names_in_closing_tags {
  136|     57|            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {
  137|     16|                let (name, _) = buf[1..].split_at(pos_end_name + 1);
  138|     16|                name
  139|       |            } else {
  140|     41|                &buf[1..]
  141|       |            }
  142|       |        } else {
  143|      0|            &buf[1..]
  144|       |        };
  145|       |
  146|     57|        let decoder = self.decoder();
  147|     57|        let mismatch_err = |expected: String, found: &[u8], offset: &mut usize| {
  148|       |            *offset -= buf.len();
  149|       |            Err(Error::EndEventMismatch {
  150|       |                expected,
  151|       |                found: decoder.decode(found).unwrap_or_default().into_owned(),
  152|       |            })
  153|       |        };
  154|       |
  155|       |        // Get the index in self.opened_buffer of the name of the last opened tag
  156|     57|        match self.opened_starts.pop() {
  157|      0|            Some(start) => {
  158|      0|                if self.check_end_names {
  159|      0|                    let expected = &self.opened_buffer[start..];
  160|      0|                    if name != expected {
  161|      0|                        let expected = decoder.decode(expected).unwrap_or_default().into_owned();
  162|      0|                        // #513: In order to allow error recovery we should drop content of the buffer
  163|      0|                        self.opened_buffer.truncate(start);
  164|      0|
  165|      0|                        return mismatch_err(expected, name, &mut self.offset);
  166|      0|                    }
  167|      0|                }
  168|       |
  169|      0|                self.opened_buffer.truncate(start);
  170|       |            }
  171|       |            None => {
  172|     57|                if self.check_end_names {
  173|     57|                    return mismatch_err("".to_string(), &buf[1..], &mut self.offset);
  174|      0|                }
  175|       |            }
  176|       |        }
  177|       |
  178|      0|        Ok(Event::End(BytesEnd::wrap(name.into())))
  179|     57|    }
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser10read_start:
  211|    256|    pub fn read_start<'b>(&mut self, content: &'b [u8]) -> Result<Event<'b>> {
  212|    256|        let len = content.len();
  213|    256|        let name_end = content
  214|    256|            .iter()
  215|    256|            .position(|&b| is_whitespace(b))
  216|    256|            .unwrap_or(len);
  217|    256|        if let Some(&b'/') = content.last() {
  218|       |            // This is self-closed tag `<something/>`
  219|      2|            let name_len = if name_end < len { name_end } else { len - 1 };
  220|      2|            let event = BytesStart::wrap(&content[..len - 1], name_len);
  221|      2|
  222|      2|            if self.expand_empty_elements {
  223|      2|                self.state = ParseState::Empty;
  224|      2|                self.opened_starts.push(self.opened_buffer.len());
  225|      2|                self.opened_buffer.extend(&content[..name_len]);
  226|      2|                Ok(Event::Start(event))
  227|       |            } else {
  228|      0|                Ok(Event::Empty(event))
  229|       |            }
  230|       |        } else {
  231|       |            // #514: Always store names event when .check_end_names == false,
  232|       |            // because checks can be temporary disabled and when they would be
  233|       |            // enabled, we should have that information
  234|    254|            self.opened_starts.push(self.opened_buffer.len());
  235|    254|            self.opened_buffer.extend(&content[..name_end]);
  236|    254|            Ok(Event::Start(BytesStart::wrap(content, name_end)))
  237|       |        }
  238|    256|    }
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser9read_text:
   68|    779|    pub fn read_text<'b>(&mut self, bytes: &'b [u8]) -> Result<Event<'b>> {
   69|    779|        let mut content = bytes;
   70|    779|
   71|    779|        if self.trim_text_end {
   72|    779|            // Skip the ending '<'
   73|    779|            let len = bytes
   74|    779|                .iter()
   75|    779|                .rposition(|&b| !is_whitespace(b))
   76|    779|                .map_or_else(|| bytes.len(), |p| p + 1);
   77|    779|            content = &bytes[..len];
   78|    779|        }
   79|       |
   80|    779|        Ok(Event::Text(BytesText::wrap(content, self.decoder())))
   81|    779|    }
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser9read_text0B8_:
   75|  2.95k|                .rposition(|&b| !is_whitespace(b))
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser10read_start0B8_:
  215|  10.1k|            .position(|&b| is_whitespace(b))
_RNvXs_NtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6ParserNtNtCsewp07EQjaMZ_4core7default7Default7default:
  265|  1.91k|    fn default() -> Self {
  266|  1.91k|        Self {
  267|  1.91k|            offset: 0,
  268|  1.91k|            state: ParseState::Init,
  269|  1.91k|            expand_empty_elements: false,
  270|  1.91k|            trim_text_start: false,
  271|  1.91k|            trim_text_end: false,
  272|  1.91k|            trim_markup_names_in_closing_tags: true,
  273|  1.91k|            check_end_names: true,
  274|  1.91k|            check_comments: false,
  275|  1.91k|            opened_buffer: Vec::new(),
  276|  1.91k|            opened_starts: Vec::new(),
  277|  1.91k|
  278|  1.91k|            #[cfg(feature = "encoding")]
  279|  1.91k|            encoding: EncodingRef::Implicit(UTF_8),
  280|  1.91k|        }
  281|  1.91k|    }
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser8read_ends_0B8_:
  147|     57|        let mismatch_err = |expected: String, found: &[u8], offset: &mut usize| {
  148|     57|            *offset -= buf.len();
  149|     57|            Err(Error::EndEventMismatch {
  150|     57|                expected,
  151|     57|                found: decoder.decode(found).unwrap_or_default().into_owned(),
  152|     57|            })
  153|     57|        };
_RNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB2_6Parser9read_bang:
   85|  5.22k|    pub fn read_bang<'b>(&mut self, bang_type: BangType, buf: &'b [u8]) -> Result<Event<'b>> {
   86|  5.22k|        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {
   87|       |            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)
   88|       |        };
   89|       |
   90|  5.22k|        let len = buf.len();
   91|    238|        match bang_type {
   92|  4.98k|            BangType::Comment if buf.starts_with(b"!--") => {
   93|      0|                debug_assert!(buf.ends_with(b"--"));
   94|  4.97k|                if self.check_comments {
   95|       |                    // search if '--' not in comments
   96|      0|                    if let Some(p) = memchr::memchr_iter(b'-', &buf[3..len - 2])
   97|      0|                        .position(|p| buf[3 + p + 1] == b'-')
   98|       |                    {
   99|      0|                        self.offset += len - p;
  100|      0|                        return Err(Error::UnexpectedToken("--".to_string()));
  101|      0|                    }
  102|  4.97k|                }
  103|  4.97k|                Ok(Event::Comment(BytesText::wrap(
  104|  4.97k|                    &buf[3..len - 2],
  105|  4.97k|                    self.decoder(),
  106|  4.97k|                )))
  107|       |            }
  108|      5|            BangType::CData if uncased_starts_with(buf, b"![CDATA[") => {
  109|      0|                debug_assert!(buf.ends_with(b"]]"));
  110|      0|                Ok(Event::CData(BytesCData::wrap(
  111|      0|                    &buf[8..len - 2],
  112|      0|                    self.decoder(),
  113|      0|                )))
  114|       |            }
  115|    233|            BangType::DocType if uncased_starts_with(buf, b"!DOCTYPE") => {
  116|     67|                let start = buf[8..]
  117|     67|                    .iter()
  118|     67|                    .position(|b| !is_whitespace(*b))
  119|     67|                    .unwrap_or(len - 8);
  120|      0|                debug_assert!(start < len - 8, "DocType must have a name");
  121|     67|                Ok(Event::DocType(BytesText::wrap(
  122|     67|                    &buf[8 + start..],
  123|     67|                    self.decoder(),
  124|     67|                )))
  125|       |            }
  126|    185|            _ => Err(bang_type.to_err()),
  127|       |        }
  128|  5.22k|    }
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser9read_bang0B8_:
   86|    238|        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {
   87|    238|            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)
   88|    238|        };
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser9read_bangs0_0B8_:
  118|    988|                    .position(|b| !is_whitespace(*b))
_RNCNvMNtNtCscrcAsbrazo7_9quick_xml6reader6parserNtB4_6Parser9read_texts0_0B8_:
   76|    779|                .map_or_else(|| bytes.len(), |p| p + 1);

_RNvNtCs19LGvG89wkE_13oxigraph_fuzz13result_format18fuzz_result_format:
    6|  1.91k|pub fn fuzz_result_format(format: QueryResultsFormat, data: &[u8]) {
    7|  1.91k|    let parser = QueryResultsParser::from_format(format);
    8|  1.91k|    let serializer = QueryResultsSerializer::from_format(format);
    9|       |
   10|  1.91k|    let Ok(reader) = parser.read_results(data) else {
   11|  1.91k|        return;
   12|       |    };
   13|      0|    match reader {
   14|      0|        QueryResultsReader::Solutions(solutions) => {
   15|      0|            let Ok(solutions) = solutions.collect::<Result<Vec<_>, _>>() else {
   16|      0|                return;
   17|       |            };
   18|       |
   19|       |            // We try to write again
   20|      0|            let mut writer = serializer
   21|      0|                .solutions_writer(
   22|      0|                    Vec::new(),
   23|      0|                    solutions
   24|      0|                        .get(0)
   25|      0|                        .map_or_else(Vec::new, |s| s.variables().to_vec()),
   26|      0|                )
   27|      0|                .unwrap();
   28|      0|            for solution in &solutions {
   29|      0|                writer.write(solution).unwrap();
   30|      0|            }
   31|      0|            let serialized = String::from_utf8(writer.finish().unwrap()).unwrap();
   32|       |
   33|       |            // And to parse again
   34|      0|            if let QueryResultsReader::Solutions(roundtrip_solutions) = parser
   35|      0|                .read_results(serialized.as_bytes())
   36|      0|                .with_context(|| format!("Parsing {:?}", &serialized))
   37|      0|                .unwrap()
   38|       |            {
   39|      0|                assert_eq!(
   40|      0|                    roundtrip_solutions
   41|      0|                        .collect::<Result<Vec<_>, _>>()
   42|      0|                        .with_context(|| format!("Parsing {:?}", &serialized))
   43|      0|                        .unwrap(),
   44|      0|                    solutions
   45|      0|                )
   46|      0|            }
   47|       |        }
   48|      0|        QueryResultsReader::Boolean(value) => {
   49|      0|            // We try to write again
   50|      0|            let mut serialized = Vec::new();
   51|      0|            serializer
   52|      0|                .write_boolean_result(&mut serialized, value)
   53|      0|                .unwrap();
   54|       |
   55|       |            // And to parse again
   56|      0|            if let QueryResultsReader::Boolean(roundtrip_value) =
   57|      0|                parser.read_results(serialized.as_slice()).unwrap()
   58|       |            {
   59|      0|                assert_eq!(roundtrip_value, value)
   60|      0|            }
   61|       |        }
   62|       |    }
   63|  1.91k|}

_RNvXs1_NtCs7SkuAFpjVRX_10sparesults5errorNtB5_10ParseErrorINtNtCsewp07EQjaMZ_4core7convert4FromNtB5_11SyntaxErrorE4fromCs19LGvG89wkE_13oxigraph_fuzz:
   43|    678|    fn from(error: SyntaxError) -> Self {
   44|    678|        Self::Syntax(error)
   45|    678|    }
_RNvXs3_NtCs7SkuAFpjVRX_10sparesults5errorNtB5_10ParseErrorINtNtCsewp07EQjaMZ_4core7convert4FromNtNtCscrcAsbrazo7_9quick_xml6errors5ErrorE4fromCs19LGvG89wkE_13oxigraph_fuzz:
   60|  1.23k|    fn from(error: quick_xml::Error) -> Self {
   61|  1.23k|        match error {
   62|      0|            quick_xml::Error::Io(error) => Self::Io(io::Error::new(error.kind(), error)),
   63|  1.23k|            error => Self::Syntax(SyntaxError {
   64|  1.23k|                inner: SyntaxErrorKind::Xml(error),
   65|  1.23k|            }),
   66|       |        }
   67|  1.23k|    }
_RINvMs4_NtCs7SkuAFpjVRX_10sparesults5errorNtB6_11SyntaxError3msgNtNtCsgGlVtr8vkIt_5alloc6string6StringECs19LGvG89wkE_13oxigraph_fuzz:
   86|    584|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|    584|        Self {
   88|    584|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|    584|        }
   90|    584|    }
_RINvMs4_NtCs7SkuAFpjVRX_10sparesults5errorNtB6_11SyntaxError3msgReECs19LGvG89wkE_13oxigraph_fuzz:
   86|     94|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|     94|        Self {
   88|     94|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|     94|        }
   90|     94|    }

_RNvMs_Cs7SkuAFpjVRX_10sparesultsNtB4_18QueryResultsParser11from_formatCs19LGvG89wkE_13oxigraph_fuzz:
  166|  1.91k|    pub fn from_format(format: QueryResultsFormat) -> Self {
  167|  1.91k|        Self { format }
  168|  1.91k|    }
_RNvMs2_Cs7SkuAFpjVRX_10sparesultsNtB5_22QueryResultsSerializer11from_formatCs19LGvG89wkE_13oxigraph_fuzz:
  362|  1.91k|    pub fn from_format(format: QueryResultsFormat) -> Self {
  363|  1.91k|        Self { format }
  364|  1.91k|    }
_RINvMs_Cs7SkuAFpjVRX_10sparesultsNtB5_18QueryResultsParser12read_resultsRShECs19LGvG89wkE_13oxigraph_fuzz:
  193|  1.91k|    pub fn read_results<R: BufRead>(&self, reader: R) -> Result<QueryResultsReader<R>, ParseError> {
  194|  1.91k|        Ok(match self.format {
  195|  1.91k|            QueryResultsFormat::Xml => match XmlQueryResultsReader::read(reader)? {
  196|      0|                XmlQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  197|       |                XmlQueryResultsReader::Solutions {
  198|      0|                    solutions,
  199|      0|                    variables,
  200|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  201|      0|                    variables: Rc::new(variables),
  202|      0|                    solutions: SolutionsReaderKind::Xml(solutions),
  203|      0|                }),
  204|       |            },
  205|      0|            QueryResultsFormat::Json => match JsonQueryResultsReader::read(reader)? {
  206|      0|                JsonQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  207|       |                JsonQueryResultsReader::Solutions {
  208|      0|                    solutions,
  209|      0|                    variables,
  210|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  211|      0|                    variables: Rc::new(variables),
  212|      0|                    solutions: SolutionsReaderKind::Json(solutions),
  213|      0|                }),
  214|       |            },
  215|      0|            QueryResultsFormat::Csv => return Err(SyntaxError::msg("CSV SPARQL results syntax is lossy and can't be parsed to a proper RDF representation").into()),
  216|      0|            QueryResultsFormat::Tsv => match TsvQueryResultsReader::read(reader)? {
  217|      0|                TsvQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  218|       |                TsvQueryResultsReader::Solutions {
  219|      0|                    solutions,
  220|      0|                    variables,
  221|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  222|      0|                    variables: Rc::new(variables),
  223|      0|                    solutions: SolutionsReaderKind::Tsv(solutions),
  224|      0|                }),
  225|       |            },
  226|       |        })
  227|  1.91k|    }

_RNvMs_NtCs7SkuAFpjVRX_10sparesults3xmlINtB4_21XmlQueryResultsReaderRShE4readCs19LGvG89wkE_13oxigraph_fuzz:
  170|  1.91k|    pub fn read(source: R) -> Result<Self, ParseError> {
  171|  1.91k|        enum State {
  172|  1.91k|            Start,
  173|  1.91k|            Sparql,
  174|  1.91k|            Head,
  175|  1.91k|            AfterHead,
  176|  1.91k|            Boolean,
  177|  1.91k|        }
  178|  1.91k|
  179|  1.91k|        let mut reader = Reader::from_reader(source);
  180|  1.91k|        reader.trim_text(true);
  181|  1.91k|        reader.expand_empty_elements(true);
  182|  1.91k|
  183|  1.91k|        let mut buffer = Vec::default();
  184|  1.91k|        let mut variables = Vec::default();
  185|  1.91k|        let mut state = State::Start;
  186|       |
  187|       |        //Read header
  188|  9.89k|        loop {
  189|  9.89k|            buffer.clear();
  190|  9.89k|            let event = reader.read_event_into(&mut buffer)?;
  191|  9.11k|            match event {
  192|    256|                Event::Start(event) => match state {
  193|       |                    State::Start => {
  194|    256|                        if event.local_name().as_ref() == b"sparql" {
  195|      0|                            state = State::Sparql;
  196|      0|                        } else {
  197|    256|                            return Err(SyntaxError::msg(format!("Expecting <sparql> tag, found <{}>", decode(&reader, &event.name())?)).into());
  198|       |                        }
  199|       |                    }
  200|       |                    State::Sparql => {
  201|      0|                        if event.local_name().as_ref() == b"head" {
  202|      0|                            state = State::Head;
  203|      0|                        } else {
  204|      0|                            return Err(SyntaxError::msg(format!("Expecting <head> tag, found <{}>",decode(&reader, &event.name())?)).into());
  205|       |                        }
  206|       |                    }
  207|       |                    State::Head => {
  208|      0|                        if event.local_name().as_ref() == b"variable" {
  209|      0|                            let name = event.attributes()
  210|      0|                                .filter_map(Result::ok)
  211|      0|                                .find(|attr| attr.key.local_name().as_ref() == b"name")
  212|      0|                                .ok_or_else(|| SyntaxError::msg("No name attribute found for the <variable> tag"))?
  213|      0|                                .decode_and_unescape_value(&reader)?;
  214|      0|                            let variable = Variable::new(name).map_err(|e| SyntaxError::msg(format!("Invalid variable name: {e}")))?;
  215|      0|                            if variables.contains(&variable) {
  216|      0|                                return Err(SyntaxError::msg(format!(
  217|      0|                                    "The variable {variable} is declared twice"
  218|      0|                                ))
  219|      0|                                    .into());
  220|      0|                            }
  221|      0|                            variables.push(variable);
  222|      0|                        } else if event.local_name().as_ref() == b"link" {
  223|      0|                            // no op
  224|      0|                        } else {
  225|      0|                            return Err(SyntaxError::msg(format!("Expecting <variable> or <link> tag, found <{}>", decode(&reader, &event.name())?)).into());
  226|       |                        }
  227|       |                    }
  228|       |                    State::AfterHead => {
  229|      0|                        if event.local_name().as_ref() == b"boolean" {
  230|      0|                            state = State::Boolean
  231|      0|                        } else if event.local_name().as_ref() == b"results" {
  232|      0|                            let mut mapping = BTreeMap::default();
  233|      0|                            for (i, var) in variables.iter().enumerate() {
  234|      0|                                mapping.insert(var.clone().into_string(), i);
  235|      0|                            }
  236|      0|                            return Ok(Self::Solutions { variables,
  237|      0|                                solutions: XmlSolutionsReader {
  238|      0|                                    reader,
  239|      0|                                    buffer,
  240|      0|                                    mapping,
  241|      0|                                    stack: Vec::new(),
  242|      0|                                    subject_stack: Vec::new(),
  243|      0|                                    predicate_stack: Vec::new(),
  244|      0|                                    object_stack: Vec::new(),
  245|      0|                                }});
  246|      0|                        } else if event.local_name().as_ref() != b"link" && event.local_name().as_ref() != b"results" && event.local_name().as_ref() != b"boolean" {
  247|      0|                            return Err(SyntaxError::msg(format!("Expecting sparql tag, found <{}>", decode(&reader, &event.name())?)).into());
  248|      0|                        }
  249|       |                    }
  250|      0|                    State::Boolean => return Err(SyntaxError::msg(format!("Unexpected tag inside of <boolean> tag: <{}>", decode(&reader, &event.name())?)).into())
  251|       |                },
  252|    779|                Event::Text(event) => {
  253|    779|                    let value = event.unescape()?;
  254|    507|                    return match state {
  255|       |                        State::Boolean => {
  256|      0|                            return if value == "true" {
  257|      0|                                Ok(Self::Boolean(true))
  258|      0|                            } else if value == "false" {
  259|      0|                                Ok(Self::Boolean(false))
  260|       |                            } else {
  261|      0|                                Err(SyntaxError::msg(format!("Unexpected boolean value. Found '{value}'")).into())
  262|       |                            };
  263|       |                        }
  264|    507|                        _ => Err(SyntaxError::msg(format!("Unexpected textual value found: '{value}'")).into())
  265|       |                    };
  266|       |                },
  267|      0|                Event::End(event) => {
  268|      0|                    if let State::Head = state {
  269|      0|                        if event.local_name().as_ref() == b"head" {
  270|      0|                            state = State::AfterHead
  271|      0|                        }
  272|       |                    } else {
  273|      0|                        return Err(SyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into());
  274|       |                    }
  275|       |                },
  276|     94|                Event::Eof => return Err(SyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into()),
  277|  7.98k|                _ => (),
  278|       |            }
  279|       |        }
  280|  1.91k|    }
_RINvNtCs7SkuAFpjVRX_10sparesults3xml6decodeRShNtNtCscrcAsbrazo7_9quick_xml4name5QNameECs19LGvG89wkE_13oxigraph_fuzz:
  598|    256|fn decode<'a, T>(
  599|    256|    reader: &Reader<T>,
  600|    256|    data: &'a impl AsRef<[u8]>,
  601|    256|) -> Result<Cow<'a, str>, ParseError> {
  602|    256|    Ok(reader.decoder().decode(data.as_ref())?)
  603|    256|}

