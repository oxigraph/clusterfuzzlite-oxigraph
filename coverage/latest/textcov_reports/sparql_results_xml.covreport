



















_RNvNtCs8v7buCb6vFJ_13oxigraph_fuzz13result_format18fuzz_result_format:
    6|  15.0k|pub fn fuzz_result_format(format: QueryResultsFormat, data: &[u8]) {
    7|  15.0k|    let Ok(reader) = QueryResultsParser::from_format(format).parse_slice(data) else {
    8|  15.0k|        return;
    9|       |    };
   10|      0|    match reader {
   11|      0|        FromSliceQueryResultsReader::Solutions(solutions) => {
   12|      0|            let Ok(solutions) = solutions.collect::<Result<Vec<_>, _>>() else {
   13|      0|                return;
   14|       |            };
   15|       |
   16|       |            // We try to write again
   17|      0|            let mut writer = QueryResultsSerializer::from_format(format)
   18|      0|                .serialize_solutions_to_write(
   19|      0|                    Vec::new(),
   20|      0|                    solutions
   21|      0|                        .first()
   22|      0|                        .map_or_else(Vec::new, |s| s.variables().to_vec()),
   23|      0|                )
   24|      0|                .unwrap();
   25|      0|            for solution in &solutions {
   26|      0|                writer.write(solution).unwrap();
   27|      0|            }
   28|      0|            let serialized = writer.finish().unwrap();
   29|       |
   30|       |            // And to parse again
   31|      0|            if let FromSliceQueryResultsReader::Solutions(roundtrip_solutions) =
   32|      0|                QueryResultsParser::from_format(format)
   33|      0|                    .parse_slice(&serialized)
   34|      0|                    .with_context(|| format!("Parsing {:?}", String::from_utf8_lossy(&serialized)))
   35|      0|                    .unwrap()
   36|       |            {
   37|      0|                assert_eq!(
   38|      0|                    roundtrip_solutions
   39|      0|                        .collect::<Result<Vec<_>, _>>()
   40|      0|                        .with_context(|| format!("Parsing {serialized:?}"))
   41|      0|                        .unwrap(),
   42|      0|                    solutions
   43|      0|                )
   44|      0|            }
   45|       |        }
   46|      0|        FromSliceQueryResultsReader::Boolean(value) => {
   47|      0|            // We try to write again
   48|      0|            let mut serialized = Vec::new();
   49|      0|            QueryResultsSerializer::from_format(format)
   50|      0|                .serialize_boolean_to_write(&mut serialized, value)
   51|      0|                .unwrap();
   52|       |
   53|       |            // And to parse again
   54|      0|            if let FromSliceQueryResultsReader::Boolean(roundtrip_value) =
   55|      0|                QueryResultsParser::from_format(format)
   56|      0|                    .parse_slice(&serialized)
   57|      0|                    .unwrap()
   58|       |            {
   59|      0|                assert_eq!(roundtrip_value, value)
   60|      0|            }
   61|       |        }
   62|       |    }
   63|  15.0k|}

_RINvMs2_NtCs1Aij2IKAmMy_10sparesults5errorNtB6_23QueryResultsSyntaxError3msgNtNtCs3OstG5Tqy1X_5alloc6string6StringEB8_:
   87|  3.05k|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   88|  3.05k|        Self(SyntaxErrorKind::Msg {
   89|  3.05k|            msg: msg.into(),
   90|  3.05k|            location: None,
   91|  3.05k|        })
   92|  3.05k|    }
_RINvMs2_NtCs1Aij2IKAmMy_10sparesults5errorNtB6_23QueryResultsSyntaxError3msgReEB8_:
   87|  1.76k|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   88|  1.76k|        Self(SyntaxErrorKind::Msg {
   89|  1.76k|            msg: msg.into(),
   90|  1.76k|            location: None,
   91|  1.76k|        })
   92|  1.76k|    }
_RNvXs0_NtCs1Aij2IKAmMy_10sparesults5errorNtB5_22QueryResultsParseErrorINtNtCscdEvteftVc2_4core7convert4FromNtNtCs4QWtT85WPeh_9quick_xml6errors5ErrorE4fromB7_:
   42|  10.2k|    fn from(error: quick_xml::Error) -> Self {
   43|  10.2k|        match error {
   44|      0|            quick_xml::Error::Io(error) => {
   45|      0|                Self::Io(Arc::try_unwrap(error).unwrap_or_else(|e| io::Error::new(e.kind(), e)))
   46|       |            }
   47|  10.2k|            _ => Self::Syntax(QueryResultsSyntaxError(SyntaxErrorKind::Xml(error))),
   48|       |        }
   49|  10.2k|    }
_RNvXs9_NtCs1Aij2IKAmMy_10sparesults5errorNtB5_22QueryResultsParseErrorINtNtCscdEvteftVc2_4core7convert4FromNtB5_23QueryResultsSyntaxErrorE4from:
    7|  4.81k|#[derive(Debug, thiserror::Error)]

_RNvMNtCs1Aij2IKAmMy_10sparesults6parserNtB2_18QueryResultsParser11from_formatCs8v7buCb6vFJ_13oxigraph_fuzz:
   65|  15.0k|    pub fn from_format(format: QueryResultsFormat) -> Self {
   66|  15.0k|        Self { format }
   67|  15.0k|    }
_RNvMNtCs1Aij2IKAmMy_10sparesults6parserNtB2_18QueryResultsParser11parse_slice:
  234|  15.0k|    pub fn parse_slice(
  235|  15.0k|        self,
  236|  15.0k|        slice: &[u8],
  237|  15.0k|    ) -> Result<FromSliceQueryResultsReader<'_>, QueryResultsSyntaxError> {
  238|  15.0k|        Ok(match self.format {
  239|  15.0k|            QueryResultsFormat::Xml => match FromSliceXmlQueryResultsReader::read(slice)? {
  240|      0|                FromSliceXmlQueryResultsReader::Boolean(r) => FromSliceQueryResultsReader::Boolean(r),
  241|       |                FromSliceXmlQueryResultsReader::Solutions {
  242|      0|                    solutions,
  243|      0|                    variables,
  244|      0|                } => FromSliceQueryResultsReader::Solutions(FromSliceSolutionsReader {
  245|      0|                    variables: variables.into(),
  246|      0|                    solutions: FromSliceSolutionsReaderKind::Xml(solutions),
  247|      0|                }),
  248|       |            },
  249|      0|            QueryResultsFormat::Json => match FromSliceJsonQueryResultsReader::read(slice)? {
  250|      0|                FromSliceJsonQueryResultsReader::Boolean(r) => FromSliceQueryResultsReader::Boolean(r),
  251|       |                FromSliceJsonQueryResultsReader::Solutions {
  252|      0|                    solutions,
  253|      0|                    variables,
  254|      0|                } => FromSliceQueryResultsReader::Solutions(FromSliceSolutionsReader {
  255|      0|                    variables: variables.into(),
  256|      0|                    solutions: FromSliceSolutionsReaderKind::Json(solutions),
  257|      0|                }),
  258|       |            },
  259|      0|            QueryResultsFormat::Csv => return Err(QueryResultsSyntaxError::msg("CSV SPARQL results syntax is lossy and can't be parsed to a proper RDF representation")),
  260|      0|            QueryResultsFormat::Tsv => match FromSliceTsvQueryResultsReader::read(slice)? {
  261|      0|                FromSliceTsvQueryResultsReader::Boolean(r) => FromSliceQueryResultsReader::Boolean(r),
  262|       |                FromSliceTsvQueryResultsReader::Solutions {
  263|      0|                    solutions,
  264|      0|                    variables,
  265|      0|                } => FromSliceQueryResultsReader::Solutions(FromSliceSolutionsReader {
  266|      0|                    variables: variables.into(),
  267|      0|                    solutions: FromSliceSolutionsReaderKind::Tsv(solutions),
  268|      0|                }),
  269|       |            },
  270|       |        })
  271|  15.0k|    }

_RNvMs2_NtCs1Aij2IKAmMy_10sparesults3xmlNtB5_30FromSliceXmlQueryResultsReader4read:
  361|  15.0k|    pub fn read(slice: &'a [u8]) -> Result<Self, QueryResultsSyntaxError> {
  362|  15.0k|        Self::do_read(slice).map_err(|e| match e {
  363|       |            QueryResultsParseError::Syntax(e) => e,
  364|       |            QueryResultsParseError::Io(e) => {
  365|       |                unreachable!("I/O error are not possible for slice but found {e}")
  366|       |            }
  367|  15.0k|        })
  368|  15.0k|    }
_RNvMs2_NtCs1Aij2IKAmMy_10sparesults3xmlNtB5_30FromSliceXmlQueryResultsReader7do_read:
  370|  15.0k|    fn do_read(slice: &'a [u8]) -> Result<Self, QueryResultsParseError> {
  371|  15.0k|        let mut reader = Reader::from_reader(slice);
  372|  15.0k|        XmlInnerQueryResultsReader::set_options(reader.config_mut());
  373|  15.0k|        let mut reader_buffer = Vec::new();
  374|  15.0k|        let mut inner = XmlInnerQueryResultsReader {
  375|  15.0k|            state: ResultsState::Start,
  376|  15.0k|            variables: Vec::new(),
  377|  15.0k|            decoder: reader.decoder(),
  378|  15.0k|        };
  379|   473k|        loop {
  380|   473k|            reader_buffer.clear();
  381|   473k|            let event = reader.read_event_into(&mut reader_buffer)?;
  382|   465k|            if let Some(result) = inner.read_event(event)? {
  383|      0|                return Ok(match result {
  384|       |                    XmlInnerQueryResults::Solutions {
  385|      0|                        variables,
  386|      0|                        solutions,
  387|      0|                    } => Self::Solutions {
  388|      0|                        variables,
  389|      0|                        solutions: FromSliceXmlSolutionsReader {
  390|      0|                            reader,
  391|      0|                            inner: solutions,
  392|      0|                            reader_buffer,
  393|      0|                        },
  394|      0|                    },
  395|      0|                    XmlInnerQueryResults::Boolean(value) => Self::Boolean(value),
  396|       |                });
  397|   458k|            }
  398|       |        }
  399|  15.0k|    }
_RNvMs4_NtCs1Aij2IKAmMy_10sparesults3xmlNtB5_26XmlInnerQueryResultsReader11set_options:
  456|  15.0k|    fn set_options(config: &mut Config) {
  457|  15.0k|        config.trim_text(true);
  458|  15.0k|        config.expand_empty_elements = true;
  459|  15.0k|    }
_RNvMs4_NtCs1Aij2IKAmMy_10sparesults3xmlNtB5_26XmlInnerQueryResultsReader10read_event:
  461|   465k|    pub fn read_event(
  462|   465k|        &mut self,
  463|   465k|        event: Event<'_>,
  464|   465k|    ) -> Result<Option<XmlInnerQueryResults>, QueryResultsParseError> {
  465|   465k|        match event {
  466|    651|            Event::Start(event) => match self.state {
  467|       |                ResultsState::Start => {
  468|    651|                    if event.local_name().as_ref() == b"sparql" {
  469|      0|                        self.state = ResultsState::Sparql;
  470|      0|                        Ok(None)
  471|       |                    } else {
  472|    651|                        Err(QueryResultsSyntaxError::msg(format!("Expecting <sparql> tag, found <{}>", self.decoder.decode(event.name().as_ref())?)).into())
  473|       |                    }
  474|       |                }
  475|       |                ResultsState::Sparql => {
  476|      0|                    if event.local_name().as_ref() == b"head" {
  477|      0|                        self.state = ResultsState::Head;
  478|      0|                        Ok(None)
  479|       |                    } else {
  480|      0|                        Err(QueryResultsSyntaxError::msg(format!("Expecting <head> tag, found <{}>", self.decoder.decode(event.name().as_ref())?)).into())
  481|       |                    }
  482|       |                }
  483|       |                ResultsState::Head => {
  484|      0|                    if event.local_name().as_ref() == b"variable" {
  485|      0|                        let name = event.attributes()
  486|      0|                            .filter_map(Result::ok)
  487|      0|                            .find(|attr| attr.key.local_name().as_ref() == b"name")
  488|      0|                            .ok_or_else(|| QueryResultsSyntaxError::msg("No name attribute found for the <variable> tag"))?;
  489|      0|                        let name = unescape(&self.decoder.decode(&name.value)?)?.into_owned();
  490|      0|                        let variable = Variable::new(name).map_err(|e| QueryResultsSyntaxError::msg(format!("Invalid variable name: {e}")))?;
  491|      0|                        if self.variables.contains(&variable) {
  492|      0|                            return Err(QueryResultsSyntaxError::msg(format!(
  493|      0|                                "The variable {variable} is declared twice"
  494|      0|                            ))
  495|      0|                                .into());
  496|      0|                        }
  497|      0|                        self.variables.push(variable);
  498|      0|                        Ok(None)
  499|      0|                    } else if event.local_name().as_ref() == b"link" {
  500|       |                        // no op
  501|      0|                        Ok(None)
  502|       |                    } else {
  503|      0|                        Err(QueryResultsSyntaxError::msg(format!("Expecting <variable> or <link> tag, found <{}>", self.decoder.decode(event.name().as_ref())?)).into())
  504|       |                    }
  505|       |                }
  506|       |                ResultsState::AfterHead => {
  507|      0|                    if event.local_name().as_ref() == b"boolean" {
  508|      0|                        self.state = ResultsState::Boolean;
  509|      0|                        Ok(None)
  510|      0|                    } else if event.local_name().as_ref() == b"results" {
  511|      0|                        let mut mapping = BTreeMap::default();
  512|      0|                        for (i, var) in self.variables.iter().enumerate() {
  513|      0|                            mapping.insert(var.clone().into_string(), i);
  514|      0|                        }
  515|      0|                        Ok(Some(XmlInnerQueryResults::Solutions {
  516|      0|                            variables: take(&mut self.variables),
  517|      0|                            solutions: XmlInnerSolutionsReader {
  518|      0|                                decoder: self.decoder,
  519|      0|                                mapping,
  520|      0|                                state_stack: vec![State::Start, State::Start],
  521|      0|                                new_bindings: Vec::new(),
  522|      0|                                current_var: None,
  523|      0|                                term: None,
  524|      0|                                lang: None,
  525|      0|                                datatype: None,
  526|      0|                                subject_stack: Vec::new(),
  527|      0|                                predicate_stack: Vec::new(),
  528|      0|                                object_stack: Vec::new(),
  529|      0|                            },
  530|      0|                        }))
  531|      0|                    } else if event.local_name().as_ref() != b"link" && event.local_name().as_ref() != b"results" && event.local_name().as_ref() != b"boolean" {
  532|      0|                        Err(QueryResultsSyntaxError::msg(format!("Expecting sparql tag, found <{}>", self.decoder.decode(event.name().as_ref())?)).into())
  533|       |                    } else {
  534|      0|                        Ok(None)
  535|       |                    }
  536|       |                }
  537|      0|                ResultsState::Boolean => Err(QueryResultsSyntaxError::msg(format!("Unexpected tag inside of <boolean> tag: <{}>", self.decoder.decode(event.name().as_ref())?)).into())
  538|       |            },
  539|  4.05k|            Event::Text(event) => {
  540|  4.05k|                let value = event.unescape()?;
  541|  2.67k|                match self.state {
  542|       |                    ResultsState::Boolean => {
  543|      0|                        if value == "true" {
  544|      0|                            Ok(Some(XmlInnerQueryResults::Boolean(true)))
  545|      0|                        } else if value == "false" {
  546|      0|                            Ok(Some(XmlInnerQueryResults::Boolean(false)))
  547|       |                        } else {
  548|      0|                            Err(QueryResultsSyntaxError::msg(format!("Unexpected boolean value. Found '{value}'")).into())
  549|       |                        }
  550|       |                    }
  551|  2.67k|                    _ => Err(QueryResultsSyntaxError::msg(format!("Unexpected textual value found: '{value}'")).into())
  552|       |                }
  553|       |            }
  554|      0|            Event::End(event) => {
  555|      0|                if let ResultsState::Head = self.state {
  556|      0|                    if event.local_name().as_ref() == b"head" {
  557|      0|                        self.state = ResultsState::AfterHead
  558|      0|                    }
  559|      0|                    Ok(None)
  560|       |                } else {
  561|      0|                    Err(QueryResultsSyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into())
  562|       |                }
  563|       |            }
  564|  1.76k|            Event::Eof => Err(QueryResultsSyntaxError::msg("Unexpected early file end. All results file should have a <head> and a <result> or <boolean> tag").into()),
  565|       |            Event::Comment(_) | Event::Decl(_) | Event::PI(_) | Event::DocType(_) => {
  566|   458k|                Ok(None)
  567|       |            }
  568|      0|            Event::Empty(_) => unreachable!("Empty events are expended"),
  569|       |            Event::CData(_) => {
  570|      5|                Err(QueryResultsSyntaxError::msg(
  571|      5|                    "<![CDATA[...]]> are not supported in SPARQL XML results",
  572|      5|                )
  573|      5|                    .into())
  574|       |            }
  575|       |        }
  576|   465k|    }
_RNCNvMs2_NtCs1Aij2IKAmMy_10sparesults3xmlNtB7_30FromSliceXmlQueryResultsReader4read0B9_:
  362|  15.0k|        Self::do_read(slice).map_err(|e| match e {
  363|  15.0k|            QueryResultsParseError::Syntax(e) => e,
  364|      0|            QueryResultsParseError::Io(e) => {
  365|      0|                unreachable!("I/O error are not possible for slice but found {e}")
  366|       |            }
  367|  15.0k|        })

