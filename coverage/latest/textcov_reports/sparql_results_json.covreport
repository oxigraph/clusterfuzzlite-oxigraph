_RINvXNtCsjGP3v9bda0n_6anyhow7contextINtNtCs2HCZCz77UhY_4core6result6ResultINtNtCs3atDPk1oays_5alloc3vec3VecNtNtCs2VHBjBJmpQG_10sparesults8solution13QuerySolutionENtNtB1L_5error10ParseErrorEINtB5_7ContextB1a_B2A_E12with_contextNtNtB1f_6string6StringNCNvNtCs5UenZY2zsE2_13oxigraph_fuzz13result_format18fuzz_result_formats0_0EB44_:
   58|    141|    fn with_context<C, F>(self, context: F) -> Result<T, Error>
   59|    141|    where
   60|    141|        C: Display + Send + Sync + 'static,
   61|    141|        F: FnOnce() -> C,
   62|    141|    {
   63|    141|        match self {
   64|    141|            Ok(ok) => Ok(ok),
   65|      0|            Err(error) => Err(error.ext_context(context())),
   66|       |        }
   67|    141|    }
_RINvXNtCsjGP3v9bda0n_6anyhow7contextINtNtCs2HCZCz77UhY_4core6result6ResultINtCs2VHBjBJmpQG_10sparesults18QueryResultsReaderRShENtNtB1d_5error10ParseErrorEINtB5_7ContextB1a_B21_E12with_contextNtNtCs3atDPk1oays_5alloc6string6StringNCNvNtCs5UenZY2zsE2_13oxigraph_fuzz13result_format18fuzz_result_formats_0EB3L_:
   58|    141|    fn with_context<C, F>(self, context: F) -> Result<T, Error>
   59|    141|    where
   60|    141|        C: Display + Send + Sync + 'static,
   61|    141|        F: FnOnce() -> C,
   62|    141|    {
   63|    141|        match self {
   64|    141|            Ok(ok) => Ok(ok),
   65|      0|            Err(error) => Err(error.ext_context(context())),
   66|       |        }
   67|    141|    }

_RNvXs1_Cs8C2xlR4lZg4_17json_event_parserNtB5_9JsonEventNtNtCs2HCZCz77UhY_4core3cmp9PartialEq2eqCs5UenZY2zsE2_13oxigraph_fuzz:
   47|  11.3k|#[derive(Eq, PartialEq, Debug, Clone, Copy, Hash)]

_RINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB3_10JsonReaderRShE14parse_constantKj5_ECs5UenZY2zsE2_13oxigraph_fuzz:
  250|     14|    fn parse_constant<'a, const SIZE: usize>(
  251|     14|        &mut self,
  252|     14|        expected: &str,
  253|     14|        value: JsonEvent<'a>,
  254|     14|    ) -> Result<JsonEvent<'a>> {
  255|      0|        debug_assert_eq!(expected.len(), SIZE);
  256|     14|        let mut buf = [0u8; SIZE];
  257|     14|        self.reader.read_exact(&mut buf)?;
  258|     12|        if buf == expected.as_bytes() {
  259|     10|            self.read_after_value(value)
  260|       |        } else {
  261|       |            Err(Error::new(
  262|      2|                ErrorKind::InvalidData,
  263|      2|                format!(
  264|      2|                    "{} expected, found {}",
  265|      2|                    expected,
  266|      2|                    str::from_utf8(&buf).map_err(|e| Error::new(ErrorKind::InvalidData, e))?
  267|       |                ),
  268|       |            ))
  269|       |        }
  270|     14|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE12lookup_frontCs5UenZY2zsE2_13oxigraph_fuzz:
  469|  17.6k|    fn lookup_front(&mut self) -> Result<Option<u8>> {
  470|  17.6k|        loop {
  471|  17.6k|            match self.reader.fill_buf() {
  472|  17.6k|                Ok(buf) => return Ok(if buf.is_empty() { None } else { Some(buf[0]) }),
  473|      0|                Err(error) => {
  474|      0|                    if error.kind() != ErrorKind::Interrupted {
  475|      0|                        return Err(error);
  476|      0|                    }
  477|       |                }
  478|       |            }
  479|       |        }
  480|  17.6k|    }
_RNCNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB4_10JsonReaderRShE12parse_string0Cs5UenZY2zsE2_13oxigraph_fuzz:
  154|      1|                                        .map_err(|e| Error::new(ErrorKind::InvalidData, e))?,
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE16check_stack_sizeCs5UenZY2zsE2_13oxigraph_fuzz:
  482|  25.3k|    fn check_stack_size(&self) -> Result<()> {
  483|  25.3k|        if let Some(max_stack_size) = self.max_stack_size {
  484|      0|            if self.state_stack.len() > max_stack_size {
  485|      0|                Err(Error::new(
  486|      0|                    ErrorKind::InvalidData,
  487|      0|                    format!(
  488|      0|                        "Max stack size of {} reached on an object opening",
  489|      0|                        max_stack_size
  490|      0|                    ),
  491|      0|                ))
  492|       |            } else {
  493|      0|                Ok(())
  494|       |            }
  495|       |        } else {
  496|  25.3k|            Ok(())
  497|       |        }
  498|  25.3k|    }
_RNCINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB5_10JsonReaderRShE14parse_constantKj4_E0Cs5UenZY2zsE2_13oxigraph_fuzz:
  266|      1|                    str::from_utf8(&buf).map_err(|e| Error::new(ErrorKind::InvalidData, e))?
_RNCNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB4_10JsonReaderRShE12parse_number0Cs5UenZY2zsE2_13oxigraph_fuzz:
  302|     35|            self.read_char(|c| matches!(c, b'0'..=b'9'), output)?;
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE10read_eventCs5UenZY2zsE2_13oxigraph_fuzz:
   50|  66.8k|    pub fn read_event<'a>(&mut self, buffer: &'a mut Vec<u8>) -> Result<JsonEvent<'a>> {
   51|  66.8k|        let front = if let Some(b) = self.lookup_front_skipping_whitespaces()? {
   52|  66.3k|            b
   53|       |        } else {
   54|    498|            return if self.state_stack.is_empty() && self.element_read {
   55|     19|                Ok(JsonEvent::Eof)
   56|       |            } else {
   57|    479|                Err(Error::from(ErrorKind::UnexpectedEof))
   58|       |            };
   59|       |        };
   60|  66.3k|        match front {
   61|       |            b'{' => {
   62|  21.1k|                self.reader.consume(1);
   63|  21.1k|                self.check_stack_size()?;
   64|  21.1k|                self.state_stack.push(JsonState::FirstObjectKey);
   65|  21.1k|                Ok(JsonEvent::StartObject)
   66|       |            }
   67|       |            b'}' => {
   68|  11.4k|                self.reader.consume(1);
   69|      3|                if matches!(
   70|  11.4k|                    self.state_stack.pop(),
   71|       |                    Some(JsonState::FirstObjectKey) | Some(JsonState::LastObjectKey)
   72|       |                ) {
   73|  11.4k|                    self.read_after_value(JsonEvent::EndObject)
   74|       |                } else {
   75|      3|                    Err(Error::new(
   76|      3|                        ErrorKind::InvalidData,
   77|      3|                        "Closing a not opened object",
   78|      3|                    ))
   79|       |                }
   80|       |            }
   81|       |            b'[' => {
   82|  4.21k|                self.reader.consume(1);
   83|  4.21k|                self.check_stack_size()?;
   84|  4.21k|                self.state_stack.push(JsonState::FirstArray);
   85|  4.21k|                Ok(JsonEvent::StartArray)
   86|       |            }
   87|       |            b']' => {
   88|  2.59k|                self.reader.consume(1);
   89|      3|                if matches!(
   90|  2.59k|                    self.state_stack.pop(),
   91|       |                    Some(JsonState::FirstArray) | Some(JsonState::LastArray)
   92|       |                ) {
   93|  2.59k|                    self.read_after_value(JsonEvent::EndArray)
   94|       |                } else {
   95|      3|                    Err(Error::new(
   96|      3|                        ErrorKind::InvalidData,
   97|      3|                        "Closing a not opened array",
   98|      3|                    ))
   99|       |                }
  100|       |            }
  101|  25.4k|            b'"' => self.parse_string(buffer),
  102|     74|            b't' => self.parse_constant::<4>("true", JsonEvent::Boolean(true)),
  103|     14|            b'f' => self.parse_constant::<5>("false", JsonEvent::Boolean(false)),
  104|      1|            b'n' => self.parse_constant::<4>("null", JsonEvent::Null),
  105|  1.49k|            b'-' | b'0'..=b'9' => self.parse_number(front, buffer),
  106|     55|            c => {
  107|     55|                self.reader.consume(1);
  108|     55|                Err(Error::new(
  109|     55|                    ErrorKind::InvalidData,
  110|     55|                    format!("Unexpected char: {}", char::from(c)),
  111|     55|                ))
  112|       |            }
  113|       |        }
  114|  66.8k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE22lookup_mandatory_frontCs5UenZY2zsE2_13oxigraph_fuzz:
  461|  8.14k|    fn lookup_mandatory_front(&mut self) -> Result<u8> {
  462|  8.14k|        if let Some(v) = self.lookup_front()? {
  463|  8.12k|            Ok(v)
  464|       |        } else {
  465|     22|            Err(Error::from(ErrorKind::UnexpectedEof))
  466|       |        }
  467|  8.14k|    }
_RINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB3_10JsonReaderRShE9read_charNCNvB2_12parse_number0ECs5UenZY2zsE2_13oxigraph_fuzz:
  338|     37|    fn read_char(&mut self, valid: impl Fn(u8) -> bool, output: &mut Vec<u8>) -> Result<()> {
  339|     37|        let c = self.lookup_mandatory_front()?;
  340|     35|        if valid(c) {
  341|     34|            output.push(c);
  342|     34|            self.reader.consume(1);
  343|     34|            Ok(())
  344|       |        } else {
  345|      1|            Err(Error::new(
  346|      1|                ErrorKind::InvalidData,
  347|      1|                format!("Invalid number. Found char {}", char::from(c)),
  348|      1|            ))
  349|       |        }
  350|     37|    }
_RINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB3_10JsonReaderRShE14parse_constantKj4_ECs5UenZY2zsE2_13oxigraph_fuzz:
  250|     75|    fn parse_constant<'a, const SIZE: usize>(
  251|     75|        &mut self,
  252|     75|        expected: &str,
  253|     75|        value: JsonEvent<'a>,
  254|     75|    ) -> Result<JsonEvent<'a>> {
  255|      0|        debug_assert_eq!(expected.len(), SIZE);
  256|     75|        let mut buf = [0u8; SIZE];
  257|     75|        self.reader.read_exact(&mut buf)?;
  258|     73|        if buf == expected.as_bytes() {
  259|     69|            self.read_after_value(value)
  260|       |        } else {
  261|       |            Err(Error::new(
  262|      4|                ErrorKind::InvalidData,
  263|      4|                format!(
  264|      4|                    "{} expected, found {}",
  265|      4|                    expected,
  266|      4|                    str::from_utf8(&buf).map_err(|e| Error::new(ErrorKind::InvalidData, e))?
  267|       |                ),
  268|       |            ))
  269|       |        }
  270|     75|    }
_RNCINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB5_10JsonReaderRShE14parse_constantKj5_E0Cs5UenZY2zsE2_13oxigraph_fuzz:
  266|      1|                    str::from_utf8(&buf).map_err(|e| Error::new(ErrorKind::InvalidData, e))?
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE11from_readerCs5UenZY2zsE2_13oxigraph_fuzz:
   35|  2.04k|    pub fn from_reader(reader: R) -> Self {
   36|  2.04k|        Self {
   37|  2.04k|            reader,
   38|  2.04k|            state_stack: Vec::new(),
   39|  2.04k|            element_read: false,
   40|  2.04k|            max_stack_size: None,
   41|  2.04k|        }
   42|  2.04k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE11read_digitsCs5UenZY2zsE2_13oxigraph_fuzz:
  352|  1.96k|    fn read_digits(&mut self, output: &mut Vec<u8>) -> Result<()> {
  353|  6.58k|        while let Some(c) = self.lookup_front()? {
  354|  6.53k|            if matches!(c, b'0'..=b'9') {
  355|  4.61k|                output.push(c);
  356|  4.61k|                self.reader.consume(1);
  357|  4.61k|            } else {
  358|  1.92k|                break;
  359|       |            }
  360|       |        }
  361|  1.96k|        Ok(())
  362|  1.96k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE12parse_numberCs5UenZY2zsE2_13oxigraph_fuzz:
  272|  1.49k|    fn parse_number<'a>(
  273|  1.49k|        &mut self,
  274|  1.49k|        first_byte: u8,
  275|  1.49k|        output: &'a mut Vec<u8>,
  276|  1.49k|    ) -> Result<JsonEvent<'a>> {
  277|  1.49k|        output.clear();
  278|  1.49k|        if first_byte == b'-' {
  279|     71|            output.push(b'-');
  280|     71|            self.reader.consume(1);
  281|  1.42k|        }
  282|       |        // integer starting with first bytes
  283|       |        // TODO: avoid too many fill_buf
  284|  1.49k|        let c = self.lookup_mandatory_front()?;
  285|  1.48k|        match c {
  286|    146|            b'0' => {
  287|    146|                output.push(b'0');
  288|    146|                self.reader.consume(1);
  289|    146|            }
  290|  1.33k|            b'1'..=b'9' => {
  291|  1.33k|                output.push(c);
  292|  1.33k|                self.reader.consume(1);
  293|  1.33k|                self.read_digits(output)?;
  294|       |            }
  295|      1|            _ => return Err(Error::new(ErrorKind::InvalidData, "Invalid number")),
  296|       |        }
  297|       |
  298|       |        // Dot
  299|  1.48k|        if self.lookup_front()? == Some(b'.') {
  300|     37|            output.push(b'.');
  301|     37|            self.reader.consume(1);
  302|     37|            self.read_char(|c| matches!(c, b'0'..=b'9'), output)?;
  303|     34|            self.read_digits(output)?;
  304|  1.44k|        }
  305|       |
  306|       |        // Exp
  307|  1.48k|        if let Some(c) = self.lookup_front()? {
  308|  1.43k|            if c == b'e' || c == b'E' {
  309|    612|                output.push(c);
  310|    612|                self.reader.consume(1);
  311|    612|                let c = self.lookup_mandatory_front()?;
  312|    606|                match c {
  313|       |                    b'-' | b'+' => {
  314|    502|                        output.push(c);
  315|    502|                        self.reader.consume(1);
  316|    502|                        self.read_char(|c| matches!(c, b'0'..=b'9'), output)?;
  317|       |                    }
  318|    103|                    b'0'..=b'9' => {
  319|    102|                        output.push(c);
  320|    102|                        self.reader.consume(1);
  321|    102|                    }
  322|       |                    _ => {
  323|      2|                        return Err(Error::new(
  324|      2|                            ErrorKind::InvalidData,
  325|      2|                            format!("Invalid number. Found char {}", char::from(c)),
  326|      2|                        ))
  327|       |                    }
  328|       |                }
  329|    597|                self.read_digits(output)?;
  330|    827|            }
  331|     41|        }
  332|       |
  333|  1.46k|        self.read_after_value(JsonEvent::Number(
  334|  1.46k|            str::from_utf8(output.as_slice()).map_err(|e| Error::new(ErrorKind::InvalidData, e))?,
  335|       |        ))
  336|  1.49k|    }
_RINvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB3_10JsonReaderRShE9read_charNCNvB2_12parse_numbers_0ECs5UenZY2zsE2_13oxigraph_fuzz:
  338|    502|    fn read_char(&mut self, valid: impl Fn(u8) -> bool, output: &mut Vec<u8>) -> Result<()> {
  339|    502|        let c = self.lookup_mandatory_front()?;
  340|    497|        if valid(c) {
  341|    495|            output.push(c);
  342|    495|            self.reader.consume(1);
  343|    495|            Ok(())
  344|       |        } else {
  345|      2|            Err(Error::new(
  346|      2|                ErrorKind::InvalidData,
  347|      2|                format!("Invalid number. Found char {}", char::from(c)),
  348|      2|            ))
  349|       |        }
  350|    502|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE16read_after_valueCs5UenZY2zsE2_13oxigraph_fuzz:
  364|  40.7k|    fn read_after_value<'a>(&mut self, value: JsonEvent<'a>) -> Result<JsonEvent<'a>> {
  365|  40.7k|        match self.state_stack.pop() {
  366|       |            Some(JsonState::FirstObjectKey) | Some(JsonState::NextObjectKey) => {
  367|  16.1k|                if self.lookup_front_skipping_whitespaces()? == Some(b':') {
  368|  16.0k|                    self.reader.consume(1);
  369|  16.0k|                    self.state_stack.push(JsonState::ObjectValue);
  370|  16.0k|                    if let JsonEvent::String(value) = value {
  371|  16.0k|                        Ok(JsonEvent::ObjectKey(value))
  372|       |                    } else {
  373|      1|                        Err(Error::new(
  374|      1|                            ErrorKind::InvalidData,
  375|      1|                            "Object keys should strings",
  376|      1|                        ))
  377|       |                    }
  378|       |                } else {
  379|     56|                    Err(Error::new(
  380|     56|                        ErrorKind::InvalidData,
  381|     56|                        "Object keys should be followed by ':'",
  382|     56|                    ))
  383|       |                }
  384|       |            }
  385|  9.89k|            Some(JsonState::ObjectValue) => match self.lookup_front_skipping_whitespaces()? {
  386|       |                Some(b',') => {
  387|  7.40k|                    self.reader.consume(1);
  388|  7.40k|                    self.state_stack.push(JsonState::NextObjectKey);
  389|  7.40k|                    Ok(value)
  390|       |                }
  391|       |                Some(b'}') => {
  392|  2.45k|                    self.state_stack.push(JsonState::LastObjectKey);
  393|  2.45k|                    Ok(value)
  394|       |                }
  395|     41|                _ => Err(Error::new(
  396|     41|                    ErrorKind::InvalidData,
  397|     41|                    "Object values should be followed by a comma or the object end",
  398|     41|                )),
  399|       |            },
  400|       |            Some(JsonState::FirstArray) | Some(JsonState::NextArray) => {
  401|  14.6k|                match self.lookup_front_skipping_whitespaces()? {
  402|       |                    Some(b',') => {
  403|  12.9k|                        self.reader.consume(1);
  404|  12.9k|                        self.state_stack.push(JsonState::NextArray);
  405|  12.9k|                        Ok(value)
  406|       |                    }
  407|       |                    Some(b']') => {
  408|  1.69k|                        self.state_stack.push(JsonState::LastArray);
  409|  1.69k|                        Ok(value)
  410|       |                    }
  411|     21|                    _ => Err(Error::new(
  412|     21|                        ErrorKind::InvalidData,
  413|     21|                        "Array values should be followed by a comma or the array end",
  414|     21|                    )),
  415|       |                }
  416|       |            }
  417|       |            None => {
  418|     80|                if self.element_read {
  419|      2|                    Err(Error::new(ErrorKind::InvalidData, "JSON trailing content"))
  420|       |                } else {
  421|     78|                    self.element_read = true;
  422|     78|                    Ok(value)
  423|       |                }
  424|       |            }
  425|      0|            Some(JsonState::LastObjectKey) => Err(Error::new(
  426|      0|                ErrorKind::InvalidData,
  427|      0|                "JSON object elements should be separated by commas",
  428|      0|            )),
  429|      0|            Some(JsonState::LastArray) => Err(Error::new(
  430|      0|                ErrorKind::InvalidData,
  431|      0|                "JSON array elements should be separated by commas",
  432|      0|            )),
  433|       |        }
  434|  40.7k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE12parse_stringCs5UenZY2zsE2_13oxigraph_fuzz:
  116|  25.4k|    fn parse_string<'a>(&mut self, output: &'a mut Vec<u8>) -> Result<JsonEvent<'a>> {
  117|  25.4k|        output.clear();
  118|  25.4k|        self.reader.consume(1);
  119|  25.4k|
  120|  25.4k|        #[derive(Eq, PartialEq, Copy, Clone)]
  121|  25.4k|        enum StringState {
  122|  25.4k|            Default,
  123|  25.4k|            Escape,
  124|  25.4k|        }
  125|  25.4k|
  126|  25.4k|        let mut state = StringState::Default;
  127|  36.4k|        loop {
  128|  36.4k|            match state {
  129|       |                StringState::Default => {
  130|  30.9k|                    let buffer = match self.reader.fill_buf() {
  131|  30.9k|                        Ok(buf) => {
  132|  30.9k|                            if buf.is_empty() {
  133|    202|                                return Err(Error::from(ErrorKind::UnexpectedEof));
  134|       |                            } else {
  135|  30.7k|                                buf
  136|       |                            }
  137|       |                        }
  138|      0|                        Err(e) => {
  139|      0|                            if e.kind() == ErrorKind::Interrupted {
  140|      0|                                continue;
  141|       |                            } else {
  142|      0|                                return Err(e);
  143|       |                            }
  144|       |                        }
  145|       |                    };
  146|  30.7k|                    let mut i = 0;
  147|   203k|                    for c in buffer {
  148|   202k|                        i += 1;
  149|   202k|                        match *c {
  150|       |                            b'"' => {
  151|  25.2k|                                self.reader.consume(i);
  152|  25.2k|                                return self.read_after_value(JsonEvent::String(
  153|  25.2k|                                    str::from_utf8(output.as_slice())
  154|  25.2k|                                        .map_err(|e| Error::new(ErrorKind::InvalidData, e))?,
  155|       |                                ));
  156|       |                            }
  157|       |                            b'\\' => {
  158|  5.50k|                                state = StringState::Escape;
  159|  5.50k|                                break;
  160|       |                            }
  161|   172k|                            0..=0x1F => {
  162|      5|                                self.reader.consume(i);
  163|      5|                                return Err(Error::new(
  164|      5|                                    ErrorKind::InvalidData,
  165|      5|                                    "Control characters are not allowed in JSON",
  166|      5|                                ));
  167|       |                            }
  168|   172k|                            c => output.push(c),
  169|       |                        }
  170|       |                    }
  171|  5.55k|                    self.reader.consume(i);
  172|       |                }
  173|       |                StringState::Escape => {
  174|  5.50k|                    let c = self.lookup_mandatory_front()?;
  175|  5.50k|                    self.reader.consume(1);
  176|  5.50k|                    match c {
  177|     80|                        b'"' => {
  178|     80|                            output.push(b'"');
  179|     80|                        }
  180|    338|                        b'\\' => {
  181|    338|                            output.push(b'\\');
  182|    338|                        }
  183|    205|                        b'/' => {
  184|    205|                            output.push(b'/');
  185|    205|                        }
  186|    230|                        b'b' => {
  187|    230|                            output.push(8);
  188|    230|                        }
  189|    212|                        b'f' => {
  190|    212|                            output.push(12);
  191|    212|                        }
  192|    228|                        b'n' => {
  193|    228|                            output.push(b'\n');
  194|    228|                        }
  195|    206|                        b'r' => {
  196|    206|                            output.push(b'\r');
  197|    206|                        }
  198|    224|                        b't' => {
  199|    224|                            output.push(b'\t');
  200|    224|                        }
  201|       |                        b'u' => {
  202|  3.77k|                            let mut buf = [0u8; 4];
  203|  3.77k|                            self.reader.read_exact(&mut buf)?;
  204|  3.77k|                            let code_point = read_hexa_char(&buf)?;
  205|  3.76k|                            if let Some(c) = char::from_u32(code_point) {
  206|  2.05k|                                output.extend_from_slice(c.encode_utf8(&mut buf).as_bytes());
  207|  2.05k|                            } else {
  208|  1.71k|                                let high_surrogate = code_point;
  209|  1.71k|                                let mut buf = [0u8; 6];
  210|  1.71k|                                self.reader.read_exact(&mut buf)?;
  211|  1.70k|                                if !buf.starts_with(b"\\u") {
  212|      2|                                    return Err(Error::new(
  213|      2|                                            ErrorKind::InvalidData,
  214|      2|                                            format!(
  215|      2|                                                "\\u{:X} is a surrogate should be followed by an other surrogate",
  216|      2|                                                high_surrogate
  217|      2|                                            ),
  218|      2|                                        ));
  219|  1.70k|                                }
  220|  1.70k|                                let low_surrogate = read_hexa_char(&buf[2..])?;
  221|  1.70k|                                let code_point = 0x10000
  222|  1.70k|                                    + ((high_surrogate & 0x03FF) << 10)
  223|  1.70k|                                    + (low_surrogate & 0x03FF);
  224|  1.70k|                                if let Some(c) = char::from_u32(code_point) {
  225|  1.70k|                                    output.extend_from_slice(c.encode_utf8(&mut buf).as_bytes())
  226|       |                                } else {
  227|      0|                                    return Err(Error::new(
  228|      0|                                        ErrorKind::InvalidData,
  229|      0|                                        format!(
  230|      0|                                            "\\u{:X}\\u{:X} is an invalid surrogate pair",
  231|      0|                                            high_surrogate, low_surrogate
  232|      0|                                        ),
  233|      0|                                    ));
  234|       |                                }
  235|       |                            }
  236|       |                        }
  237|       |                        _ => {
  238|      2|                            return Err(Error::new(
  239|      2|                                ErrorKind::InvalidData,
  240|      2|                                "Invalid string escape",
  241|      2|                            ));
  242|       |                        }
  243|       |                    }
  244|  5.48k|                    state = StringState::Default;
  245|       |                }
  246|       |            }
  247|       |        }
  248|  25.4k|    }
_RNCNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB4_10JsonReaderRShE12parse_numbers_0Cs5UenZY2zsE2_13oxigraph_fuzz:
  316|    497|                        self.read_char(|c| matches!(c, b'0'..=b'9'), output)?;
_RNvMNtCs8C2xlR4lZg4_17json_event_parser4readINtB2_10JsonReaderRShE33lookup_front_skipping_whitespacesCs5UenZY2zsE2_13oxigraph_fuzz:
  436|   107k|    fn lookup_front_skipping_whitespaces(&mut self) -> Result<Option<u8>> {
  437|   107k|        loop {
  438|   107k|            match self.reader.fill_buf() {
  439|   107k|                Ok(buf) => {
  440|   107k|                    if buf.is_empty() {
  441|    567|                        return Ok(None);
  442|   107k|                    }
  443|   107k|                    let skipped = skip_whitespaces(buf);
  444|   107k|                    if skipped == buf.len() {
  445|     37|                        self.reader.consume(skipped);
  446|     37|                    } else {
  447|   106k|                        let result = Some(buf[skipped]);
  448|   106k|                        self.reader.consume(skipped);
  449|   106k|                        return Ok(result);
  450|       |                    }
  451|       |                }
  452|      0|                Err(error) => {
  453|      0|                    if error.kind() != ErrorKind::Interrupted {
  454|      0|                        return Err(error);
  455|      0|                    }
  456|       |                }
  457|       |            }
  458|       |        }
  459|   107k|    }
_RNvNtCs8C2xlR4lZg4_17json_event_parser4read16skip_whitespaces:
  512|   107k|fn skip_whitespaces(buf: &[u8]) -> usize {
  513|   110k|    for (i, c) in buf.iter().enumerate() {
  514|   110k|        if !matches!(c, b' ' | b'\t' | b'\n' | b'\r') {
  515|   106k|            return i;
  516|  3.90k|        }
  517|       |    }
  518|     37|    buf.len()
  519|   107k|}
_RNvNtCs8C2xlR4lZg4_17json_event_parser4read14read_hexa_char:
  521|  5.47k|fn read_hexa_char(input: &[u8]) -> Result<u32> {
  522|  5.47k|    let mut value = 0;
  523|  21.9k|    for c in input.iter().copied() {
  524|  21.9k|        value = value * 16
  525|  21.9k|            + match c {
  526|  21.8k|                b'0'..=b'9' => u32::from(c) - u32::from(b'0'),
  527|  2.75k|                b'a'..=b'f' => u32::from(c) - u32::from(b'a') + 10,
  528|  9.52k|                b'A'..=b'F' => u32::from(c) - u32::from(b'A') + 10,
  529|       |                _ => {
  530|      8|                    return Err(Error::new(
  531|      8|                        ErrorKind::InvalidData,
  532|      8|                        "Unexpected character in a unicode escape",
  533|      8|                    ))
  534|       |                }
  535|       |            }
  536|       |    }
  537|  5.47k|    Ok(value)
  538|  5.47k|}

_RINvNtCs8C2xlR4lZg4_17json_event_parser5write25write_escaped_json_stringINtNtCs3atDPk1oays_5alloc3vec3VechEECs5UenZY2zsE2_13oxigraph_fuzz:
  169|  1.17k|fn write_escaped_json_string(s: &str, sink: &mut impl Write) -> Result<()> {
  170|  1.17k|    sink.write_all(b"\"")?;
  171|  1.17k|    let mut buffer = [b'\\', b'u', 0, 0, 0, 0];
  172|  13.1k|    for c in s.chars() {
  173|  13.1k|        match c {
  174|      0|            '\\' => sink.write_all(b"\\\\"),
  175|      0|            '"' => sink.write_all(b"\\\""),
  176|  13.1k|            c => {
  177|  13.1k|                if c < char::from(32) {
  178|      0|                    match c {
  179|      0|                        '\u{08}' => sink.write_all(b"\\b"),
  180|      0|                        '\u{0C}' => sink.write_all(b"\\f"),
  181|      0|                        '\n' => sink.write_all(b"\\n"),
  182|      0|                        '\r' => sink.write_all(b"\\r"),
  183|      0|                        '\t' => sink.write_all(b"\\t"),
  184|      0|                        c => {
  185|      0|                            let mut c = c as u8;
  186|      0|                            for i in (2..6).rev() {
  187|      0|                                let ch = c % 16;
  188|      0|                                buffer[i] = ch + if ch < 10 { b'0' } else { b'A' };
  189|      0|                                c /= 16;
  190|       |                            }
  191|      0|                            sink.write_all(&buffer)
  192|       |                        }
  193|       |                    }
  194|       |                } else {
  195|  13.1k|                    sink.write_all(c.encode_utf8(&mut buffer[2..]).as_bytes())
  196|       |                }
  197|       |            }
  198|      0|        }?;
  199|       |    }
  200|  1.17k|    sink.write_all(b"\"")?;
  201|  1.17k|    Ok(())
  202|  1.17k|}
_RINvNtCs8C2xlR4lZg4_17json_event_parser5write25write_escaped_json_stringQINtNtCs3atDPk1oays_5alloc3vec3VechEECs5UenZY2zsE2_13oxigraph_fuzz:
  169|      2|fn write_escaped_json_string(s: &str, sink: &mut impl Write) -> Result<()> {
  170|      2|    sink.write_all(b"\"")?;
  171|      2|    let mut buffer = [b'\\', b'u', 0, 0, 0, 0];
  172|     11|    for c in s.chars() {
  173|     11|        match c {
  174|      0|            '\\' => sink.write_all(b"\\\\"),
  175|      0|            '"' => sink.write_all(b"\\\""),
  176|     11|            c => {
  177|     11|                if c < char::from(32) {
  178|      0|                    match c {
  179|      0|                        '\u{08}' => sink.write_all(b"\\b"),
  180|      0|                        '\u{0C}' => sink.write_all(b"\\f"),
  181|      0|                        '\n' => sink.write_all(b"\\n"),
  182|      0|                        '\r' => sink.write_all(b"\\r"),
  183|      0|                        '\t' => sink.write_all(b"\\t"),
  184|      0|                        c => {
  185|      0|                            let mut c = c as u8;
  186|      0|                            for i in (2..6).rev() {
  187|      0|                                let ch = c % 16;
  188|      0|                                buffer[i] = ch + if ch < 10 { b'0' } else { b'A' };
  189|      0|                                c /= 16;
  190|       |                            }
  191|      0|                            sink.write_all(&buffer)
  192|       |                        }
  193|       |                    }
  194|       |                } else {
  195|     11|                    sink.write_all(c.encode_utf8(&mut buffer[2..]).as_bytes())
  196|       |                }
  197|       |            }
  198|      0|        }?;
  199|       |    }
  200|      2|    sink.write_all(b"\"")?;
  201|      2|    Ok(())
  202|      2|}
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE11from_writerCs5UenZY2zsE2_13oxigraph_fuzz:
   27|    141|    pub fn from_writer(writer: W) -> Self {
   28|    141|        Self {
   29|    141|            writer,
   30|    141|            state_stack: Vec::new(),
   31|    141|            element_written: false,
   32|    141|        }
   33|    141|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE10into_innerCs5UenZY2zsE2_13oxigraph_fuzz:
   35|    141|    pub fn into_inner(self) -> W {
   36|    141|        self.writer
   37|    141|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterQINtNtCs3atDPk1oays_5alloc3vec3VechEE10into_innerCs5UenZY2zsE2_13oxigraph_fuzz:
   35|      1|    pub fn into_inner(self) -> W {
   36|      1|        self.writer
   37|      1|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterQINtNtCs3atDPk1oays_5alloc3vec3VechEE11from_writerCs5UenZY2zsE2_13oxigraph_fuzz:
   27|      1|    pub fn from_writer(writer: W) -> Self {
   28|      1|        Self {
   29|      1|            writer,
   30|      1|            state_stack: Vec::new(),
   31|      1|            element_written: false,
   32|      1|        }
   33|      1|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE11write_eventCs5UenZY2zsE2_13oxigraph_fuzz:
   43|  9.45k|    pub fn write_event(&mut self, event: JsonEvent<'_>) -> Result<()> {
   44|  9.45k|        match event {
   45|    609|            JsonEvent::String(s) => {
   46|    609|                self.before_value()?;
   47|    609|                write_escaped_json_string(s, &mut self.writer)
   48|       |            }
   49|      0|            JsonEvent::Number(number) => {
   50|      0|                self.before_value()?;
   51|      0|                self.writer.write_all(number.as_bytes())
   52|       |            }
   53|      0|            JsonEvent::Boolean(b) => {
   54|      0|                self.before_value()?;
   55|      0|                self.writer.write_all(if b { b"true" } else { b"false" })
   56|       |            }
   57|       |            JsonEvent::Null => {
   58|      0|                self.before_value()?;
   59|      0|                self.writer.write_all(b"null")
   60|       |            }
   61|       |            JsonEvent::StartArray => {
   62|    282|                self.before_value()?;
   63|    282|                self.state_stack.push(JsonState::OpenArray);
   64|    282|                self.writer.write_all(b"[")
   65|       |            }
   66|    282|            JsonEvent::EndArray => match self.state_stack.pop() {
   67|       |                Some(JsonState::OpenArray) | Some(JsonState::ContinuationArray) => {
   68|    282|                    self.writer.write_all(b"]")
   69|       |                }
   70|      0|                Some(s) => {
   71|      0|                    self.state_stack.push(s);
   72|      0|                    Err(Error::new(
   73|      0|                        ErrorKind::InvalidInput,
   74|      0|                        "Closing a not opened array",
   75|      0|                    ))
   76|       |                }
   77|      0|                None => Err(Error::new(
   78|      0|                    ErrorKind::InvalidInput,
   79|      0|                    "Closing a not opened array",
   80|      0|                )),
   81|       |            },
   82|       |            JsonEvent::StartObject => {
   83|  3.85k|                self.before_value()?;
   84|  3.85k|                self.state_stack.push(JsonState::OpenObject);
   85|  3.85k|                self.writer.write_all(b"{")
   86|       |            }
   87|  3.85k|            JsonEvent::EndObject => match self.state_stack.pop() {
   88|       |                Some(JsonState::OpenObject) | Some(JsonState::ContinuationObject) => {
   89|  3.85k|                    self.writer.write_all(b"}")
   90|       |                }
   91|      0|                Some(s) => {
   92|      0|                    self.state_stack.push(s);
   93|      0|                    Err(Error::new(
   94|      0|                        ErrorKind::InvalidInput,
   95|      0|                        "Closing a not opened object",
   96|      0|                    ))
   97|       |                }
   98|      0|                None => Err(Error::new(
   99|      0|                    ErrorKind::InvalidInput,
  100|      0|                    "Closing a not opened object",
  101|      0|                )),
  102|       |            },
  103|    564|            JsonEvent::ObjectKey(key) => {
  104|    564|                match self.state_stack.pop() {
  105|    423|                    Some(JsonState::OpenObject) => (),
  106|    141|                    Some(JsonState::ContinuationObject) => self.writer.write_all(b",")?,
  107|       |                    _ => {
  108|      0|                        return Err(Error::new(
  109|      0|                            ErrorKind::InvalidInput,
  110|      0|                            "Trying to write an object key in an not object",
  111|      0|                        ))
  112|       |                    }
  113|       |                }
  114|    564|                self.state_stack.push(JsonState::ContinuationObject);
  115|    564|                self.state_stack.push(JsonState::ObjectValue);
  116|    564|                write_escaped_json_string(key, &mut self.writer)?;
  117|    564|                self.writer.write_all(b":")
  118|       |            }
  119|      0|            JsonEvent::Eof => Err(Error::new(
  120|      0|                ErrorKind::InvalidInput,
  121|      0|                "EOF is not allowed in JSON writer",
  122|      0|            )),
  123|       |        }
  124|  9.45k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterQINtNtCs3atDPk1oays_5alloc3vec3VechEE11write_eventCs5UenZY2zsE2_13oxigraph_fuzz:
   43|      7|    pub fn write_event(&mut self, event: JsonEvent<'_>) -> Result<()> {
   44|      7|        match event {
   45|      0|            JsonEvent::String(s) => {
   46|      0|                self.before_value()?;
   47|      0|                write_escaped_json_string(s, &mut self.writer)
   48|       |            }
   49|      0|            JsonEvent::Number(number) => {
   50|      0|                self.before_value()?;
   51|      0|                self.writer.write_all(number.as_bytes())
   52|       |            }
   53|      1|            JsonEvent::Boolean(b) => {
   54|      1|                self.before_value()?;
   55|      1|                self.writer.write_all(if b { b"true" } else { b"false" })
   56|       |            }
   57|       |            JsonEvent::Null => {
   58|      0|                self.before_value()?;
   59|      0|                self.writer.write_all(b"null")
   60|       |            }
   61|       |            JsonEvent::StartArray => {
   62|      0|                self.before_value()?;
   63|      0|                self.state_stack.push(JsonState::OpenArray);
   64|      0|                self.writer.write_all(b"[")
   65|       |            }
   66|      0|            JsonEvent::EndArray => match self.state_stack.pop() {
   67|       |                Some(JsonState::OpenArray) | Some(JsonState::ContinuationArray) => {
   68|      0|                    self.writer.write_all(b"]")
   69|       |                }
   70|      0|                Some(s) => {
   71|      0|                    self.state_stack.push(s);
   72|      0|                    Err(Error::new(
   73|      0|                        ErrorKind::InvalidInput,
   74|      0|                        "Closing a not opened array",
   75|      0|                    ))
   76|       |                }
   77|      0|                None => Err(Error::new(
   78|      0|                    ErrorKind::InvalidInput,
   79|      0|                    "Closing a not opened array",
   80|      0|                )),
   81|       |            },
   82|       |            JsonEvent::StartObject => {
   83|      2|                self.before_value()?;
   84|      2|                self.state_stack.push(JsonState::OpenObject);
   85|      2|                self.writer.write_all(b"{")
   86|       |            }
   87|      2|            JsonEvent::EndObject => match self.state_stack.pop() {
   88|       |                Some(JsonState::OpenObject) | Some(JsonState::ContinuationObject) => {
   89|      2|                    self.writer.write_all(b"}")
   90|       |                }
   91|      0|                Some(s) => {
   92|      0|                    self.state_stack.push(s);
   93|      0|                    Err(Error::new(
   94|      0|                        ErrorKind::InvalidInput,
   95|      0|                        "Closing a not opened object",
   96|      0|                    ))
   97|       |                }
   98|      0|                None => Err(Error::new(
   99|      0|                    ErrorKind::InvalidInput,
  100|      0|                    "Closing a not opened object",
  101|      0|                )),
  102|       |            },
  103|      2|            JsonEvent::ObjectKey(key) => {
  104|      2|                match self.state_stack.pop() {
  105|      1|                    Some(JsonState::OpenObject) => (),
  106|      1|                    Some(JsonState::ContinuationObject) => self.writer.write_all(b",")?,
  107|       |                    _ => {
  108|      0|                        return Err(Error::new(
  109|      0|                            ErrorKind::InvalidInput,
  110|      0|                            "Trying to write an object key in an not object",
  111|      0|                        ))
  112|       |                    }
  113|       |                }
  114|      2|                self.state_stack.push(JsonState::ContinuationObject);
  115|      2|                self.state_stack.push(JsonState::ObjectValue);
  116|      2|                write_escaped_json_string(key, &mut self.writer)?;
  117|      2|                self.writer.write_all(b":")
  118|       |            }
  119|      0|            JsonEvent::Eof => Err(Error::new(
  120|      0|                ErrorKind::InvalidInput,
  121|      0|                "EOF is not allowed in JSON writer",
  122|      0|            )),
  123|       |        }
  124|      7|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE12before_valueCs5UenZY2zsE2_13oxigraph_fuzz:
  126|  4.75k|    fn before_value(&mut self) -> Result<()> {
  127|  4.75k|        match self.state_stack.pop() {
  128|       |            Some(JsonState::OpenArray) => {
  129|    250|                self.state_stack.push(JsonState::ContinuationArray);
  130|    250|                Ok(())
  131|       |            }
  132|       |            Some(JsonState::ContinuationArray) => {
  133|  3.79k|                self.state_stack.push(JsonState::ContinuationArray);
  134|  3.79k|                self.writer.write_all(b",")?;
  135|  3.79k|                Ok(())
  136|       |            }
  137|      0|            Some(last_state @ JsonState::OpenObject)
  138|      0|            | Some(last_state @ JsonState::ContinuationObject) => {
  139|      0|                self.state_stack.push(last_state);
  140|      0|                Err(Error::new(
  141|      0|                    ErrorKind::InvalidInput,
  142|      0|                    "Object key expected, string found",
  143|      0|                ))
  144|       |            }
  145|    564|            Some(JsonState::ObjectValue) => Ok(()),
  146|       |            None => {
  147|    141|                if self.element_written {
  148|      0|                    Err(Error::new(
  149|      0|                        ErrorKind::InvalidInput,
  150|      0|                        "A root JSON value has already been written",
  151|      0|                    ))
  152|       |                } else {
  153|    141|                    self.element_written = true;
  154|    141|                    Ok(())
  155|       |                }
  156|       |            }
  157|       |        }
  158|  4.75k|    }
_RNvMNtCs8C2xlR4lZg4_17json_event_parser5writeINtB2_10JsonWriterQINtNtCs3atDPk1oays_5alloc3vec3VechEE12before_valueCs5UenZY2zsE2_13oxigraph_fuzz:
  126|      3|    fn before_value(&mut self) -> Result<()> {
  127|      3|        match self.state_stack.pop() {
  128|       |            Some(JsonState::OpenArray) => {
  129|      0|                self.state_stack.push(JsonState::ContinuationArray);
  130|      0|                Ok(())
  131|       |            }
  132|       |            Some(JsonState::ContinuationArray) => {
  133|      0|                self.state_stack.push(JsonState::ContinuationArray);
  134|      0|                self.writer.write_all(b",")?;
  135|      0|                Ok(())
  136|       |            }
  137|      0|            Some(last_state @ JsonState::OpenObject)
  138|      0|            | Some(last_state @ JsonState::ContinuationObject) => {
  139|      0|                self.state_stack.push(last_state);
  140|      0|                Err(Error::new(
  141|      0|                    ErrorKind::InvalidInput,
  142|      0|                    "Object key expected, string found",
  143|      0|                ))
  144|       |            }
  145|      2|            Some(JsonState::ObjectValue) => Ok(()),
  146|       |            None => {
  147|      1|                if self.element_written {
  148|      0|                    Err(Error::new(
  149|      0|                        ErrorKind::InvalidInput,
  150|      0|                        "A root JSON value has already been written",
  151|      0|                    ))
  152|       |                } else {
  153|      1|                    self.element_written = true;
  154|      1|                    Ok(())
  155|       |                }
  156|       |            }
  157|       |        }
  158|      3|    }

_RNvNvCsevhe6skJR6e_19sparql_results_json1__19___libfuzzer_sys_run:
  241|  1.90k|            fn __libfuzzer_sys_run($bytes: &[u8]) {
  242|  1.90k|                $body
  243|  1.90k|            }
rust_fuzzer_test_input:
  209|  1.90k|            pub extern "C" fn rust_fuzzer_test_input(bytes: &[u8]) -> i32 {
  210|       |                // When `RUST_LIBFUZZER_DEBUG_PATH` is set, write the debug
  211|       |                // formatting of the input to that file. This is only intended for
  212|       |                // `cargo fuzz`'s use!
  213|       |
  214|       |                // `RUST_LIBFUZZER_DEBUG_PATH` is set in initialization.
  215|  1.90k|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|  1.90k|                }
  223|  1.90k|
  224|  1.90k|                __libfuzzer_sys_run(bytes);
  225|  1.90k|                0
  226|  1.90k|            }
LLVMFuzzerTestOneInput:
   58|  1.90k|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|  1.90k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|  1.90k|    });
   63|  1.90k|
   64|  1.90k|    match test_input {
   65|  1.90k|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|  1.90k|}
_RNCNvCslwzdfZTU7Ci_13libfuzzer_sys15test_input_wrap0B3_:
   59|  1.90k|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|  1.90k|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|  1.90k|        rust_fuzzer_test_input(data_slice)
   62|  1.90k|    });
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_RNvMs2_NtCs2T8McUXGNlo_9once_cell3impINtB5_8OnceCellNtNtCs3atDPk1oays_5alloc6string6StringE14is_initializedCslwzdfZTU7Ci_13libfuzzer_sys:
   49|  1.90k|    pub(crate) fn is_initialized(&self) -> bool {
   50|  1.90k|        // An `Acquire` load is enough because that makes all the initialization
   51|  1.90k|        // operations visible to us, and, this being a fast path, weaker
   52|  1.90k|        // ordering helps with performance. This `Acquire` synchronizes with
   53|  1.90k|        // `SeqCst` operations on the slow path.
   54|  1.90k|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   55|  1.90k|    }

_RNvMs4_NtCs2T8McUXGNlo_9once_cell4syncINtB5_8OnceCellNtNtCs3atDPk1oays_5alloc6string6StringE3getCslwzdfZTU7Ci_13libfuzzer_sys:
  965|  1.90k|        pub fn get(&self) -> Option<&T> {
  966|  1.90k|            if self.0.is_initialized() {
  967|       |                // Safe b/c value is initialized.
  968|      0|                Some(unsafe { self.get_unchecked() })
  969|       |            } else {
  970|  1.90k|                None
  971|       |            }
  972|  1.90k|        }

_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE14parse_relativeCs3LEgFa65ccV_5oxrdf:
 1152|    681|    fn parse_relative(&mut self) -> Result<(), IriParseError> {
 1153|    681|        if let Some(base) = self.base {
 1154|      0|            match self.input.front() {
 1155|       |                None => {
 1156|      0|                    self.output.push_str(&base.iri[..base.positions.query_end]);
 1157|      0|                    self.output_positions.scheme_end = base.positions.scheme_end;
 1158|      0|                    self.output_positions.authority_end = base.positions.authority_end;
 1159|      0|                    self.output_positions.path_end = base.positions.path_end;
 1160|      0|                    self.output_positions.query_end = base.positions.query_end;
 1161|      0|                    Ok(())
 1162|       |                }
 1163|       |                Some('/') => {
 1164|      0|                    self.input.next();
 1165|      0|                    self.parse_relative_slash(&base)
 1166|       |                }
 1167|       |                Some('?') => {
 1168|      0|                    self.input.next();
 1169|      0|                    self.output.push_str(&base.iri[..base.positions.path_end]);
 1170|      0|                    self.output.push('?');
 1171|      0|                    self.output_positions.scheme_end = base.positions.scheme_end;
 1172|      0|                    self.output_positions.authority_end = base.positions.authority_end;
 1173|      0|                    self.output_positions.path_end = base.positions.path_end;
 1174|      0|                    self.parse_query()
 1175|       |                }
 1176|       |                Some('#') => {
 1177|      0|                    self.input.next();
 1178|      0|                    self.output.push_str(&base.iri[..base.positions.query_end]);
 1179|      0|                    self.output_positions.scheme_end = base.positions.scheme_end;
 1180|      0|                    self.output_positions.authority_end = base.positions.authority_end;
 1181|      0|                    self.output_positions.path_end = base.positions.path_end;
 1182|      0|                    self.output_positions.query_end = base.positions.query_end;
 1183|      0|                    self.output.push('#');
 1184|      0|                    self.parse_fragment()
 1185|       |                }
 1186|       |                _ => {
 1187|      0|                    self.output.push_str(&base.iri[..base.positions.path_end]);
 1188|      0|                    self.output_positions.scheme_end = base.positions.scheme_end;
 1189|      0|                    self.output_positions.authority_end = base.positions.authority_end;
 1190|      0|                    self.output_positions.path_end = base.positions.path_end;
 1191|      0|                    self.remove_last_segment();
 1192|      0|                    if self.output.len() > base.positions.scheme_end {
 1193|      0|                        // We have some path or authority, we keep a base '/'
 1194|      0|                        self.output.push('/');
 1195|      0|                    }
 1196|      0|                    self.parse_path()
 1197|       |                }
 1198|       |            }
 1199|       |        } else {
 1200|    681|            self.output_positions.scheme_end = 0;
 1201|    681|            self.input_scheme_end = 0;
 1202|    681|            if self.input.starts_with('/') {
 1203|    299|                self.input.next();
 1204|    299|                self.output.push('/');
 1205|    299|                self.parse_path_or_authority()
 1206|       |            } else {
 1207|    382|                self.output_positions.authority_end = 0;
 1208|    382|                self.parse_path()
 1209|       |            }
 1210|       |        }
 1211|    681|    }
_RNvMsp_CskoZt5jAeZrn_5oxiriINtB5_3IriNtNtCs3atDPk1oays_5alloc6string6StringE5parseCs3LEgFa65ccV_5oxrdf:
  501|  3.18k|    pub fn parse(iri: T) -> Result<Self, IriParseError> {
  502|  3.18k|        IriRef::parse(iri)?.try_into()
  503|  3.18k|    }
_RNvMCskoZt5jAeZrn_5oxiriINtB2_6IriRefNtNtCs3atDPk1oays_5alloc6string6StringE5parseCs3LEgFa65ccV_5oxrdf:
   55|  3.18k|    pub fn parse(iri: T) -> Result<Self, IriParseError> {
   56|  3.18k|        let positions = IriParser::parse(&iri, None, &mut VoidOutputBuffer::default())?;
   57|  3.08k|        Ok(Self { iri, positions })
   58|  3.18k|    }
_RNvMCskoZt5jAeZrn_5oxiriINtB2_6IriRefNtNtCs3atDPk1oays_5alloc6string6StringE11is_absoluteCs3LEgFa65ccV_5oxrdf:
  146|  3.08k|    pub fn is_absolute(&self) -> bool {
  147|  3.08k|        self.positions.scheme_end != 0
  148|  3.08k|    }
_RNCNvMs11_CskoZt5jAeZrn_5oxiriINtB8_9IriParserNtB8_16VoidOutputBufferE10read_echar0Cs3LEgFa65ccV_5oxrdf:
 1437|  1.87k|        if c1.map_or(false, |c| c.is_ascii_hexdigit())
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE18parse_scheme_startCs3LEgFa65ccV_5oxrdf:
 1101|  3.18k|    fn parse_scheme_start(&mut self) -> Result<(), IriParseError> {
 1102|  3.18k|        match self.input.front() {
 1103|      1|            Some(':') => self.parse_error(IriParseErrorKind::NoScheme),
 1104|  3.18k|            Some(c) if c.is_ascii_alphabetic() => self.parse_scheme(),
 1105|    607|            _ => self.parse_relative(),
 1106|       |        }
 1107|  3.18k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE10parse_hostCs3LEgFa65ccV_5oxrdf:
 1255|  1.59k|    fn parse_host(&mut self) -> Result<(), IriParseError> {
 1256|  1.59k|        if self.input.starts_with('[') {
 1257|       |            // IP v6
 1258|     42|            let start_position = self.input.position;
 1259|  1.86k|            while let Some(c) = self.input.next() {
 1260|  1.82k|                self.output.push(c);
 1261|  1.82k|                if c == ']' {
 1262|      3|                    let ip = &self.iri[start_position + 1..self.input.position - 1];
 1263|      3|                    if let Err(error) = Ipv6Addr::from_str(ip) {
 1264|      3|                        return self.parse_error(IriParseErrorKind::InvalidHostIp(error));
 1265|      0|                    }
 1266|      0|
 1267|      0|                    let c = self.input.next();
 1268|      0|                    return match c {
 1269|       |                        Some(':') => {
 1270|      0|                            self.output.push(':');
 1271|      0|                            self.parse_port()
 1272|       |                        }
 1273|       |                        None | Some('/') | Some('?') | Some('#') => {
 1274|      0|                            self.output_positions.authority_end = self.output.len();
 1275|      0|                            self.parse_path_start(c)
 1276|       |                        }
 1277|      0|                        Some(c) => self.parse_error(IriParseErrorKind::InvalidHostCharacter(c)),
 1278|       |                    };
 1279|  1.82k|                }
 1280|       |            }
 1281|     39|            self.parse_error(IriParseErrorKind::InvalidHostCharacter('['))
 1282|       |        } else {
 1283|       |            // Other host
 1284|  5.46k|            loop {
 1285|  5.46k|                let c = self.input.next();
 1286|  5.46k|                match c {
 1287|       |                    Some(':') => {
 1288|    841|                        self.output.push(':');
 1289|    841|                        return self.parse_port();
 1290|       |                    }
 1291|       |                    None | Some('/') | Some('?') | Some('#') => {
 1292|    705|                        self.output_positions.authority_end = self.output.len();
 1293|    705|                        return self.parse_path_start(c);
 1294|       |                    }
 1295|  3.92k|                    Some(c) => self.read_url_codepoint_or_echar(c)?,
 1296|       |                }
 1297|       |            }
 1298|       |        }
 1299|  1.59k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE23parse_path_or_authorityCs3LEgFa65ccV_5oxrdf:
 1141|  1.95k|    fn parse_path_or_authority(&mut self) -> Result<(), IriParseError> {
 1142|  1.95k|        if self.input.starts_with('/') {
 1143|  1.59k|            self.input.next();
 1144|  1.59k|            self.output.push('/');
 1145|  1.59k|            self.parse_authority()
 1146|       |        } else {
 1147|    360|            self.output_positions.authority_end = self.output.len() - 1;
 1148|    360|            self.parse_path()
 1149|       |        }
 1150|  1.95k|    }
_RNvMsp_CskoZt5jAeZrn_5oxiriINtB5_3IriNtNtCs3atDPk1oays_5alloc6string6StringE10into_innerCs3LEgFa65ccV_5oxrdf:
  568|  2.49k|    pub fn into_inner(self) -> T {
  569|  2.49k|        self.0.into_inner()
  570|  2.49k|    }
_RINvMs11_CskoZt5jAeZrn_5oxiriINtB7_9IriParserNtB7_16VoidOutputBufferE11parse_erroruECs3LEgFa65ccV_5oxrdf:
 1454|    103|    fn parse_error<T>(&self, kind: IriParseErrorKind) -> Result<T, IriParseError> {
 1455|    103|        Err(IriParseError { kind })
 1456|    103|    }
_RNvMCskoZt5jAeZrn_5oxiriINtB2_6IriRefNtNtCs3atDPk1oays_5alloc6string6StringE10into_innerCs3LEgFa65ccV_5oxrdf:
  132|  2.49k|    pub fn into_inner(self) -> T {
  133|  2.49k|        self.iri
  134|  2.49k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE15parse_authorityCs3LEgFa65ccV_5oxrdf:
 1231|  1.59k|    fn parse_authority(&mut self) -> Result<(), IriParseError> {
 1232|       |        // @ are not allowed in IRI authorities so not need to take care of ambiguities
 1233|  6.60k|        loop {
 1234|  6.60k|            let c = self.input.next();
 1235|  6.60k|            match c {
 1236|       |                Some('@') => {
 1237|     10|                    self.output.push('@');
 1238|     10|                    return self.parse_host();
 1239|       |                }
 1240|       |                None | Some('[') | Some('/') | Some('?') | Some('#') => {
 1241|  1.58k|                    self.input = ParserInput {
 1242|  1.58k|                        value: self.iri[self.input_scheme_end + 2..].chars(),
 1243|  1.58k|                        position: self.input_scheme_end + 2,
 1244|  1.58k|                    };
 1245|  1.58k|                    self.output.truncate(self.output_positions.scheme_end + 2);
 1246|  1.58k|                    return self.parse_host();
 1247|       |                }
 1248|  5.01k|                Some(c) => {
 1249|  5.01k|                    self.read_url_codepoint_or_echar(c)?;
 1250|       |                }
 1251|       |            }
 1252|       |        }
 1253|  1.59k|    }
_RNvXsV_CskoZt5jAeZrn_5oxiriINtB5_3IriNtNtCs3atDPk1oays_5alloc6string6StringEINtNtCs2HCZCz77UhY_4core7convert7TryFromINtB5_6IriRefBz_EE8try_fromCs3LEgFa65ccV_5oxrdf:
  871|  3.08k|    fn try_from(iri: IriRef<T>) -> Result<Self, IriParseError> {
  872|  3.08k|        if iri.is_absolute() {
  873|  2.49k|            Ok(Self(iri))
  874|       |        } else {
  875|    581|            Err(IriParseError {
  876|    581|                kind: IriParseErrorKind::NoScheme,
  877|    581|            })
  878|       |        }
  879|  3.08k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE16parse_path_startCs3LEgFa65ccV_5oxrdf:
 1315|  1.52k|    fn parse_path_start(&mut self, c: Option<char>) -> Result<(), IriParseError> {
 1316|  1.52k|        match c {
 1317|       |            None => {
 1318|    668|                self.output_positions.path_end = self.output.len();
 1319|    668|                self.output_positions.query_end = self.output.len();
 1320|    668|                Ok(())
 1321|       |            }
 1322|       |            Some('?') => {
 1323|    138|                self.output_positions.path_end = self.output.len();
 1324|    138|                self.output.push('?');
 1325|    138|                self.parse_query()
 1326|       |            }
 1327|       |            Some('#') => {
 1328|    120|                self.output_positions.path_end = self.output.len();
 1329|    120|                self.output_positions.query_end = self.output.len();
 1330|    120|                self.output.push('#');
 1331|    120|                self.parse_fragment()
 1332|       |            }
 1333|       |            Some('/') => {
 1334|    603|                self.output.push('/');
 1335|    603|                self.parse_path()
 1336|       |            }
 1337|      0|            Some(c) => {
 1338|      0|                self.read_url_codepoint_or_echar(c)?;
 1339|      0|                self.parse_path()
 1340|       |            }
 1341|       |        }
 1342|  1.52k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE33read_url_query_codepoint_or_echarCs3LEgFa65ccV_5oxrdf:
 1422|  6.10k|    fn read_url_query_codepoint_or_echar(&mut self, c: char) -> Result<(), IriParseError> {
 1423|  6.10k|        if c == '%' {
 1424|    218|            self.read_echar()
 1425|  5.89k|        } else if is_url_query_code_point(c) {
 1426|  5.87k|            self.output.push(c);
 1427|  5.87k|            Ok(())
 1428|       |        } else {
 1429|     11|            self.parse_error(IriParseErrorKind::InvalidIriCodePoint(c))
 1430|       |        }
 1431|  6.10k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE11parse_queryCs3LEgFa65ccV_5oxrdf:
 1380|    470|    fn parse_query(&mut self) -> Result<(), IriParseError> {
 1381|  6.56k|        while let Some(c) = self.input.next() {
 1382|  6.12k|            if c == '#' {
 1383|     12|                self.output_positions.query_end = self.output.len();
 1384|     12|                self.output.push('#');
 1385|     12|                return self.parse_fragment();
 1386|       |            } else {
 1387|  6.10k|                self.read_url_query_codepoint_or_echar(c)?
 1388|       |            }
 1389|       |        }
 1390|    445|        self.output_positions.query_end = self.output.len();
 1391|    445|        Ok(())
 1392|    470|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE14parse_fragmentCs3LEgFa65ccV_5oxrdf:
 1394|    337|    fn parse_fragment(&mut self) -> Result<(), IriParseError> {
 1395|  2.65k|        while let Some(c) = self.input.next() {
 1396|  2.32k|            self.read_url_codepoint_or_echar(c)?
 1397|       |        }
 1398|    329|        Ok(())
 1399|    337|    }
_RNCNvMs11_CskoZt5jAeZrn_5oxiriINtB8_9IriParserNtB8_16VoidOutputBufferE10read_echars_0Cs3LEgFa65ccV_5oxrdf:
 1438|  1.86k|            && c2.map_or(false, |c| c.is_ascii_hexdigit())
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE12parse_schemeCs3LEgFa65ccV_5oxrdf:
 1109|  2.57k|    fn parse_scheme(&mut self) -> Result<(), IriParseError> {
 1110|  9.82k|        loop {
 1111|  9.82k|            let c = self.input.next();
 1112|  9.78k|            match c {
 1113|  9.78k|                Some(c) if c.is_ascii_alphanumeric() || c == '+' || c == '-' || c == '.' => {
 1114|  7.24k|                    self.output.push(c)
 1115|       |                }
 1116|       |                Some(':') => {
 1117|  2.50k|                    self.output.push(':');
 1118|  2.50k|                    self.output_positions.scheme_end = self.output.len();
 1119|  2.50k|                    self.input_scheme_end = self.input.position;
 1120|  2.50k|                    return if self.input.starts_with('/') {
 1121|  1.65k|                        self.input.next();
 1122|  1.65k|                        self.output.push('/');
 1123|  1.65k|                        self.parse_path_or_authority()
 1124|       |                    } else {
 1125|    848|                        self.output_positions.authority_end = self.output.len();
 1126|    848|                        self.parse_path()
 1127|       |                    };
 1128|       |                }
 1129|       |                _ => {
 1130|     74|                    self.input = ParserInput {
 1131|     74|                        value: self.iri.chars(),
 1132|     74|                        position: 0,
 1133|     74|                    }; // reset
 1134|     74|                    self.output.clear();
 1135|     74|                    return self.parse_relative();
 1136|       |                }
 1137|       |            }
 1138|       |        }
 1139|  2.57k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE10parse_portCs3LEgFa65ccV_5oxrdf:
 1301|    841|    fn parse_port(&mut self) -> Result<(), IriParseError> {
 1302|  1.06k|        loop {
 1303|  1.06k|            let c = self.input.next();
 1304|    655|            match c {
 1305|    655|                Some(c) if c.is_ascii_digit() => self.output.push(c),
 1306|       |                Some('/') | Some('?') | Some('#') | None => {
 1307|    824|                    self.output_positions.authority_end = self.output.len();
 1308|    824|                    return self.parse_path_start(c);
 1309|       |                }
 1310|     17|                Some(c) => return self.parse_error(IriParseErrorKind::InvalidPortCharacter(c)),
 1311|       |            }
 1312|       |        }
 1313|    841|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE27read_url_codepoint_or_echarCs3LEgFa65ccV_5oxrdf:
 1410|  18.4k|    fn read_url_codepoint_or_echar(&mut self, c: char) -> Result<(), IriParseError> {
 1411|  18.4k|        if c == '%' {
 1412|  1.66k|            self.read_echar()
 1413|  16.7k|        } else if is_url_code_point(c) {
 1414|  16.7k|            self.output.push(c);
 1415|  16.7k|            Ok(())
 1416|       |        } else {
 1417|      8|            self.parse_error(IriParseErrorKind::InvalidIriCodePoint(c))
 1418|       |        }
 1419|  18.4k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE10parse_pathCs3LEgFa65ccV_5oxrdf:
 1344|  2.19k|    fn parse_path(&mut self) -> Result<(), IriParseError> {
 1345|  10.6k|        loop {
 1346|  10.6k|            let c = self.input.next();
 1347|  10.6k|            match c {
 1348|       |                None | Some('/') | Some('?') | Some('#') => {
 1349|  3.48k|                    if self.output.as_str().ends_with("/..") {
 1350|      0|                        self.remove_last_segment();
 1351|      0|                        self.remove_last_segment();
 1352|      0|                        self.output.push('/');
 1353|  3.48k|                    } else if self.output.as_str().ends_with("/.") {
 1354|      0|                        self.remove_last_segment();
 1355|      0|                        self.output.push('/');
 1356|  3.48k|                    } else if c == Some('/') {
 1357|  1.30k|                        self.output.push('/');
 1358|  2.17k|                    }
 1359|       |
 1360|  3.48k|                    if c == Some('?') {
 1361|    332|                        self.output_positions.path_end = self.output.len();
 1362|    332|                        self.output.push('?');
 1363|    332|                        return self.parse_query();
 1364|  3.15k|                    } else if c == Some('#') {
 1365|    205|                        self.output_positions.path_end = self.output.len();
 1366|    205|                        self.output_positions.query_end = self.output.len();
 1367|    205|                        self.output.push('#');
 1368|    205|                        return self.parse_fragment();
 1369|  2.94k|                    } else if c == None {
 1370|  1.63k|                        self.output_positions.path_end = self.output.len();
 1371|  1.63k|                        self.output_positions.query_end = self.output.len();
 1372|  1.63k|                        return Ok(());
 1373|  1.30k|                    }
 1374|       |                }
 1375|  7.15k|                Some(c) => self.read_url_codepoint_or_echar(c)?,
 1376|       |            }
 1377|       |        }
 1378|  2.19k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE10read_echarCs3LEgFa65ccV_5oxrdf:
 1434|  1.88k|    fn read_echar(&mut self) -> Result<(), IriParseError> {
 1435|  1.88k|        let c1 = self.input.next();
 1436|  1.88k|        let c2 = self.input.next();
 1437|  1.88k|        if c1.map_or(false, |c| c.is_ascii_hexdigit())
 1438|  1.86k|            && c2.map_or(false, |c| c.is_ascii_hexdigit())
 1439|       |        {
 1440|  1.86k|            self.output.push('%');
 1441|  1.86k|            self.output.push(c1.unwrap());
 1442|  1.86k|            self.output.push(c2.unwrap());
 1443|  1.86k|            Ok(())
 1444|       |        } else {
 1445|     24|            self.parse_error(IriParseErrorKind::InvalidPercentEncoding([
 1446|     24|                Some('%'),
 1447|     24|                c1,
 1448|     24|                c2,
 1449|     24|            ]))
 1450|       |        }
 1451|  1.88k|    }
_RNvMs11_CskoZt5jAeZrn_5oxiriINtB6_9IriParserNtB6_16VoidOutputBufferE5parseCs3LEgFa65ccV_5oxrdf:
 1076|  3.18k|    fn parse(
 1077|  3.18k|        iri: &'a str,
 1078|  3.18k|        base: Option<IriRef<&'a str>>,
 1079|  3.18k|        output: &'a mut O,
 1080|  3.18k|    ) -> Result<IriElementsPositions, IriParseError> {
 1081|  3.18k|        let mut parser = Self {
 1082|  3.18k|            iri,
 1083|  3.18k|            base,
 1084|  3.18k|            input: ParserInput {
 1085|  3.18k|                value: iri.chars(),
 1086|  3.18k|                position: 0,
 1087|  3.18k|            },
 1088|  3.18k|            output,
 1089|  3.18k|            output_positions: IriElementsPositions {
 1090|  3.18k|                scheme_end: 0,
 1091|  3.18k|                authority_end: 0,
 1092|  3.18k|                path_end: 0,
 1093|  3.18k|                query_end: 0,
 1094|  3.18k|            },
 1095|  3.18k|            input_scheme_end: 0,
 1096|  3.18k|        };
 1097|  3.18k|        parser.parse_scheme_start()?;
 1098|  3.08k|        Ok(parser.output_positions)
 1099|  3.18k|    }
_RNvMs10_CskoZt5jAeZrn_5oxiriNtB6_11ParserInput5frontCs3LEgFa65ccV_5oxrdf:
 1053|  3.18k|    fn front(&self) -> Option<char> {
 1054|  3.18k|        self.value.clone().next()
 1055|  3.18k|    }
_RNvXsY_CskoZt5jAeZrn_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer5clearCs3LEgFa65ccV_5oxrdf:
  985|     74|    fn clear(&mut self) {
  986|     74|        self.len = 0;
  987|     74|    }
_RNvMs10_CskoZt5jAeZrn_5oxiriNtB6_11ParserInput11starts_withCs3LEgFa65ccV_5oxrdf:
 1058|  6.72k|    fn starts_with(&self, c: char) -> bool {
 1059|  6.72k|        self.value.as_str().starts_with(c)
 1060|  6.72k|    }
_RNvXs1b_CskoZt5jAeZrn_5oxiriNtB6_16VoidOutputBufferNtNtCs2HCZCz77UhY_4core7default7Default7defaultCs3LEgFa65ccV_5oxrdf:
  968|  3.18k|#[derive(Default)]
_RNvXsY_CskoZt5jAeZrn_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer8truncateCs3LEgFa65ccV_5oxrdf:
  990|  1.58k|    fn truncate(&mut self, new_len: usize) {
  991|  1.58k|        self.len = new_len;
  992|  1.58k|    }
_RNvXsY_CskoZt5jAeZrn_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer3lenCs3LEgFa65ccV_5oxrdf:
  995|  11.4k|    fn len(&self) -> usize {
  996|  11.4k|        self.len
  997|  11.4k|    }
_RNvXsY_CskoZt5jAeZrn_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer6as_strCs3LEgFa65ccV_5oxrdf:
 1000|  6.96k|    fn as_str(&self) -> &str {
 1001|  6.96k|        ""
 1002|  6.96k|    }
_RNvXsY_CskoZt5jAeZrn_5oxiriNtB5_16VoidOutputBufferNtB5_12OutputBuffer4pushCs3LEgFa65ccV_5oxrdf:
  975|  47.1k|    fn push(&mut self, c: char) {
  976|  47.1k|        self.len += c.len_utf8();
  977|  47.1k|    }
_RNvMs10_CskoZt5jAeZrn_5oxiriNtB6_11ParserInput4nextCs3LEgFa65ccV_5oxrdf:
 1043|  51.9k|    fn next(&mut self) -> Option<char> {
 1044|  51.9k|        if let Some(head) = self.value.next() {
 1045|  48.1k|            self.position += head.len_utf8();
 1046|  48.1k|            Some(head)
 1047|       |        } else {
 1048|  3.84k|            None
 1049|       |        }
 1050|  51.9k|    }
_RNvCskoZt5jAeZrn_5oxiri23is_url_query_code_point:
 1503|  5.89k|fn is_url_query_code_point(c: char) -> bool {
 1504|  5.89k|    is_url_code_point(c)
 1505|    107|        || matches!(c, '\u{E000}'..='\u{F8FF}' | '\u{F0000}'..='\u{FFFFD}' | '\u{100000}'..='\u{10FFFD}')
 1506|  5.89k|}
_RNvCskoZt5jAeZrn_5oxiri17is_url_code_point:
 1459|  22.6k|fn is_url_code_point(c: char) -> bool {
 1460|  22.6k|    matches!(c,
 1461|  6.65k|        'a'..='z'
 1462|  5.64k|        | 'A'..='Z'
 1463|  12.3k|        | '0'..='9'
 1464|       |        | '!'
 1465|       |        | '$'
 1466|       |        | '&'
 1467|       |        | '\''
 1468|       |        | '('
 1469|       |        | ')'
 1470|       |        | '*'
 1471|       |        | '+'
 1472|       |        | ','
 1473|       |        | '-'
 1474|       |        | '.'
 1475|       |        | '/'
 1476|       |        | ':'
 1477|       |        | ';'
 1478|       |        | '='
 1479|       |        | '?'
 1480|       |        | '@'
 1481|       |        | '_'
 1482|       |        | '~'
 1483|  3.54k|        | '\u{A0}'..='\u{D7FF}'
 1484|  1.34k|        | '\u{F900}'..='\u{FDCF}'
 1485|  1.34k|        | '\u{FDF0}'..='\u{FFEF}'
 1486|  1.34k|        | '\u{10000}'..='\u{1FFFD}'
 1487|  1.13k|        | '\u{20000}'..='\u{2FFFD}'
 1488|  1.11k|        | '\u{30000}'..='\u{3FFFD}'
 1489|  1.11k|        | '\u{40000}'..='\u{4FFFD}'
 1490|     53|        | '\u{50000}'..='\u{5FFFD}'
 1491|     33|        | '\u{60000}'..='\u{6FFFD}'
 1492|     33|        | '\u{70000}'..='\u{7FFFD}'
 1493|     33|        | '\u{80000}'..='\u{8FFFD}'
 1494|     32|        | '\u{90000}'..='\u{9FFFD}'
 1495|     32|        | '\u{A0000}'..='\u{AFFFD}'
 1496|     32|        | '\u{B0000}'..='\u{BFFFD}'
 1497|     32|        | '\u{C0000}'..='\u{CFFFD}'
 1498|     30|        | '\u{D0000}'..='\u{DFFFD}'
 1499|     30|        | '\u{E1000}'..='\u{EFFFD}'
 1500|       |    )
 1501|  22.6k|}
_RNvXsW_CskoZt5jAeZrn_5oxiriNtB5_13IriParseErrorNtNtCs2HCZCz77UhY_4core3fmt7Display3fmt:
  906|    684|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  907|    684|        match &self.kind {
  908|    582|            IriParseErrorKind::NoScheme => write!(f, "No scheme found in an absolute IRI"),
  909|     39|            IriParseErrorKind::InvalidHostCharacter(c) => {
  910|     39|                write!(f, "Invalid character '{}' in host", c)
  911|       |            }
  912|      3|            IriParseErrorKind::InvalidHostIp(e) => write!(f, "Invalid host IP ({})", e),
  913|     17|            IriParseErrorKind::InvalidPortCharacter(c) => write!(f, "Invalid character '{}'", c),
  914|     19|            IriParseErrorKind::InvalidIriCodePoint(c) => {
  915|     19|                write!(f, "Invalid IRI code point '{}'", c)
  916|       |            }
  917|     24|            IriParseErrorKind::InvalidPercentEncoding(cs) => write!(
  918|     24|                f,
  919|     24|                "Invalid IRI percent encoding '{}'",
  920|     24|                cs.iter().flatten().cloned().collect::<String>()
  921|     24|            ),
  922|       |        }
  923|    684|    }

_RNvNtCs5UenZY2zsE2_13oxigraph_fuzz13result_format18fuzz_result_format:
    6|  1.90k|pub fn fuzz_result_format(format: QueryResultsFormat, data: &[u8]) {
    7|  1.90k|    let parser = QueryResultsParser::from_format(format);
    8|  1.90k|    let serializer = QueryResultsSerializer::from_format(format);
    9|       |
   10|  1.90k|    let Ok(reader) = parser.read_results(data) else {
   11|  1.70k|        return;
   12|       |    };
   13|    194|    match reader {
   14|    193|        QueryResultsReader::Solutions(solutions) => {
   15|    193|            let Ok(solutions) = solutions.collect::<Result<Vec<_>, _>>() else {
   16|     52|                return;
   17|       |            };
   18|       |
   19|       |            // We try to write again
   20|    141|            let mut writer = serializer
   21|    141|                .solutions_writer(
   22|    141|                    Vec::new(),
   23|    141|                    solutions
   24|    141|                        .get(0)
   25|    141|                        .map_or_else(Vec::new, |s| s.variables().to_vec()),
   26|    141|                )
   27|    141|                .unwrap();
   28|  3.57k|            for solution in &solutions {
   29|  3.43k|                writer.write(solution).unwrap();
   30|  3.43k|            }
   31|    141|            let serialized = String::from_utf8(writer.finish().unwrap()).unwrap();
   32|       |
   33|       |            // And to parse again
   34|    141|            if let QueryResultsReader::Solutions(roundtrip_solutions) = parser
   35|    141|                .read_results(serialized.as_bytes())
   36|    141|                .with_context(|| format!("Parsing {:?}", &serialized))
   37|    141|                .unwrap()
   38|       |            {
   39|    141|                assert_eq!(
   40|    141|                    roundtrip_solutions
   41|    141|                        .collect::<Result<Vec<_>, _>>()
   42|    141|                        .with_context(|| format!("Parsing {:?}", &serialized))
   43|    141|                        .unwrap(),
   44|    141|                    solutions
   45|    141|                )
   46|      0|            }
   47|       |        }
   48|      1|        QueryResultsReader::Boolean(value) => {
   49|      1|            // We try to write again
   50|      1|            let mut serialized = Vec::new();
   51|      1|            serializer
   52|      1|                .write_boolean_result(&mut serialized, value)
   53|      1|                .unwrap();
   54|       |
   55|       |            // And to parse again
   56|      1|            if let QueryResultsReader::Boolean(roundtrip_value) =
   57|      1|                parser.read_results(serialized.as_slice()).unwrap()
   58|       |            {
   59|      1|                assert_eq!(roundtrip_value, value)
   60|      0|            }
   61|       |        }
   62|       |    }
   63|  1.90k|}
_RNCNvNtCs5UenZY2zsE2_13oxigraph_fuzz13result_format18fuzz_result_format0B5_:
   25|    138|                        .map_or_else(Vec::new, |s| s.variables().to_vec()),

_RINvMNtCs3LEgFa65ccV_5oxrdf10named_nodeNtB3_9NamedNode3newReEB5_:
   24|  3.18k|    pub fn new(iri: impl Into<String>) -> Result<Self, IriParseError> {
   25|  3.18k|        Ok(Self::new_from_iri(Iri::parse(iri.into())?))
   26|  3.18k|    }
_RINvMNtCs3LEgFa65ccV_5oxrdf10named_nodeNtB3_9NamedNode13new_uncheckedNtNtCs3atDPk1oays_5alloc6string6StringEB5_:
   39|  2.49k|    pub fn new_unchecked(iri: impl Into<String>) -> Self {
   40|  2.49k|        Self { iri: iri.into() }
   41|  2.49k|    }
_RNvMNtCs3LEgFa65ccV_5oxrdf10named_nodeNtB2_9NamedNode12new_from_iriB4_:
   29|  2.49k|    pub(crate) fn new_from_iri(iri: Iri<String>) -> Self {
   30|  2.49k|        Self::new_unchecked(iri.into_inner())
   31|  2.49k|    }

_RNvXs1_NtCs3LEgFa65ccV_5oxrdf8variableNtB5_11VariableRefNtNtCs2HCZCz77UhY_4core3fmt7Display3fmtCs5UenZY2zsE2_13oxigraph_fuzz:
  123|      9|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  124|      9|        write!(f, "?{}", self.name)
  125|      9|    }
_RNvXs_NtCs3LEgFa65ccV_5oxrdf8variableNtB4_8VariableNtNtCs2HCZCz77UhY_4core3fmt7Display3fmtCs5UenZY2zsE2_13oxigraph_fuzz:
   61|      9|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   62|      9|        self.as_ref().fmt(f)
   63|      9|    }
_RNvMNtCs3LEgFa65ccV_5oxrdf8variableNtB2_8Variable6as_strCs5UenZY2zsE2_13oxigraph_fuzz:
   44|  3.52k|    pub fn as_str(&self) -> &str {
   45|  3.52k|        &self.name
   46|  3.52k|    }
_RNvMNtCs3LEgFa65ccV_5oxrdf8variableNtB2_8Variable6as_refCs5UenZY2zsE2_13oxigraph_fuzz:
   54|      9|    pub fn as_ref(&self) -> VariableRef<'_> {
   55|      9|        VariableRef { name: &self.name }
   56|      9|    }
_RNvXs8_NtCs3LEgFa65ccV_5oxrdf8variableNtB5_22VariableNameParseErrorNtNtCs2HCZCz77UhY_4core3fmt7Display3fmtCs5UenZY2zsE2_13oxigraph_fuzz:
  226|     16|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  227|     16|        write!(f, "The variable name is invalid")
  228|     16|    }
_RNvXsd_NtCs3LEgFa65ccV_5oxrdf8variableNtB5_8VariableNtNtCs2HCZCz77UhY_4core3cmp9PartialEq2eqCs5UenZY2zsE2_13oxigraph_fuzz:
   17|  27.1k|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvXsh_NtCs3LEgFa65ccV_5oxrdf8variableNtB5_8VariableNtNtCs2HCZCz77UhY_4core5clone5Clone5cloneCs5UenZY2zsE2_13oxigraph_fuzz:
   17|    609|#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Hash)]
_RNvNtCs3LEgFa65ccV_5oxrdf8variable28validate_variable_identifier:
  170|  4.95k|fn validate_variable_identifier(id: &str) -> Result<(), VariableNameParseError> {
  171|  4.95k|    let mut chars = id.chars();
  172|  4.95k|    let front = chars.next().ok_or(VariableNameParseError {})?;
  173|  4.95k|    match front {
  174|  4.95k|        '0'..='9'
  175|       |        | '_'
  176|       |        | ':'
  177|  4.48k|        | 'A'..='Z'
  178|  2.98k|        | 'a'..='z'
  179|    111|        | '\u{00C0}'..='\u{00D6}'
  180|    111|        | '\u{00D8}'..='\u{00F6}'
  181|    111|        | '\u{00F8}'..='\u{02FF}'
  182|     81|        | '\u{0370}'..='\u{037D}'
  183|     81|        | '\u{037F}'..='\u{1FFF}'
  184|     56|        | '\u{200C}'..='\u{200D}'
  185|     56|        | '\u{2070}'..='\u{218F}'
  186|     56|        | '\u{2C00}'..='\u{2FEF}'
  187|     56|        | '\u{3001}'..='\u{D7FF}'
  188|     44|        | '\u{F900}'..='\u{FDCF}'
  189|     44|        | '\u{FDF0}'..='\u{FFFD}'
  190|  4.94k|        | '\u{10000}'..='\u{EFFFF}' => (),
  191|      3|        _ => return Err(VariableNameParseError {}),
  192|       |    }
  193|  30.5k|    for c in chars {
  194|  25.6k|        match c {
  195|  25.6k|            '0'..='9'
  196|       |            | '\u{00B7}'
  197|  1.99k|            | '\u{00300}'..='\u{036F}'
  198|  1.26k|            | '\u{203F}'..='\u{2040}'
  199|       |            | '_'
  200|  15.5k|            | 'A'..='Z'
  201|  10.7k|            | 'a'..='z'
  202|  2.12k|            | '\u{00C0}'..='\u{00D6}'
  203|  2.12k|            | '\u{00D8}'..='\u{00F6}'
  204|  2.12k|            | '\u{00F8}'..='\u{02FF}'
  205|  1.99k|            | '\u{0370}'..='\u{037D}'
  206|  1.99k|            | '\u{037F}'..='\u{1FFF}'
  207|  1.26k|            | '\u{200C}'..='\u{200D}'
  208|  1.26k|            | '\u{2070}'..='\u{218F}'
  209|  1.25k|            | '\u{2C00}'..='\u{2FEF}'
  210|  1.25k|            | '\u{3001}'..='\u{D7FF}'
  211|    838|            | '\u{F900}'..='\u{FDCF}'
  212|    836|            | '\u{FDF0}'..='\u{FFFD}'
  213|  25.5k|            | '\u{10000}'..='\u{EFFFF}' => (),
  214|     11|            _ => return Err(VariableNameParseError {}),
  215|       |        }
  216|       |    }
  217|  4.93k|    Ok(())
  218|  4.95k|}
_RINvMNtCs3LEgFa65ccV_5oxrdf8variableNtB3_8Variable13new_uncheckedNtNtCs3atDPk1oays_5alloc6string6StringEB5_:
   39|  4.93k|    pub fn new_unchecked(name: impl Into<String>) -> Self {
   40|  4.93k|        Self { name: name.into() }
   41|  4.93k|    }
_RINvMNtCs3LEgFa65ccV_5oxrdf8variableNtB3_8Variable3newReEB5_:
   26|  4.95k|    pub fn new(name: impl Into<String>) -> Result<Self, VariableNameParseError> {
   27|  4.95k|        let name = name.into();
   28|  4.95k|        validate_variable_identifier(&name)?;
   29|  4.93k|        Ok(Self::new_unchecked(name))
   30|  4.95k|    }

_RNvXs1_NtCs2VHBjBJmpQG_10sparesults5errorNtB5_10ParseErrorINtNtCs2HCZCz77UhY_4core7convert4FromNtB5_11SyntaxErrorE4fromCs5UenZY2zsE2_13oxigraph_fuzz:
   43|    835|    fn from(error: SyntaxError) -> Self {
   44|    835|        Self::Syntax(error)
   45|    835|    }
_RNvXs0_NtCs2VHBjBJmpQG_10sparesults5errorNtB5_10ParseErrorINtNtCs2HCZCz77UhY_4core7convert4FromNtNtNtCs5kpxwJF3eK4_3std2io5error5ErrorE4fromCs5UenZY2zsE2_13oxigraph_fuzz:
   36|    924|    fn from(error: io::Error) -> Self {
   37|    924|        Self::Io(error)
   38|    924|    }
_RINvMs4_NtCs2VHBjBJmpQG_10sparesults5errorNtB6_11SyntaxError3msgNtNtCs3atDPk1oays_5alloc6string6StringECs5UenZY2zsE2_13oxigraph_fuzz:
   86|    743|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|    743|        Self {
   88|    743|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|    743|        }
   90|    743|    }
_RINvMs4_NtCs2VHBjBJmpQG_10sparesults5errorNtB6_11SyntaxError3msgReECs5UenZY2zsE2_13oxigraph_fuzz:
   86|     92|    pub(crate) fn msg(msg: impl Into<String>) -> Self {
   87|     92|        Self {
   88|     92|            inner: SyntaxErrorKind::Msg { msg: msg.into() },
   89|     92|        }
   90|     92|    }

_RINvNtCs2VHBjBJmpQG_10sparesults4json12ignore_valueRShECs5UenZY2zsE2_13oxigraph_fuzz:
  578|  1.34k|fn ignore_value<R: BufRead>(
  579|  1.34k|    reader: &mut JsonReader<R>,
  580|  1.34k|    buffer: &mut Vec<u8>,
  581|  1.34k|) -> Result<(), ParseError> {
  582|  1.34k|    let mut nesting = 0;
  583|       |    loop {
  584|  9.73k|        match reader.read_event(buffer)? {
  585|       |            JsonEvent::Boolean(_)
  586|       |            | JsonEvent::Null
  587|       |            | JsonEvent::Number(_)
  588|       |            | JsonEvent::String(_) => {
  589|  1.94k|                if nesting == 0 {
  590|    780|                    return Ok(());
  591|  1.16k|                }
  592|       |            }
  593|  1.66k|            JsonEvent::ObjectKey(_) => (),
  594|  4.22k|            JsonEvent::StartArray | JsonEvent::StartObject => nesting += 1,
  595|       |            JsonEvent::EndArray | JsonEvent::EndObject => {
  596|  1.80k|                nesting -= 1;
  597|  1.80k|                if nesting == 0 {
  598|    472|                    return Ok(());
  599|  1.32k|                }
  600|       |            }
  601|      0|            JsonEvent::Eof => return Err(SyntaxError::msg("Unexpected end of file").into()),
  602|       |        }
  603|       |    }
  604|  1.34k|}
_RNCNvMs0_NtCs2VHBjBJmpQG_10sparesults4jsonINtB7_19JsonSolutionsReaderRShE9read_next0Cs5UenZY2zsE2_13oxigraph_fuzz:
  288|      9|                            let k = *self.mapping.get(key).ok_or_else(|| {
  289|      9|                                SyntaxError::msg(format!(
  290|      9|                                    "The variable {key} has not been defined in the header"
  291|      9|                                ))
  292|      9|                            })?;
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShEs_0Cs5UenZY2zsE2_13oxigraph_fuzz:
  440|      1|                        Some(Type::Uri) => Ok(NamedNode::new(value.ok_or_else(|| {
  441|      1|                            SyntaxError::msg("uri serialization should have a 'value' key")
  442|      1|                        })?)
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShEs5_0Cs5UenZY2zsE2_13oxigraph_fuzz:
  477|      1|                            match subject.ok_or_else(|| {
  478|      1|                                SyntaxError::msg("triple serialization should have a 'subject' key")
  479|      1|                            })? {
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json9read_headRShE0Cs5UenZY2zsE2_13oxigraph_fuzz:
  534|     16|                                let new_var = Variable::new(s).map_err(|e| {
  535|     16|                                    SyntaxError::msg(format!(
  536|     16|                                        "Invalid variable declaration '{s}': {e}"
  537|     16|                                    ))
  538|     16|                                })?;
_RINvNtCs2VHBjBJmpQG_10sparesults4json9read_headRShECs5UenZY2zsE2_13oxigraph_fuzz:
  516|  1.72k|fn read_head<R: BufRead>(
  517|  1.72k|    reader: &mut JsonReader<R>,
  518|  1.72k|    buffer: &mut Vec<u8>,
  519|  1.72k|) -> Result<Vec<Variable>, ParseError> {
  520|  1.72k|    if reader.read_event(buffer)? != JsonEvent::StartObject {
  521|      2|        return Err(SyntaxError::msg("head should be an object").into());
  522|  1.71k|    }
  523|  1.71k|    let mut variables = Vec::new();
  524|       |    loop {
  525|  3.53k|        match reader.read_event(buffer)? {
  526|  2.03k|            JsonEvent::ObjectKey(key) => match key {
  527|  2.03k|                "vars" => {
  528|  1.03k|                    if reader.read_event(buffer)? != JsonEvent::StartArray {
  529|      1|                        return Err(SyntaxError::msg("Variable list should be an array").into());
  530|  1.03k|                    }
  531|       |                    loop {
  532|  5.96k|                        match reader.read_event(buffer)? {
  533|  4.95k|                            JsonEvent::String(s) => {
  534|  4.95k|                                let new_var = Variable::new(s).map_err(|e| {
  535|       |                                    SyntaxError::msg(format!(
  536|       |                                        "Invalid variable declaration '{s}': {e}"
  537|       |                                    ))
  538|  4.95k|                                })?;
  539|  4.93k|                                if variables.contains(&new_var) {
  540|      9|                                    return Err(SyntaxError::msg(format!(
  541|      9|                                        "The variable {new_var} is declared twice"
  542|      9|                                    ))
  543|      9|                                    .into());
  544|  4.92k|                                }
  545|  4.92k|                                variables.push(new_var);
  546|       |                            }
  547|    913|                            JsonEvent::EndArray => break,
  548|       |                            _ => {
  549|      1|                                return Err(
  550|      1|                                    SyntaxError::msg("Variable names should be strings").into()
  551|      1|                                )
  552|       |                            }
  553|       |                        }
  554|       |                    }
  555|       |                }
  556|  1.00k|                "link" => {
  557|     89|                    if reader.read_event(buffer)? != JsonEvent::StartArray {
  558|      1|                        return Err(SyntaxError::msg("Variable list should be an array").into());
  559|     85|                    }
  560|       |                    loop {
  561|    282|                        match reader.read_event(buffer)? {
  562|    197|                            JsonEvent::String(_) => (),
  563|     75|                            JsonEvent::EndArray => break,
  564|       |                            _ => {
  565|      1|                                return Err(SyntaxError::msg("Link names should be strings").into())
  566|       |                            }
  567|       |                        }
  568|       |                    }
  569|       |                }
  570|    916|                _ => ignore_value(reader, buffer)?,
  571|       |            },
  572|  1.43k|            JsonEvent::EndObject => return Ok(variables),
  573|      1|            _ => return Err(SyntaxError::msg("Invalid head serialization").into()),
  574|       |        }
  575|       |    }
  576|  1.72k|}
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShEs1_0Cs5UenZY2zsE2_13oxigraph_fuzz:
  445|      1|                        Some(Type::BNode) => Ok(BlankNode::new(value.ok_or_else(|| {
  446|      1|                            SyntaxError::msg("bnode serialization should have a 'value' key")
  447|      1|                        })?)
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShE0Cs5UenZY2zsE2_13oxigraph_fuzz:
  419|    684|                            .map_err(|e| SyntaxError::msg(format!("Invalid datatype IRI: {e}")))?,
_RNvMNtCs2VHBjBJmpQG_10sparesults4jsonINtB2_19JsonSolutionsWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE6finishCs5UenZY2zsE2_13oxigraph_fuzz:
   66|    141|    pub fn finish(mut self) -> io::Result<W> {
   67|    141|        self.writer.write_event(JsonEvent::EndArray)?;
   68|    141|        self.writer.write_event(JsonEvent::EndObject)?;
   69|    141|        self.writer.write_event(JsonEvent::EndObject)?;
   70|    141|        let mut inner = self.writer.into_inner();
   71|    141|        inner.flush()?;
   72|    141|        Ok(inner)
   73|    141|    }
_RNvMs0_NtCs2VHBjBJmpQG_10sparesults4jsonINtB5_19JsonSolutionsReaderRShE9read_nextCs5UenZY2zsE2_13oxigraph_fuzz:
  278|  7.43k|    pub fn read_next(&mut self) -> Result<Option<Vec<Option<Term>>>, ParseError> {
  279|  7.43k|        match &mut self.kind {
  280|  7.23k|            JsonSolutionsReaderKind::Streaming { reader, buffer } => {
  281|  7.23k|                let mut new_bindings = vec![None; self.mapping.len()];
  282|       |                loop {
  283|  14.3k|                    match reader.read_event(buffer)? {
  284|  7.11k|                        JsonEvent::StartObject => (),
  285|  6.90k|                        JsonEvent::EndObject => return Ok(Some(new_bindings)),
  286|    273|                        JsonEvent::EndArray | JsonEvent::Eof => return Ok(None),
  287|     10|                        JsonEvent::ObjectKey(key) => {
  288|     10|                            let k = *self.mapping.get(key).ok_or_else(|| {
  289|       |                                SyntaxError::msg(format!(
  290|       |                                    "The variable {key} has not been defined in the header"
  291|       |                                ))
  292|     10|                            })?;
  293|      1|                            new_bindings[k] = Some(read_value(reader, buffer, 0)?)
  294|       |                        }
  295|      1|                        _ => return Err(SyntaxError::msg("Invalid result serialization").into()),
  296|       |                    }
  297|       |                }
  298|       |            }
  299|    203|            JsonSolutionsReaderKind::Buffered { bindings } => {
  300|    203|                Ok(if let Some((variables, values)) = bindings.next() {
  301|    194|                    let mut new_bindings = vec![None; self.mapping.len()];
  302|    194|                    for (variable, value) in variables.into_iter().zip(values) {
  303|      0|                        let k = *self.mapping.get(&variable).ok_or_else(|| {
  304|       |                            SyntaxError::msg(format!(
  305|       |                                "The variable {variable} has not been defined in the header"
  306|       |                            ))
  307|      0|                        })?;
  308|      0|                        new_bindings[k] = Some(value)
  309|       |                    }
  310|    194|                    Some(new_bindings)
  311|       |                } else {
  312|      9|                    None
  313|       |                })
  314|       |            }
  315|       |        }
  316|  7.43k|    }
_RNvMs_NtCs2VHBjBJmpQG_10sparesults4jsonINtB4_22JsonQueryResultsReaderRShE4readCs5UenZY2zsE2_13oxigraph_fuzz:
  138|  2.04k|    pub fn read(source: R) -> Result<Self, ParseError> {
  139|  2.04k|        let mut reader = JsonReader::from_reader(source);
  140|  2.04k|        let mut buffer = Vec::default();
  141|  2.04k|        let mut variables = None;
  142|  2.04k|        let mut buffered_bindings: Option<Vec<_>> = None;
  143|  2.04k|        let mut output_iter = None;
  144|  2.04k|
  145|  2.04k|        if reader.read_event(&mut buffer)? != JsonEvent::StartObject {
  146|     57|            return Err(SyntaxError::msg("SPARQL JSON results should be an object").into());
  147|  1.75k|        }
  148|       |
  149|       |        loop {
  150|  4.24k|            let event = reader.read_event(&mut buffer)?;
  151|  4.13k|            match event {
  152|  3.78k|                JsonEvent::ObjectKey(key) => match key {
  153|  3.78k|                    "head" => {
  154|  1.72k|                        let extracted_variables = read_head(&mut reader, &mut buffer)?;
  155|  1.43k|                        if let Some(buffered_bindings) = buffered_bindings.take() {
  156|    478|                            let mut mapping = BTreeMap::default();
  157|  1.35k|                            for (i, var) in extracted_variables.iter().enumerate() {
  158|  1.35k|                                mapping.insert(var.as_str().to_owned(), i);
  159|  1.35k|                            }
  160|    478|                            output_iter = Some(Self::Solutions {
  161|    478|                                variables: extracted_variables,
  162|    478|                                solutions: JsonSolutionsReader {
  163|    478|                                    kind: JsonSolutionsReaderKind::Buffered {
  164|    478|                                        bindings: buffered_bindings.into_iter(),
  165|    478|                                    },
  166|    478|                                    mapping,
  167|    478|                                },
  168|    478|                            });
  169|    955|                        } else {
  170|    955|                            variables = Some(extracted_variables);
  171|    955|                        }
  172|       |                    }
  173|  2.05k|                    "results" => {
  174|  2.05k|                        if reader.read_event(&mut buffer)? != JsonEvent::StartObject {
  175|      1|                            return Err(SyntaxError::msg("'results' should be an object").into());
  176|  2.04k|                        }
  177|       |                        loop {
  178|  2.46k|                            match reader.read_event(&mut buffer)? {
  179|  2.45k|                                JsonEvent::ObjectKey("bindings") => break, // Found
  180|    433|                                JsonEvent::ObjectKey(_) => ignore_value(&mut reader, &mut buffer)?,
  181|       |                                _ => {
  182|      3|                                    return Err(SyntaxError::msg(
  183|      3|                                        "'results' should contain a 'bindings' key",
  184|      3|                                    )
  185|      3|                                    .into())
  186|       |                                }
  187|       |                            }
  188|       |                        }
  189|  2.02k|                        if reader.read_event(&mut buffer)? != JsonEvent::StartArray {
  190|      1|                            return Err(SyntaxError::msg("'bindings' should be an object").into());
  191|  2.01k|                        }
  192|  2.01k|                        if let Some(variables) = variables {
  193|    325|                            let mut mapping = BTreeMap::default();
  194|  1.56k|                            for (i, var) in variables.iter().enumerate() {
  195|  1.56k|                                mapping.insert(var.as_str().to_owned(), i);
  196|  1.56k|                            }
  197|    325|                            return Ok(Self::Solutions {
  198|    325|                                variables,
  199|    325|                                solutions: JsonSolutionsReader {
  200|    325|                                    kind: JsonSolutionsReaderKind::Streaming { reader, buffer },
  201|    325|                                    mapping,
  202|    325|                                },
  203|    325|                            });
  204|  1.69k|                        }
  205|  1.69k|                        // We buffer all results before being able to read the header
  206|  1.69k|                        let mut bindings = Vec::new();
  207|  1.69k|                        let mut variables = Vec::new();
  208|  1.69k|                        let mut values = Vec::new();
  209|       |                        loop {
  210|  5.65k|                            match reader.read_event(&mut buffer)? {
  211|  2.49k|                                JsonEvent::StartObject => (),
  212|  1.46k|                                JsonEvent::EndObject => {
  213|  1.46k|                                    bindings.push((take(&mut variables), take(&mut values)));
  214|  1.46k|                                }
  215|       |                                JsonEvent::EndArray | JsonEvent::Eof => {
  216|    731|                                    buffered_bindings = Some(bindings);
  217|    731|                                    break;
  218|       |                                }
  219|    933|                                JsonEvent::ObjectKey(key) => {
  220|    933|                                    variables.push(key.to_owned());
  221|    933|                                    values.push(read_value(&mut reader, &mut buffer, 0)?);
  222|       |                                }
  223|       |                                _ => {
  224|      1|                                    return Err(
  225|      1|                                        SyntaxError::msg("Invalid result serialization").into()
  226|      1|                                    )
  227|       |                                }
  228|       |                            }
  229|       |                        }
  230|       |                    }
  231|      8|                    "boolean" => {
  232|      4|                        return if let JsonEvent::Boolean(v) = reader.read_event(&mut buffer)? {
  233|      2|                            Ok(Self::Boolean(v))
  234|       |                        } else {
  235|      1|                            Err(SyntaxError::msg("Unexpected boolean value").into())
  236|       |                        }
  237|       |                    }
  238|       |                    _ => {
  239|      4|                        return Err(SyntaxError::msg(format!(
  240|      4|                            "Expecting head or result key, found {key}"
  241|      4|                        ))
  242|      4|                        .into());
  243|       |                    }
  244|       |                },
  245|    331|                JsonEvent::EndObject => (),
  246|       |                JsonEvent::Eof => {
  247|     19|                    return if let Some(output_iter) = output_iter {
  248|      9|                        Ok(output_iter)
  249|       |                    } else {
  250|     10|                        Err(SyntaxError::msg(
  251|     10|                            "Unexpected end of JSON object without 'results' or 'boolean' key",
  252|     10|                        )
  253|     10|                        .into())
  254|       |                    }
  255|       |                }
  256|      2|                _ => return Err(SyntaxError::msg("Invalid SPARQL results serialization").into()),
  257|       |            }
  258|       |        }
  259|  2.04k|    }
_RINvNtCs2VHBjBJmpQG_10sparesults4json25write_boolean_json_resultQINtNtCs3atDPk1oays_5alloc3vec3VechEECs5UenZY2zsE2_13oxigraph_fuzz:
   16|      1|pub fn write_boolean_json_result<W: Write>(sink: W, value: bool) -> io::Result<W> {
   17|      1|    let mut writer = JsonWriter::from_writer(sink);
   18|      1|    writer.write_event(JsonEvent::StartObject)?;
   19|      1|    writer.write_event(JsonEvent::ObjectKey("head"))?;
   20|      1|    writer.write_event(JsonEvent::StartObject)?;
   21|      1|    writer.write_event(JsonEvent::EndObject)?;
   22|      1|    writer.write_event(JsonEvent::ObjectKey("boolean"))?;
   23|      1|    writer.write_event(JsonEvent::Boolean(value))?;
   24|      1|    writer.write_event(JsonEvent::EndObject)?;
   25|      1|    Ok(writer.into_inner())
   26|      1|}
_RNCINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShEs3_0Cs5UenZY2zsE2_13oxigraph_fuzz:
  451|      1|                            let value = value.ok_or_else(|| {
  452|      1|                                SyntaxError::msg("literal serialization should have a 'value' key")
  453|      1|                            })?;
_RNvMNtCs2VHBjBJmpQG_10sparesults4jsonINtB2_19JsonSolutionsWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE5startCs5UenZY2zsE2_13oxigraph_fuzz:
   33|    141|    pub fn start(sink: W, variables: &[Variable]) -> io::Result<Self> {
   34|    141|        let mut writer = JsonWriter::from_writer(sink);
   35|    141|        writer.write_event(JsonEvent::StartObject)?;
   36|    141|        writer.write_event(JsonEvent::ObjectKey("head"))?;
   37|    141|        writer.write_event(JsonEvent::StartObject)?;
   38|    141|        writer.write_event(JsonEvent::ObjectKey("vars"))?;
   39|    141|        writer.write_event(JsonEvent::StartArray)?;
   40|    750|        for variable in variables {
   41|    609|            writer.write_event(JsonEvent::String(variable.as_str()))?;
   42|       |        }
   43|    141|        writer.write_event(JsonEvent::EndArray)?;
   44|    141|        writer.write_event(JsonEvent::EndObject)?;
   45|    141|        writer.write_event(JsonEvent::ObjectKey("results"))?;
   46|    141|        writer.write_event(JsonEvent::StartObject)?;
   47|    141|        writer.write_event(JsonEvent::ObjectKey("bindings"))?;
   48|    141|        writer.write_event(JsonEvent::StartArray)?;
   49|    141|        Ok(Self { writer })
   50|    141|    }
_RINvMNtCs2VHBjBJmpQG_10sparesults4jsonINtB3_19JsonSolutionsWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE5writeINtNtNtNtCs2HCZCz77UhY_4core4iter8adapters3map3MapNtNtB5_8solution4IterNCINvMs3_B5_INtB5_15SolutionsWriterB11_E5writeRNtNtCs3LEgFa65ccV_5oxrdf8variable8VariableRNtNtB3F_6triple4TermRNtB2x_13QuerySolutionE0EECs5UenZY2zsE2_13oxigraph_fuzz:
   52|  3.43k|    pub fn write<'a>(
   53|  3.43k|        &mut self,
   54|  3.43k|        solution: impl IntoIterator<Item = (VariableRef<'a>, TermRef<'a>)>,
   55|  3.43k|    ) -> io::Result<()> {
   56|  3.43k|        self.writer.write_event(JsonEvent::StartObject)?;
   57|  3.43k|        for (variable, value) in solution {
   58|      0|            self.writer
   59|      0|                .write_event(JsonEvent::ObjectKey(variable.as_str()))?;
   60|      0|            write_json_term(value, &mut self.writer)?;
   61|       |        }
   62|  3.43k|        self.writer.write_event(JsonEvent::EndObject)?;
   63|  3.43k|        Ok(())
   64|  3.43k|    }
_RINvNtCs2VHBjBJmpQG_10sparesults4json10read_valueRShECs5UenZY2zsE2_13oxigraph_fuzz:
  319|  2.63k|fn read_value<R: BufRead>(
  320|  2.63k|    reader: &mut JsonReader<R>,
  321|  2.63k|    buffer: &mut Vec<u8>,
  322|  2.63k|    number_of_recursive_calls: usize,
  323|  2.63k|) -> Result<Term, ParseError> {
  324|  2.63k|    enum Type {
  325|  2.63k|        Uri,
  326|  2.63k|        BNode,
  327|  2.63k|        Literal,
  328|  2.63k|        #[cfg(feature = "rdf-star")]
  329|  2.63k|        Triple,
  330|  2.63k|    }
  331|  2.63k|    #[derive(Eq, PartialEq)]
  332|  2.63k|    enum State {
  333|  2.63k|        Type,
  334|  2.63k|        Value,
  335|  2.63k|        Lang,
  336|  2.63k|        Datatype,
  337|  2.63k|    }
  338|  2.63k|
  339|  2.63k|    if number_of_recursive_calls == MAX_NUMBER_OF_NESTED_TRIPLES {
  340|      1|        return Err(SyntaxError::msg(format!(
  341|      1|            "Too many nested triples ({MAX_NUMBER_OF_NESTED_TRIPLES}). The parser fails here to avoid a stack overflow."
  342|      1|        ))
  343|      1|            .into());
  344|  2.63k|    }
  345|  2.63k|    let mut state = None;
  346|  2.63k|    let mut t = None;
  347|  2.63k|    let mut value = None;
  348|  2.63k|    let mut lang = None;
  349|  2.63k|    let mut datatype = None;
  350|  2.63k|    #[cfg(feature = "rdf-star")]
  351|  2.63k|    let mut subject = None;
  352|  2.63k|    #[cfg(feature = "rdf-star")]
  353|  2.63k|    let mut predicate = None;
  354|  2.63k|    #[cfg(feature = "rdf-star")]
  355|  2.63k|    let mut object = None;
  356|  2.63k|    if reader.read_event(buffer)? != JsonEvent::StartObject {
  357|      1|        return Err(SyntaxError::msg("Term serializations should be an object").into());
  358|  2.59k|    }
  359|       |    loop {
  360|  9.08k|        match reader.read_event(buffer)? {
  361|  5.20k|            JsonEvent::ObjectKey(key) => match key {
  362|  5.20k|                "type" => state = Some(State::Type),
  363|  5.15k|                "value" => state = Some(State::Value),
  364|  4.99k|                "xml:lang" => state = Some(State::Lang),
  365|  4.89k|                "datatype" => state = Some(State::Datatype),
  366|       |                #[cfg(feature = "rdf-star")]
  367|  1.71k|                "subject" => {
  368|     50|                    subject = Some(read_value(reader, buffer, number_of_recursive_calls + 1)?)
  369|       |                }
  370|       |                #[cfg(feature = "rdf-star")]
  371|  1.66k|                "predicate" => {
  372|  1.62k|                    predicate = Some(read_value(reader, buffer, number_of_recursive_calls + 1)?)
  373|       |                }
  374|       |                #[cfg(feature = "rdf-star")]
  375|     36|                "object" => {
  376|     22|                    object = Some(read_value(reader, buffer, number_of_recursive_calls + 1)?)
  377|       |                }
  378|       |                _ => {
  379|     14|                    return Err(SyntaxError::msg(format!(
  380|     14|                        "Unexpected key in term serialization: '{key}'"
  381|     14|                    ))
  382|     14|                    .into())
  383|       |                }
  384|       |            },
  385|       |            JsonEvent::StartObject => {
  386|    241|                if state != Some(State::Value) {
  387|      1|                    return Err(
  388|      1|                        SyntaxError::msg("Unexpected nested object in term serialization").into(),
  389|      1|                    );
  390|    240|                }
  391|       |            }
  392|  3.43k|            JsonEvent::String(s) => match state {
  393|       |                Some(State::Type) => {
  394|     53|                    match s {
  395|     53|                        "uri" => t = Some(Type::Uri),
  396|     51|                        "bnode" => t = Some(Type::BNode),
  397|     32|                        "literal" | "typed-literal" => t = Some(Type::Literal),
  398|       |                        #[cfg(feature = "rdf-star")]
  399|     19|                        "triple" => t = Some(Type::Triple),
  400|       |                        _ => {
  401|      6|                            return Err(
  402|      6|                                SyntaxError::msg(format!("Unexpected term type: '{s}'")).into()
  403|      6|                            )
  404|       |                        }
  405|       |                    };
  406|     47|                    state = None;
  407|       |                }
  408|     93|                Some(State::Value) => {
  409|     93|                    value = Some(s.to_owned());
  410|     93|                    state = None;
  411|     93|                }
  412|    101|                Some(State::Lang) => {
  413|    101|                    lang = Some(s.to_owned());
  414|    101|                    state = None;
  415|    101|                }
  416|  2.49k|                Some(State::Datatype) => {
  417|  2.49k|                    datatype = Some(
  418|  3.18k|                        NamedNode::new(s)
  419|  3.18k|                            .map_err(|e| SyntaxError::msg(format!("Invalid datatype IRI: {e}")))?,
  420|       |                    );
  421|  2.49k|                    state = None;
  422|       |                }
  423|      0|                _ => (), // impossible
  424|       |            },
  425|       |            JsonEvent::EndObject => {
  426|     23|                if let Some(s) = state {
  427|     18|                    if s == State::Value {
  428|     18|                        state = None; //End of triple
  429|     18|                    } else {
  430|      0|                        return Err(
  431|      0|                            SyntaxError::msg("Term description values should be string").into()
  432|      0|                        );
  433|       |                    }
  434|       |                } else {
  435|      4|                    return match t {
  436|      1|                        None => Err(SyntaxError::msg(
  437|      1|                            "Term serialization should have a 'type' key",
  438|      1|                        )
  439|      1|                        .into()),
  440|      1|                        Some(Type::Uri) => Ok(NamedNode::new(value.ok_or_else(|| {
  441|       |                            SyntaxError::msg("uri serialization should have a 'value' key")
  442|      1|                        })?)
  443|      0|                        .map_err(|e| SyntaxError::msg(format!("Invalid uri value: {e}")))?
  444|      0|                        .into()),
  445|      1|                        Some(Type::BNode) => Ok(BlankNode::new(value.ok_or_else(|| {
  446|       |                            SyntaxError::msg("bnode serialization should have a 'value' key")
  447|      1|                        })?)
  448|      0|                        .map_err(|e| SyntaxError::msg(format!("Invalid bnode value: {e}")))?
  449|      0|                        .into()),
  450|       |                        Some(Type::Literal) => {
  451|      1|                            let value = value.ok_or_else(|| {
  452|       |                                SyntaxError::msg("literal serialization should have a 'value' key")
  453|      1|                            })?;
  454|      0|                            Ok(match lang {
  455|      0|                                Some(lang) => {
  456|      0|                                    if let Some(datatype) = datatype {
  457|      0|                                        if datatype.as_ref() != rdf::LANG_STRING {
  458|      0|                                            return Err(SyntaxError::msg(format!(
  459|      0|                                                "xml:lang value '{lang}' provided with the datatype {datatype}"
  460|      0|                                            )).into())
  461|      0|                                        }
  462|      0|                                    }
  463|      0|                                    Literal::new_language_tagged_literal(value, &lang).map_err(|e| {
  464|       |                                        SyntaxError::msg(format!("Invalid xml:lang value '{lang}': {e}"))
  465|      0|                                    })?
  466|       |                                }
  467|      0|                                None => if let Some(datatype) = datatype {
  468|      0|                                    Literal::new_typed_literal(value, datatype)
  469|       |                                } else {
  470|      0|                                    Literal::new_simple_literal(value)
  471|       |                                }
  472|       |                            }
  473|      0|                                .into())
  474|       |                        }
  475|       |                        #[cfg(feature = "rdf-star")]
  476|       |                        Some(Type::Triple) => Ok(Triple::new(
  477|      1|                            match subject.ok_or_else(|| {
  478|       |                                SyntaxError::msg("triple serialization should have a 'subject' key")
  479|      1|                            })? {
  480|      0|                                Term::NamedNode(subject) => subject.into(),
  481|      0|                                Term::BlankNode(subject) => subject.into(),
  482|      0|                                Term::Triple(subject) => Subject::Triple(subject),
  483|       |                                Term::Literal(_) => {
  484|      0|                                    return Err(SyntaxError::msg(
  485|      0|                                        "The 'subject' value should not be a literal",
  486|      0|                                    )
  487|      0|                                    .into())
  488|       |                                }
  489|       |                            },
  490|      0|                            match predicate.ok_or_else(|| {
  491|       |                                SyntaxError::msg(
  492|       |                                    "triple serialization should have a 'predicate' key",
  493|       |                                )
  494|      0|                            })? {
  495|      0|                                Term::NamedNode(predicate) => predicate,
  496|       |                                _ => {
  497|      0|                                    return Err(SyntaxError::msg(
  498|      0|                                        "The 'predicate' value should be a uri",
  499|      0|                                    )
  500|      0|                                    .into())
  501|       |                                }
  502|       |                            },
  503|      0|                            object.ok_or_else(|| {
  504|       |                                SyntaxError::msg("triple serialization should have a 'object' key")
  505|      0|                            })?,
  506|       |                        )
  507|      0|                        .into()),
  508|       |                    };
  509|       |                }
  510|       |            }
  511|      1|            _ => return Err(SyntaxError::msg("Invalid term serialization").into()),
  512|       |        }
  513|       |    }
  514|  2.63k|}
_RNvXs1_NvNtCs2VHBjBJmpQG_10sparesults4json10read_valueNtB5_5StateNtNtCs2HCZCz77UhY_4core3cmp9PartialEq2eqCs5UenZY2zsE2_13oxigraph_fuzz:
  331|    258|    #[derive(Eq, PartialEq)]

_RNvMs_Cs2VHBjBJmpQG_10sparesultsNtB4_18QueryResultsParser11from_formatCs5UenZY2zsE2_13oxigraph_fuzz:
  166|  1.90k|    pub fn from_format(format: QueryResultsFormat) -> Self {
  167|  1.90k|        Self { format }
  168|  1.90k|    }
_RNvMs2_Cs2VHBjBJmpQG_10sparesultsNtB5_22QueryResultsSerializer11from_formatCs5UenZY2zsE2_13oxigraph_fuzz:
  362|  1.90k|    pub fn from_format(format: QueryResultsFormat) -> Self {
  363|  1.90k|        Self { format }
  364|  1.90k|    }
_RNCNvXs1_Cs2VHBjBJmpQG_10sparesultsINtB7_15SolutionsReaderRShENtNtNtNtCs2HCZCz77UhY_4core4iter6traits8iterator8Iterator4next0Cs5UenZY2zsE2_13oxigraph_fuzz:
  321|  7.10k|            .map(|values| (Rc::clone(&self.variables), values).into()),
_RINvMs_Cs2VHBjBJmpQG_10sparesultsNtB5_18QueryResultsParser12read_resultsRShECs5UenZY2zsE2_13oxigraph_fuzz:
  193|  2.04k|    pub fn read_results<R: BufRead>(&self, reader: R) -> Result<QueryResultsReader<R>, ParseError> {
  194|  2.04k|        Ok(match self.format {
  195|      0|            QueryResultsFormat::Xml => match XmlQueryResultsReader::read(reader)? {
  196|      0|                XmlQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  197|       |                XmlQueryResultsReader::Solutions {
  198|      0|                    solutions,
  199|      0|                    variables,
  200|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  201|      0|                    variables: Rc::new(variables),
  202|      0|                    solutions: SolutionsReaderKind::Xml(solutions),
  203|      0|                }),
  204|       |            },
  205|  2.04k|            QueryResultsFormat::Json => match JsonQueryResultsReader::read(reader)? {
  206|      2|                JsonQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  207|       |                JsonQueryResultsReader::Solutions {
  208|    334|                    solutions,
  209|    334|                    variables,
  210|    334|                } => QueryResultsReader::Solutions(SolutionsReader {
  211|    334|                    variables: Rc::new(variables),
  212|    334|                    solutions: SolutionsReaderKind::Json(solutions),
  213|    334|                }),
  214|       |            },
  215|      0|            QueryResultsFormat::Csv => return Err(SyntaxError::msg("CSV SPARQL results syntax is lossy and can't be parsed to a proper RDF representation").into()),
  216|      0|            QueryResultsFormat::Tsv => match TsvQueryResultsReader::read(reader)? {
  217|      0|                TsvQueryResultsReader::Boolean(r) => QueryResultsReader::Boolean(r),
  218|       |                TsvQueryResultsReader::Solutions {
  219|      0|                    solutions,
  220|      0|                    variables,
  221|      0|                } => QueryResultsReader::Solutions(SolutionsReader {
  222|      0|                    variables: Rc::new(variables),
  223|      0|                    solutions: SolutionsReaderKind::Tsv(solutions),
  224|      0|                }),
  225|       |            },
  226|       |        })
  227|  2.04k|    }
_RNvMs3_Cs2VHBjBJmpQG_10sparesultsINtB5_15SolutionsWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE6finishCs5UenZY2zsE2_13oxigraph_fuzz:
  490|    141|    pub fn finish(self) -> io::Result<W> {
  491|    141|        match self.formatter {
  492|      0|            SolutionsWriterKind::Xml(write) => write.finish(),
  493|    141|            SolutionsWriterKind::Json(write) => write.finish(),
  494|      0|            SolutionsWriterKind::Csv(write) => write.finish(),
  495|      0|            SolutionsWriterKind::Tsv(write) => write.finish(),
  496|       |        }
  497|    141|    }
_RINvMs2_Cs2VHBjBJmpQG_10sparesultsNtB6_22QueryResultsSerializer20write_boolean_resultQINtNtCs3atDPk1oays_5alloc3vec3VechEECs5UenZY2zsE2_13oxigraph_fuzz:
  378|      1|    pub fn write_boolean_result<W: Write>(&self, writer: W, value: bool) -> io::Result<W> {
  379|      1|        match self.format {
  380|      0|            QueryResultsFormat::Xml => write_boolean_xml_result(writer, value),
  381|      1|            QueryResultsFormat::Json => write_boolean_json_result(writer, value),
  382|      0|            QueryResultsFormat::Csv => write_boolean_csv_result(writer, value),
  383|      0|            QueryResultsFormat::Tsv => write_boolean_tsv_result(writer, value),
  384|       |        }
  385|      1|    }
_RINvMs3_Cs2VHBjBJmpQG_10sparesultsINtB6_15SolutionsWriterINtNtCs3atDPk1oays_5alloc3vec3VechEE5writeRNtNtCs3LEgFa65ccV_5oxrdf8variable8VariableRNtNtB1E_6triple4TermRNtNtB6_8solution13QuerySolutionECs5UenZY2zsE2_13oxigraph_fuzz:
  476|  3.43k|    pub fn write<'a>(
  477|  3.43k|        &mut self,
  478|  3.43k|        solution: impl IntoIterator<Item = (impl Into<VariableRef<'a>>, impl Into<TermRef<'a>>)>,
  479|  3.43k|    ) -> io::Result<()> {
  480|  3.43k|        let solution = solution.into_iter().map(|(v, s)| (v.into(), s.into()));
  481|  3.43k|        match &mut self.formatter {
  482|      0|            SolutionsWriterKind::Xml(writer) => writer.write(solution),
  483|  3.43k|            SolutionsWriterKind::Json(writer) => writer.write(solution),
  484|      0|            SolutionsWriterKind::Csv(writer) => writer.write(solution),
  485|      0|            SolutionsWriterKind::Tsv(writer) => writer.write(solution),
  486|       |        }
  487|  3.43k|    }
_RINvMs2_Cs2VHBjBJmpQG_10sparesultsNtB6_22QueryResultsSerializer16solutions_writerINtNtCs3atDPk1oays_5alloc3vec3VechEECs5UenZY2zsE2_13oxigraph_fuzz:
  403|    141|    pub fn solutions_writer<W: Write>(
  404|    141|        &self,
  405|    141|        writer: W,
  406|    141|        variables: Vec<Variable>,
  407|    141|    ) -> io::Result<SolutionsWriter<W>> {
  408|    141|        Ok(SolutionsWriter {
  409|    141|            formatter: match self.format {
  410|       |                QueryResultsFormat::Xml => {
  411|      0|                    SolutionsWriterKind::Xml(XmlSolutionsWriter::start(writer, &variables)?)
  412|       |                }
  413|       |                QueryResultsFormat::Json => {
  414|    141|                    SolutionsWriterKind::Json(JsonSolutionsWriter::start(writer, &variables)?)
  415|       |                }
  416|       |                QueryResultsFormat::Csv => {
  417|      0|                    SolutionsWriterKind::Csv(CsvSolutionsWriter::start(writer, variables)?)
  418|       |                }
  419|       |                QueryResultsFormat::Tsv => {
  420|      0|                    SolutionsWriterKind::Tsv(TsvSolutionsWriter::start(writer, variables)?)
  421|       |                }
  422|       |            },
  423|       |        })
  424|    141|    }
_RNvXs1_Cs2VHBjBJmpQG_10sparesultsINtB5_15SolutionsReaderRShENtNtNtNtCs2HCZCz77UhY_4core4iter6traits8iterator8Iterator4nextCs5UenZY2zsE2_13oxigraph_fuzz:
  313|  7.43k|    fn next(&mut self) -> Option<Result<QuerySolution, ParseError>> {
  314|  7.43k|        Some(
  315|  7.43k|            match &mut self.solutions {
  316|      0|                SolutionsReaderKind::Xml(reader) => reader.read_next(),
  317|  7.43k|                SolutionsReaderKind::Json(reader) => reader.read_next(),
  318|      0|                SolutionsReaderKind::Tsv(reader) => reader.read_next(),
  319|       |            }
  320|  7.43k|            .transpose()?
  321|  7.15k|            .map(|values| (Rc::clone(&self.variables), values).into()),
  322|       |        )
  323|  7.43k|    }

_RNvXs_NtCs2VHBjBJmpQG_10sparesults8solutionNtB4_13QuerySolutionINtNtCs2HCZCz77UhY_4core7convert4FromTINtNtCs3atDPk1oays_5alloc2rc2RcINtNtB1G_3vec3VecNtNtCs3LEgFa65ccV_5oxrdf8variable8VariableEEIB27_INtNtB14_6option6OptionNtNtB2r_6triple4TermEEEE4fromCs5UenZY2zsE2_13oxigraph_fuzz:
  121|  7.10k|    fn from((v, s): (V, S)) -> Self {
  122|  7.10k|        Self {
  123|  7.10k|            variables: v.into(),
  124|  7.10k|            values: s.into(),
  125|  7.10k|        }
  126|  7.10k|    }
_RNvMNtCs2VHBjBJmpQG_10sparesults8solutionNtB2_13QuerySolution9variablesCs5UenZY2zsE2_13oxigraph_fuzz:
  114|    138|    pub fn variables(&self) -> &[Variable] {
  115|    138|        &self.variables
  116|    138|    }
_RNvXs0_NtCs2VHBjBJmpQG_10sparesults8solutionRNtB5_13QuerySolutionNtNtNtNtCs2HCZCz77UhY_4core4iter6traits7collect12IntoIterator9into_iterCs5UenZY2zsE2_13oxigraph_fuzz:
  134|  3.43k|    fn into_iter(self) -> Iter<'a> {
  135|  3.43k|        Iter {
  136|  3.43k|            inner: self.variables.iter().zip(&self.values),
  137|  3.43k|        }
  138|  3.43k|    }
_RNvXs9_NtCs2VHBjBJmpQG_10sparesults8solutionNtB5_4IterNtNtNtNtCs2HCZCz77UhY_4core4iter6traits8iterator8Iterator4nextCs5UenZY2zsE2_13oxigraph_fuzz:
  229|  3.43k|    fn next(&mut self) -> Option<(&'a Variable, &'a Term)> {
  230|  5.52k|        for (variable, value) in &mut self.inner {
  231|  2.09k|            if let Some(value) = value {
  232|      0|                return Some((variable, value));
  233|  2.09k|            }
  234|       |        }
  235|  3.43k|        None
  236|  3.43k|    }
_RNvXs9_NtCs2VHBjBJmpQG_10sparesults8solutionNtB5_4IterNtNtNtNtCs2HCZCz77UhY_4core4iter6traits8iterator8Iterator4nextB7_:
  229|  6.87k|    fn next(&mut self) -> Option<(&'a Variable, &'a Term)> {
  230|  11.0k|        for (variable, value) in &mut self.inner {
  231|  4.18k|            if let Some(value) = value {
  232|      0|                return Some((variable, value));
  233|  4.18k|            }
  234|       |        }
  235|  6.87k|        None
  236|  6.87k|    }
_RNvXs6_NtCs2VHBjBJmpQG_10sparesults8solutionNtB5_13QuerySolutionNtNtCs2HCZCz77UhY_4core3cmp9PartialEq2eq:
  189|  3.43k|    fn eq(&self, other: &Self) -> bool {
  190|  3.43k|        for (k, v) in self.iter() {
  191|      0|            if other.get(k) != Some(v) {
  192|      0|                return false;
  193|      0|            }
  194|       |        }
  195|  3.43k|        for (k, v) in other.iter() {
  196|      0|            if self.get(k) != Some(v) {
  197|      0|                return false;
  198|      0|            }
  199|       |        }
  200|  3.43k|        true
  201|  3.43k|    }
_RNvMNtCs2VHBjBJmpQG_10sparesults8solutionNtB2_13QuerySolution4iterB4_:
   86|  6.87k|    pub fn iter(&self) -> impl Iterator<Item = (&Variable, &Term)> {
   87|  6.87k|        self.into_iter()
   88|  6.87k|    }
_RNvXs0_NtCs2VHBjBJmpQG_10sparesults8solutionRNtB5_13QuerySolutionNtNtNtNtCs2HCZCz77UhY_4core4iter6traits7collect12IntoIterator9into_iterB7_:
  134|  6.87k|    fn into_iter(self) -> Iter<'a> {
  135|  6.87k|        Iter {
  136|  6.87k|            inner: self.variables.iter().zip(&self.values),
  137|  6.87k|        }
  138|  6.87k|    }

